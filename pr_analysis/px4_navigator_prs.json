[
  {
    "title": "Navigator RTL: run find_RTL_destination() only on_inactive",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21782",
    "number": 21782,
    "created_at": "2023-06-30T10:13:08Z",
    "merged": true,
    "merged_at": "2023-07-04T07:36:22Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nRTL::find_RTL_destination() is called also when the RTL has already started, and can override the set _destination etc. I don't think that's desired.\r\n\r\nThis was introduced through a refactor commit: https://github.com/PX4/PX4-Autopilot/pull/21208/commits/2bff49475b504b29eba8fb5cf1cb65400ea80482\r\n\r\n### Solution\r\nRemove it again.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: RTL: do not edit RTL destination once RTL is started\r\n```\r\n\r\n\r\n### Test coverage\r\n- Unit/integration test: ...\r\n- Simulation/hardware testing logs: https://review.px4.io/\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "I assume this is only there such that active and inactive are the same.\r\nThe `_destination_check_time` gets reset now even if the digestion does not change. That's not a problem in my eyes. When you switch out of RTL and in again within less than a second then the old destination stays. Maybe that's even a feature. It could be named `_slow_rate_timestamp` or so.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR prevents find_RTL_destination() from running while RTL is active, which previously allowed the RTL destination/state to be overwritten after RTL had started â€” an unintended state transition/incorrect behavior introduced during a refactor. Restoring the check prevents the navigator from changing RTL destination mid-flight, which matches the definition of a logic error.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -322,9 +322,8 @@ void RTL::on_active()\n \t\trtl_time_estimate_s rtl_time_estimate{};\n \t\trtl_time_estimate.valid = false;\n \n-\t\t// Calculate RTL destination and time estimate only when there is a valid home and global position\n+\t\t// Calculate time estimate only when there is a valid home and global position\n \t\tif (_navigator->home_global_position_valid() && global_position_recently_updated) {\n-\t\t\tfind_RTL_destination();\n \t\t\tcalcRtlTimeEstimate(_rtl_state, rtl_time_estimate);\n \t\t\trtl_time_estimate.valid = true;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/597da76221294b0d9b78fb908e12e71a376322f0/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::on_active"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_active"
        ]
      }
    }
  },
  {
    "title": "Navigator: loiter: remove unnecessary _loiter_pos_set",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21776",
    "number": 21776,
    "created_at": "2023-06-29T12:50:08Z",
    "merged": true,
    "merged_at": "2023-06-30T13:40:21Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nWhile working on https://github.com/PX4/PX4-Autopilot/pull/21775 I noticed this seemingly unnecessary class variable `_loiter_pos_set`, that was set to false in `on_inactive()` or in `on_active`, and then though only ever checked in `on_activation` (through `set_loiter_position()`). I don't see how it could be false when entering on_activation(), and thus can just be removed, or am I missing something?\r\n\r\n### Solution\r\nRemove it!\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nRefactor: remove unnecessary variable\r\n```\r\n\r\n### Test coverage\r\nBit of SITL testing.\r\n\r\n",
      "issue_comments": [
        {
          "author": "junwoo091400",
          "created_at": "2023-06-30T14:39:16Z",
          "body": "![image](https://github.com/PX4/PX4-Autopilot/assets/23277211/50c94e3d-b230-4dd2-946f-cea632b8088c)\r\n\r\nIdk why but the merge commit in main branch itself doesn't show these build failures, any clue why in this PR page itself it shows so many build errors? @MaEtUgR ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2023-06-30T12:03:23Z",
          "body": "```suggestion\r\n```",
          "path": "src/modules/navigator/loiter.h",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "It was introduced here: https://github.com/PX4/PX4-Autopilot/commit/8960ab3402a87b182d17ab1b3cb165115e0f4bad\r\nBut I cannot possibly understand what for. Maybe an unfinished thought about setting the loiter position once armed when already being in hold mode but I'm pretty sure it never worked correctly since as you mention the loiter point is never set again once hold mode is engaged ðŸ¤·â€â™‚ï¸\r\n\r\nMaybe a draft implementation contained a second call to `set_loiter_position()` and that's where it had an effect.\r\n\r\nI also did some tests and I cannot find a case to enter the loiter's `on_activation()` with the flag true.",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR removes a dead/unused class variable that appears never to affect runtime behavior: the flag was only set/reset in places but only ever checked during activation where it cannot be false. Reviewers and the author couldn't find a scenario where the flag changes logic, so this is a refactor/cleanup rather than a fix for incorrect program behavior.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "patch": "@@ -48,12 +48,6 @@ Loiter::Loiter(Navigator *navigator) :\n {\n }\n \n-void\n-Loiter::on_inactive()\n-{\n-\t_loiter_pos_set = false;\n-}\n-\n void\n Loiter::on_activation()\n {\n@@ -74,11 +68,6 @@ Loiter::on_active()\n \tif (_navigator->get_reposition_triplet()->current.valid) {\n \t\treposition();\n \t}\n-\n-\t// reset the loiter position if we get disarmed\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n-\t\t_loiter_pos_set = false;\n-\t}\n }\n \n void\n@@ -93,16 +82,10 @@ Loiter::set_loiter_position()\n \t\t_navigator->set_can_loiter_at_sp(false);\n \t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n \t\t_navigator->set_position_setpoint_triplet_updated();\n-\t\t_loiter_pos_set = false;\n \t\treturn;\n \n-\t} else if (_loiter_pos_set) {\n-\t\t// Already set, nothing to do.\n-\t\treturn;\n \t}\n \n-\t_loiter_pos_set = true;\n-\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \tif (_navigator->get_land_detected()->landed) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2e4679673dca6fb10e73f38a2667fa72c3733a04/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -51,7 +51,6 @@ class Loiter : public MissionBlock, public ModuleParams\n \tLoiter(Navigator *navigator);\n \t~Loiter() = default;\n \n-\tvoid on_inactive() override;\n \tvoid on_activation() override;\n \tvoid on_active() override;\n \n@@ -67,5 +66,4 @@ class Loiter : public MissionBlock, public ModuleParams\n \t */\n \tvoid set_loiter_position();\n \n-\tbool _loiter_pos_set{false};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2e4679673dca6fb10e73f38a2667fa72c3733a04/src%2Fmodules%2Fnavigator%2Floiter.h"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::Loiter",
        "on_inactive",
        "Loiter::on_active",
        "Loiter::set_loiter_position"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::Loiter",
          "Loiter::on_active",
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/loiter.h": [
          "on_inactive"
        ]
      }
    }
  },
  {
    "title": "Navigator: Loiter: always establish new Loiter with center at current position",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21775",
    "number": 21775,
    "created_at": "2023-06-29T12:43:22Z",
    "merged": true,
    "merged_at": "2023-07-04T07:35:41Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nhttps://github.com/PX4/PX4-Autopilot/issues/21702\r\n\r\nVehicle keeps flying towards Loiter waypoint if Hold mode is selected. In the past we within Navigator set the type to POSITION when far away from a Loiter waypoint, and then only to LOITER when really on established loiter, but this distinction is now no longer part of Navigator and the FW position controller handles it.\r\n\r\n### Solution\r\nWhen switching into Hold mode establish a Loiter around current position, even if we were before already loitering (eg in Mission mode). This results in the same behavior when switching into Hold/Loiter mode directly (either through RC switch or in the flight mode selection in QGC) or through the \"Hold\" button in QGC (which sends a DO_REPOSITION with the fields at the current position). \r\n\r\nIn this screen recording you see the behavior prior and after this PR.\r\nhttps://github.com/PX4/PX4-Autopilot/assets/26798987/9079b575-77fc-40a2-be54-b3c11816cca3\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Fixed-wing: Always establish loiter around current position when switching into Hold mode\r\n```\r\n\r\n\r\n### Alternatives\r\nFix detection on whether we're currently on an established loiter, and in that case don't loiter around current position but keep established loiter. Personally I though prefer to stick to Hold = Loiter around current position always. Imagine being on a huge loiter. If the vehicle then keeps following it it's hardly anymore \"Holding position\". \r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-06-30T18:26:40Z",
          "body": "> But while testing that I found that when I press pause in QGC it actually flies to the next waypoint still and stops there. The code changed it here not called at all in this case probably because of the reposition command like you wrote.\r\n\r\nWhich QGC version did you test with? I couldn't reproduce with mine (v4.2.6 from this March). But yes, like you said not affected by this PR.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "Makes sense to me.\r\nI tested and with the multirotor I could not get it to not stop when just changing to hold mode also before.\r\n\r\nBut while testing that I found that when I press pause in QGC it actually flies to the next waypoint still and stops there. The code changed it here not called at all in this case probably because of the reposition command like you wrote.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior when switching into Hold/Loiter: the navigator was not establishing a loiter centered at the current vehicle position, causing the vehicle to continue toward an existing loiter waypoint. This is an improper state transition / data-flow logic bug (mode switch handling), and the change forces the correct loiter state around the current position to produce the intended behavior.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "patch": "@@ -61,6 +61,7 @@ Loiter::on_activation()\n \t\treposition();\n \n \t} else {\n+\t\t// this is executed when the flight mode is switched to Hold manually, not through a reposition\n \t\tset_loiter_position();\n \t}\n \n@@ -109,16 +110,11 @@ Loiter::set_loiter_position()\n \t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n \n \t} else {\n-\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n-\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n \n \t\t} else {\n-\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n-\n-\t\t\t} else {\n-\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n-\t\t\t}\n+\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n \t\t}\n \n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2c3f79813eeb4e1d4676c7bc8bf2885e0e9f4beb/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::set_loiter_position",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::set_loiter_position",
          "Loiter::on_activation"
        ]
      }
    }
  },
  {
    "title": "Some parameter cleanup",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21736",
    "number": 21736,
    "created_at": "2023-06-19T10:13:47Z",
    "merged": true,
    "merged_at": "2023-07-17T08:35:03Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nSafes a bit of flash and reduces entropy by removing two params that aren't really required anymore. \r\n\r\n### Solution\r\n\r\n### Changelog Entry\r\n\r\n```\r\nRemove COM_ARM_ARSP_EN and VT_B_DEC_FF params, plus shorten parameter descriptions\r\n```\r\n\r\n",
      "issue_comments": [
        {
          "author": "DronecodeBot",
          "created_at": "2024-07-25T00:45:43Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-v1-15-public-changes-what-needs-docs/39850/1\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR removes two obsolete parameters to save flash and shorten descriptions; it is a cleanup/maintenance change rather than a correction of incorrect program behavior. There is no mention of fixing wrong outputs, incorrect state transitions, or behavioural bugs, so this does not appear to address a logic error.",
    "patches": {
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -43,7 +43,7 @@\n /**\n  * Loiter radius (FW only)\n  *\n- * Default value of loiter radius for missions, Hold mode, Return mode, etc. (fixedwing only).\n+ * Default value of loiter radius in FW mode (e.g. for Loiter mode).\n  *\n  * @unit m\n  * @min 25",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c86d6903901a03b679bff043fedfb222ec292968/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Navigator: Resume mission with last flight speed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21714",
    "number": 21714,
    "created_at": "2023-06-12T16:34:18Z",
    "merged": true,
    "merged_at": "2023-08-08T11:22:05Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Based on https://github.com/PX4/PX4-Autopilot/pull/21710\r\n\r\n### Solved Problem\r\nOn resuming a mission, the flight speed was reset to the vehicle default. Especially for surveys this is not acceptable. \r\n\r\n### Solution\r\nFurther extend the ideas from https://github.com/PX4/PX4-Autopilot/pull/21710: some mission items contain not momentary setpoints (like go to point A), but instead contain settings that are then relevant for the whole mission (or until over-turned by a negating command). \r\nDO_CHANGE_SPEED items belong to the same category as eg camera settings: you want to re-apply them when resuming a mission. \r\n\r\nI've further removed the separated mc/fw stored flight speeds, as it's only ever needed to store the speed of the current mode we're in, and we reset it during VTOL transitions. \r\n\r\n### Changelog Entry\r\n\r\n```\r\nFeature: Resume mission with flight speed from previous mission items\r\nDocumentation: Need to clarify page ...\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "DronecodeBot",
          "created_at": "2023-06-14T09:43:32Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/set-mission-speed-being-ignored-upon-starting-auto-flight/32705/2\n",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-06-23T12:20:00Z",
          "body": "will likely need this in before the beaglebone is passing https://github.com/PX4/PX4-Autopilot/pull/21749",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-07-17T13:57:40Z",
          "body": "[Removed some speed handling logic from Navigator,](https://github.com/PX4/PX4-Autopilot/pull/21714/commits/0b18bd59a46268574460aa9b60f0e13cea5aa36e) and then rebased and force pushed. @tstastny would be good if you could make yourself a picture here and comment if you agree with the general direction of it (removing speed logic from Navigator). ",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2023-08-09T04:56:52Z",
          "body": "I think it is an excellent feature to start from the previous setpoint. Can you update the docs @sfuhrer ? \r\n\r\nI was thinking perhaps a very short section on pausing and resuming the mission in https://docs.px4.io/main/en/flight_modes/mission.html#mission-mode. Make it clear this applies to all frames.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "tstastny",
          "created_at": "2023-06-23T12:09:34Z",
          "body": "if this is just about speed commands, shouldnt we just look here for the exact NAV_CMD corresponding to a DO_CHANGE_SPEED?\r\n\r\nAlso - why are we sending the command again instead of just applying the properties? (sorry im a bit out of the loop on all this)",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-06-23T12:10:23Z",
          "body": "i dont really care either way - but what's the reason for keeping these lines at all if they are commented out?",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-06-23T12:18:45Z",
          "body": "so this one\r\n1. updates to the latest potential speed change ONLY by the mission item iteration\r\n2. and then sends the vehicle command such that\r\n3. `cruising_speed_sp_update()` picks up that command when it checks for do set speed commands? (where it would also pick up any operator freeform do set speed commands?)\r\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-23T14:48:54Z",
          "body": "No reason, those are left overs from debugging, will remove!",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-23T14:58:44Z",
          "body": "> if this is just about speed commands, shouldnt we just look here for the exact NAV_CMD corresponding to a DO_CHANGE_SPEED?\r\n\r\ngood point, changed it to do so.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-23T15:22:42Z",
          "body": ">ONLY by the mission item iteration\r\nCan you expand what you mean?\r\n\r\nBut yes otherwise that's what happens. Note that also the fixed-wing position controller and the multicopter flight mode manager listen to VEHICLE_CMD_DO_CHANGE_SPEED and execute it independently of `cruising_speed_sp_update()` (which is only run in Mission, but not in eg Loiter). \r\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-23T15:26:28Z",
          "body": "Maybe we could even remove `cruising_speed_sp_update()`? It's a fundamental question if the speed setpoint should be part of the position setpoint or if it's rather an independent system setting.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-07-17T13:52:17Z",
          "body": "Removed it in https://github.com/PX4/PX4-Autopilot/pull/21714/commits/0b18bd59a46268574460aa9b60f0e13cea5aa36e. I feel like we should rather de-couple path handling (through the position setpoints) and speed setpoints (independent of the path) for now.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-07-17T13:54:29Z",
          "body": ">Also - why are we sending the command again instead of just applying the properties? (sorry im a bit out of the loop on all this)\r\n\r\nBecause the speed setpoint is handled by the Navigator but by the Position controllers (FW Pos and MPC). See https://github.com/PX4/PX4-Autopilot/pull/19407. So Navigator has to re-publish the command, and the position controllers can take it up and execute the change.\r\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "tstastny",
          "created_at": "",
          "body": "I left some questions, just because navigator is quite nebulous to me. But otherwise great that we are reducing complexity where possible.",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "Addressed two of your comments with new commits @tstastny ",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "tstastny",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior where resuming a mission reset the flight speed to the vehicle default instead of preserving a previously issued DO_CHANGE_SPEED setpoint. That is a logic/state error (lost persistent state across pause/resume), and the change to reapply the last mission speed and simplify stored-speed handling corrects the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 25,
        "changes": 46,
        "patch": "@@ -190,7 +190,8 @@ Mission::on_activation()\n \t// we already reset the mission items\n \t_execution_mode_changed = false;\n \n-\t// reset the cache and fill it with the camera and gimbal items up to the previous item\n+\t// reset the cache and fill it with the items up to the previous item. The cache contains\n+\t// commands that are valid for the whole mission, not just a sinlge waypoint.\n \tif (_current_mission_index > 0) {\n \t\tresetItemCache();\n \t\tupdateCachedItemsUpToIndex(_current_mission_index - 1);\n@@ -281,6 +282,8 @@ Mission::on_active()\n \t\treplayCachedTriggerItems();\n \t}\n \n+\treplayCachedSpeedChangeItems();\n+\n \t/* lets check if we reached the current mission item */\n \tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n \t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n@@ -302,11 +305,6 @@ Mission::on_active()\n \t\t}\n \t}\n \n-\t/* check if a cruise speed change has been commanded */\n-\tif (_mission_type != MISSION_TYPE_NONE) {\n-\t\tcruising_speed_sp_update();\n-\t}\n-\n \t/* see if we need to update the current yaw heading */\n \tif (!_param_mis_mnt_yaw_ctl.get()\n \t    && (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING)\n@@ -1480,25 +1478,6 @@ Mission::heading_sp_update()\n \t}\n }\n \n-void\n-Mission::cruising_speed_sp_update()\n-{\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\tconst float cruising_speed = _navigator->get_cruising_speed();\n-\n-\t/* Don't change setpoint if the current waypoint is not valid */\n-\tif (!pos_sp_triplet->current.valid ||\n-\t    fabsf(pos_sp_triplet->current.cruising_speed - cruising_speed) < FLT_EPSILON) {\n-\t\treturn;\n-\t}\n-\n-\tpos_sp_triplet->current.cruising_speed = cruising_speed;\n-\n-\tpublish_navigator_mission_item();\n-\t_navigator->set_position_setpoint_triplet_updated();\n-}\n-\n void\n Mission::do_abort_landing()\n {\n@@ -2060,6 +2039,15 @@ void Mission::cacheItem(const mission_item_s &mission_item)\n \t\t_last_camera_trigger_item = mission_item;\n \t\tbreak;\n \n+\tcase NAV_CMD_DO_CHANGE_SPEED:\n+\t\t_last_speed_change_item = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_DO_VTOL_TRANSITION:\n+\t\t// delete speed changes after a VTOL transition\n+\t\t_last_speed_change_item = {};\n+\t\tbreak;\n+\n \tdefault:\n \t\tbreak;\n \t}\n@@ -2091,6 +2079,14 @@ void Mission::replayCachedTriggerItems()\n \t}\n }\n \n+void Mission::replayCachedSpeedChangeItems()\n+{\n+\tif (_last_speed_change_item.nav_cmd == NAV_CMD_DO_CHANGE_SPEED) {\n+\t\tissue_command(_last_speed_change_item);\n+\t\t_last_speed_change_item = {}; // delete cached item\n+\t}\n+}\n+\n void Mission::resetItemCache()\n {\n \t_last_gimbal_configure_item = {};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0b18bd59a46268574460aa9b60f0e13cea5aa36e/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "patch": "@@ -163,11 +163,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t */\n \tvoid heading_sp_update();\n \n-\t/**\n-\t * Update the cruising speed setpoint.\n-\t */\n-\tvoid cruising_speed_sp_update();\n-\n \t/**\n \t * Abort landing\n \t */\n@@ -295,6 +290,12 @@ class Mission : public MissionBlock, public ModuleParams\n \t */\n \tvoid replayCachedTriggerItems();\n \n+\t/**\n+\t * @brief Replay the cached speed change items and delete them afterwards\n+\t *\n+\t */\n+\tvoid replayCachedSpeedChangeItems();\n+\n \t/**\n \t * @brief Reset the item cache\n \t */\n@@ -373,4 +374,5 @@ class Mission : public MissionBlock, public ModuleParams\n \tmission_item_s _last_gimbal_control_item {};\n \tmission_item_s _last_camera_mode_item {};\n \tmission_item_s _last_camera_trigger_item {};\n+\tmission_item_s _last_speed_change_item {};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0b18bd59a46268574460aa9b60f0e13cea5aa36e/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "patch": "@@ -199,25 +199,21 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t *\n \t * @return the desired cruising speed for this mission\n \t */\n-\tfloat get_cruising_speed();\n+\tfloat get_cruising_speed() { return _cruising_speed_current_mode; }\n \n \t/**\n \t * Set the cruising speed\n \t *\n-\t * Passing a negative value or leaving the parameter away will reset the cruising speed\n-\t * to its default value.\n-\t *\n-\t * For VTOL: sets cruising speed for current mode only (multirotor or fixed-wing).\n-\t *\n+\t * Passing a negative value will reset the cruising speed\n+\t * to its default value. Will automatically be reset to default\n+\t * on mode switch.\n \t */\n-\tvoid set_cruising_speed(float speed = -1.0f);\n+\tvoid set_cruising_speed(float desired_speed) { _cruising_speed_current_mode = desired_speed; }\n \n \t/**\n \t * Reset cruising speed to default values\n-\t *\n-\t * For VTOL: resets both cruising speeds.\n \t */\n-\tvoid reset_cruising_speed();\n+\tvoid reset_cruising_speed() { _cruising_speed_current_mode = -1.f; }\n \n \t/**\n \t *  Set triplets to invalid\n@@ -389,8 +385,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _param_mpc_jerk_auto{4.f}; \t/**< initialized with the default jerk auto value to prevent division by 0 if the parameter is accidentally set to 0 */\n \tfloat _param_mpc_acc_hor{3.f};\t\t/**< initialized with the default horizontal acc value to prevent division by 0 if the parameter is accidentally set to 0 */\n \n-\tfloat _mission_cruising_speed_mc{-1.0f};\n-\tfloat _mission_cruising_speed_fw{-1.0f};\n+\tfloat _cruising_speed_current_mode{-1.0f};\n \tfloat _mission_throttle{NAN};\n \n \ttraffic_buffer_s _traffic_buffer{};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0b18bd59a46268574460aa9b60f0e13cea5aa36e/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 38,
        "changes": 39,
        "patch": "@@ -605,7 +605,7 @@ void Navigator::run()\n \t\t\t\t\tset_cruising_speed(cmd.param2);\n \n \t\t\t\t} else {\n-\t\t\t\t\tset_cruising_speed();\n+\t\t\t\t\treset_cruising_speed();\n \n \t\t\t\t\t/* if no speed target was given try to set throttle */\n \t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n@@ -1144,43 +1144,6 @@ float Navigator::get_altitude_acceptance_radius()\n \t}\n }\n \n-float Navigator::get_cruising_speed()\n-{\n-\t/* there are three options: The mission-requested cruise speed, or the current hover / plane speed */\n-\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\tif (_mission_cruising_speed_mc > 0.0f) {\n-\t\t\treturn _mission_cruising_speed_mc;\n-\n-\t\t} else {\n-\t\t\treturn -1.0f;\n-\t\t}\n-\n-\t} else {\n-\t\tif (_mission_cruising_speed_fw > 0.0f) {\n-\t\t\treturn _mission_cruising_speed_fw;\n-\n-\t\t} else {\n-\t\t\treturn -1.0f;\n-\t\t}\n-\t}\n-}\n-\n-void Navigator::set_cruising_speed(float speed)\n-{\n-\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t_mission_cruising_speed_mc = speed;\n-\n-\t} else {\n-\t\t_mission_cruising_speed_fw = speed;\n-\t}\n-}\n-\n-void Navigator::reset_cruising_speed()\n-{\n-\t_mission_cruising_speed_mc = -1.0f;\n-\t_mission_cruising_speed_fw = -1.0f;\n-}\n-\n void Navigator::reset_triplets()\n {\n \treset_position_setpoint(_pos_sp_triplet.previous);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0b18bd59a46268574460aa9b60f0e13cea5aa36e/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::on_active",
        "Navigator::run",
        "Mission::on_activation",
        "Mission::replayCachedTriggerItems",
        "Mission::cacheItem",
        "only",
        "set_cruising_speed",
        "get_cruising_speed",
        "Navigator::get_altitude_acceptance_radius",
        "Navigator::set_cruising_speed",
        "Navigator::get_cruising_speed",
        "Mission::heading_sp_update",
        "cruising_speed_sp_update",
        "reset_cruising_speed",
        "Navigator::reset_cruising_speed"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_active",
          "Mission::on_activation",
          "Mission::replayCachedTriggerItems",
          "Mission::cacheItem",
          "Mission::heading_sp_update"
        ],
        "src/modules/navigator/mission.h": [
          "cruising_speed_sp_update"
        ],
        "src/modules/navigator/navigator.h": [
          "only",
          "set_cruising_speed",
          "get_cruising_speed",
          "reset_cruising_speed"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run",
          "Navigator::get_altitude_acceptance_radius",
          "Navigator::set_cruising_speed",
          "Navigator::get_cruising_speed",
          "Navigator::reset_cruising_speed"
        ]
      }
    }
  },
  {
    "title": "Navigator Mission: Improve mission resume",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21710",
    "number": 21710,
    "created_at": "2023-06-09T15:07:09Z",
    "merged": true,
    "merged_at": "2023-06-20T12:38:04Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Replaces https://github.com/PX4/PX4-Autopilot/pull/21643. I've tried to clean up the logic a bit and make it less entangled.\r\n\r\n### Solved Problem\r\nSurvey mission contain, beside the position items, contain items for gimbal config, camera mode config, and camera trigger. When the execution of a mission is stopped, we want also to stop the camera from taking pictures and move the gimbal back to neutral. Upon resuming the mission though, we have to re-configure gimbal and camera and start the triggering once back on the mission path.\r\n\r\n### Solution\r\nStore (cache) all gimbal/camera/trigger mission items and replay them on resuming the mission. In detail:\r\n- `on_inactivation() `store the currently active index as `_inactivation_index`\r\n- `on_activation()`, store all gimbal/camera/trigger items up to the currently active index and reset the mission to the previous. Also set flag (`_align_heading_necessary`) that a yaw alignment is required upon reaching this waypoint (we want to only start triggering once yaw is correctly aligned with next WP).\r\n- `on_active()`\r\n  - if `_align_heading_necessary` is set and mission item is reached, update current item with yaw field and force it to accept that one before starting the trigger.\r\n  - read the gimbal and camera mode command items from cache, thus making the gimbal move to the right orientation and setting the right camera mode\r\n  - read the trigger commands once the previous waypoint incl. yaw alignment is accepted\r\n\r\nFurther:\r\n- reset cached items if mission is updated\r\n- reset mission on disarmed only if we reached the last mission item, otherwise keep\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Improve mission resume (e.g. replay gimbal and camera commands of a survey)\r\nDocumentation: Need to clarify page\r\n```\r\n\r\n### Alternatives\r\nIt would be nice to not resume the mission from the previous mission item but from the actual lat/lon position where the mission was interrupted. \r\n\r\n### Test coverage\r\nSITL tested.\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2023-06-16T06:35:14Z",
          "body": "@sfuhrer LGTM. I hard a hard time understanding how the mission item is set when resuming the survey without calling `set_mission_items` but then I realized that `set_current_mission_index` does it under the hood :-p",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-06-18T16:46:37Z",
          "body": "@sfuhrer Flash overflow :-(",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-19T09:11:53Z",
          "body": "> @sfuhrer Flash overflow :-(\r\n\r\nv4_test indeed is at 100.00%..in an effort to bring it slightly down I've removed some rather unnecessary params and made some other param descriptions more compact, let's see if that's enough. ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-19T10:05:39Z",
          "body": "> > @sfuhrer Flash overflow :-(\r\n> \r\n> v4_test indeed is at 100.00%..in an effort to bring it slightly down I've removed some rather unnecessary params and made some other param descriptions more compact, let's see if that's enough.\r\n\r\nThat wasn't enough. I've proposed to remove the gyro FFT instead: https://github.com/PX4/PX4-Autopilot/pull/20811",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2023-06-16T06:22:23Z",
          "body": "```suggestion\r\n\t\t// add yaw alignment requirement on the current mission item\r\n```",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-06-16T06:29:45Z",
          "body": "@sfuhrer Can you make a comment why this is necessary here?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-06-16T06:31:17Z",
          "body": "@sfuhrer Can these functions be made const?",
          "path": "src/modules/navigator/mission.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-06-16T06:32:02Z",
          "body": "```suggestion\r\n\tint _inactivation_index{-1}; // index of mission item at which the mission was paused. Used to resume survey missions at previous waypoint to not lose images.\r\n```",
          "path": "src/modules/navigator/mission.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-06-16T06:41:08Z",
          "body": "@sfuhrer I am trying to think about a stupid corner case. What if the user sets the current mission index to the resume index manually while the vehicle is paused. Then he engages RTL and cancels RTL. Then he resumes the mission.\r\nThe `_mission_item` would have been overriden by RTL (shared item) and `_current_mission_index` would be equal to `resume_index`in which case `set_current_mission_index` does an early return. Is that a potential corner case where the mission would fly to the RTL item?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 50,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-16T09:43:34Z",
          "body": "Well I was actually wanting to ask you the exact same question :sweat_smile: . I actually don't see where it comes from. Reverse mission is only something that's supported in RTL, no? And there we don't care about mission resume camera logic..\r\nRemove it?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-16T09:57:26Z",
          "body": "certainly, done",
          "path": "src/modules/navigator/mission.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-16T10:05:12Z",
          "body": "removed it.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-06-16T10:20:19Z",
          "body": "Yes you're right, but it seems that this behavior is already like that without this PR.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 50,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "Added comments in the code",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect runtime behaviour (improper state transitions and sequencing) when resuming survey missions: camera/gimbal/trigger commands were not re-applied and triggering could resume at the wrong orientation. The change caches and replays the relevant mission items, enforces yaw alignment before restarting triggers, and resets state on mission updates/disarm, which addresses a logic bug rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 205,
        "deletions": 18,
        "changes": 223,
        "patch": "@@ -161,14 +161,7 @@ Mission::on_inactive()\n void\n Mission::on_inactivation()\n {\n-\t// Disable camera trigger\n-\tvehicle_command_s cmd {};\n-\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n-\t// Pause trigger\n-\tcmd.param1 = -1.0f;\n-\tcmd.param3 = 1.0f;\n-\t_navigator->publish_vehicle_cmd(&cmd);\n-\n+\t_navigator->disable_camera_trigger();\n \t_navigator->stop_capturing_images();\n \t_navigator->release_gimbal_control();\n \n@@ -178,6 +171,8 @@ Mission::on_inactivation()\n \n \t/* reset so current mission item gets restarted if mission was paused */\n \t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\n+\t_inactivation_index = _current_mission_index;\n }\n \n void\n@@ -195,15 +190,28 @@ Mission::on_activation()\n \t// we already reset the mission items\n \t_execution_mode_changed = false;\n \n-\tset_mission_items();\n+\t// reset the cache and fill it with the camera and gimbal items up to the previous item\n+\tif (_current_mission_index > 0) {\n+\t\tresetItemCache();\n+\t\tupdateCachedItemsUpToIndex(_current_mission_index - 1);\n+\t}\n+\n+\tunsigned resume_index;\n \n-\t// unpause triggering if it was paused\n-\tvehicle_command_s cmd = {};\n-\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n-\t// unpause trigger\n-\tcmd.param1 = -1.0f;\n-\tcmd.param3 = 0.0f;\n-\t_navigator->publish_vehicle_cmd(&cmd);\n+\tif (_inactivation_index > 0 && cameraWasTriggering()\n+\t    && getPreviousPositionItemIndex(_mission, _inactivation_index - 1, resume_index)) {\n+\t\t// The mission we are resuming had camera triggering enabled. In order to not lose any images\n+\t\t// we restart the mission at the previous position item.\n+\t\t// We will replay the cached commands once we reach the previous position item and have yaw aligned.\n+\t\tset_current_mission_index(resume_index);\n+\n+\t\t_align_heading_necessary = true;\n+\n+\t} else {\n+\t\tset_mission_items();\n+\t}\n+\n+\t_inactivation_index = -1; // reset\n \n \t// reset cruise speed\n \t_navigator->reset_cruising_speed();\n@@ -242,6 +250,37 @@ Mission::on_active()\n \t\tset_mission_items();\n \t}\n \n+\t// check if heading alignment is necessary, and add it to the current mission item if necessary\n+\tif (_align_heading_necessary && is_mission_item_reached_or_completed()) {\n+\t\tmission_item_s next_position_mission_item = {};\n+\n+\t\t// add yaw alignment requirement on the current mission item\n+\t\tif (getNextPositionMissionItem(_mission, _current_mission_index + 1, next_position_mission_item)\n+\t\t    && !PX4_ISFINITE(_mission_item.yaw)) {\n+\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon));\n+\t\t\t_mission_item.force_heading = true; // note: doesn't have effect in fixed-wing mode\n+\t\t}\n+\n+\t\tmission_apply_limitation(_mission_item);\n+\t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n+\n+\t\treset_mission_item_reached();\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t_align_heading_necessary = false;\n+\t}\n+\n+\t// replay gimbal and camera commands immediately after resuming mission\n+\tif (haveCachedGimbalOrCameraItems()) {\n+\t\treplayCachedGimbalCameraItems();\n+\t}\n+\n+\t// replay trigger commands upon raching the resume waypoint if the trigger relay flag is set\n+\tif (cameraWasTriggering() && is_mission_item_reached_or_completed()) {\n+\t\treplayCachedTriggerItems();\n+\t}\n+\n \t/* lets check if we reached the current mission item */\n \tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n \t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n@@ -312,6 +351,11 @@ Mission::set_current_mission_index(uint16_t index)\n \n \t\t_current_mission_index = index;\n \n+\t\t// we start from the first item so can reset the cache\n+\t\tif (_current_mission_index == 0) {\n+\t\t\tresetItemCache();\n+\t\t}\n+\n \t\t// a mission index is set manually which has the higher priority than the closest mission item\n \t\t// as it is set by the user\n \t\t_mission_waypoints_changed = false;\n@@ -387,6 +431,7 @@ Mission::set_execution_mode(const uint8_t mode)\n \t\t\t\t// handle switch from reverse to forward mission\n \t\t\t\tif (_current_mission_index < 0) {\n \t\t\t\t\t_current_mission_index = 0;\n+\t\t\t\t\tresetItemCache(); // reset cache as we start from the beginning\n \n \t\t\t\t} else if (_current_mission_index < _mission.count - 1) {\n \t\t\t\t\t++_current_mission_index;\n@@ -585,6 +630,14 @@ Mission::update_mission()\n \t\t_current_mission_index = 0;\n \t}\n \n+\t// we start from the first item so can reset the cache\n+\tif (_current_mission_index == 0) {\n+\t\tresetItemCache();\n+\t}\n+\n+\t// reset as when we update mission we don't want to proceed at previous index\n+\t_inactivation_index = -1;\n+\n \t// find and store landing start marker (if available)\n \tfind_mission_land_start();\n \n@@ -1819,8 +1872,9 @@ Mission::reset_mission(struct mission_s &mission)\n bool\n Mission::need_to_reset_mission()\n {\n-\t/* reset mission state when disarmed */\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED && _need_mission_reset) {\n+\t// reset mission when disarmed, mission was actually started and we reached the last mission item\n+\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED && _need_mission_reset\n+\t    && (_current_mission_index == _mission.count - 1)) {\n \t\t_need_mission_reset = false;\n \t\treturn true;\n \t}\n@@ -1938,3 +1992,136 @@ void Mission::publish_navigator_mission_item()\n \n \t_navigator_mission_item_pub.publish(navigator_mission_item);\n }\n+\n+bool Mission::getPreviousPositionItemIndex(const mission_s &mission, int inactivation_index,\n+\t\tunsigned &prev_pos_index) const\n+{\n+\tstruct mission_item_s missionitem = {};\n+\n+\tfor (int index = inactivation_index; index >= 0; index--) {\n+\t\tif (!readMissionItemAtIndex(mission, index, missionitem)) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (MissionBlock::item_contains_position(missionitem)) {\n+\t\t\tprev_pos_index = index;\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool Mission::getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item) const\n+{\n+\twhile (start_index < mission.count) {\n+\t\tif (readMissionItemAtIndex(mission, start_index, mission_item) && MissionBlock::item_contains_position(mission_item)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tstart_index++;\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool Mission::readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem) const\n+{\n+\tbool success = false;\n+\n+\tif (index >= 0 && index < mission.count) {\n+\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n+\t\tconst ssize_t len = sizeof(missionitem);\n+\t\tsuccess = (dm_read(dm_current, index, &missionitem, len) == len);\n+\t}\n+\n+\treturn success;\n+}\n+\n+void Mission::cacheItem(const mission_item_s &mission_item)\n+{\n+\tswitch (mission_item.nav_cmd) {\n+\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n+\t\t_last_gimbal_configure_item = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n+\t\t_last_gimbal_control_item = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_SET_CAMERA_MODE:\n+\t\t_last_camera_mode_item = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n+\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n+\tcase NAV_CMD_IMAGE_START_CAPTURE:\n+\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n+\t\t_last_camera_trigger_item = mission_item;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n+void Mission::replayCachedGimbalCameraItems()\n+{\n+\tif (_last_gimbal_configure_item.nav_cmd > 0) {\n+\t\tissue_command(_last_gimbal_configure_item);\n+\t\t_last_gimbal_configure_item = {}; // delete cached item\n+\t}\n+\n+\tif (_last_gimbal_control_item.nav_cmd > 0) {\n+\t\tissue_command(_last_gimbal_control_item);\n+\t\t_last_gimbal_control_item = {}; // delete cached item\n+\t}\n+\n+\tif (_last_camera_mode_item.nav_cmd > 0) {\n+\t\tissue_command(_last_camera_mode_item);\n+\t\t_last_camera_mode_item = {}; // delete cached item\n+\t}\n+}\n+\n+void Mission::replayCachedTriggerItems()\n+{\n+\tif (_last_camera_trigger_item.nav_cmd > 0) {\n+\t\tissue_command(_last_camera_trigger_item);\n+\t\t_last_camera_trigger_item = {}; // delete cached item\n+\t}\n+}\n+\n+void Mission::resetItemCache()\n+{\n+\t_last_gimbal_configure_item = {};\n+\t_last_gimbal_control_item = {};\n+\t_last_camera_mode_item = {};\n+\t_last_camera_trigger_item = {};\n+}\n+\n+bool Mission::haveCachedGimbalOrCameraItems()\n+{\n+\treturn _last_gimbal_configure_item.nav_cmd > 0 ||\n+\t       _last_gimbal_control_item.nav_cmd > 0 ||\n+\t       _last_camera_mode_item.nav_cmd > 0;\n+}\n+\n+bool Mission::cameraWasTriggering()\n+{\n+\treturn (_last_camera_trigger_item.nav_cmd == NAV_CMD_DO_TRIGGER_CONTROL\n+\t\t&& (int)(_last_camera_trigger_item.params[0] + 0.5f) == 1) ||\n+\t       (_last_camera_trigger_item.nav_cmd == NAV_CMD_IMAGE_START_CAPTURE) ||\n+\t       (_last_camera_trigger_item.nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST\n+\t\t&& _last_camera_trigger_item.params[0] > FLT_EPSILON);\n+}\n+\n+void Mission::updateCachedItemsUpToIndex(const int end_index)\n+{\n+\tfor (int i = 0; i <= end_index; i++) {\n+\t\tmission_item_s mission_item = {};\n+\n+\t\tif (readMissionItemAtIndex(_mission, i, mission_item)) {\n+\t\t\tcacheItem(mission_item);\n+\t\t}\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/63e1d42134e78ea7077f308600ddf6bb4044fdae/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "patch": "@@ -240,6 +240,80 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tvoid publish_navigator_mission_item();\n \n+\n+\t/**\n+\t* @brief Get the index associated with the last item that contains a position\n+\t* @param mission The mission to search\n+\t* @param start_index The index to start searching from\n+\t* @param prev_pos_index The index of the previous position item containing a position\n+\t* @return true if a previous position item was found\n+\t*/\n+\tbool getPreviousPositionItemIndex(const mission_s &mission, int start_index, unsigned &prev_pos_index) const;\n+\n+\t/**\n+\t * @brief Get the next item after start_index that contains a position\n+\t *\n+\t * @param mission The mission to search\n+\t * @param start_index The index to start searching from\n+\t * @param mission_item The mission item to populate\n+\t * @return true if successful\n+\t */\n+\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item) const;\n+\n+\t/**\n+\t * @brief Read the mission item at the given index\n+\t *\n+\t * @param mission The mission to read from\n+\t * @param index The index to read\n+\t * @param missionitem The mission item to populate\n+\t * @return true if successful\n+\t */\n+\tbool readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem) const;\n+\n+\t/**\n+\t * @brief Cache the mission items containing gimbal, camera mode and trigger commands\n+\t *\n+\t * @param mission_item The mission item to cache if applicable\n+\t */\n+\tvoid cacheItem(const mission_item_s &mission_item);\n+\n+\t/**\n+\t * @brief Update the cached items up to the given index\n+\t *\n+\t * @param end_index The index to update up to\n+\t */\n+\tvoid updateCachedItemsUpToIndex(int end_index);\n+\n+\t/**\n+\t * @brief Replay the cached gimbal and camera mode items\n+\t */\n+\tvoid replayCachedGimbalCameraItems();\n+\n+\t/**\n+\t * @brief Replay the cached trigger items\n+\t *\n+\t */\n+\tvoid replayCachedTriggerItems();\n+\n+\t/**\n+\t * @brief Reset the item cache\n+\t */\n+\tvoid resetItemCache();\n+\n+\t/**\n+\t * @brief Check if there are cached gimbal or camera mode items to be replayed\n+\t *\n+\t * @return true if there are cached items\n+\t */\n+\tbool haveCachedGimbalOrCameraItems();\n+\n+\t/**\n+\t * @brief Check if the camera was triggering\n+\t *\n+\t * @return true if there was a camera trigger command in the cached items that didn't disable triggering\n+\t */\n+\tbool cameraWasTriggering();\n+\n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n@@ -291,4 +365,12 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tuint8_t _mission_execution_mode{mission_result_s::MISSION_EXECUTION_MODE_NORMAL};\t/**< the current mode of how the mission is executed,look at mission_result.msg for the definition */\n \tbool _execution_mode_changed{false};\n+\n+\tint _inactivation_index{-1}; // index of mission item at which the mission was paused. Used to resume survey missions at previous waypoint to not lose images.\n+\tbool _align_heading_necessary{false}; // if true, heading of vehicle needs to be aligned with heading of next waypoint. Used to create new mission items for heading alignment.\n+\n+\tmission_item_s _last_gimbal_configure_item {};\n+\tmission_item_s _last_gimbal_control_item {};\n+\tmission_item_s _last_camera_mode_item {};\n+\tmission_item_s _last_camera_trigger_item {};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/63e1d42134e78ea7077f308600ddf6bb4044fdae/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -302,8 +302,10 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvoid acquire_gimbal_control();\n \tvoid release_gimbal_control();\n \n-\tvoid \t\tcalculate_breaking_stop(double &lat, double &lon, float &yaw);\n-\tvoid        \tstop_capturing_images();\n+\tvoid calculate_breaking_stop(double &lat, double &lon, float &yaw);\n+\n+\tvoid stop_capturing_images();\n+\tvoid disable_camera_trigger();\n \n \tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/63e1d42134e78ea7077f308600ddf6bb4044fdae/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "patch": "@@ -1527,6 +1527,18 @@ void Navigator::mode_completed(uint8_t nav_state, uint8_t result)\n \t_mode_completed_pub.publish(mode_completed);\n }\n \n+\n+void Navigator::disable_camera_trigger()\n+{\n+\t// Disable camera trigger\n+\tvehicle_command_s cmd {};\n+\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n+\t// Pause trigger\n+\tcmd.param1 = -1.0f;\n+\tcmd.param3 = 1.0f;\n+\tpublish_vehicle_cmd(&cmd);\n+}\n+\n int Navigator::print_usage(const char *reason)\n {\n \tif (reason) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/63e1d42134e78ea7077f308600ddf6bb4044fdae/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::reset_mission",
        "Mission::update_mission",
        "Mission::on_active",
        "Navigator::mode_completed",
        "Mission::on_inactive",
        "Mission::on_activation",
        "Mission::publish_navigator_mission_item",
        "calculate_breaking_stop",
        "stop_capturing_images",
        "Mission::set_execution_mode",
        "Mission::set_current_mission_index",
        "Mission::on_inactivation"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::reset_mission",
          "Mission::update_mission",
          "Mission::on_active",
          "Mission::on_inactive",
          "Mission::on_activation",
          "Mission::publish_navigator_mission_item",
          "Mission::set_execution_mode",
          "Mission::set_current_mission_index",
          "Mission::on_inactivation"
        ],
        "src/modules/navigator/navigator.h": [
          "calculate_breaking_stop",
          "stop_capturing_images"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::mode_completed"
        ]
      }
    }
  },
  {
    "title": "navigator: send commands to anyone listening",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21697",
    "number": 21697,
    "created_at": "2023-06-07T14:56:50Z",
    "merged": true,
    "merged_at": "2023-06-12T07:41:28Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\n POI commands that are part of a mission do not work when the gimbal is controlled by a companion computer. \r\n\r\n### Solution\r\nSend commands to anyone listening. \r\n\r\n### Test coverage\r\nWe have been flying with that change for some years now.\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-06-07T15:00:10Z",
          "body": "@bkueng @ThomasDebrunner you were looking into this before - do you think this change is needed?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "I don't remember exactly but I think it's still needed.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior (POI mission commands not reaching a gimbal when it's driven by a companion computer) by changing how commands are routed (broadcasting to any listener). This addresses a data-flow/recipient-selection logic bug that caused mission commands to be ignored rather than a syntax or crash issue.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -1428,7 +1428,7 @@ void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n \t\tbreak;\n \n \tdefault:\n-\t\tvcmd->target_component = _vstatus.component_id;\n+\t\tvcmd->target_component = 0;\n \t\tbreak;\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/89f9706a554fa43f149952dc8f83f5d6c3ddc967/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::publish_vehicle_cmd"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_vehicle_cmd"
        ]
      }
    }
  },
  {
    "title": "(Mission) FeasibilityChecker: remove duplicate line",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21689",
    "number": 21689,
    "created_at": "2023-06-06T12:53:56Z",
    "merged": true,
    "merged_at": "2023-07-04T09:17:24Z",
    "state": "closed",
    "conversation": {
      "author": "tstastny",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nI was poking around code and saw this duplicated line.\r\n\r\n### Solution\r\nremoved it\r\n\r\n### Changelog Entry\r\nN/A\r\n",
      "issue_comments": [
        {
          "author": "mrpollo",
          "created_at": "2023-06-28T17:53:36Z",
          "body": "Thanks @tstastny ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "mcsauder",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR simply removes a duplicated line according to the description and contains no mention of incorrect behavior, failing tests, or state inconsistencies. There is no evidence in the title, body, or comments that this change fixes unintended program output or state, so it appears to be a cosmetic/cleanup change rather than a logic bug fix.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -380,7 +380,6 @@ bool FeasibilityChecker::checkTakeoff(mission_item_s &mission_item)\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n-\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION);\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e5ab9ffc001f193d2188dede3c90cd0c3513a2ed/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::checkTakeoff"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkTakeoff"
        ]
      }
    }
  },
  {
    "title": "Port VTOL mission item resets and QC rework",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21665",
    "number": 21665,
    "created_at": "2023-05-31T17:45:54Z",
    "merged": true,
    "merged_at": "2023-06-02T08:22:34Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Port of https://github.com/PX4/PX4-Autopilot/pull/21641 and https://github.com/PX4/PX4-Autopilot/pull/21598 to 1.14",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and linked upstream changes indicate it ports fixes for 'VTOL mission item resets' and a 'QC rework', which suggest corrections to mission-state handling and quality-control logic (i.e. incorrect state transitions/behavior). However, the PR body and comments contain no concrete code snippets or details here, so the conclusion relies on the intent described rather than direct evidence from the diff.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -982,7 +982,10 @@ Mission::set_mission_items()\n \t\t\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t\t\t_mission_item.autocontinue = true;\n-\t\t\t\t\t_mission_item.time_inside = 0.0f;\n+\n+\t\t\t\t\t// have to reset here because these field were used in set_vtol_transition_item\n+\t\t\t\t\t_mission_item.time_inside = 0.f;\n+\t\t\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \n \t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n \t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/62d4481a809166b28908a9dd2fee1e27efa72e86/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -544,6 +544,10 @@ void RTL::set_rtl_item()\n \t\t\t_mission_item.altitude = loiter_altitude;\n \t\t\t_mission_item.altitude_is_relative = false;\n \n+\t\t\t// have to reset here because these field were used in set_vtol_transition_item\n+\t\t\t_mission_item.time_inside = 0.f;\n+\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\n \t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING) {\n \t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n \n@@ -554,7 +558,6 @@ void RTL::set_rtl_item()\n \t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n \t\t\t}\n \n-\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \t\t\tbreak;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/62d4481a809166b28908a9dd2fee1e27efa72e86/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -117,8 +117,9 @@ VtolTakeoff::on_active()\n \t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n \t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n \t\t\t\t// however it will just continue loitering as there is no next mission item\n-\t\t\t\t_mission_item.time_inside = 1;\n+\t\t\t\t_mission_item.time_inside = 1.f;\n \t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n \t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n \n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/62d4481a809166b28908a9dd2fee1e27efa72e86/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "VtolTakeoff::on_active",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Adsb warnings fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21663",
    "number": 21663,
    "created_at": "2023-05-31T12:39:32Z",
    "merged": true,
    "merged_at": "2024-04-22T08:14:39Z",
    "state": "closed",
    "conversation": {
      "author": "asimopunov",
      "body": "- warn about full traffic conflict buffer at 1/60hz.\r\n- add conflict expiry for buffer.\r\n- use only events for buffer full warning. mavlink_log_critical no longer needed.\r\n- use icao address for conflict warnings id, stop using uas_id. UTM_GLOBAL_POSITION assumed deprecated.\r\n- remove mavlink_log_critical warnings. Replaced with events.\r\n- stop spamming when buffer is full. log using px4_info and px4_warn for ulog since events don't show up on flight review or plotjuggler.\r\n- fix warning wording if buffer is full.\r\n- fix missing {1}, {2} etc. from events\r\n\r\n\r\nfollow up on https://github.com/PX4/PX4-Autopilot/pull/21283",
      "issue_comments": [
        {
          "author": "asimopunov",
          "created_at": "2023-09-29T01:05:33Z",
          "body": "@dakejahl Could you please fetch the adsb changes over to your next release? I was asked about this by Will. ",
          "type": "issue_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-04-11T20:13:24Z",
          "body": "> The CI failure happens on main already, but would be a good opportunity to quickly have a look.\r\n\r\n@bkueng hmm\r\nthey pass locally when I run `make tests TESTFILTER=functional-AdsbConflict`\r\nThe build step also passed when the tests were merged here - https://github.com/PX4/PX4-Autopilot/actions/runs/4431457384/job/12034874013\r\n\r\nMaybe it's unrelated - need to look more\r\n\r\nDoes that work-queue error directly point to anything for you?\r\n\r\n```\r\n[1277/1278] Running tests\r\n   Site: c36612c519c7\r\n   Build name: Linux-c++\r\nCreate new tag: 20240411-1954 - Experimental\r\nTest project /__w/PX4-Autopilot/PX4-Autopilot/build/px4_sitl_test\r\n        Start   1: functional-AdsbConflict\r\n  1/140 Test   #1: functional-AdsbConflict ..............................***Failed    0.01 sec\r\nERROR [px4_work_queue] not running\r\nERROR [px4_work_queue] wq:lp_default not available\r\nERROR [px4_work_queue] init failed\r\n[==========] Running 3 tests from 1 test suite.\r\n[----------] Global test environment set-up.\r\n[----------] 3 tests from AdsbConflictTest\r\n[ RUN      ] AdsbConflictTest.detectTrafficConflict\r\n```",
          "type": "issue_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-04-17T14:46:03Z",
          "body": "> The following tests FAILED:\r\n> \t  1 - functional-AdsbConflict (Failed)\r\n\r\n@bkueng It's passing now",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:40:25Z",
          "body": "This removes it but then accesses it in the next lines.\r\nWhy not directly remove them without the extra `expired_conflicts`?",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:41:48Z",
          "body": "they're displayed now in flight review",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:42:56Z",
          "body": "`events::send(events::ID(\"buffer_full\"), events::Log::Notice, \"Too much traffic! Showing all messages from now on\");` (remove the space)",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:45:47Z",
          "body": "The `@description` above contains the details. If you want to add them here as well, please make it more readable. hdg -> heading",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:46:10Z",
          "body": "Same here and below",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 199,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:46:49Z",
          "body": "Can you remove this?",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-11T06:47:21Z",
          "body": "It is 120",
          "path": "src/lib/adsb/AdsbConflict.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-04-11T19:33:24Z",
          "body": "Thanks, doesn't look like there was a good reason.\r\nfixed",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-04-11T19:33:56Z",
          "body": "yup, better?",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-17T06:15:29Z",
          "body": "After removing you must ensure the index does not increase otherwise an element is skipped.",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 34,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-17T07:14:49Z",
          "body": "Yes, thanks",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-04-18T14:10:30Z",
          "body": "Did you mean to add this?",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-04-18T16:03:49Z",
          "body": "Of course, we don't need it. I'm just being lazy so I don't need to add another time if this CI fails again. I can remove.",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-04-18T22:22:34Z",
          "body": "removed",
          "path": "src/lib/adsb/AdsbConflict.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "The CI failure happens on main already, but would be a good opportunity to quickly have a look.\r\n```\r\nThe following tests FAILED:\r\n\t  1 - functional-AdsbConflict (Failed)\r\n```",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "",
          "body": "> Does that work-queue error directly point to anything for you?\r\n\r\nIt's probably unrelated unless the test accesses params.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "",
          "body": ">  @bkueng It's passing now\r\n\r\nNice, thanks",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect runtime behavior: it changes how the ADS-B conflict buffer is managed (adding expiry, reducing spam by throttling full-buffer warnings), corrects the identifier used for conflict warnings (ICAO vs uas_id), and fixes event formatting and logging behavior. These are logic-level fixes (state handling, incorrect IDs, improper error/spam handling) rather than syntax or style changes.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -1273,6 +1273,9 @@ void Navigator::check_traffic()\n \t\t\t}\n \t\t}\n \t}\n+\n+\t_adsb_conflict.remove_expired_conflicts();\n+\n }\n \n bool Navigator::abort_landing()\n@@ -1544,7 +1547,7 @@ controller.\n \tPRINT_MODULE_USAGE_NAME(\"navigator\", \"controller\");\n \tPRINT_MODULE_USAGE_COMMAND(\"start\");\n \tPRINT_MODULE_USAGE_COMMAND_DESCR(\"fencefile\", \"load a geofence file from SD card, stored at etc/geofence.txt\");\n-\tPRINT_MODULE_USAGE_COMMAND_DESCR(\"fake_traffic\", \"publishes 4 fake transponder_report_s uORB messages\");\n+\tPRINT_MODULE_USAGE_COMMAND_DESCR(\"fake_traffic\", \"publishes 24 fake transponder_report_s uORB messages\");\n \tPRINT_MODULE_USAGE_DEFAULT_COMMANDS();\n \n \treturn 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a34d3019c088597ad51b97b4bb19c4ec77f6e257/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::check_traffic"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::check_traffic"
        ]
      }
    }
  },
  {
    "title": "[1.14 Backport] Geofence: Disable pre-emptive geofence predictor by default",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21657",
    "number": 21657,
    "created_at": "2023-05-30T16:19:33Z",
    "merged": true,
    "merged_at": "2023-06-06T15:22:48Z",
    "state": "closed",
    "conversation": {
      "author": "junwoo091400",
      "body": "## About\r\nAs discussed in\r\nhttps://discuss.px4.io/t/px4-maintainers-call-may-30-2023/32372#v114-new-beta-release-5, Geofence predictor feature was not well tested / maintained, hence was agreed upon to be disabled for the 1.14 release\r\n\r\nThis is a backport because 1.14 has been branched out, but not going to `main` branch yet, since we haven't discussed what to do for the next release.",
      "issue_comments": [
        {
          "author": "DronecodeBot",
          "created_at": "2023-05-30T16:20:22Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-maintainers-call-may-30-2023/32372/1\n",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2023-06-06T15:36:05Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-maintainers-call-june-06-2023/32473/1\n",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2023-07-20T00:03:30Z",
          "body": "Should this also be disabled by default in main?",
          "type": "issue_comment"
        },
        {
          "author": "junwoo091400",
          "created_at": "2023-07-23T20:54:07Z",
          "body": "> Should this also be disabled by default in main?\r\n\r\nThanks for the reminder, it should! Hence I created a branch against the `main`. Thanks!",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "junwoo091400",
          "created_at": "2023-05-31T15:59:44Z",
          "body": "I've added the note, what do you think? @bresch @dagar ",
          "path": "src/modules/navigator/geofence_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2023-05-31T23:18:57Z",
          "body": "Certainly better than nothing. It is unfortunate that the parameter tables are rendered as HTML tables so we can't use markdown formatting.\r\n\r\nPerhaps something for 1.15 (as per [the discussion on feature support here](https://discuss.px4.io/t/px4-maintainers-call-may-30-2023/32372#fire-v115-next-release-improvement-discussion-8)) but perhaps we could add an `@experimental` tag in the parameter names to make it clear that the feature is experimental? (probably not, since a whole feature is experimental, not a particular parameter).\r\n\r\n```suggestion\r\n * [EXPERIMENTAL] Use Pre-emptive geofence triggering\r\n *\r\n * WARNING: This experimental feature may cause flyaways. Use at your own risk.\r\n```",
          "path": "src/modules/navigator/geofence_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "junwoo091400",
          "created_at": "2023-06-06T12:24:52Z",
          "body": "> Perhaps something for 1.15 (as per [the discussion on feature support here](https://discuss.px4.io/t/px4-maintainers-call-may-30-2023/32372#fire-v115-next-release-improvement-discussion-8)) but perhaps we could add an `@experimental` tag in the parameter names to make it clear that the feature is experimental?\r\n\r\nI think that could be nice, if we have mechanism in QGC to prompt \"WARNING! This feature is experimental!\" to make sure user gets notified the fact that it's experimental properly.\r\n\r\nOtherwise, I think you are probably thinking of documentation aspect of it as well, for displaying parameters with those tags with special colors perhaps?\r\n\r\nBtw, displaying markdown formatting in HTML is possible, for example like this: https://www.makeuseof.com/md-block-render-markdown-web-page/",
          "path": "src/modules/navigator/geofence_params.c",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "Should we add a note in the param that this is an experimental feature?\r\nOr what's the point of letting someone enabling it if we know that it can lead to a fly-away?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR changes the default configuration to disable an experimental geofence predictor feature that was untested and potentially unsafe. This is a safety/default change to avoid triggering incorrect behavior, not a correction of an algorithmic or control-flow bug in the code itself.",
    "patches": {
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -128,7 +128,9 @@ PARAM_DEFINE_FLOAT(GF_MAX_HOR_DIST, 0);\n PARAM_DEFINE_FLOAT(GF_MAX_VER_DIST, 0);\n \n /**\n- * Use Pre-emptive geofence triggering\n+ * [EXPERIMENTAL] Use Pre-emptive geofence triggering\n+ *\n+ * WARNING: This experimental feature may cause flyaways. Use at your own risk.\n  *\n  * Predict the motion of the vehicle and trigger the breach if it is determined that the current trajectory\n  * would result in a breach happening before the vehicle can make evasive maneuvers.\n@@ -137,4 +139,4 @@ PARAM_DEFINE_FLOAT(GF_MAX_VER_DIST, 0);\n  * @boolean\n  * @group Geofence\n  */\n-PARAM_DEFINE_INT32(GF_PREDICT, 1);\n+PARAM_DEFINE_INT32(GF_PREDICT, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8af7ec193e1f1c0f2d4355c24b3380a50d9f01ca/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "navigator: improve survey resume",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21643",
    "number": 21643,
    "created_at": "2023-05-26T14:04:18Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "Igor-Misic",
      "body": null,
      "issue_comments": [
        {
          "author": "Igor-Misic",
          "created_at": "2023-06-18T16:25:19Z",
          "body": "continued here: https://github.com/PX4/PX4-Autopilot/pull/21710 ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "There is insufficient information to conclude this PR fixes a logic error: the title ('navigator: improve survey resume') hints at behavioral changes but no description, diffs, or discussion of incorrect behavior/bug are provided. It may be an improvement or refactor, but without code or issue details we cannot identify a specific logic bug being fixed.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 206,
        "deletions": 18,
        "changes": 224,
        "patch": "@@ -161,14 +161,7 @@ Mission::on_inactive()\n void\n Mission::on_inactivation()\n {\n-\t// Disable camera trigger\n-\tvehicle_command_s cmd {};\n-\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n-\t// Pause trigger\n-\tcmd.param1 = -1.0f;\n-\tcmd.param3 = 1.0f;\n-\t_navigator->publish_vehicle_cmd(&cmd);\n-\n+\t_navigator->disable_camera_trigger();\n \t_navigator->stop_capturing_images();\n \t_navigator->release_gimbal_control();\n \n@@ -178,6 +171,8 @@ Mission::on_inactivation()\n \n \t/* reset so current mission item gets restarted if mission was paused */\n \t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\n+\t_inactivation_index = _current_mission_index;\n }\n \n void\n@@ -195,15 +190,26 @@ Mission::on_activation()\n \t// we already reset the mission items\n \t_execution_mode_changed = false;\n \n-\tset_mission_items();\n+\tif (_current_mission_index > 0 && _current_mission_index != _inactivation_index) {\n+\t\treset_command_cache();\n+\t\tupdateChachedCommandsUpToIndex(_current_mission_index - 1);\n+\t}\n+\n+\tunsigned resume_index;\n+\n+\tif (cameraWasTriggering()\n+\t    && getPreviousPositionItemIndex(_mission, _current_mission_index - 1, resume_index)) {\n+\t\t// the mission we are resuming had camera triggering enabled. In order to not lose any images\n+\t\t// we restart the mission at the previous position item.\n+\t\t// we will replay the cached commands once we reach the previous position item\n+\t\tset_current_mission_index(resume_index);\n+\n+\t} else {\n+\t\tset_mission_items();\n+\t}\n \n-\t// unpause triggering if it was paused\n-\tvehicle_command_s cmd = {};\n-\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n-\t// unpause trigger\n-\tcmd.param1 = -1.0f;\n-\tcmd.param3 = 0.0f;\n-\t_navigator->publish_vehicle_cmd(&cmd);\n+\t_replay_cached_gimbal_commands_at_next_waypoint = haveCachedCommands();\n+\t_inactivation_index = -1;\n \n \t// reset cruise speed\n \t_navigator->reset_cruising_speed();\n@@ -242,6 +248,43 @@ Mission::on_active()\n \t\tset_mission_items();\n \t}\n \n+\tconst bool mission_item_reached = is_mission_item_reached_or_completed();\n+\n+\tif (mission_item_reached && _replay_cached_gimbal_commands_at_next_waypoint\n+\t    && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n+\n+\t\treplay_cached_gimbal_commands();\n+\t\t_replay_cached_gimbal_commands_at_next_waypoint = false;\n+\n+\t\tmission_item_s next_mission_item = {};\n+\n+\t\tif (getNextPositionMissionItem(_mission, _current_mission_index + 1, next_mission_item)\n+\t\t    && !PX4_ISFINITE(_mission_item.yaw)) {\n+\t\t\t// we are at the waypoint from which we want to resume the mission, first make sure that we are facing the next waypoint if there is one\n+\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t\t\t\t\t    next_mission_item.lat, next_mission_item.lon));\n+\t\t\t_mission_item.force_heading = true;\n+\n+\t\t\t// replay camera commands at the next waypoint to ensure the gimbal and vehicle are aligned for shooting\n+\t\t\t_replay_cached_camera_commands_at_next_waypoint = cameraWasTriggering();\n+\n+\t\t}\n+\n+\t\tmission_apply_limitation(_mission_item);\n+\t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n+\n+\t\treset_mission_item_reached();\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t\treturn;\n+\t}\n+\n+\tif (_replay_cached_camera_commands_at_next_waypoint && mission_item_reached) {\n+\t\treplay_cached_camera_commands();\n+\t\t_replay_cached_camera_commands_at_next_waypoint = false;\n+\t}\n+\n \t/* lets check if we reached the current mission item */\n \tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n \t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n@@ -312,6 +355,10 @@ Mission::set_current_mission_index(uint16_t index)\n \n \t\t_current_mission_index = index;\n \n+\t\tif (_current_mission_index == 0) {\n+\t\t\treset_command_cache();\n+\t\t}\n+\n \t\t// a mission index is set manually which has the higher priority than the closest mission item\n \t\t// as it is set by the user\n \t\t_mission_waypoints_changed = false;\n@@ -362,6 +409,7 @@ Mission::set_execution_mode(const uint8_t mode)\n \t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n \t\t\t\t\tpublish_navigator_mission_item(); // for logging\n \t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t\t\t\tcache_command(_mission_item);\n \t\t\t\t\tissue_command(_mission_item);\n \t\t\t\t}\n \n@@ -387,6 +435,7 @@ Mission::set_execution_mode(const uint8_t mode)\n \t\t\t\t// handle switch from reverse to forward mission\n \t\t\t\tif (_current_mission_index < 0) {\n \t\t\t\t\t_current_mission_index = 0;\n+\t\t\t\t\treset_command_cache();\n \n \t\t\t\t} else if (_current_mission_index < _mission.count - 1) {\n \t\t\t\t\t++_current_mission_index;\n@@ -585,6 +634,10 @@ Mission::update_mission()\n \t\t_current_mission_index = 0;\n \t}\n \n+\tif (_current_mission_index == 0) {\n+\t\treset_command_cache();\n+\t}\n+\n \t// find and store landing start marker (if available)\n \tfind_mission_land_start();\n \n@@ -1816,8 +1869,9 @@ Mission::reset_mission(struct mission_s &mission)\n bool\n Mission::need_to_reset_mission()\n {\n-\t/* reset mission state when disarmed */\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED && _need_mission_reset) {\n+\t/* reset mission state when disarmed and the mission was finished */\n+\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED && _need_mission_reset\n+\t    && (_current_mission_index == _mission.count - 1 || _navigator->get_vstatus()->is_vtol)) {\n \t\t_need_mission_reset = false;\n \t\treturn true;\n \t}\n@@ -1935,3 +1989,137 @@ void Mission::publish_navigator_mission_item()\n \n \t_navigator_mission_item_pub.publish(navigator_mission_item);\n }\n+\n+bool Mission::getPreviousPositionItemIndex(const mission_s &mission, int start_index, unsigned &prev_pos_index)\n+{\n+\tstruct mission_item_s missionitem = {};\n+\n+\tfor (int index = start_index; index >= 0; index--) {\n+\n+\t\tif (!readMissionItemAtIndex(mission, index, missionitem)) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (MissionBlock::item_contains_position(missionitem)) {\n+\t\t\tprev_pos_index = index;\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool Mission::getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item)\n+{\n+\twhile (start_index < mission.count) {\n+\t\tif (readMissionItemAtIndex(mission, start_index, mission_item) && MissionBlock::item_contains_position(mission_item)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tstart_index++;\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool Mission::readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem)\n+{\n+\tbool success = false;\n+\n+\tif (index >= 0 && index < mission.count) {\n+\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n+\t\tconst ssize_t len = sizeof(missionitem);\n+\n+\t\tsuccess = (dm_read(dm_current, index, &missionitem, len) == len);\n+\t}\n+\n+\treturn success;\n+}\n+\n+void Mission::cache_command(const mission_item_s &mission_item)\n+{\n+\tswitch (mission_item.nav_cmd) {\n+\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n+\t\t_last_gimbal_configure_command = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n+\t\t_last_gimbal_control_command = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_SET_CAMERA_MODE:\n+\t\t_last_camera_mode_command = mission_item;\n+\t\tbreak;\n+\n+\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n+\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n+\tcase NAV_CMD_IMAGE_START_CAPTURE:\n+\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n+\t\t_last_camera_trigger_command = mission_item;\n+\t\tbreak;\n+\n+\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n+void Mission::replay_cached_gimbal_commands()\n+{\n+\tif (_last_gimbal_configure_command.nav_cmd > 0) {\n+\t\tissue_command(_last_gimbal_configure_command);\n+\t}\n+\n+\tif (_last_gimbal_control_command.nav_cmd > 0) {\n+\t\tissue_command(_last_gimbal_control_command);\n+\t}\n+}\n+\n+void Mission::replay_cached_camera_commands()\n+{\n+\tif (_last_camera_mode_command.nav_cmd > 0) {\n+\t\tissue_command(_last_camera_mode_command);\n+\t}\n+\n+\tif (_last_gimbal_configure_command.nav_cmd > 0) {\n+\t\tissue_command(_last_camera_trigger_command);\n+\t}\n+}\n+\n+void Mission::reset_command_cache()\n+{\n+\t_last_gimbal_configure_command = {};\n+\t_last_gimbal_control_command = {};\n+\t_last_camera_mode_command = {};\n+\t_last_camera_trigger_command = {};\n+}\n+\n+bool Mission::haveCachedCommands()\n+{\n+\treturn _last_gimbal_configure_command.nav_cmd > 0 ||\n+\t       _last_gimbal_control_command.nav_cmd > 0 ||\n+\t       _last_camera_mode_command.nav_cmd > 0 ||\n+\t       _last_camera_trigger_command.nav_cmd > 0;\n+\n+}\n+\n+bool Mission::cameraWasTriggering()\n+{\n+\treturn (_last_camera_trigger_command.nav_cmd == NAV_CMD_DO_TRIGGER_CONTROL\n+\t\t&& (int)(_last_camera_trigger_command.params[0] + 0.5f) == 1) ||\n+\t       (_last_camera_trigger_command.nav_cmd == NAV_CMD_IMAGE_START_CAPTURE) ||\n+\t       (_last_camera_trigger_command.nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST\n+\t\t&& _last_camera_trigger_command.params[0] > 0.f);\n+}\n+\n+void Mission::updateChachedCommandsUpToIndex(const int end_index)\n+{\n+\tfor (int i = 0; i <= end_index; i++) {\n+\t\tmission_item_s mission_item = {};\n+\n+\t\tif (readMissionItemAtIndex(_mission, i, mission_item)) {\n+\t\t\tcache_command(_mission_item);\n+\t\t\tcache_command(mission_item);\n+\t\t}\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac2c4097d03f7857cf0295181aa7b7239e9c11a2/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "patch": "@@ -240,6 +240,24 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tvoid publish_navigator_mission_item();\n \n+\tbool getPreviousPositionItemIndex(const mission_s &mission, int start_index, unsigned &prev_pos_index);\n+\n+\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item);\n+\n+\tbool readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem);\n+\tvoid cache_command(const mission_item_s &mission_item);\n+\n+\tvoid updateChachedCommandsUpToIndex(int end_index);\n+\n+\n+\tvoid replay_cached_gimbal_commands();\n+\tvoid replay_cached_camera_commands();\n+\tvoid reset_command_cache();\n+\n+\tbool haveCachedCommands();\n+\n+\tbool cameraWasTriggering();\n+\n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n@@ -291,4 +309,14 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tuint8_t _mission_execution_mode{mission_result_s::MISSION_EXECUTION_MODE_NORMAL};\t/**< the current mode of how the mission is executed,look at mission_result.msg for the definition */\n \tbool _execution_mode_changed{false};\n+\n+\n+\tbool _replay_cached_gimbal_commands_at_next_waypoint = false;\n+\tbool _replay_cached_camera_commands_at_next_waypoint = false;\n+\tint _inactivation_index = -1;\n+\n+\tmission_item_s _last_gimbal_configure_command {};\n+\tmission_item_s _last_gimbal_control_command {};\n+\tmission_item_s _last_camera_mode_command {};\n+\tmission_item_s _last_camera_trigger_command {};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac2c4097d03f7857cf0295181aa7b7239e9c11a2/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -302,8 +302,9 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvoid acquire_gimbal_control();\n \tvoid release_gimbal_control();\n \n-\tvoid \t\tcalculate_breaking_stop(double &lat, double &lon, float &yaw);\n-\tvoid        \tstop_capturing_images();\n+\tvoid calculate_breaking_stop(double &lat, double &lon, float &yaw);\n+\tvoid stop_capturing_images();\n+\tvoid disable_camera_trigger();\n \n \tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac2c4097d03f7857cf0295181aa7b7239e9c11a2/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "patch": "@@ -1488,6 +1488,18 @@ Navigator::stop_capturing_images()\n \t}\n }\n \n+void\n+Navigator::disable_camera_trigger()\n+{\n+\t// Disable camera trigger\n+\tvehicle_command_s cmd {};\n+\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n+\t// Pause trigger\n+\tcmd.param1 = -1.0f;\n+\tcmd.param3 = 1.0f;\n+\tpublish_vehicle_cmd(&cmd);\n+}\n+\n bool Navigator::geofence_allows_position(const vehicle_global_position_s &pos)\n {\n \tif ((_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac2c4097d03f7857cf0295181aa7b7239e9c11a2/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::reset_mission",
        "Mission::update_mission",
        "Mission::on_active",
        "Navigator::stop_capturing_images",
        "Mission::on_inactive",
        "Mission::on_activation",
        "Mission::publish_navigator_mission_item",
        "calculate_breaking_stop",
        "stop_capturing_images",
        "Mission::set_execution_mode",
        "Mission::set_current_mission_index",
        "Mission::on_inactivation"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::reset_mission",
          "Mission::update_mission",
          "Mission::on_active",
          "Mission::on_inactive",
          "Mission::on_activation",
          "Mission::publish_navigator_mission_item",
          "Mission::set_execution_mode",
          "Mission::set_current_mission_index",
          "Mission::on_inactivation"
        ],
        "src/modules/navigator/navigator.h": [
          "calculate_breaking_stop",
          "stop_capturing_images"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::stop_capturing_images"
        ]
      }
    }
  },
  {
    "title": "Navigator: make sure to reset mission.item fields touched by set_vtol_transition_item",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21641",
    "number": 21641,
    "created_at": "2023-05-26T12:10:22Z",
    "merged": true,
    "merged_at": "2023-06-02T08:21:23Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "`\r\nmission_block::set_vtol_transition_item` sets the params of the mission item directly to values that make sense for NAV_CMD_DO_VTOL_TRANSITION, but don't for other NAV_CMDs. So make sure that whenever we use it, we then in the next step reset the touched mission_item fields.\r\n\r\n### Solved Problem\r\nacceptance radius and/or time_inside fields of mision_item can be wrong after a VTOL transition. \r\n\r\n### Solution\r\nMake sure to at least always fill the fields touched by set_vtol_transition_item, which are fields 0 (another union with eg time_inside), and acceptance_radius. \r\n\r\n### Alternatives\r\nChange the way of how `set_vtol_transition_item` works? Does it have to manually adapt the fields of _mission_item?\r\n\r\n### Test coverage\r\nSome SITL testing. \r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-05-31T17:42:02Z",
          "body": "Flight tested on multiple VTOLs, LGTM.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error where set_vtol_transition_item mutates mission_item fields to values valid only for NAV_CMD_DO_VTOL_TRANSITION and leaves those fields in an inappropriate state for subsequent commands, causing incorrect acceptance_radius/time_inside behavior. Resetting the touched fields prevents unintended state leakage and restores correct mission-item semantics.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -982,7 +982,10 @@ Mission::set_mission_items()\n \t\t\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t\t\t_mission_item.autocontinue = true;\n-\t\t\t\t\t_mission_item.time_inside = 0.0f;\n+\n+\t\t\t\t\t// have to reset here because these field were used in set_vtol_transition_item\n+\t\t\t\t\t_mission_item.time_inside = 0.f;\n+\t\t\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \n \t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n \t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/801ecd584655aab579093a13af97f6e380516678/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -544,6 +544,10 @@ void RTL::set_rtl_item()\n \t\t\t_mission_item.altitude = loiter_altitude;\n \t\t\t_mission_item.altitude_is_relative = false;\n \n+\t\t\t// have to reset here because these field were used in set_vtol_transition_item\n+\t\t\t_mission_item.time_inside = 0.f;\n+\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\n \t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING) {\n \t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n \n@@ -554,7 +558,6 @@ void RTL::set_rtl_item()\n \t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n \t\t\t}\n \n-\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \t\t\tbreak;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/801ecd584655aab579093a13af97f6e380516678/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -117,8 +117,9 @@ VtolTakeoff::on_active()\n \t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n \t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n \t\t\t\t// however it will just continue loitering as there is no next mission item\n-\t\t\t\t_mission_item.time_inside = 1;\n+\t\t\t\t_mission_item.time_inside = 1.f;\n \t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n \t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n \n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/801ecd584655aab579093a13af97f6e380516678/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "VtolTakeoff::on_active",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Fix incorrect _rtl_alt if RTL_TYPE param is RTL_TYPE_MISSION_LANDING_â€¦",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21620",
    "number": 21620,
    "created_at": "2023-05-20T20:05:36Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "s-lisovenko",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nPrevent aircraft crashing during return home mode if RTL_TYPE is 2 (RTL_TYPE_MISSION_LANDING_REVERSED)\r\nWhen RTL_TYPE==2 the **find_RTL_destination** function returns before **_rtl_alt** is calculated. Thus **_rtl_alt** == 0 which causes the aircraft to immediately descend during the activation of the return home and as a consequence of its crash.\r\n\r\n### Solution\r\nCalculate **_rtl_alt** before return from function\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-09-18T15:09:26Z",
          "body": "@KonradRudin I guess this is something you also fix through https://github.com/PX4/PX4-Autopilot/pull/20903? ",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-09-18T18:02:23Z",
          "body": "@sfuhrer, yes this should not happen anymore in the mentioned PR",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-09-19T08:34:36Z",
          "body": "@s-lisovenko would you be able to test https://github.com/PX4/PX4-Autopilot/pull/20903 and check if it indeed acts the same as you indented here? And then close this PR? Thanks!",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: an early return when RTL_TYPE==2 prevented _rtl_alt from being computed, leaving it at 0 and causing unintended immediate descent. This is an incorrect control-flow/state bug (improper ordering/conditional) that produces wrong runtime behavior rather than a syntax or style issue.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -259,6 +259,13 @@ void RTL::find_RTL_destination()\n \n \t// do not consider rally point if RTL type is set to RTL_TYPE_MISSION_LANDING_REVERSED, so exit function and use either home or mission landing\n \tif (_param_rtl_type.get() == RTL_TYPE_MISSION_LANDING_REVERSED) {\n+                if (_param_rtl_cone_half_angle_deg.get() > 0\n+                    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+                        _rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n+\n+                } else {\n+                        _rtl_alt = max(global_position.alt, _destination.alt + _param_rtl_return_alt.get());\n+                }\n \t\treturn;\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/10fa753e3a3526afbd36c6558b07fe02a8c34508/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::find_RTL_destination"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::find_RTL_destination"
        ]
      }
    }
  },
  {
    "title": "Navigator: MissionFeasibilityCheck: check if items fit to the current vehicle type",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21602",
    "number": 21602,
    "created_at": "2023-05-17T13:56:51Z",
    "merged": true,
    "merged_at": "2023-05-31T17:27:27Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nWhen switching between different vehicle types on the same groundstation, it can happen that by accident a mission that was planned for example for a VTOL gets uploaded to a Multicopter. This is can lead to undesired/unexpected behavior.\r\n\r\n### Solution\r\nAdd `checkItemsFitToVehicleType()` check that checks if the vehicle type is non-VTOL but there are VTOL mission items (VTOL_TAKEOFF, VTOL_LAND, VTOL_TRANSITION). The check can later be extended to handle all kind of vehicle type vs mission item checks.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Mission Feasibility Check: prevent uploading a mission containing VTOL items to non-VTOL vehicles\r\n```\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR adds a validation that prevents VTOL-specific mission items from being uploaded to non-VTOL vehicles, correcting incorrect program behavior (accepting incompatible missions). This addresses an improper state/validation logic that could produce unexpected behavior without crashing, which fits the definition of a logic error.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 2,
        "changes": 22,
        "patch": "@@ -206,6 +206,10 @@ void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int\n \tif (!_takeoff_failed) {\n \t\t_takeoff_failed = !checkTakeoff(mission_item);\n \t}\n+\n+\tif (!_items_fit_to_vehicle_type_failed) {\n+\t\t_items_fit_to_vehicle_type_failed = !checkItemsFitToVehicleType(mission_item);\n+\t}\n }\n \n void FeasibilityChecker::doVtolChecks(mission_item_s &mission_item, const int current_index, const int last_index)\n@@ -686,12 +690,26 @@ bool FeasibilityChecker::checkIfBelowHomeAltitude(const mission_item_s &mission_\n \n \tif (PX4_ISFINITE(_home_alt_msl) && _home_alt_msl > wp_alt && MissionBlock::item_contains_position(mission_item)) {\n \n-\n-\n \t\tmavlink_log_critical(_mavlink_log_pub, \"Warning: Waypoint %d below home\\t\", current_index + 1);\n \t\tevents::send<int16_t>(events::ID(\"navigator_mis_wp_below_home\"), {events::Log::Warning, events::LogInternal::Info},\n \t\t\t\t      \"Waypoint {1} below home\", current_index + 1);\n \t}\n \n \treturn true;\n }\n+\n+bool FeasibilityChecker::checkItemsFitToVehicleType(const mission_item_s &mission_item)\n+{\n+\tif (_vehicle_type != VehicleType::Vtol &&\n+\t    (mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF || mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n+\t     || mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION)) {\n+\n+\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Mission contains VTOL items but vehicle is not a VTOL\\t\");\n+\t\tevents::send(events::ID(\"navigator_mis_vtol_items\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t     \"Mission rejected: Mission contains VTOL items but vehicle is not a VTOL\");\n+\n+\t\treturn false;\n+\t}\n+\n+\treturn true;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/32132988050058f205ae8ee64a8f4505577a97e2/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "patch": "@@ -120,6 +120,7 @@ class FeasibilityChecker : public ModuleParams\n \tbool _below_home_alt_failed{false};\n \tbool _fixed_wing_land_approach_failed{false};\n \tbool _takeoff_land_available_failed{false};\n+\tbool _items_fit_to_vehicle_type_failed{false};\n \n \t// internal checkTakeoff related variables\n \tbool _found_item_with_position{false};\n@@ -163,6 +164,14 @@ class FeasibilityChecker : public ModuleParams\n \t*/\n \tbool checkTakeoff(mission_item_s &mission_item);\n \n+\t/**\n+\t * @brief Check if the mission items fit to the vehicle type\n+\t *\n+\t * @param mission_item The current mission item\n+\t * @return False if the check failed.\n+\t*/\n+\tbool checkItemsFitToVehicleType(const mission_item_s &mission_item);\n+\n \t/**\n \t * @brief Check validity of landing pattern (fixed wing & vtol)\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/32132988050058f205ae8ee64a8f4505577a97e2/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.hpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::doCommonChecks",
        "FeasibilityChecker::checkIfBelowHomeAltitude"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::doCommonChecks",
          "FeasibilityChecker::checkIfBelowHomeAltitude"
        ]
      }
    }
  },
  {
    "title": "Refactoring dataman to remove locking mechanisms and to use uORB",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21594",
    "number": 21594,
    "created_at": "2023-05-15T14:58:49Z",
    "merged": true,
    "merged_at": "2023-07-24T11:10:32Z",
    "state": "closed",
    "conversation": {
      "author": "Igor-Misic",
      "body": "Changes brought by this PR:\r\n\r\n-  Refactored the initialization process of the Dataman file.\r\n-  Removed the thread-locking mechanism from the Dataman thread.\r\n-  Added two new classes, DatamanClient and DatmanCache, which facilitate communication with Dataman using uORB messages.\r\n- Removed the locking mechanism for Dataman itself\r\n\r\n**Refactored Initialization of the Dataman File**\r\nThis fix addresses the issue outlined in the following link: https://github.com/PX4/PX4-Autopilot/issues/21278.\r\nNow, if the file doesn't exist or contains an incorrect compact key, it will be cleared, and default values will be set.\r\n\r\n**DatamanClient**\r\nIntroduces a new method of communicating with the Dataman thread. Previously, direct access to the Dataman module was used, where requests were inserted into the queue with a semaphore. This approach has now been replaced with the uORB messaging system.\r\n\r\nDatamanClient introduces both **synchronous** and **asynchronous** modes of communication with Dataman.\r\n\r\n**DatamanCache**\r\nThis class serves as a cache storage for a defined amount of Dataman items. Currently, the cache does not employ any advanced caching algorithms.\r\n\r\n**Integration within mission**\r\nThe mission now incorporates a simple caching mechanism that attempts to cache the next N items whenever the \"current item\" is modified. \r\nIn order to eliminate the need for a locking mechanism within the mission, logic has been implemented to check if the set of mission items has been updated in the Dataman. The write operation to DM_KEY_MISSION_STATE has been removed from the mavlink thread, and instead, the existing uORB (mission.msg) message is utilized.\r\n\r\n **Integration geofence and safe points**\r\nAs the information on new geofence and safe points is updated at the end, it is safe to utilize it without the need for a lock. Integration has been implemented to store all geofence and safe point items within the cache and update them whenever changes occur.\r\n\r\n**Overview of the new architecture**\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/10188706/8fdcda1c-c64f-4e28-b03b-c52f6330c162)\r\n\r\n**Stack is increased as it was needed**\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/10188706/65dd9daf-7440-4f1d-ac18-cdf2e7e1bc5e)\r\n",
      "issue_comments": [
        {
          "author": "julianoes",
          "created_at": "2023-05-30T05:14:29Z",
          "body": "Nice, this looks amazing @Igor-Misic!",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-06-16T15:01:19Z",
          "body": "There's a failure on the test rack that looks real. http://px4-jenkins.dagar.ca:8080/blue/organizations/jenkins/PX4-Autopilot/detail/pr-dataman_refactoring/21/pipeline/125\r\n\r\n![Screenshot from 2023-06-16 11-00-08](https://github.com/PX4/PX4-Autopilot/assets/84712/9de49fed-20e3-4cd7-9283-eb26d61045d4)\r\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-06-19T09:59:22Z",
          "body": "> There's a failure on the test rack that looks real. http://px4-jenkins.dagar.ca:8080/blue/organizations/jenkins/PX4-Autopilot/detail/pr-dataman_refactoring/21/pipeline/125\r\n\r\nI didn't reproduce locally, but I think I fixed it in the last commit.",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-06-19T12:01:53Z",
          "body": "looks like only remaining build failure is 0.01% flash on diatone mamba",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-06-21T11:57:18Z",
          "body": "@dagar - what do you think? gtg?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-06-21T17:51:35Z",
          "body": " - DM_KEY_MISSION_STATE is obsolete and can be purged, we don't need to save the progress to the SD card\r\n - publishing ORB_ID(mission) is used to signal navigation mission to update and rerun mission feasibility, but now it's also updating with any geofence or safe point changes \r\n - DatamanClient is using the old uORB API where a subscription is a file descriptor, we need to check that the extra FD usage doesn't trigger the warning (or change to uORB::SubscriptionBlocking, etc)",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-06-22T06:13:35Z",
          "body": "> DM_KEY_MISSION_STATE is obsolete and can be purged, we don't need to save the progress to the SD card\r\n\r\nResuming a mission on battery change isn't a thing? Either way is fine with me but it's a functional change we can do as a separate PR.\r\n\r\n> publishing ORB_ID(mission) is used to signal navigation mission to update and rerun mission feasibility, but now it's also updating with any geofence or safe point changes\r\n\r\nI didn't think this is a problem. If you're concerned I can make it more granular.\r\n\r\n> DatamanClient is using the old uORB API where a subscription is a file descriptor, we need to check that the extra FD usage doesn't trigger the warning (or change to uORB::SubscriptionBlocking, etc)\r\n\r\nI did not see any.",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-06-22T11:33:36Z",
          "body": ">  publishing ORB_ID(mission) is used to signal navigation mission to update and rerun mission feasibility, but now it's also updating with any geofence or safe point changes\r\n\r\nI didn't consider the reporting happening multiple times. I fixed it.",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-07-03T09:07:52Z",
          "body": "@dagar good to go?",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-07-20T06:03:14Z",
          "body": "@bkueng looks like it needs one more rebase.\r\n\r\n@dagar any last words? this one has been blocking some things for quite a while now",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-07-24T11:10:22Z",
          "body": "@dagar I'm getting this in as a few things are blocking on this. I'll do a follow-up, if there's anything else needed.",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2023-09-15T11:33:28Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/how-to-start-developing/34131/4\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2023-06-16T14:16:47Z",
          "body": "Why?",
          "path": ".ci/Jenkinsfile-hardware",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-06-19T10:00:06Z",
          "body": "Igor explained it in the commit: https://github.com/PX4/PX4-Autopilot/pull/21594/commits/50f23de177e338623b0e473a6c9add9a6113e89e.\r\n\r\nI made it a bit more explicit in https://github.com/PX4/PX4-Autopilot/pull/21594/commits/b0c918fc42a4a10043dd14fe280e6a96dcbfb32c",
          "path": ".ci/Jenkinsfile-hardware",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-06-21T17:43:24Z",
          "body": "Why? \r\nDM_KEY_MISSION_STATE and ORB_ID(mission) are the same thing, mavlink_mission would have published `mission` and written DM_KEY_MISSION_STATE back to back. I think it's time to kill DM_KEY_MISSION_STATE and remove some of the confusion.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 128,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-06-21T21:01:27Z",
          "body": "Let's try to keep this one.\r\n\r\n```suggestion\r\n```",
          "path": "boards/px4/fmu-v4/test.px4board",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "Nice work @Igor-Misic! I went through it, tested quite a bit, and fixed some things.\r\n\r\nRAM usage increases a bit (depending on geofence/safe point usage ~2KB).\r\n\r\nNavigator does not block anymore during a mission execution (unless DO_JUMP is used). This is in sih with geofence and safe points:\r\n```\r\nPR:\r\nnavigator: 2337 events, 121802us elapsed, 52.12us avg, min 21us max 803us 650.441us rms\r\nmain:\r\nnavigator: 2539 events, 919572us elapsed, 362.18us avg, min 19us max 26094us 3136.414us rms\r\n```",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "tstastny",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes incorrect behaviour and synchronization issues (logic errors) â€” it corrects Dataman file initialization (clearing bad or missing compact keys), removes unsafe thread-locking and replaces ad-hoc queue+semaphore access with uORB messaging and a cache to avoid race conditions and inconsistent state, and adjusts mission/geofence integration to prevent incorrect updates. These are behavioral fixes rather than syntax/style changes.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -51,6 +51,7 @@ px4_add_module(\n \t\tgeofence.cpp\n \t\tvtol_takeoff.cpp\n \tDEPENDS\n+\t\tdataman_client\n \t\tgeo\n \t\tadsb\n \t\tgeofence_breach_avoidance",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9e56674213de7344556c8d7238d5719ef9fddf41/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/GeofenceBreachAvoidanceTest.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/GeofenceBreachAvoidanceTest.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "patch": "@@ -34,7 +34,6 @@\n #include <gtest/gtest.h>\n #include \"geofence_breach_avoidance.h\"\n #include \"fake_geofence.hpp\"\n-#include \"dataman_mocks.hpp\"\n #include <parameters/param.h>\n \n using namespace matrix;\n@@ -88,7 +87,7 @@ TEST_F(GeofenceBreachAvoidanceTest, generateLoiterPointForFixedWing)\n \tVector2d home_global(42.1, 8.2);\n \tMapProjection ref{home_global(0), home_global(1)};\n \n-\tgeofence_violation_type_u gf_violation;\n+\tgeofence_violation_type_u gf_violation{};\n \tgf_violation.flags.fence_violation = true;\n \n \tgf_avoidance.setHorizontalTestPointDistance(20.0f);\n@@ -148,7 +147,7 @@ TEST_F(GeofenceBreachAvoidanceTest, generateLoiterPointForMultirotor)\n \tvalue = 8;\n \tparam_set(param, &value);\n \n-\tgeofence_violation_type_u gf_violation;\n+\tgeofence_violation_type_u gf_violation{};\n \tgf_violation.flags.fence_violation = true;\n \n \tgf_avoidance.setHorizontalTestPointDistance(30.0f);\n@@ -198,7 +197,7 @@ TEST_F(GeofenceBreachAvoidanceTest, generateLoiterAltitudeForFixedWing)\n \n \tgf_avoidance.setVerticalTestPointDistance(vertical_test_point_dist);\n \tgf_avoidance.setCurrentPosition(0, 0, current_alt_amsl); // just care about altitude\n-\tgeofence_violation_type_u gf_violation;\n+\tgeofence_violation_type_u gf_violation{};\n \tgf_violation.flags.max_altitude_exceeded = true;\n \n \tfloat loiter_alt = gf_avoidance.generateLoiterAltitudeForFixedWing(gf_violation);\n@@ -217,7 +216,7 @@ TEST_F(GeofenceBreachAvoidanceTest, generateLoiterAltitudeForMulticopter)\n \tGeofenceBreachAvoidance gf_avoidance(nullptr);\n \tconst float climbrate = 10.0f;\n \tconst float current_alt_amsl = 100.0f;\n-\tgeofence_violation_type_u gf_violation;\n+\tgeofence_violation_type_u gf_violation{};\n \tgf_violation.flags.max_altitude_exceeded = true;\n \n \tgf_avoidance.setClimbRate(climbrate);\n@@ -242,7 +241,7 @@ TEST_F(GeofenceBreachAvoidanceTest, maxDistToHomeViolationMulticopter)\n \tFakeGeofence geo;\n \tVector2d home_global(42.1, 8.2);\n \tMapProjection ref{home_global(0), home_global(1)};\n-\tgeofence_violation_type_u gf_violation;\n+\tgeofence_violation_type_u gf_violation{};\n \tgf_violation.flags.dist_to_home_exceeded = true;\n \n \tconst float hor_vel = 8.0f;\n@@ -274,7 +273,7 @@ TEST_F(GeofenceBreachAvoidanceTest, maxDistToHomeViolationFixedWing)\n \tFakeGeofence geo;\n \tVector2d home_global(42.1, 8.2);\n \tMapProjection ref{home_global(0), home_global(1)};\n-\tgeofence_violation_type_u gf_violation;\n+\tgeofence_violation_type_u gf_violation{};\n \tgf_violation.flags.dist_to_home_exceeded = true;\n \n \tconst float test_point_distance = 30.0f;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9e56674213de7344556c8d7238d5719ef9fddf41/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2FGeofenceBreachAvoidanceTest.cpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp",
        "status": "removed",
        "additions": 0,
        "deletions": 93,
        "changes": 93,
        "patch": "@@ -1,93 +0,0 @@\n-/****************************************************************************\n- *\n- *   Copyright (c) 2021 PX4 Development Team. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- * 3. Neither the name PX4 nor the names of its contributors may be\n- *    used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- *\n- ****************************************************************************/\n-/**\n- * @file dataman_mocks.h\n- * Provides a minimal dataman implementation to compile against for testing\n- *\n- * @author Roman Bapst\n- * @author Julian Kent\n- */\n-#pragma once\n-\n-#include <dataman/dataman.h>\n-extern \"C\" {\n-\t__EXPORT ssize_t\n-\tdm_read(\n-\t\tdm_item_t item,\t\t\t/* The item type to retrieve */\n-\t\tunsigned index,\t\t\t/* The index of the item */\n-\t\tvoid *buffer,\t\t\t/* Pointer to caller data buffer */\n-\t\tsize_t buflen\t\t\t/* Length in bytes of data to retrieve */\n-\t) {return 0;};\n-\n-\t/** write to the data manager store */\n-\t__EXPORT ssize_t\n-\tdm_write(\n-\t\tdm_item_t  item,\t\t/* The item type to store */\n-\t\tunsigned index,\t\t\t/* The index of the item */\n-\t\tconst void *buffer,\t\t/* Pointer to caller data buffer */\n-\t\tsize_t buflen\t\t\t/* Length in bytes of data to retrieve */\n-\t) {return 0;};\n-\n-\t/**\n-\t * Lock all items of a type. Can be used for atomic updates of multiple items (single items are always updated\n-\t * atomically).\n-\t * Note that this lock is independent from dm_read & dm_write calls.\n-\t * @return 0 on success and lock taken, -1 on error (lock not taken, errno set)\n-\t */\n-\t__EXPORT int\n-\tdm_lock(\n-\t\tdm_item_t item\t\t\t/* The item type to lock */\n-\t) {return 0;};\n-\n-\t/**\n-\t * Try to lock all items of a type (@see sem_trywait()).\n-\t * @return 0 if lock is taken, -1 otherwise (on error or if already locked. errno is set accordingly)\n-\t */\n-\t__EXPORT int\n-\tdm_trylock(\n-\t\tdm_item_t item\t\t\t/* The item type to lock */\n-\t) {return 0;};\n-\n-\t/** Unlock all items of a type */\n-\t__EXPORT void\n-\tdm_unlock(\n-\t\tdm_item_t item\t\t\t/* The item type to unlock */\n-\t) {};\n-\n-\t/** Erase all items of this type */\n-\t__EXPORT int\n-\tdm_clear(\n-\t\tdm_item_t item\t\t\t/* The item type to clear */\n-\t) {return 0;};\n-}\n-",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eb9bcb0c2822f243e4600a92e10945885fb264ee/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fdataman_mocks.hpp"
      },
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 128,
        "deletions": 60,
        "changes": 188,
        "patch": "@@ -43,7 +43,7 @@\n \n #include <ctype.h>\n \n-#include <dataman/dataman.h>\n+#include <dataman_client/DatamanClient.hpp>\n #include <drivers/drv_hrt.h>\n #include <lib/geo/geo.h>\n #include <systemlib/mavlink_log.h>\n@@ -58,9 +58,8 @@ Geofence::Geofence(Navigator *navigator) :\n \t_navigator(navigator),\n \t_sub_airdata(ORB_ID(vehicle_air_data))\n {\n-\t// we assume there's no concurrent fence update on startup\n \tif (_navigator != nullptr) {\n-\t\t_updateFence();\n+\t\tupdateFence();\n \t}\n }\n \n@@ -71,42 +70,113 @@ Geofence::~Geofence()\n \t}\n }\n \n-void Geofence::updateFence()\n+void Geofence::run()\n {\n-\t// Note: be aware that when calling this, it can block for quite some time, the duration of a geofence transfer.\n-\t// However this is currently not used\n-\tif (dm_lock(DM_KEY_FENCE_POINTS) != 0) {\n-\t\tPX4_ERR(\"lock failed\");\n-\t\treturn;\n+\tbool success;\n+\n+\tswitch (_dataman_state) {\n+\n+\tcase DatamanState::UpdateRequestWait:\n+\n+\t\tif (_initiate_fence_updated) {\n+\t\t\t_initiate_fence_updated = false;\n+\t\t\t_dataman_state\t= DatamanState::Read;\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase DatamanState::Read:\n+\n+\t\t_dataman_state = DatamanState::ReadWait;\n+\t\tsuccess = _dataman_client.readAsync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n+\t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n+\n+\t\tif (!success) {\n+\t\t\t_error_state = DatamanState::Read;\n+\t\t\t_dataman_state = DatamanState::Error;\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase DatamanState::ReadWait:\n+\n+\t\t_dataman_client.update();\n+\n+\t\tif (_dataman_client.lastOperationCompleted(success)) {\n+\n+\t\t\tif (!success) {\n+\t\t\t\t_error_state = DatamanState::ReadWait;\n+\t\t\t\t_dataman_state = DatamanState::Error;\n+\n+\t\t\t} else if (_update_counter != _stats.update_counter) {\n+\n+\t\t\t\t_update_counter = _stats.update_counter;\n+\t\t\t\t_fence_updated = false;\n+\n+\t\t\t\t_dataman_cache.invalidate();\n+\n+\t\t\t\tif (_dataman_cache.size() != _stats.num_items) {\n+\t\t\t\t\t_dataman_cache.resize(_stats.num_items);\n+\t\t\t\t}\n+\n+\t\t\t\tfor (int index = 1; index <= _dataman_cache.size(); ++index) {\n+\t\t\t\t\t_dataman_cache.load(DM_KEY_FENCE_POINTS, index);\n+\t\t\t\t}\n+\n+\t\t\t\t_dataman_state = DatamanState::Load;\n+\n+\t\t\t} else {\n+\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n+\t\t\t}\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase DatamanState::Load:\n+\n+\t\t_dataman_cache.update();\n+\n+\t\tif (!_dataman_cache.isLoading()) {\n+\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n+\t\t\t_updateFence();\n+\t\t\t_fence_updated = true;\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase DatamanState::Error:\n+\t\tPX4_ERR(\"Geofence update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n+\t\t_dataman_state = DatamanState::UpdateRequestWait;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n+\n \t}\n+}\n \n-\t_updateFence();\n-\tdm_unlock(DM_KEY_FENCE_POINTS);\n+void Geofence::updateFence()\n+{\n+\t_initiate_fence_updated = true;\n }\n \n void Geofence::_updateFence()\n {\n-\t// initialize fence points count\n-\tmission_stats_entry_s stats;\n-\tint ret = dm_read(DM_KEY_FENCE_POINTS, 0, &stats, sizeof(mission_stats_entry_s));\n-\tint num_fence_items = 0;\n-\n-\tif (ret == sizeof(mission_stats_entry_s)) {\n-\t\tnum_fence_items = stats.num_items;\n-\t\t_update_counter = stats.update_counter;\n-\t}\n+\tmission_fence_point_s mission_fence_point;\n+\tbool is_circle_area = false;\n \n \t// iterate over all polygons and store their starting vertices\n \t_num_polygons = 0;\n \tint current_seq = 1;\n \n-\twhile (current_seq <= num_fence_items) {\n-\t\tmission_fence_point_s mission_fence_point;\n-\t\tbool is_circle_area = false;\n+\twhile (current_seq <= _dataman_cache.size()) {\n \n-\t\tif (dm_read(DM_KEY_FENCE_POINTS, current_seq, &mission_fence_point, sizeof(mission_fence_point_s)) !=\n-\t\t    sizeof(mission_fence_point_s)) {\n-\t\t\tPX4_ERR(\"dm_read failed\");\n+\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, current_seq,\n+\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n+\t\t\t\t\t\t       sizeof(mission_fence_point_s));\n+\n+\t\tif (!success) {\n+\t\t\tPX4_ERR(\"loadWait failed, seq: %i\", current_seq);\n \t\t\tbreak;\n \t\t}\n \n@@ -172,9 +242,7 @@ void Geofence::_updateFence()\n \t\t\t++current_seq;\n \t\t\tbreak;\n \t\t}\n-\n \t}\n-\n }\n \n bool Geofence::checkAll(const struct vehicle_global_position_s &global_position)\n@@ -306,35 +374,18 @@ bool Geofence::isBelowMaxAltitude(float altitude)\n \n bool Geofence::isInsidePolygonOrCircle(double lat, double lon, float altitude)\n {\n-\t// the following uses dm_read, so first we try to lock all items. If that fails, it (most likely) means\n-\t// the data is currently being updated (via a mavlink geofence transfer), and we do not check for a violation now\n-\tif (dm_trylock(DM_KEY_FENCE_POINTS) != 0) {\n-\t\treturn true;\n-\t}\n-\n-\t// we got the lock, now check if the fence data got updated\n-\tmission_stats_entry_s stats;\n-\tint ret = dm_read(DM_KEY_FENCE_POINTS, 0, &stats, sizeof(mission_stats_entry_s));\n-\n-\tif (ret == sizeof(mission_stats_entry_s) && _update_counter != stats.update_counter) {\n-\t\t_updateFence();\n-\t}\n-\n \tif (isEmpty()) {\n-\t\tdm_unlock(DM_KEY_FENCE_POINTS);\n \t\t/* Empty fence -> accept all points */\n \t\treturn true;\n \t}\n \n \t/* Vertical check */\n \tif (_altitude_max > _altitude_min) { // only enable vertical check if configured properly\n \t\tif (altitude > _altitude_max || altitude < _altitude_min) {\n-\t\t\tdm_unlock(DM_KEY_FENCE_POINTS);\n \t\t\treturn false;\n \t\t}\n \t}\n \n-\n \t/* Horizontal check: iterate all polygons & circles */\n \tbool outside_exclusion = true;\n \tbool inside_inclusion = false;\n@@ -375,8 +426,6 @@ bool Geofence::isInsidePolygonOrCircle(double lat, double lon, float altitude)\n \t\t}\n \t}\n \n-\tdm_unlock(DM_KEY_FENCE_POINTS);\n-\n \treturn (!had_inclusion_areas || inside_inclusion) && outside_exclusion;\n }\n \n@@ -394,13 +443,18 @@ bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon,\n \tbool c = false;\n \n \tfor (unsigned i = 0, j = polygon.vertex_count - 1; i < polygon.vertex_count; j = i++) {\n-\t\tif (dm_read(DM_KEY_FENCE_POINTS, polygon.dataman_index + i, &temp_vertex_i,\n-\t\t\t    sizeof(mission_fence_point_s)) != sizeof(mission_fence_point_s)) {\n+\n+\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index + i,\n+\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&temp_vertex_i), sizeof(mission_fence_point_s));\n+\n+\t\tif (!success) {\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (dm_read(DM_KEY_FENCE_POINTS, polygon.dataman_index + j, &temp_vertex_j,\n-\t\t\t    sizeof(mission_fence_point_s)) != sizeof(mission_fence_point_s)) {\n+\t\tsuccess = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index + j,\n+\t\t\t\t\t\t  reinterpret_cast<uint8_t *>(&temp_vertex_j), sizeof(mission_fence_point_s));\n+\n+\t\tif (!success) {\n \t\t\tbreak;\n \t\t}\n \n@@ -426,9 +480,10 @@ bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon,\n {\n \n \tmission_fence_point_s circle_point{};\n+\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index,\n+\t\t\t\t\t       reinterpret_cast<uint8_t *>(&circle_point), sizeof(mission_fence_point_s));\n \n-\tif (dm_read(DM_KEY_FENCE_POINTS, polygon.dataman_index, &circle_point,\n-\t\t    sizeof(mission_fence_point_s)) != sizeof(mission_fence_point_s)) {\n+\tif (!success) {\n \t\tPX4_ERR(\"dm_read failed\");\n \t\treturn false;\n \t}\n@@ -531,7 +586,10 @@ Geofence::loadFromFile(const char *filename)\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (dm_write(DM_KEY_FENCE_POINTS, pointCounter + 1, &vertex, sizeof(vertex)) != sizeof(vertex)) {\n+\t\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, pointCounter + 1, reinterpret_cast<uint8_t *>(&vertex),\n+\t\t\t\t\tsizeof(vertex));\n+\n+\t\t\tif (!success) {\n \t\t\t\tgoto error;\n \t\t\t}\n \n@@ -555,22 +613,32 @@ Geofence::loadFromFile(const char *filename)\n \tif (gotVertical && pointCounter > 2) {\n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Geofence imported\\t\");\n \t\tevents::send(events::ID(\"navigator_geofence_imported\"), events::Log::Info, \"Geofence imported\");\n-\t\tret_val = PX4_OK;\n+\t\tret_val = PX4_ERROR;\n \n \t\t/* do a second pass, now that we know the number of vertices */\n \t\tfor (int seq = 1; seq <= pointCounter; ++seq) {\n \t\t\tmission_fence_point_s mission_fence_point;\n \n-\t\t\tif (dm_read(DM_KEY_FENCE_POINTS, seq, &mission_fence_point, sizeof(mission_fence_point_s)) ==\n-\t\t\t    sizeof(mission_fence_point_s)) {\n+\t\t\tbool success = _dataman_client.readSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n+\t\t\t\t\t\t\t\tsizeof(mission_fence_point_s));\n+\n+\t\t\tif (success) {\n \t\t\t\tmission_fence_point.vertex_count = pointCounter;\n-\t\t\t\tdm_write(DM_KEY_FENCE_POINTS, seq, &mission_fence_point, sizeof(mission_fence_point_s));\n+\t\t\t\t_dataman_client.writeSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n+\t\t\t\t\t\t\t  sizeof(mission_fence_point_s));\n \t\t\t}\n \t\t}\n \n \t\tmission_stats_entry_s stats;\n \t\tstats.num_items = pointCounter;\n-\t\tret_val = dm_write(DM_KEY_FENCE_POINTS, 0, &stats, sizeof(mission_stats_entry_s));\n+\t\tstats.update_counter = _update_counter + 1;\n+\n+\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&stats),\n+\t\t\t\tsizeof(mission_stats_entry_s));\n+\n+\t\tif (success) {\n+\t\t\tret_val = PX4_OK;\n+\t\t}\n \n \t} else {\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence: import error\\t\");\n@@ -586,7 +654,7 @@ Geofence::loadFromFile(const char *filename)\n \n int Geofence::clearDm()\n {\n-\tdm_clear(DM_KEY_FENCE_POINTS);\n+\t_dataman_client.clearSync(DM_KEY_FENCE_POINTS);\n \tupdateFence();\n \treturn PX4_OK;\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9e56674213de7344556c8d7238d5719ef9fddf41/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 25,
        "deletions": 4,
        "changes": 29,
        "patch": "@@ -42,6 +42,7 @@\n \n #include <float.h>\n \n+#include <dataman_client/DatamanClient.hpp>\n #include <lib/mathlib/mathlib.h>\n #include <px4_platform_common/module_params.h>\n #include <drivers/drv_hrt.h>\n@@ -77,9 +78,13 @@ class Geofence : public ModuleParams\n \t\tGF_SOURCE_GPS = 1\n \t};\n \n+\t/**\n+\t * @brief function to call regularly to do background work\n+\t */\n+\tvoid run();\n+\n \t/**\n \t * update the geofence from dataman.\n-\t * It's generally not necessary to call this as it will automatically update when the data is changed.\n \t */\n \tvoid updateFence();\n \n@@ -136,7 +141,7 @@ class Geofence : public ModuleParams\n \t */\n \tint loadFromFile(const char *filename);\n \n-\tbool isEmpty() { return _num_polygons == 0; }\n+\tbool isEmpty() { return (!_fence_updated || (_num_polygons == 0)); }\n \n \tint getSource() { return _param_gf_source.get(); }\n \tint getGeofenceAction() { return _param_gf_action.get(); }\n@@ -154,6 +159,14 @@ class Geofence : public ModuleParams\n \n private:\n \n+\tenum class DatamanState {\n+\t\tUpdateRequestWait,\n+\t\tRead,\n+\t\tReadWait,\n+\t\tLoad,\n+\t\tError\n+\t};\n+\n \tstruct PolygonInfo {\n \t\tuint16_t fence_type; ///< one of MAV_CMD_NAV_FENCE_* (can also be a circular region)\n \t\tuint16_t dataman_index;\n@@ -166,6 +179,12 @@ class Geofence : public ModuleParams\n \tNavigator   *_navigator{nullptr};\n \tPolygonInfo *_polygons{nullptr};\n \n+\tmission_stats_entry_s _stats;\n+\tDatamanState _dataman_state{DatamanState::UpdateRequestWait};\n+\tDatamanState _error_state{DatamanState::UpdateRequestWait};\n+\tDatamanCache _dataman_cache{\"geofence_dm_cache_miss\", 4};\n+\tDatamanClient\t&_dataman_client = _dataman_cache.client();\n+\n \thrt_abstime _last_horizontal_range_warning{0};\n \thrt_abstime _last_vertical_range_warning{0};\n \n@@ -179,10 +198,12 @@ class Geofence : public ModuleParams\n \tuORB::SubscriptionData<vehicle_air_data_s> _sub_airdata;\n \n \tint _outside_counter{0};\n-\tuint16_t _update_counter{0}; ///< dataman update counter: if it does not match, we polygon data was updated\n+\tuint16_t _update_counter{0}; ///< dataman update counter: if it does not match, polygon data was updated\n+\tbool _fence_updated{true};  ///< flag indicating if fence are updated to dataman cache\n+\tbool _initiate_fence_updated{true}; ///< flag indicating if fence updated is needed\n \n \t/**\n-\t * implementation of updateFence(), but without locking\n+\t * implementation of updateFence()\n \t */\n \tvoid _updateFence();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9e56674213de7344556c8d7238d5719ef9fddf41/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 142,
        "deletions": 94,
        "changes": 236,
        "patch": "@@ -50,7 +50,7 @@\n \n #include <string.h>\n #include <drivers/drv_hrt.h>\n-#include <dataman/dataman.h>\n+#include <dataman_client/DatamanClient.hpp>\n #include <systemlib/mavlink_log.h>\n #include <systemlib/err.h>\n #include <lib/geo/geo.h>\n@@ -70,27 +70,48 @@ Mission::Mission(Navigator *navigator) :\n \tmission_init();\n }\n \n+void\n+Mission::run()\n+{\n+\tif ((_mission.count > 0) && (_current_mission_index != _load_mission_index)) {\n+\n+\t\tuint32_t start_index = _current_mission_index;\n+\t\tuint32_t end_index = start_index + DATAMAN_CACHE_SIZE;\n+\n+\t\tend_index = math::min(end_index, static_cast<uint32_t>(_mission.count));\n+\n+\t\tfor (uint32_t index = start_index; index < end_index; ++index) {\n+\n+\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.dataman_id), index);\n+\t\t}\n+\n+\t\t_load_mission_index = _current_mission_index;\n+\t}\n+\n+\t_dataman_cache.update();\n+}\n+\n void Mission::mission_init()\n {\n \t// init mission state, do it here to allow navigator to use stored mission even if mavlink failed to start\n-\tmission_s mission{};\n \n-\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s)) == sizeof(mission_s)) {\n-\t\tif ((mission.timestamp != 0)\n-\t\t    && (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1)) {\n-\t\t\tif (mission.count > 0) {\n-\t\t\t\tPX4_INFO(\"Mission #%\" PRIu8 \" loaded, %\" PRIu16 \" WPs\", mission.dataman_id, mission.count);\n+\tif (_dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&_mission), sizeof(mission_s))) {\n+\t\tif ((_mission.timestamp != 0)\n+\t\t    && (_mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || _mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1)) {\n+\t\t\tif (_mission.count > 0) {\n+\t\t\t\tPX4_INFO(\"Mission #%\" PRIu8 \" loaded, %\" PRIu16 \" WPs\", _mission.dataman_id, _mission.count);\n \t\t\t}\n \n \t\t} else {\n-\t\t\tPX4_ERR(\"reading mission state failed\");\n-\n \t\t\t// initialize mission state in dataman\n-\t\t\tmission.dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n-\t\t\tmission.timestamp = hrt_absolute_time();\n-\t\t\tdm_write(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s));\n+\t\t\t_mission.dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n+\t\t\t_mission.timestamp = hrt_absolute_time();\n+\t\t\t_dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&_mission), sizeof(mission_s));\n \t\t}\n \t}\n+\n+\t_current_mission_index = _mission.current_seq;\n+\n }\n \n void\n@@ -101,6 +122,10 @@ Mission::on_inactive()\n \t\treturn;\n \t}\n \n+\tif (_need_mission_save && _navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n+\t\tsave_mission_state();\n+\t}\n+\n \tif (_inited) {\n \t\tif (_mission_sub.updated()) {\n \t\t\tupdate_mission();\n@@ -124,14 +149,11 @@ Mission::on_inactive()\n \t\t/* load missions from storage */\n \t\tmission_s mission_state = {};\n \n-\t\tdm_lock(DM_KEY_MISSION_STATE);\n-\n \t\t/* read current state */\n-\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n-\n-\t\tdm_unlock(DM_KEY_MISSION_STATE);\n+\t\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n+\t\t\t\t\t\t\tsizeof(mission_s));\n \n-\t\tif (read_res == sizeof(mission_s)) {\n+\t\tif (success) {\n \t\t\t_mission.dataman_id = mission_state.dataman_id;\n \t\t\t_mission.count = mission_state.count;\n \t\t\t_current_mission_index = mission_state.current_seq;\n@@ -464,10 +486,12 @@ Mission::find_mission_land_start()\n \tbool found_land_start_marker = false;\n \n \tfor (size_t i = 1; i < _mission.count; i++) {\n-\t\tconst ssize_t len = sizeof(missionitem);\n \t\tmissionitem_prev = missionitem; // store the last mission item before reading a new one\n \n-\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n+\t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\t\t\t\t\t\tsizeof(mission_item_s), 500_ms);\n+\n+\t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tPX4_ERR(\"dataman read failure\");\n \t\t\tbreak;\n@@ -564,6 +588,9 @@ Mission::update_mission()\n \n \tbool failed = true;\n \n+\t_dataman_cache.invalidate();\n+\t_load_mission_index = -1;\n+\n \t/* Reset vehicle_roi\n \t * Missions that do not explicitly configure ROI would not override\n \t * an existing ROI setting from previous missions */\n@@ -572,6 +599,14 @@ Mission::update_mission()\n \tconst mission_s old_mission = _mission;\n \n \tif (_mission_sub.copy(&_mission)) {\n+\n+\t\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&_mission),\n+\t\t\t\tsizeof(mission_s));\n+\n+\t\tif (!success) {\n+\t\t\tPX4_ERR(\"Can't update mission state in Dataman\");\n+\t\t}\n+\n \t\t/* determine current index */\n \t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n \t\t\t_current_mission_index = _mission.current_seq;\n@@ -589,29 +624,31 @@ Mission::update_mission()\n \t\t\t/* otherwise, just leave it */\n \t\t}\n \n-\t\tcheck_mission_valid(true);\n+\t\tif (old_mission.mission_update_counter != _mission.mission_update_counter) {\n+\t\t\tcheck_mission_valid(true);\n \n-\t\tfailed = !_navigator->get_mission_result()->valid;\n+\t\t\tfailed = !_navigator->get_mission_result()->valid;\n \n-\t\tif (!failed) {\n-\t\t\t/* reset mission failure if we have an updated valid mission */\n-\t\t\t_navigator->get_mission_result()->failure = false;\n+\t\t\tif (!failed) {\n+\t\t\t\t/* reset mission failure if we have an updated valid mission */\n+\t\t\t\t_navigator->get_mission_result()->failure = false;\n \n-\t\t\t/* reset sequence info as well */\n-\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n-\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n+\t\t\t\t/* reset sequence info as well */\n+\t\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n+\t\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n \n-\t\t\t/* reset work item if new mission has been accepted */\n-\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n-\t\t\t_mission_changed = true;\n-\t\t}\n+\t\t\t\t/* reset work item if new mission has been accepted */\n+\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t\t\t_mission_changed = true;\n+\t\t\t}\n \n-\t\t/* check if the mission waypoints changed while the vehicle is in air\n-\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n-\t\tif (((_mission.count != old_mission.count) ||\n-\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n-\t\t    !_navigator->get_land_detected()->landed) {\n-\t\t\t_mission_waypoints_changed = true;\n+\t\t\t/* check if the mission waypoints changed while the vehicle is in air\n+\t\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n+\t\t\tif (((_mission.count != old_mission.count) ||\n+\t\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n+\t\t\t    !_navigator->get_land_detected()->landed) {\n+\t\t\t\t_mission_waypoints_changed = true;\n+\t\t\t}\n \t\t}\n \n \t} else {\n@@ -668,9 +705,11 @@ Mission::advance_mission()\n \n \t\t\t\tfor (int32_t i = _current_mission_index - 1; i >= 0; i--) {\n \t\t\t\t\tstruct mission_item_s missionitem = {};\n-\t\t\t\t\tconst ssize_t len = sizeof(missionitem);\n \n-\t\t\t\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n+\t\t\t\t\tbool success = _dataman_cache.loadWait(dm_current, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\t\t\t\t\t\t\t\t       sizeof(mission_item_s), 100_ms);\n+\n+\t\t\t\t\tif (!success) {\n \t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\t\t\t\tPX4_ERR(\"dataman read failure\");\n \t\t\t\t\t\tbreak;\n@@ -1618,7 +1657,7 @@ Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n \tint index_to_read = current_index + offset;\n \n \tint *mission_index_ptr = (offset == 0) ? (int *) &_current_mission_index : &index_to_read;\n-\tconst dm_item_t dm_item = (dm_item_t)_mission.dataman_id;\n+\tconst dm_item_t dataman_id = (dm_item_t)_mission.dataman_id;\n \n \t/* do not work on empty missions */\n \tif (_mission.count == 0) {\n@@ -1641,13 +1680,14 @@ Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n \t\t\treturn false;\n \t\t}\n \n-\t\tconst ssize_t len = sizeof(struct mission_item_s);\n-\n \t\t/* read mission item to temp storage first to not overwrite current mission item if data damaged */\n \t\tstruct mission_item_s mission_item_tmp;\n \n \t\t/* read mission item from datamanager */\n-\t\tif (dm_read(dm_item, *mission_index_ptr, &mission_item_tmp, len) != len) {\n+\t\tbool success = _dataman_cache.loadWait(dataman_id, *mission_index_ptr, reinterpret_cast<uint8_t *>(&mission_item_tmp),\n+\t\t\t\t\t\t       sizeof(mission_item_s), 500_ms);\n+\n+\t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Waypoint could not be read.\\t\");\n \t\t\tevents::send<uint16_t>(events::ID(\"mission_failed_to_read_wp\"), events::Log::Error,\n@@ -1668,7 +1708,10 @@ Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n \t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n \n \t\t\t\t\t/* save repeat count */\n-\t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, &mission_item_tmp, len) != len) {\n+\t\t\t\t\tsuccess = _dataman_client.writeSync(dataman_id, *mission_index_ptr, reinterpret_cast<uint8_t *>(&mission_item_tmp),\n+\t\t\t\t\t\t\t\t\t    sizeof(struct mission_item_s));\n+\n+\t\t\t\t\tif (!success) {\n \t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the dataman */\n \t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"DO JUMP waypoint could not be written.\\t\");\n \t\t\t\t\t\tevents::send(events::ID(\"mission_failed_to_write_do_jump\"), events::Log::Error,\n@@ -1715,27 +1758,31 @@ Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n void\n Mission::save_mission_state()\n {\n-\tmission_s mission_state = {};\n-\n-\t/* lock MISSION_STATE item */\n-\tint dm_lock_ret = dm_lock(DM_KEY_MISSION_STATE);\n-\n-\tif (dm_lock_ret != 0) {\n-\t\tPX4_ERR(\"DM_KEY_MISSION_STATE lock failed\");\n+\tif (_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n+\t\t// Save only while disarmed, as this is a blocking operation\n+\t\t_need_mission_save = true;\n+\t\treturn;\n \t}\n \n+\t_need_mission_save = false;\n+\tmission_s mission_state = {};\n+\n \t/* read current state */\n-\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n+\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n+\t\t\t\t\t\tsizeof(mission_s));\n \n-\tif (read_res == sizeof(mission_s)) {\n+\tif (success) {\n \t\t/* data read successfully, check dataman ID and items count */\n \t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count) {\n \t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n \t\t\tif (mission_state.current_seq != _current_mission_index) {\n \t\t\t\tmission_state.current_seq = _current_mission_index;\n \t\t\t\tmission_state.timestamp = hrt_absolute_time();\n \n-\t\t\t\tif (dm_write(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s)) != sizeof(mission_s)) {\n+\t\t\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n+\t\t\t\t\t\t\t\t    sizeof(mission_s));\n+\n+\t\t\t\tif (!success) {\n \n \t\t\t\t\tPX4_ERR(\"Can't save mission state\");\n \t\t\t\t}\n@@ -1756,16 +1803,14 @@ Mission::save_mission_state()\n \t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Error, \"Invalid mission state\");\n \n \t\t/* write modified state only if changed */\n-\t\tif (dm_write(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s)) != sizeof(mission_s)) {\n+\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n+\t\t\t\t\t\t    sizeof(mission_s));\n+\n+\t\tif (!success) {\n \n \t\t\tPX4_ERR(\"Can't save mission state\");\n \t\t}\n \t}\n-\n-\t/* unlock MISSION_STATE item */\n-\tif (dm_lock_ret == 0) {\n-\t\tdm_unlock(DM_KEY_MISSION_STATE);\n-\t}\n }\n \n void\n@@ -1803,7 +1848,7 @@ Mission::check_mission_valid(bool force)\n {\n \tif ((!_home_inited && _navigator->home_global_position_valid()) || force) {\n \n-\t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator);\n+\t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator, _dataman_client);\n \n \t\t_navigator->get_mission_result()->valid =\n \t\t\t_missionFeasibilityChecker.checkMissionFeasible(_mission);\n@@ -1821,30 +1866,33 @@ Mission::check_mission_valid(bool force)\n void\n Mission::reset_mission(struct mission_s &mission)\n {\n-\tdm_lock(DM_KEY_MISSION_STATE);\n-\n-\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s)) == sizeof(mission_s)) {\n+\tif (_dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission), sizeof(mission_s))) {\n \t\tif (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) {\n \t\t\t/* set current item to 0 */\n \t\t\tmission.current_seq = 0;\n \n \t\t\t/* reset jump counters */\n \t\t\tif (mission.count > 0) {\n-\t\t\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n+\t\t\t\tconst dm_item_t dataman_id = (dm_item_t)mission.dataman_id;\n \n \t\t\t\tfor (unsigned index = 0; index < mission.count; index++) {\n \t\t\t\t\tstruct mission_item_s item;\n \t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n \n-\t\t\t\t\tif (dm_read(dm_current, index, &item, len) != len) {\n+\t\t\t\t\tbool success = _dataman_client.readSync(dataman_id, index, reinterpret_cast<uint8_t *>(&item), sizeof(mission_item_s),\n+\t\t\t\t\t\t\t\t\t\t500_ms);\n+\n+\t\t\t\t\tif (!success) {\n \t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n \t\t\t\t\t\titem.do_jump_current_count = 0;\n \n-\t\t\t\t\t\tif (dm_write(dm_current, index, &item, len) != len) {\n+\t\t\t\t\t\tsuccess = _dataman_client.writeSync(dataman_id, index, reinterpret_cast<uint8_t *>(&item), len);\n+\n+\t\t\t\t\t\tif (!success) {\n \t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n@@ -1863,10 +1911,8 @@ Mission::reset_mission(struct mission_s &mission)\n \t\t\tmission.current_seq = 0;\n \t\t}\n \n-\t\tdm_write(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s));\n+\t\t_dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission), sizeof(mission_s));\n \t}\n-\n-\tdm_unlock(DM_KEY_MISSION_STATE);\n }\n \n bool\n@@ -1883,7 +1929,7 @@ Mission::need_to_reset_mission()\n }\n \n int32_t\n-Mission::index_closest_mission_item() const\n+Mission::index_closest_mission_item()\n {\n \tint32_t min_dist_index(0);\n \tfloat min_dist(FLT_MAX), dist_xy(FLT_MAX), dist_z(FLT_MAX);\n@@ -1892,9 +1938,11 @@ Mission::index_closest_mission_item() const\n \n \tfor (size_t i = 0; i < _mission.count; i++) {\n \t\tstruct mission_item_s missionitem = {};\n-\t\tconst ssize_t len = sizeof(missionitem);\n \n-\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n+\t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\t\t\t\t\t\tsizeof(mission_item_s), 500_ms);\n+\n+\t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tPX4_ERR(\"dataman read failure\");\n \t\t\tbreak;\n@@ -1996,14 +2044,18 @@ void Mission::publish_navigator_mission_item()\n bool Mission::getPreviousPositionItemIndex(const mission_s &mission, int inactivation_index,\n \t\tunsigned &prev_pos_index) const\n {\n-\tstruct mission_item_s missionitem = {};\n \n \tfor (int index = inactivation_index; index >= 0; index--) {\n-\t\tif (!readMissionItemAtIndex(mission, index, missionitem)) {\n+\t\tmission_item_s mission_item;\n+\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n+\t\tbool success = _dataman_client.readSync(dm_current, index, reinterpret_cast<uint8_t *>(&mission_item),\n+\t\t\t\t\t\t\tsizeof(mission_item), 500_ms);\n+\n+\t\tif (!success) {\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (MissionBlock::item_contains_position(missionitem)) {\n+\t\tif (MissionBlock::item_contains_position(mission_item)) {\n \t\t\tprev_pos_index = index;\n \t\t\treturn true;\n \t\t}\n@@ -2012,10 +2064,16 @@ bool Mission::getPreviousPositionItemIndex(const mission_s &mission, int inactiv\n \treturn false;\n }\n \n-bool Mission::getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item) const\n+bool Mission::getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item)\n {\n+\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n+\n \twhile (start_index < mission.count) {\n-\t\tif (readMissionItemAtIndex(mission, start_index, mission_item) && MissionBlock::item_contains_position(mission_item)) {\n+\t\t// start_index is expected to be after _current_mission_index, and the item should therefore be cached\n+\t\tbool success = _dataman_cache.loadWait(dm_current, start_index, reinterpret_cast<uint8_t *>(&mission_item),\n+\t\t\t\t\t\t       sizeof(mission_item), 500_ms);\n+\n+\t\tif (success && MissionBlock::item_contains_position(mission_item)) {\n \t\t\treturn true;\n \t\t}\n \n@@ -2025,19 +2083,6 @@ bool Mission::getNextPositionMissionItem(const mission_s &mission, int start_ind\n \treturn false;\n }\n \n-bool Mission::readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem) const\n-{\n-\tbool success = false;\n-\n-\tif (index >= 0 && index < mission.count) {\n-\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n-\t\tconst ssize_t len = sizeof(missionitem);\n-\t\tsuccess = (dm_read(dm_current, index, &missionitem, len) == len);\n-\t}\n-\n-\treturn success;\n-}\n-\n void Mission::cacheItem(const mission_item_s &mission_item)\n {\n \tswitch (mission_item.nav_cmd) {\n@@ -2118,9 +2163,12 @@ bool Mission::cameraWasTriggering()\n void Mission::updateCachedItemsUpToIndex(const int end_index)\n {\n \tfor (int i = 0; i <= end_index; i++) {\n-\t\tmission_item_s mission_item = {};\n+\t\tmission_item_s mission_item;\n+\t\tconst dm_item_t dm_current = (dm_item_t)_mission.dataman_id;\n+\t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&mission_item),\n+\t\t\t\t\t\t\tsizeof(mission_item), 500_ms);\n \n-\t\tif (readMissionItemAtIndex(_mission, i, mission_item)) {\n+\t\tif (success) {\n \t\t\tcacheItem(mission_item);\n \t\t}\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9e56674213de7344556c8d7238d5719ef9fddf41/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "patch": "@@ -52,7 +52,7 @@\n \n #include <float.h>\n \n-#include <dataman/dataman.h>\n+#include <dataman_client/DatamanClient.hpp>\n #include <drivers/drv_hrt.h>\n #include <px4_platform_common/module_params.h>\n #include <uORB/Subscription.hpp>\n@@ -74,6 +74,11 @@ class Mission : public MissionBlock, public ModuleParams\n \tMission(Navigator *navigator);\n \t~Mission() override = default;\n \n+\t/**\n+\t * @brief function to call regularly to do background work\n+\t */\n+\tvoid run();\n+\n \tvoid on_inactive() override;\n \tvoid on_inactivation() override;\n \tvoid on_activation() override;\n@@ -234,7 +239,7 @@ class Mission : public MissionBlock, public ModuleParams\n \t/**\n \t * Return the index of the closest mission item to the current global position.\n \t */\n-\tint32_t index_closest_mission_item() const;\n+\tint32_t index_closest_mission_item();\n \n \tbool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;\n \n@@ -258,17 +263,7 @@ class Mission : public MissionBlock, public ModuleParams\n \t * @param mission_item The mission item to populate\n \t * @return true if successful\n \t */\n-\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item) const;\n-\n-\t/**\n-\t * @brief Read the mission item at the given index\n-\t *\n-\t * @param mission The mission to read from\n-\t * @param index The index to read\n-\t * @param missionitem The mission item to populate\n-\t * @return true if successful\n-\t */\n-\tbool readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem) const;\n+\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item);\n \n \t/**\n \t * @brief Cache the mission items containing gimbal, camera mode and trigger commands\n@@ -324,6 +319,10 @@ class Mission : public MissionBlock, public ModuleParams\n \tuORB::Subscription\t_mission_sub{ORB_ID(mission)};\t\t/**< mission subscription */\n \tmission_s\t\t_mission {};\n \n+\tstatic constexpr uint32_t DATAMAN_CACHE_SIZE = 10;\n+\tDatamanCache _dataman_cache{\"mission_dm_cache_miss\", DATAMAN_CACHE_SIZE};\n+\tDatamanClient\t&_dataman_client = _dataman_cache.client();\n+\tint32_t _load_mission_index{-1};\n \tint32_t _current_mission_index{-1};\n \n \t// track location of planned mission landing\n@@ -349,6 +348,7 @@ class Mission : public MissionBlock, public ModuleParams\n \tbool _inited{false};\n \tbool _home_inited{false};\n \tbool _need_mission_reset{false};\n+\tbool _need_mission_save{false};\n \tbool _mission_waypoints_changed{false};\n \tbool _mission_changed{false}; /** < true if the mission changed since the mission mode was active */\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9e56674213de7344556c8d7238d5719ef9fddf41/src%2Fmodules%2Fnavigator%2Fmission.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::reset_mission",
        "Mission::update_mission",
        "Mission::need_to_reset_mission",
        "type",
        "Geofence::Geofence",
        "Mission::cameraWasTriggering",
        "Geofence::updateFence",
        "Mission::save_mission_state",
        "Mission::advance_mission",
        "Mission::index_closest_mission_item",
        "_missionFeasibilityChecker",
        "Mission::publish_navigator_mission_item",
        "Mission::getNextPositionMissionItem",
        "readMissionItemAtIndex",
        "Mission::check_mission_valid",
        "index_closest_mission_item",
        "Geofence::loadFromFile",
        "Geofence::insideCircle",
        "Geofence::_updateFence",
        "Geofence::isBelowMaxAltitude",
        "Mission::readMissionItemAtIndex",
        "MissionBlock::item_contains_position",
        "Mission::read_mission_item",
        "getNextPositionMissionItem",
        "Mission::on_inactive",
        "isEmpty",
        "Copyright",
        "Mission::find_mission_land_start",
        "Mission::getPreviousPositionItemIndex",
        "Geofence::insidePolygon",
        "updateFence",
        "Geofence::isInsidePolygonOrCircle"
      ],
      "by_file": {
        "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp": [
          "type",
          "Copyright"
        ],
        "src/modules/navigator/geofence.cpp": [
          "Geofence::Geofence",
          "Geofence::updateFence",
          "Geofence::insidePolygon",
          "Geofence::isInsidePolygonOrCircle",
          "Geofence::loadFromFile",
          "Geofence::_updateFence",
          "Geofence::isBelowMaxAltitude",
          "Geofence::insideCircle"
        ],
        "src/modules/navigator/geofence.h": [
          "updateFence",
          "isEmpty"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::reset_mission",
          "Mission::update_mission",
          "Mission::need_to_reset_mission",
          "MissionBlock::item_contains_position",
          "Mission::read_mission_item",
          "Mission::cameraWasTriggering",
          "Mission::save_mission_state",
          "Mission::on_inactive",
          "Mission::advance_mission",
          "Mission::index_closest_mission_item",
          "_missionFeasibilityChecker",
          "Mission::publish_navigator_mission_item",
          "Mission::find_mission_land_start",
          "Mission::getNextPositionMissionItem",
          "Mission::getPreviousPositionItemIndex",
          "Mission::check_mission_valid",
          "Mission::readMissionItemAtIndex"
        ],
        "src/modules/navigator/mission.h": [
          "readMissionItemAtIndex",
          "index_closest_mission_item",
          "getNextPositionMissionItem"
        ]
      }
    }
  },
  {
    "title": "Navigator: set cruise_speed to default on entering new mode",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21503",
    "number": 21503,
    "created_at": "2023-04-21T15:24:37Z",
    "merged": true,
    "merged_at": "2023-05-05T13:53:17Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Follow up on https://github.com/PX4/PX4-Autopilot/pull/21414.\r\n\r\nThe resets in the modes (eg Loiter mode) are not active yet, so manually set rep->current.cruising_speed = -1.f if not already in the same flight mode.\r\n\r\n\r\n### Test coverage\r\nSITL and flight tested on VTOLs.\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-05-05T12:38:16Z",
          "body": "@RomanBapst this is needed because the [Navigator sets the the speed setpoint of the current position_setpoint based on the currently set cruising speed](https://github.com/PX4/PX4-Autopilot/blob/40324b03f4acc8eb49423b4e12b585a0cabfd713/src/modules/navigator/navigator_main.cpp#L285) before the [stored cruising speed is reset by the mode. ](https://github.com/PX4/PX4-Autopilot/blob/40324b03f4acc8eb49423b4e12b585a0cabfd713/src/modules/navigator/loiter.cpp#L68)\r\nSee the printfs when I change the speed in a mission and then switch into Hold mode:\r\n```\r\nget_cruising_speed(): 20.000000\r\nrest cruising speed\r\n```\r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” this PR fixes a logic error caused by an ordering/state problem: the Navigator was using a stale cruising_speed to set the position setpoint before the flight mode reset cleared it. The change forces the cruising_speed to a default when entering a new mode, preventing incorrect speed setpoints due to the timing/state inconsistency.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "patch": "@@ -282,7 +282,13 @@ void Navigator::run()\n \n \t\t\t\t\t// If no argument for ground speed, use default value.\n \t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n-\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n+\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n+\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t} else {\n \t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n@@ -403,7 +409,14 @@ void Navigator::run()\n \n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \n-\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n+\t\t\t\t\tif (_navigation_mode != &_loiter) {\n+\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n+\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\t\t\t\t\t}\n+\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n \t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n \t\t\t\t\trep->current.yaw = NAN;\n@@ -468,9 +481,16 @@ void Navigator::run()\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n \t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n-\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n \n+\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n+\t\t\t\t\tif (_navigation_mode != &_loiter) {\n+\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n+\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\t\t\t\t\t}\n+\n \t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n \t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n \t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n@@ -499,6 +519,7 @@ void Navigator::run()\n \t\t\t\trep->current.loiter_radius = get_loiter_radius();\n \t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n \t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n+\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n \n \t\t\t\tif (home_global_position_valid()) {\n \t\t\t\t\t// Only set yaw if we know the true heading",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06d030c0baa4f03834a74befdbae335cc9da9a23/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "mission: only run update_mission() if mission is updated, not when reset due to landing",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21492",
    "number": 21492,
    "created_at": "2023-04-19T08:56:56Z",
    "merged": true,
    "merged_at": "2023-04-21T05:47:58Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nWhen landing with a mission stored on the vehicle, that has not been updated since power cycling, these errors appear:\r\n```\r\nERROR [navigator] mission update failed\r\nWARN  [mavlink] ERROR: wp index out of bounds\r\n```\r\n\r\n### Solution\r\nThe errors come from the fact that when the mission is not updated, the [_mission_sub.copy(_mission) ](https://github.com/PX4/PX4-Autopilot/blob/202e2770da50caff0ed00c06a574e3c39933df52/src/modules/navigator/mission.cpp#L524)returns false, and thus the code below is not run, which would [reset _current_mission_index to 0 over current_seq](https://github.com/PX4/PX4-Autopilot/blob/202e2770da50caff0ed00c06a574e3c39933df52/src/modules/navigator/mission.cpp#L527), that was previously set to 0 in reset_mission. \r\nI thus here propose to only run `update_mission()` when the mission was actually updated, and otherwise, when we need to reset the mission on landing, only reset `_current_mission_index` to 0. \r\n\r\nWhat I'm not very sure yet: do we want to run the mission feasibility checks also on the reset? \r\n\r\n### Changelog Entry\r\nNot relevant.\r\n\r\n### Alternatives\r\nRemove the whole auto-reset logic on landing? It's not given that a mission should always start from 0. Though then the option in QGC should be there to reset the mission on landing/on vehicle boot.\r\n\r\n### Test coverage\r\nSITL tested. \r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-04-20T11:13:05Z",
          "body": "> _navigator->reset_vroi(); \r\n\r\nRight, added it.\r\n\r\n> set_current_mission_item()\r\n\r\nThat one contains partly duplicated logic that is also in reset_mission() . But I don't a reason speaking against also including it here.\r\n\r\nAdded both.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "> What I'm not very sure yet: do we want to run the mission feasibility checks also on the reset?\r\n\r\nI don't think so as the reset only changes the index.\r\n\r\nBut do these need to be called too?\r\n- https://github.com/PX4/PX4-Autopilot/blob/202e2770da50caff0ed00c06a574e3c39933df52/src/modules/navigator/mission.cpp#L520\r\n- https://github.com/PX4/PX4-Autopilot/blob/202e2770da50caff0ed00c06a574e3c39933df52/src/modules/navigator/mission.cpp#L586",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes an incorrect state transition/boundary condition: code path depended on _mission_sub.copy(...) returning true to perform a reset of _current_mission_index, but when copy() returned false the index was left in an invalid state leading to 'wp index out of bounds'. The change makes update_mission() gated by an actual mission update and explicitly resets the mission index on landing, correcting the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -113,8 +113,10 @@ Mission::on_inactive()\n \t\t/* reset the current mission if needed */\n \t\tif (need_to_reset_mission()) {\n \t\t\treset_mission(_mission);\n-\t\t\tupdate_mission();\n \t\t\t_navigator->reset_cruising_speed();\n+\t\t\t_current_mission_index = 0;\n+\t\t\t_navigator->reset_vroi();\n+\t\t\tset_current_mission_item();\n \t\t}\n \n \t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b97151d314c73022983d0540fac441476eb22a1/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::on_inactive"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_inactive"
        ]
      }
    }
  },
  {
    "title": "navigator_main: orbit in FW: get_cruising_speed()",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21484",
    "number": 21484,
    "created_at": "2023-04-17T12:28:46Z",
    "merged": true,
    "merged_at": "2023-04-18T14:01:24Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "`rep->current.cruising_speed = get_cruising_speed();` was missing on entry of a FW Orbit, thus always resetting the speed to the vehicle default. ",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-04-18T11:05:56Z",
          "body": "> only concern is that it returns -1 if no cruising speed is present.. is this handled in the remainder of navigator and/or the fixed-wing controller?\r\n\r\nYes FW Pos control checks for >0 to use the cruising_speed setpoint. ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "tstastny",
          "created_at": "",
          "body": "only concern is that it returns -1 if no cruising speed is present.. is this handled in the remainder of navigator and/or the fixed-wing controller?",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: the code failed to initialize the cruising_speed on entry to a fixedâ€‘wing Orbit, causing the system to fall back to the vehicle default instead of preserving or using the intended setpoint. Reviewer concerns about a -1 sentinel are noted but the fixedâ€‘wing position controller checks for >0, so the sentinel is handled and the change corrects the incorrect program state/behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -468,6 +468,7 @@ void Navigator::run()\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n \t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n+\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n \n \t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/16ee9b7ff570ccf7f069a8cc1c55bf8b327bfc65/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "RTL: fix Mission RTL vs normal RTL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21464",
    "number": 21464,
    "created_at": "2023-04-12T09:59:43Z",
    "merged": true,
    "merged_at": "2023-04-14T07:49:48Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Fixes by parts regressions that came in with https://github.com/PX4/PX4-Autopilot/pull/21390, and in other parts things that were still broken even before that PR.\r\nSee commits for more details. \r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-04-13T15:33:46Z",
          "body": "Flight tested, no more issues found, LGTM.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-04-12T14:36:32Z",
          "body": "I could add a comment why this class variable is necessary:\r\nOn switching into RTL, this variable is updated concerning the RTL destination type and whether the system is in fixed-wing mode at this moment.",
          "path": "src/modules/navigator/navigator.h",
          "position": 13,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR explicitly states it fixes regressions and broken behavior between Mission RTL and normal RTL introduced by a prior change, which indicates incorrect program behavior rather than syntax/style issues. The mention of flight testing and resolved issues further supports that this corrects logic faults (state/behavior errors) in the RTL implementation.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -468,7 +468,9 @@ Mission::land_start()\n {\n \t// if not currently landing, jump to do_land_start\n \tif (_land_start_available) {\n-\t\tif (landing()) {\n+\t\t// check if we're currently already in mission mode and on landing part, then simply return true.\n+\t\t// note: it's not enough to check landing(), as that is not reset until set_current_mission_index(get_land_start_index())\n+\t\tif (_navigator->on_mission_landing()) {\n \t\t\treturn true;\n \n \t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5d4c7b5d6003351581d8ca061cee04367a050b44/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -261,7 +261,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool is_planned_mission() const { return _navigation_mode == &_mission; }\n \n-\tbool on_mission_landing() { return _mission.landing(); }\n+\tbool on_mission_landing() { return (_mission.landing() && _navigation_mode == &_mission); }\n \n \tbool start_mission_landing() { return _mission.land_start(); }\n \n@@ -365,6 +365,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool \t\t_pos_sp_triplet_published_invalid_once{false};\t/**< flags if position SP triplet has been published once to UORB */\n \tbool\t\t_mission_result_updated{false};\t\t\t/**< flags if mission result has seen an update */\n \n+\tbool\t\t_shouldEngageMissionForLanding{false};\n+\n \tMission\t\t_mission;\t\t\t/**< class that handles the missions */\n \tLoiter\t\t_loiter;\t\t\t/**< class that handles loiter */\n \tTakeoff\t\t_takeoff;\t\t\t/**< class for handling takeoff commands */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5d4c7b5d6003351581d8ca061cee04367a050b44/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 12,
        "changes": 39,
        "patch": "@@ -668,24 +668,38 @@ void Navigator::run()\n \n \t\t\t\tswitch (_rtl.get_rtl_type()) {\n \t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING:\n-\t\t\t\tcase RTL::RTL_TYPE_CLOSEST:\n-\t\t\t\t\tif (on_mission_landing() && _rtl.getShouldEngageMissionForLanding()) {\n-\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n+\t\t\t\tcase RTL::RTL_TYPE_CLOSEST: {\n+\t\t\t\t\t\t// If a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode.\n+\t\t\t\t\t\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission.\n+\t\t\t\t\t\tif (rtl_activated_now) {\n+\t\t\t\t\t\t\t_shouldEngageMissionForLanding = _rtl.getRTLDestinationTypeMission()\n+\t\t\t\t\t\t\t\t\t\t\t && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\tnavigation_mode_new = &_mission;\n+\t\t\t\t\t\tif (_shouldEngageMissionForLanding && (on_mission_landing() || _rtl.getRTLState() > RTL::RTL_STATE_CLIMB)) {\n \n-\t\t\t\t\t\tif (rtl_activated_now) {\n-\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n-\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n-\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n+\t\t\t\t\t\t\t// already in a mission landing, we just need to inform the user and stay in mission\n+\t\t\t\t\t\t\tif (rtl_activated_now) {\n+\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n+\t\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n+\t\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n+\t\t\t\t\t\t\t\t// the first time we're here start the mission landig\n+\t\t\t\t\t\t\t\tstart_mission_landing();\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n+\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \n-\t\t\t\t\tbreak;\n-\n \t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING_REVERSED:\n \t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n \t\t\t\t\t\t// the mission contains a landing spot\n@@ -801,6 +815,7 @@ void Navigator::run()\n \n \t\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {\n \t\t\t_rtl_activated = false;\n+\t\t\t_rtl.resetRtlState();\n \t\t}\n \n \t\t// Do not execute any state machine while we are disarmed",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5d4c7b5d6003351581d8ca061cee04367a050b44/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "patch": "@@ -253,11 +253,6 @@ void RTL::on_activation()\n {\n \t_rtl_state = RTL_STATE_NONE;\n \n-\t// if a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode\n-\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission\n-\t_should_engange_mission_for_landing = (_destination.type == RTL_DESTINATION_MISSION_LANDING)\n-\t\t\t\t\t      && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n-\n \t// output the correct message, depending on where the RTL destination is\n \tswitch (_destination.type) {\n \tcase RTL_DESTINATION_HOME:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5d4c7b5d6003351581d8ca061cee04367a050b44/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -112,7 +112,9 @@ class RTL : public MissionBlock, public ModuleParams\n \n \tRTLState getRTLState() { return _rtl_state; }\n \n-\tbool getShouldEngageMissionForLanding() const { return _should_engange_mission_for_landing; }\n+\tbool getRTLDestinationTypeMission() { return _destination.type == RTLDestinationType::RTL_DESTINATION_MISSION_LANDING; }\n+\n+\tvoid resetRtlState() { _rtl_state = RTL_STATE_NONE; }\n \n private:\n \n@@ -161,7 +163,6 @@ class RTL : public MissionBlock, public ModuleParams\n \tfloat _rtl_alt{0.0f};\t// AMSL altitude at which the vehicle should return to the home position\n \n \tbool _rtl_alt_min{false};\n-\tbool _should_engange_mission_for_landing{false};\n \n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::RTL_RETURN_ALT>)  _param_rtl_return_alt,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5d4c7b5d6003351581d8ca061cee04367a050b44/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::land_start",
        "getShouldEngageMissionForLanding",
        "RTL::on_activation",
        "on_mission_landing",
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::land_start"
        ],
        "src/modules/navigator/navigator.h": [
          "on_mission_landing"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_activation"
        ],
        "src/modules/navigator/rtl.h": [
          "getShouldEngageMissionForLanding"
        ]
      }
    }
  },
  {
    "title": "Add NAV_CMD_DO_SET_ACTUATOR to mission commands",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21446",
    "number": 21446,
    "created_at": "2023-04-07T10:00:30Z",
    "merged": true,
    "merged_at": "2023-04-11T06:12:19Z",
    "state": "closed",
    "conversation": {
      "author": "cruise-control",
      "body": "### Solved Problem\r\nWhen  I tried to setup offboard actuator set  (with dynamic control allocation) and enable a mission item triggered/driven offboard actuator set, I found that the mission feasibility checker rejects the commands but the mission block supports them.\r\n\r\n\r\n### Solution\r\n- Add the `NAV_CMD_DO_SET_ACTUATOR` to the supported commands\r\n\r\n### Test Setup\r\n1. Setup `offboard actuator outputs` in QGC configuration page\r\n2. Create a mission with a \"Set Servo\" mission item and save it\r\n3. Manually  edit \"Set Servo\" mission item to change command to 187 (NAV_CMD_DO_SET_ACTUATOR)\r\n4. Alternatively use the development build of QGC and create \"Set Actuator\" mission item\r\n5. Upload to PX4\r\n6. Inspection of `actuator_outputs` and `vehicle_command`  uorb messages\r\n7. Using Iris Model\r\n\r\n### Test coverage\r\n- SITL\r\n  - Mission uploading working\r\n  - Mission item working\r\n- HITL\r\n  - Mission uploading working\r\n  - Mission item working\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "Thanks",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior where the mission feasibility checker rejected a valid actuator-set command that the mission block supported. The root cause is a logic mismatch (missing supported command) causing unintended rejections; adding NAV_CMD_DO_SET_ACTUATOR aligns the checker with runtime behavior.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -280,6 +280,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \t    mission_item.nav_cmd != NAV_CMD_DO_MOUNT_CONTROL &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE &&\n+\t    mission_item.nav_cmd != NAV_CMD_DO_SET_ACTUATOR &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_LOCATION &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/434cd278942fa70ad288be42071f2cf85a7ece1f/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::checkMissionItemValidity"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkMissionItemValidity"
        ]
      }
    }
  },
  {
    "title": "Speed reset when switching flight modes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21414",
    "number": 21414,
    "created_at": "2023-04-03T04:56:00Z",
    "merged": true,
    "merged_at": "2023-04-27T15:32:44Z",
    "state": "closed",
    "conversation": {
      "author": "afwilkin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen I issued a DO_CHANGE_SPEED, and then changed flight modes, that speed continued over to the new flight mode. \r\nFor example, if I issue a DO_CHANGE_SPEED in mission mode for 1 m/s, and then switch to Loiter mode, I am still restricted to 1 m/s.\r\n\r\nFrom the conversations that I have had with maintainers, this is not the behavior we want to have\r\n\r\nThe only flight mode that this **does not** happen for is RTL, which has the following line\r\n`_navigator->reset_cruising_speed();`\r\n\r\n\r\n### Solution\r\nI reset the cruising speed upon entering a new navigation mode.\r\n\r\n### Alternatives\r\nWe could also create a new module that keeps track of what mode we are in and changes speed limits from there\r\n\r\n### Test coverage\r\n- Create a waypoint mission with a change speed waypoint item at 1 m/s. Mid-mission flip to HOLD mode and issue a do_relocate. \r\nBefore the change: [log](https://review.px4.io/plot_app?log=784a1777-8dff-446c-989e-8bf3cc0210ec)\r\n![image](https://user-images.githubusercontent.com/16963678/229414814-126a9520-6e09-45c8-9e83-ca82b665525d.png)\r\n\r\nAfter the change: [log](https://review.px4.io/plot_app?log=015494ff-ad95-498b-bfd3-b59632db3525)\r\n![image](https://user-images.githubusercontent.com/16963678/229414936-f46b1814-8105-4f38-a5c5-cfbb1b980273.png)\r\n\r\n",
      "issue_comments": [
        {
          "author": "DronecodeBot",
          "created_at": "2023-04-04T15:25:41Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-community-q-a-april-05-2023/31435/4\n",
          "type": "issue_comment"
        },
        {
          "author": "junwoo091400",
          "created_at": "2023-04-05T15:19:48Z",
          "body": "@dagar we mentioned this during the call, and concluded that more discussion on the context of this problem is needed. So it would be nice to have your feedback on use-cases for this!",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2023-04-05T15:36:48Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-community-q-a-april-05-2023/31435/1\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "This is good to go from my side. We've tested it a bit in SITL and real vehicles (VTOLs). Needs follow up https://github.com/PX4/PX4-Autopilot/pull/21503 to have effect immediately always and not just when you set a new loiter for example.\r\n\r\nThe speed interface / handling in Navigator is quite ugly so I hope we get to fix it more fundamentally after the release. ",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes an incorrect program state: a DO_CHANGE_SPEED command's cruising speed persisted across flight-mode transitions (except RTL), producing unintended behavior. Resetting the cruising speed when entering a new navigation mode corrects an improper state transition/boundary-condition bug.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -65,6 +65,9 @@ Land::on_activation()\n \t_navigator->set_can_loiter_at_sp(false);\n \n \t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t// reset cruising speed to default\n+\t_navigator->reset_cruising_speed();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d61ac621db851cf4775a1cf37d92cdb16129b511/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -63,6 +63,9 @@ Loiter::on_activation()\n \t} else {\n \t\tset_loiter_position();\n \t}\n+\n+\t// reset cruising speed to default\n+\t_navigator->reset_cruising_speed();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d61ac621db851cf4775a1cf37d92cdb16129b511/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -210,6 +210,9 @@ Mission::on_activation()\n \tcmd.param1 = -1.0f;\n \tcmd.param3 = 0.0f;\n \t_navigator->publish_vehicle_cmd(&cmd);\n+\n+\t// reset cruise speed\n+\t_navigator->reset_cruising_speed();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d61ac621db851cf4775a1cf37d92cdb16129b511/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -300,7 +300,7 @@ void RTL::on_activation()\n \t}\n \n \t// reset cruising speed and throttle to default for RTL\n-\t_navigator->set_cruising_speed();\n+\t_navigator->reset_cruising_speed();\n \t_navigator->set_cruising_throttle();\n \n \tset_rtl_item();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d61ac621db851cf4775a1cf37d92cdb16129b511/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -51,6 +51,9 @@ void\n Takeoff::on_activation()\n {\n \tset_takeoff_position();\n+\n+\t// reset cruising speed to default\n+\t_navigator->reset_cruising_speed();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d61ac621db851cf4775a1cf37d92cdb16129b511/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_activation",
        "RTL::on_activation",
        "Takeoff::on_activation",
        "Mission::on_activation",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ],
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_activation"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::on_activation"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_activation"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_activation"
        ]
      }
    }
  },
  {
    "title": "[BACKPORT] Avoid unexpected repositions",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22100",
    "number": 22100,
    "created_at": "2023-09-19T15:40:58Z",
    "merged": true,
    "merged_at": "2023-09-19T23:16:03Z",
    "state": "closed",
    "conversation": {
      "author": "tstastny",
      "body": "backport of https://github.com/PX4/PX4-Autopilot/pull/22078\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Don't allow external reposition commands without a mode switch, and ensure old reposition commands are not erroneously set.\r\n```",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR explicitly fixes incorrect behavior around reposition commands â€” preventing external repositions without a mode switch and avoiding stale reposition commands being applied. This addresses improper state transitions and unintended behavior (unexpected repositions), which are classic logic errors.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -57,7 +57,8 @@ Loiter::on_inactive()\n void\n Loiter::on_activation()\n {\n-\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\tif (_navigator->get_reposition_triplet()->current.valid\n+\t    && hrt_elapsed_time(&_navigator->get_reposition_triplet()->current.timestamp) < 500_ms) {\n \t\treposition();\n \n \t} else {\n@@ -72,7 +73,8 @@ Loiter::on_activation()\n void\n Loiter::on_active()\n {\n-\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\tif (_navigator->get_reposition_triplet()->current.valid\n+\t    && hrt_elapsed_time(&_navigator->get_reposition_triplet()->current.timestamp) < 500_ms) {\n \t\treposition();\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/aca3f32f94b9b4dcaecc26aa26c7af273f8f1b27/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::on_inactive",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_inactive",
          "Loiter::on_activation"
        ]
      }
    }
  },
  {
    "title": "VTOL Takeoff: Use global position instead of home for takoeff",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22097",
    "number": 22097,
    "created_at": "2023-09-19T10:47:07Z",
    "merged": true,
    "merged_at": "2023-09-19T17:00:54Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "\r\n### Solved Problem\r\nWhen the vehicle home position does not coincide with the takeoff position the vehicle drifts off towards the home position during takeoff which is not the expected behavior.\r\n\r\n\r\n### Solution\r\n- Use global position for takeoff instead of home position.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: \r\nPrevent VTOL Takeoff from drifting during takeoff ascent when home position does not coincide with takeoff position.\r\n```",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-09-19T11:19:03Z",
          "body": "What happens actually if that's not fulfilled? ",
          "path": "src/modules/navigator/vtol_takeoff.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-09-19T17:00:21Z",
          "body": "@sfuhrer Then the triplet will not be published and not takeoff will happen.",
          "path": "src/modules/navigator/vtol_takeoff.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior where the system used the stored 'home' position as the takeoff reference instead of the vehicle's current global position, causing unintended drift when those positions differ. This is a logic error (wrong source of state/coordinate used for takeoff), and switching to the global position corrects the program's incorrect behavior.",
    "patches": {
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "patch": "@@ -51,7 +51,7 @@ VtolTakeoff::VtolTakeoff(Navigator *navigator) :\n void\n VtolTakeoff::on_activation()\n {\n-\tif (_navigator->home_global_position_valid()) {\n+\tif (hrt_elapsed_time(&_navigator->get_global_position()->timestamp) < 1_s) {\n \t\tset_takeoff_position();\n \t\t_takeoff_state = vtol_takeoff_state::TAKEOFF_HOVER;\n \t\t_navigator->reset_cruising_speed();\n@@ -71,8 +71,8 @@ VtolTakeoff::on_active()\n \t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_navigator->get_home_position()->lat,\n-\t\t\t\t\t\t\t    _navigator->get_home_position()->lon, _loiter_location(0), _loiter_location(1)));\n+\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat,\n+\t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n \t\t\t\t_mission_item.force_heading = true;\n \t\t\t\tmission_apply_limitation(_mission_item);\n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n@@ -172,8 +172,8 @@ VtolTakeoff::set_takeoff_position()\n \t// set current mission item to takeoff\n \tset_takeoff_item(&_mission_item, _transition_alt_amsl);\n \n-\t_mission_item.lat = _navigator->get_home_position()->lat;\n-\t_mission_item.lon = _navigator->get_home_position()->lon;\n+\t_mission_item.lat = _navigator->get_global_position()->lat;\n+\t_mission_item.lon = _navigator->get_global_position()->lon;\n \n \t_navigator->get_mission_result()->finished = false;\n \t_navigator->set_mission_result_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/99f302d0f8f3cb99e028eae002e3e04fc8c11b16/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "VtolTakeoff::VtolTakeoff",
        "VtolTakeoff::set_takeoff_position",
        "VtolTakeoff::on_active"
      ],
      "by_file": {
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::VtolTakeoff",
          "VtolTakeoff::set_takeoff_position",
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Avoid unexpected repositions",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22078",
    "number": 22078,
    "created_at": "2023-09-13T17:32:25Z",
    "merged": true,
    "merged_at": "2023-09-13T19:29:31Z",
    "state": "closed",
    "conversation": {
      "author": "tstastny",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\n1. Geofence reposition lifetime: when in RTL, the geofence reposition setpoint is ignored (ok, fine) - however, the reposition struct that holds that geofence position is stored until the next flight. If a manual control loss then engages a hold (during RTL delay time), the reposition setpoint is taken for the hold, which may be anywhere else other than the vehicle's current position.. which would be the desired hold position.\r\n2. External reposition commands without a requested mode switch (flag) are silently accepted and can cause unexpected positioning when hold is engaged.\r\n\r\n### Solution\r\n1. In the loiter activation methods, check the reposition setpoint's timestamp in addition to validity.\r\n3. Don't allow reposition commands without a requested mode switch.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Don't allow external reposition commands without a mode switch, and ensure old reposition commands are not erroneously set.\r\n```\r\n\r\n### Alternatives\r\nReal solution is not sharing the reposition struct between multiple modes, and not reusing loiter mode for goto and hold.\r\n\r\n### Test coverage\r\n- used libmav to send a reposition command without the modeswitch bit.. it rejects now\r\n- test case:\r\n  - unplug manual control\r\n  - let the multicopter rtl with geo fence boundary set near home\r\n  - geo fence sets reposition struct somewhere along the path towards home (but rtl ignores)\r\n  - vehicle lands, disarms\r\n  - arm and takeoff again in manual\r\n  - unplug manual control\r\n  - rtl ensues\r\n  - the rtl hold delay before returning to home is correctly set to the vehicle's current position (not the previously set reposition struct from last flight)",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect program logic: stale reposition state is being reused across flights (improper state/lifetime handling) and external reposition commands are accepted without the required mode-switch flag (incorrect command validation). Both lead to unintended vehicle positioning (wrong state transitions/outputs), which matches the definition of logic errors.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -51,7 +51,8 @@ Loiter::Loiter(Navigator *navigator) :\n void\n Loiter::on_activation()\n {\n-\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\tif (_navigator->get_reposition_triplet()->current.valid\n+\t    && hrt_elapsed_time(&_navigator->get_reposition_triplet()->current.timestamp) < 500_ms) {\n \t\treposition();\n \n \t} else {\n@@ -66,7 +67,8 @@ Loiter::on_activation()\n void\n Loiter::on_active()\n {\n-\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\tif (_navigator->get_reposition_triplet()->current.valid\n+\t    && hrt_elapsed_time(&_navigator->get_reposition_triplet()->current.timestamp) < 500_ms) {\n \t\treposition();\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ae5e123a339f56b781b948539a49142924de7e4b/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::Loiter",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::Loiter",
          "Loiter::on_activation"
        ]
      }
    }
  },
  {
    "title": "mavlink: increase first mission read timeout",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22057",
    "number": 22057,
    "created_at": "2023-09-07T18:26:54Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": " - relax timeout considerably, but only during init (typically when system is first starting up)\r\n\r\nSome boards are hitting this on the test rack, but it's fine if only happening at system startup when everything fighting to start in parallel.\r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/84712/0b0bcdf8-b74b-41d0-9ac6-5f5e6e739259)\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2023-09-07T18:40:30Z",
          "body": "Unless this is just a race condition with `navigator` establishing `DM_KEY_MISSION_STATE` (which is argubably obsolete anyway) in the first place.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-09-07T18:55:24Z",
          "body": "Something else is going on here, increasing the timeout made this fail on more boards.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-09-07T19:01:15Z",
          "body": "I had the dataman id indexing wrong, the problem was actually with DM_KEY_SAFE_POINTS and DM_KEY_FENCE_POINTS (items 0 & 1), not DM_KEY_WAYPOINTS_OFFBOARD_0/DM_KEY_WAYPOINTS_OFFBOARD_1.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-09-07T23:20:43Z",
          "body": "Proper fix is https://github.com/PX4/PX4-Autopilot/pull/22058 ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR only relaxes the initial mission read timeout (a mitigation for a startup race) rather than correcting incorrect program logic. The author later discovered the real bug was wrong dataman ID indexing and submitted the proper fix in a separate PR (22058), so this change does not address the underlying logic error.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -92,6 +92,7 @@ void Geofence::run()\n \t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n \n \t\tif (!success) {\n+\t\t\tPX4_ERR(\"geofence dataman read failed\");\n \t\t\t_error_state = DatamanState::Read;\n \t\t\t_dataman_state = DatamanState::Error;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/47b545658a05557c72de94a5840a6ef7f64e00ce/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -89,6 +89,7 @@ void RTL::run()\n \t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n \n \t\tif (!success) {\n+\t\t\tPX4_ERR(\"RTL dataman read failed\");\n \t\t\t_error_state = DatamanState::Read;\n \t\t\t_dataman_state = DatamanState::Error;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/47b545658a05557c72de94a5840a6ef7f64e00ce/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::run",
        "RTL::run"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::run"
        ]
      }
    }
  },
  {
    "title": "FixedWingPosControl: Handle waypoint type LAND for VTOL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21985",
    "number": 21985,
    "created_at": "2023-08-21T11:33:32Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nUntil now the navigator was hiding LAND type setpoints from the fixed wing position controller for VTOL_LAND items.\r\nIt published the wayoint as a normal position waypoint which made the position controller unaware of an impending transition. Furthermore, navigator internally set the altitude acceptance radius for a VTOL_LAND item to infinity (don't care about altitude) while the position controller was still using the default fixed wing altitude acceptance radius. In the worst case this causes the position controller to initiate a loiter during the approach to the land waypoint when the altitude error exceeded the threshold defined by the acceptance value.\r\n\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\nIt makes more sense to make the position controller aware of the setpoint type. This allows the position controller to take actions depending on the setpoint type (e.g. never loiter to recover altitude during the approach to a land waypoint.)\r\n\r\n### Changelog Entry\r\n```\r\nBugfix: Fixed issues where fixed wing position controller could instantiate a loiter when approaching a VTOL_LAND waypoint.\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\n- Unit/integration test: ...\r\n- Simulation/hardware testing logs: https://review.px4.io/\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2024-01-16T10:19:56Z",
          "body": "Addressed by  #22642",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2023-08-21T13:59:49Z",
          "body": "```suggestion\r\n\t\tint32_t val = 0;\r\n```",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 13,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-08-21T16:50:02Z",
          "body": "Couldn't this removal of the default cmd to type WAYPOINT cause problems? Why is it necessary in the context of this PR?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-08-21T16:57:23Z",
          "body": "What about a normal LAND command? Eg together with a backtransition waypoint?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-08-24T05:48:36Z",
          "body": "@sfuhrer Because if you scroll a few lines up you will see that we are in the context of NAV_CMD_VTOL_LAND and we should not need to tamper with the nav command just to achieve an expected behavior. Now, the position controller understands position setpoint type land so we can let it handle it. That's much cleaner IMO.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-08-24T05:50:57Z",
          "body": "@sfuhrer That is handled by `vtol_back_transition` flag.\r\nBut it's good that you bring it up. I actually tested it and I find this worflow highly confusing. I did not even understand from the way it's planned in QGC where the actual backtransition is going to happen. Also the mavlink specs don't actually give any helpful information how to use this command. In the end, that's the reason why VTOL_LAND was invented but we still should increase clarity for this option.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-08-24T10:46:51Z",
          "body": "right, I was not at the right location, all good!",
          "path": "src/modules/navigator/mission.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-08-24T10:49:06Z",
          "body": "okay, if the behavior isn't changed for the separate transition and land items workflow it's all good for now. ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "Makes sense to me, though even nicer would it be if we had a \"follow line\" interface to the position controller (instead of having it customized for the landing only). ",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes a behavioral/state-mismatch bug where LAND-type (VTOL_LAND) waypoints were published as normal position setpoints, causing the fixed-wing position controller to use incorrect altitude-acceptance logic and potentially loiter during approach. Making the controller aware of the setpoint type corrects the improper state/conditional handling and prevents the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -1019,7 +1019,6 @@ Mission::set_mission_items()\n \n \t\t\t\t\t_mission_item.altitude = altitude;\n \t\t\t\t\t_mission_item.altitude_is_relative = false;\n-\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t\t\t_mission_item.autocontinue = true;\n \t\t\t\t\t_mission_item.time_inside = 0.0f;\n \t\t\t\t\t_mission_item.vtol_back_transition = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bc8dfc05545c0ac0db5961d73ab38dbbd3d6537c/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "patch": "@@ -100,7 +100,11 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t// Indefinite Waypoints\n \tcase NAV_CMD_LAND: /* fall through */\n \tcase NAV_CMD_VTOL_LAND:\n-\t\treturn _navigator->get_land_detected()->landed;\n+\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\treturn _navigator->get_land_detected()->landed;\n+\t\t}\n+\n+\t\tbreak;\n \n \tcase NAV_CMD_IDLE: /* fall through */\n \tcase NAV_CMD_LOITER_UNLIMITED:\n@@ -339,8 +343,8 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();\n \n \t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n-\t\t\tif (_mission_item.vtol_back_transition\n-\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n+\t\t\t    && (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND || _mission_item.vtol_back_transition)) {\n \n \t\t\t\tfloat velocity = sqrtf(_navigator->get_local_position()->vx * _navigator->get_local_position()->vx +\n \t\t\t\t\t\t       _navigator->get_local_position()->vy * _navigator->get_local_position()->vy);\n@@ -355,7 +359,6 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t// do not care for altitude when approaching the backtransition point. Not accepting the waypoint causes\n \t\t\t\t// the vehicle to perform a sharp turn after passing the land waypoint and this causes worse unexected behavior\n \t\t\t\talt_acc_rad_m = INFINITY;\n-\n \t\t\t}\n \n \t\t\tbool passed_curr_wp = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bc8dfc05545c0ac0db5961d73ab38dbbd3d6537c/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ]
      }
    }
  },
  {
    "title": "multiple: Fix abs(int) usage on float values",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21963",
    "number": 21963,
    "created_at": "2023-08-14T13:30:30Z",
    "merged": true,
    "merged_at": "2023-08-15T08:18:32Z",
    "state": "closed",
    "conversation": {
      "author": "sverrevr",
      "body": "### Solved Problem\r\nResolves https://github.com/PX4/PX4-Autopilot/issues/21924\r\n\r\n### Solution\r\nSolves incorrect usage of abs. See https://github.com/PX4/PX4-Autopilot/issues/21924 for details\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix XYZ\r\nNew parameter: XYZ_Z\r\nDocumentation: Solves incorrect usage of abs\r\n```\r\n\r\n### Alternatives\r\nN/A\r\n\r\n### Test coverage\r\n- Unit/integration test: All tests still pass\r\n- Simulation/hardware testing logs: None\r\n\r\n### Context\r\nI realized that using abs() on float values casts them to int, which caused problems in some code I was working on. While searching through the code I realized that there were 3 places abs is currently being used on float values which can cause problems/inaccuracies.  I don't have a setup to test these changes, so I have not tested it beyond verifying that no tests fail.\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2023-08-14T13:48:16Z",
          "body": "Thanks @sverrevr, I suspect some of the confusion comes from std::abs (and using namespace std). ",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-08-14T14:24:54Z",
          "body": "We could consider ratcheting up the conversion warnings (+ -Werror), but last time I checked there's a huge number of harmless cases we'd have to adjust first.\r\n\r\n-Wconversion, -Wfloat-conversion, -Wsign-conversion, etc",
          "type": "issue_comment"
        },
        {
          "author": "sverrevr",
          "created_at": "2023-08-15T10:29:01Z",
          "body": "> We could consider ratcheting up the conversion warnings (+ -Werror), but last time I checked there's a huge number of harmless cases we'd have to adjust first.\r\n> \r\n> -Wconversion, -Wfloat-conversion, -Wsign-conversion, etc\r\n\r\nI think that would be ideal, but I see that it can be a large job to fix all the harmless cases ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: calling the integer abs overload on float values causes implicit conversion/truncation to int and produces incorrect numerical results. Changing to the proper float-aware absolute (e.g., std::abs/fabsf) corrects the unintended behavior.",
    "patches": {
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -159,7 +159,7 @@ GeofenceBreachAvoidance::generateLoiterPointForMultirotor(geofence_violation_typ\n \t\tVector2d test_point;\n \n \t\t// binary search for the distance from the drone to the geofence in the given direction\n-\t\twhile (abs(current_max - current_min) > 0.5f) {\n+\t\twhile (fabsf(current_max - current_min) > 0.5f) {\n \t\t\ttest_point = waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, current_distance);\n \n \t\t\tif (!geofence->isInsidePolygonOrCircle(test_point(0), test_point(1), _current_alt_amsl)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24c1475bcdc71fd99305105113fe83924b071083/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "GeofenceBreachAvoidance::generateLoiterPointForMultirotor"
      ],
      "by_file": {
        "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": [
          "GeofenceBreachAvoidance::generateLoiterPointForMultirotor"
        ]
      }
    }
  },
  {
    "title": "Remove checkIfBelowHomeAltitude in Navigator",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21904",
    "number": 21904,
    "created_at": "2023-07-28T06:57:43Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "potaito",
      "body": "### Solved Problem\r\nWhen taking off an elevated location (hill, mountain) and planning a mission in a valley relative to the take off location, PX4 will throw warnings for each single waypoint whose altitude is below the home location's altitude. This warning was most likely added to protect the user from mistakes, but flying below the home altitude with a drone is not so uncommon and the warnings are therefore too excessive.\r\n\r\n\r\n### Solution\r\nThe check for the waypoint altitude being below home has been completely removed. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Don't print warnings for waypoints with altitudes below the home position\r\n```\r\n\r\n### Alternatives\r\nWe could also limit to one warning per mission that contains waypoints below home, instead of one warning per waypoint. But I'd rather not have any unnecessary warnings during nominal operation of the drone.\r\n\r\n### Test coverage\r\nTested in simulation.\r\n\r\n#### Prior to this PR\r\n```\r\nINFO  [mavlink] mode: Onboard, data rate: 4000000 B/s on udp port 14580 remote port 14540\r\n[Msg] Connected to gazebo master @ http://127.0.0.1:11345\r\n[Msg] Publicized address: 192.168.0.30\r\nINFO  [mavlink] mode: Onboard, data rate: 4000 B/s on udp port 14280 remote port 14030\r\nINFO  [mavlink] mode: Gimbal, data rate: 400000 B/s on udp port 13030 remote port 13280\r\nINFO  [logger] logger started (mode=all)\r\nINFO  [logger] Start file log (type: full)\r\nINFO  [logger] [logger] ./log/2023-07-28/06_55_16.ulg\t\r\nINFO  [logger] Opened full log file: ./log/2023-07-28/06_55_16.ulg\r\nINFO  [mavlink] MAVLink only on localhost (set param MAV_{i}_BROADCAST = 1 to enable network)\r\nINFO  [mavlink] MAVLink only on localhost (set param MAV_{i}_BROADCAST = 1 to enable network)\r\nINFO  [px4] Startup script returned successfully\r\npxh> INFO  [tone_alarm] home set\r\nWARN  [mission_feasibility_checker] Warning: Waypoint 2 below home\t\r\nWARN  [mission_feasibility_checker] Warning: Waypoint 3 below home\t\r\nWARN  [mission_feasibility_checker] Warning: Waypoint 4 below home\t\r\n[Wrn] [Event.cc:61] Warning: Deleting a connection right after creation. Make sure to save the ConnectionPtr from a Connect call\r\nINFO  [tone_alarm] notify positive\r\nINFO  [commander] Ready for takeoff!\r\nINFO  [commander] Armed by external command\t\r\nINFO  [tone_alarm] arming warning\r\nINFO  [navigator] Executing Mission\t\r\nINFO  [navigator] Takeoff to 2.5 meters above home\t\r\nINFO  [commander] Takeoff detected\t\r\nINFO  [navigator] Mission finished, loitering\r\n```\r\nhttps://logs.px4.io/plot_app?log=b91adbc1-f7e4-448d-aa3b-5194d4fb407f\r\n\r\n#### After this PR\r\nNo warnings:\r\n```\r\nINFO  [mavlink] mode: Onboard, data rate: 4000000 B/s on udp port 14580 remote port 14540\r\n[Msg] Connected to gazebo master @ http://127.0.0.1:11345\r\n[Msg] Publicized address: 192.168.0.30\r\nINFO  [mavlink] mode: Onboard, data rate: 4000 B/s on udp port 14280 remote port 14030\r\nINFO  [mavlink] mode: Gimbal, data rate: 400000 B/s on udp port 13030 remote port 13280\r\nINFO  [logger] logger started (mode=all)\r\nINFO  [logger] Start file log (type: full)\r\nINFO  [logger] [logger] ./log/2023-07-28/06_53_28.ulg\t\r\nINFO  [logger] Opened full log file: ./log/2023-07-28/06_53_28.ulg\r\nINFO  [mavlink] MAVLink only on localhost (set param MAV_{i}_BROADCAST = 1 to enable network)\r\nINFO  [mavlink] MAVLink only on localhost (set param MAV_{i}_BROADCAST = 1 to enable network)\r\nINFO  [px4] Startup script returned successfully\r\npxh> INFO  [tone_alarm] home set\r\n[Wrn] [Event.cc:61] Warning: Deleting a connection right after creation. Make sure to save the ConnectionPtr from a Connect call\r\nINFO  [tone_alarm] notify positive\r\nINFO  [commander] Ready for takeoff!\r\nINFO  [commander] Armed by external command\t\r\nINFO  [tone_alarm] arming warning\r\nINFO  [navigator] Executing Mission\t\r\nINFO  [navigator] Takeoff to 2.5 meters above home\t\r\nINFO  [commander] Takeoff detected\t\r\nINFO  [navigator] Mission finished, loitering\r\n```\r\nhttps://logs.px4.io/plot_app?log=330407db-73a0-4fc5-8203-09a3a94da4c6\r\n\r\n",
      "issue_comments": [
        {
          "author": "potaito",
          "created_at": "2023-07-28T08:22:54Z",
          "body": "I would also have to remove the event `\"navigator_mis_wp_below_home\"` if the intent of this PR is accepted",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-07-31T08:12:15Z",
          "body": "@potaito Maybe we should issue the warning once when the altitude mode is relative to home point. In that case it's quite likely that the user does not intend to fly lower than home. But we can remove the warning when altitude mode is set to global. In that case the user has either specified AMSL altitudes or altitudes above terrain (which are converted to AMSL by QGC)",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-17T12:29:23Z",
          "body": "Done in https://github.com/PX4/PX4-Autopilot/pull/22624",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR removes an overly aggressive check that produced repeated, false-positive warnings whenever waypoints were below the home altitude. That behavior is incorrect/unintended (excessive user alerts) rather than a syntax/crash issue, so removing or adjusting the conditional constitutes a logic bug fix.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "patch": "@@ -58,7 +58,6 @@ void FeasibilityChecker::reset()\n \t_land_pattern_validity_failed = false;\n \t_distance_first_waypoint_failed = false;\n \t_distance_between_waypoints_failed = false;\n-\t_below_home_alt_failed = false;\n \t_fixed_wing_land_approach_failed = false;\n \t_takeoff_land_available_failed = false;\n \n@@ -199,10 +198,6 @@ void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int\n \t\t_distance_first_waypoint_failed = !checkHorizontalDistanceToFirstWaypoint(mission_item);\n \t}\n \n-\tif (!_below_home_alt_failed) {\n-\t\t_below_home_alt_failed = !checkIfBelowHomeAltitude(mission_item, current_index);\n-\t}\n-\n \tif (!_takeoff_failed) {\n \t\t_takeoff_failed = !checkTakeoff(mission_item);\n \t}\n@@ -682,21 +677,6 @@ bool FeasibilityChecker::checkDistancesBetweenWaypoints(const mission_item_s &mi\n \treturn true;\n }\n \n-bool FeasibilityChecker::checkIfBelowHomeAltitude(const mission_item_s &mission_item, const int current_index)\n-{\n-\t/* calculate the global waypoint altitude */\n-\tfloat wp_alt = (mission_item.altitude_is_relative) ? mission_item.altitude + _home_alt_msl : mission_item.altitude;\n-\n-\tif (PX4_ISFINITE(_home_alt_msl) && _home_alt_msl > wp_alt && MissionBlock::item_contains_position(mission_item)) {\n-\n-\t\tmavlink_log_critical(_mavlink_log_pub, \"Warning: Waypoint %d below home\\t\", current_index + 1);\n-\t\tevents::send<int16_t>(events::ID(\"navigator_mis_wp_below_home\"), {events::Log::Warning, events::LogInternal::Info},\n-\t\t\t\t      \"Waypoint {1} below home\", current_index + 1);\n-\t}\n-\n-\treturn true;\n-}\n-\n bool FeasibilityChecker::checkItemsFitToVehicleType(const mission_item_s &mission_item)\n {\n \tif (_vehicle_type != VehicleType::Vtol &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/de56f64076dd4163c0f3ad47c1459dbc93dbcba6/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "patch": "@@ -81,7 +81,6 @@ class FeasibilityChecker : public ModuleParams\n \t\t       _distance_between_waypoints_failed ||\n \t\t       _land_pattern_validity_failed ||\n \t\t       _fixed_wing_land_approach_failed ||\n-\t\t       _below_home_alt_failed ||\n \t\t       _mission_validity_failed ||\n \t\t       _takeoff_land_available_failed;\n \t}\n@@ -117,7 +116,6 @@ class FeasibilityChecker : public ModuleParams\n \tbool _land_pattern_validity_failed{false};\n \tbool _distance_first_waypoint_failed{false};\n \tbool _distance_between_waypoints_failed{false};\n-\tbool _below_home_alt_failed{false};\n \tbool _fixed_wing_land_approach_failed{false};\n \tbool _takeoff_land_available_failed{false};\n \tbool _items_fit_to_vehicle_type_failed{false};\n@@ -198,15 +196,6 @@ class FeasibilityChecker : public ModuleParams\n \t*/\n \tbool checkDistancesBetweenWaypoints(const mission_item_s &mission_item);\n \n-\t/**\n-\t * @brief Check if any waypoint is below the home altitude. Issues warning only.\n-\t *\n-\t * @param mission_item The current mission item\n-\t * @param current_index The current mission index\n-\t * @return Always returns true, only issues warning.\n-\t*/\n-\tbool checkIfBelowHomeAltitude(const mission_item_s &mission_item, const int current_index);\n-\n \t/**\n \t * @brief Check fixed wing land approach (fixed wing only)\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/de56f64076dd4163c0f3ad47c1459dbc93dbcba6/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.hpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::item_contains_position",
        "FeasibilityChecker::checkIfBelowHomeAltitude",
        "FeasibilityChecker::reset",
        "FeasibilityChecker::doCommonChecks",
        "checkIfBelowHomeAltitude",
        "FeasibilityChecker::checkDistancesBetweenWaypoints"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "MissionBlock::item_contains_position",
          "FeasibilityChecker::checkIfBelowHomeAltitude",
          "FeasibilityChecker::doCommonChecks",
          "FeasibilityChecker::reset",
          "FeasibilityChecker::checkDistancesBetweenWaypoints"
        ],
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": [
          "checkIfBelowHomeAltitude"
        ]
      }
    }
  },
  {
    "title": "Fix mission failed bug",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21888",
    "number": 21888,
    "created_at": "2023-07-26T14:28:44Z",
    "merged": true,
    "merged_at": "2023-07-27T05:21:30Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nI found two issues with mission uploading in the newest main. \r\n\r\n1. Mission module per default assumed the mission was not valid when the mission uorb topic changed. Only when the mission counter is updated, it actually checks the validity of the mission. But since the mission topic gets updated as well when the geofence or safepoints changed, this would lead to wrongly failed missions in the mission module where the mission would be reset.\r\n2. The mission counter in mavlink_mission module was always set to 0 on startup. When on the last powercycle, exactly one mission was loaded, the mission counter in the dataman was set to one. On the next powerccle and the first mission upload, the mavlink_mission would report again a mission counter of 1. This would lead in the mission module to believe, that the mission was not updated at all.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n\r\n1. Mission module loads the previously calculated mission validity and if the mission changes, calculates it newly.\r\n2. mavlink_mission loads the mission counter on startup from the datamn (safepoints as well, already done for geofence).\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Mission failed on geofence/safepoint upload\r\nBufgix: Mission failed on first mission upload\r\n```\r\n\r\n### Test coverage\r\n- SITL test: checking the px4 console output.\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "Thanks, a good reminder to me to not just quickly do things.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR corrects incorrect state/conditional logic: the mission validity was being improperly invalidated on any topic change (including geofence/safepoint updates) instead of only when the mission truly changed, and the mavlink_mission module erroneously initialized the mission counter to 0 on startup causing false 'not updated' detections. Both fixes address improper state handling/validation and are classic logic errors.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -586,7 +586,7 @@ void\n Mission::update_mission()\n {\n \n-\tbool failed = true;\n+\tbool failed = !_navigator->get_mission_result()->valid;\n \n \t_dataman_cache.invalidate();\n \t_load_mission_index = -1;\n@@ -653,6 +653,7 @@ Mission::update_mission()\n \n \t} else {\n \t\tPX4_ERR(\"mission update failed\");\n+\t\tfailed = true;\n \t}\n \n \tif (failed) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d92a0068102697d8d2bf102a7c39c6b7e426adb2/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_mission"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::update_mission"
        ]
      }
    }
  },
  {
    "title": "Geofence: Disable pre-emptive geofence predictor by default",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21875",
    "number": 21875,
    "created_at": "2023-07-23T20:53:44Z",
    "merged": true,
    "merged_at": "2023-07-24T14:25:31Z",
    "state": "closed",
    "conversation": {
      "author": "junwoo091400",
      "body": "## About\r\nAs discussed in https://discuss.px4.io/t/px4-maintainers-call-may-30-2023/32372#v114-new-beta-release-5, Geofence predictor feature was not well tested / maintained, hence was agreed upon to be disabled for the 1.14 release. And this was merged with the PR: https://github.com/PX4/PX4-Autopilot/pull/21657\r\n\r\nAlthough we didn't discuss how to proceed with this feature in `main`, since it isn't actively maintained, I think it makes sense to backport this back to `main`.",
      "issue_comments": [
        {
          "author": "AlexKlimaj",
          "created_at": "2023-07-24T07:48:19Z",
          "body": "I highly support this.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR changes the default configuration by disabling an unmaintained feature (the geofence predictor) rather than correcting an incorrect algorithm, conditional, or state transition. The description and comments indicate it's a precautionary/backport change to avoid potential instability, not a targeted fix of a specific logic bug.",
    "patches": {
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -128,7 +128,9 @@ PARAM_DEFINE_FLOAT(GF_MAX_HOR_DIST, 0);\n PARAM_DEFINE_FLOAT(GF_MAX_VER_DIST, 0);\n \n /**\n- * Use Pre-emptive geofence triggering\n+ * [EXPERIMENTAL] Use Pre-emptive geofence triggering\n+ *\n+ * WARNING: This experimental feature may cause flyaways. Use at your own risk.\n  *\n  * Predict the motion of the vehicle and trigger the breach if it is determined that the current trajectory\n  * would result in a breach happening before the vehicle can make evasive maneuvers.\n@@ -137,4 +139,4 @@ PARAM_DEFINE_FLOAT(GF_MAX_VER_DIST, 0);\n  * @boolean\n  * @group Geofence\n  */\n-PARAM_DEFINE_INT32(GF_PREDICT, 1);\n+PARAM_DEFINE_INT32(GF_PREDICT, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/43400895f2248c2b8c36fbc65bc52278ca78f7b8/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Support Figure of eight loitering",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21852",
    "number": 21852,
    "created_at": "2023-07-14T14:59:51Z",
    "merged": true,
    "merged_at": "2023-10-31T19:58:00Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nAdd support for a figure of eight loitering pattern for fixed wing vehicles (can e.g. be used to replace orbit when tracking POIs with a limited panning gimbal). This adds the support for the MAV_CMD_DO_FIGURE_EIGHT mavlink command currently defined in the development dialect.\r\n\r\n### Solution\r\n- Add a new functionality in the FixedWingPositionControl to process a figure of eight loitering pattern. The class checks the relevant segment of the figure of eight and passes the path segment to the npfg guidance logic for lateral guidance.\r\n- Addded a configuration to enable the figure of 8 loitering. It is disabled by default since it would need the development mavlink dialect (only enabled for sitl config).\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature Support for Figure 8 loiter pattern\r\n```\r\n\r\n### Alternatives\r\n\r\n### Test coverage\r\n- Simulation tests performed in sitl.\r\n- Build tests for fmu_v5x\r\n\r\n![Screenshot from 2023-07-14 16-50-24](https://github.com/PX4/PX4-Autopilot/assets/98741601/52325dc6-6aec-4f91-9d01-c3e5d67af798)\r\n\r\n\r\n### Context\r\nTo discuss:\r\n\r\n- [ ] Currently QGCS has no support for sending this command only AMC is this a problem?\r\n- [ ] Added a kconfig parameter to disable it since we need the development mavlink dialect to enable it. But i have not found a solution to make a dependency on the development dialect. Any input on how to handle this is appreciated.\r\n",
      "issue_comments": [
        {
          "author": "tstastny",
          "created_at": "2023-09-08T14:48:57Z",
          "body": "@dagar just so that this one doesnt get kicked down the road too far:\r\n\r\n> Added a kconfig parameter to disable it since we need the development mavlink dialect to enable it. But i have not found a solution to make a dependency on the development dialect. Any input on how to handle this is appreciated.\r\n\r\ndo you have insights here how to handle? would the current action look something like default kconfiging the fig8 as disabled while there is a development mavlink link? (but then need to still make sure we have mavsdk test and a build that can run in ci.. even though on all the main binary builds it would be disabled)\r\n\r\n> no GCS implementation\r\n\r\nIs this already a nogo? or would mavsdk test be enough while this is in mavlink development.xml?\r\n\r\nIf the lack of operator command ease marks this as not good for merging now.. let's just decide quickly so that we'll take this back downstream until such point that we can bring it in more properly upstream.\r\n\r\n\r\n@KonradRudin if we proceed with this PR - you may need to check the implications of this PR on the figure eight logic #21988 ",
          "type": "issue_comment"
        },
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2023-09-27T09:05:41Z",
          "body": "> Is this already a nogo? or would mavsdk test be enough while this is in mavlink development.xml?\r\n\r\n@tstastny Why not just add it to QGC :smirk:? ",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-09-27T09:10:08Z",
          "body": "> @tstastny Why not just add it to QGC ðŸ˜?\r\n\r\n@KonradRudin @RomanBapst  ^^",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-10-30T15:35:52Z",
          "body": "@dagar is this ok to go in now? before we e.g. run out of flash / need another rebase with other fixed-wing things on the docket?\r\n\r\n@KonradRudin i re-started the tailsitter test, it was failing, but i didnt see an erroneous timeout.. may actually be something wrong, can you check? https://github.com/PX4/PX4-Autopilot/actions/runs/6655895059/job/18096246149#step:17:1383\r\n",
          "type": "issue_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-10-30T16:53:43Z",
          "body": "@dagar all checks passing - should we smash the button?",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-10-31T15:59:24Z",
          "body": "@tstastny had to rebase, since it had some merge conflicts (only in the mavsdk tests).",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2023-10-25T20:03:08Z",
          "body": "This part could be \r\n```suggestion\r\n#if defined(MAVLINK_MSG_ID_FIGURE_EIGHT_EXECUTION_STATUS)\r\n```",
          "path": "src/modules/mavlink/mavlink_messages.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-10-25T20:04:42Z",
          "body": "How about we make the mavlink part dependent on `MAVLINK_MSG_ID_ACTUATOR_CONTROL_TARGET`\r\n\r\nThen either drop CONFIG_FIGURE_OF_EIGHT or make it clear it's FW (with a dependency on CONFIG_MODULES_FW_POS_CONTROL).",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-10-25T20:31:23Z",
          "body": "> How about we make the mavlink part dependent on MAVLINK_MSG_ID_ACTUATOR_CONTROL_TARGET\r\n\r\ndid you mean `MAVLINK_MSG_ID_FIGURE_EIGHT_EXECUTION_STATUS`?",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-10-26T12:11:24Z",
          "body": "Sounds like a good idea, thanks for the input.",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-10-26T14:16:00Z",
          "body": "@dagar the dependency is already defined in the kconfig, i guess this should be enough?",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-10-26T14:23:03Z",
          "body": "It doesn't need to be completely tied to mavlink.",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-10-26T14:26:09Z",
          "body": "Yes the mavlink part i will make only dependent on the MAVLINK_MSG_ID but the CONFIG_FIGURE_OF_EIGHT is already dependent on MODULES_FW_POS_CONTROL in the kconfig.",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-10-26T18:28:25Z",
          "body": "Hey @dagar with the new commit, i have removed the dependency to the development dialect. you can now build the figure of eight with the common, you just wont get any feedback message. ",
          "path": "boards/px4/sitl/default.px4board",
          "position": 4,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "tstastny",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR introduces a new feature (figureâ€‘ofâ€‘eight loitering) and related configuration/testing changes rather than correcting an existing incorrect behavior. The description and comments discuss adding functionality and configuration concerns (mavlink dialect, tests), with no indication it fixes an unintended or incorrect program state, conditional, or algorithmic bug.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "patch": "@@ -382,6 +382,27 @@ void Navigator::run()\n \t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n \t\t\t\t\t\t}\n \n+\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n+\t\t\t\t\t\t\trep->current.loiter_minor_radius = curr->current.loiter_minor_radius;\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\trep->current.loiter_minor_radius = NAN;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_orientation) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n+\t\t\t\t\t\t\trep->current.loiter_orientation = curr->current.loiter_orientation;\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (curr->current.loiter_pattern > 0) {\n+\t\t\t\t\t\t\trep->current.loiter_pattern = curr->current.loiter_pattern;\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n+\t\t\t\t\t\t}\n+\n \t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n \t\t\t\t\t}\n \n@@ -505,6 +526,8 @@ void Navigator::run()\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n \t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n+\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n+\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n \n \t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n@@ -531,6 +554,61 @@ void Navigator::run()\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n \t\t\t\t}\n \n+\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_FIGUREEIGHT &&\n+\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+#ifdef CONFIG_FIGURE_OF_EIGHT\n+\t\t\t\t// Only valid for fixed wing mode\n+\n+\t\t\t\tbool orbit_location_valid = true;\n+\n+\t\t\t\tvehicle_global_position_s position_setpoint{};\n+\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n+\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n+\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n+\n+\t\t\t\tif (have_geofence_position_data) {\n+\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n+\t\t\t\t}\n+\n+\t\t\t\tif (orbit_location_valid) {\n+\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n+\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n+\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n+\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n+\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n+\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\n+\t\t\t\t\tif (PX4_ISFINITE(cmd.param2) && fabsf(cmd.param2) > FLT_EPSILON) {\n+\t\t\t\t\t\trep->current.loiter_minor_radius = fabsf(cmd.param2);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\trep->current.loiter_radius = 2.5f * rep->current.loiter_minor_radius;\n+\n+\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n+\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n+\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n+\n+\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n+\t\t\t\t\t\trep->current.loiter_orientation = cmd.param4;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\trep->current.lat = position_setpoint.lat;\n+\t\t\t\t\trep->current.lon = position_setpoint.lon;\n+\t\t\t\t\trep->current.alt = position_setpoint.alt;\n+\n+\t\t\t\t\trep->current.valid = true;\n+\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n+\t\t\t\t}\n+\n+#endif // CONFIG_FIGURE_OF_EIGHT\n+\n \t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n \t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/550cca6337debd34bddb1cc0627210e7f026a585/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Support mavlink opaque ID",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21839",
    "number": 21839,
    "created_at": "2023-07-12T07:09:06Z",
    "merged": true,
    "merged_at": "2023-11-29T16:10:41Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nThis PR adds support for the Mavlink Mission opaque ID as defined in https://github.com/mavlink/mavlink/pull/2012. It is based on the earlier implementation for the mission checksum support in https://github.com/PX4/PX4-Autopilot/pull/18418, but the mission checksum in Mavlink will be deprecated in https://github.com/mavlink/mavlink/pull/2010.\r\n\r\n### Solution\r\n- Add an opaque Id for the mission, geofence and rally points. The opaque id is based on a Crc32 checksum as in the implementation in https://github.com/PX4/PX4-Autopilot/pull/18418\r\n- Opaque id is send from the System in the MISSION_COUNT on download. On upload, the opaque id is sent on the final MISSION_ACK\r\n- The opaque Id is also streamed continuously in the MISSION_CURRENT message, such that a GCS can detect plan changes.\r\n- The opaque id internally also replaces the mission counter, as those serves the same purpose.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Add Support for Mavlink mission opaque Id.\r\n```\r\n\r\n### Alternatives\r\nOpqaue id could also just be a counter instead of the Crc32. The hash implementation has the advantage that on loading the same mission (e.g. also from a file) should result in the same Id and thus the potentially multiple connected GCS does not need to download it again. Also it would allow for the feature, that a GCS does not need to download the mission on first connection if the old stored mission and opaque id is the same.\r\n\r\n### Test coverage\r\n- Unit/integration test: SITL testing by observing the mavlink message sent from the system.\r\n\r\n### Context\r\n- Before this can be merged, the respective mavlink PR should be merged\r\n",
      "issue_comments": [
        {
          "author": "hamishwillee",
          "created_at": "2023-11-14T08:08:10Z",
          "body": "@KonradRudin Looks like this is getting close. Let me know when it is ready to merge and you have test results/stuff we can use to validate this (so that I can push for merging of the MAVLink changes). ",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-11-20T15:26:13Z",
          "body": "As soon as https://github.com/mavlink/mavlink/pull/2012 is merged we can update the mavlink submodule and bring this in.",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-20T19:53:48Z",
          "body": "rebased on main again",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-20T19:55:20Z",
          "body": "@hamishwillee This PR was discussed now in the maintainer call and in agreement wirh @dagar . This side is ready now",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-29T10:18:14Z",
          "body": "Upstream mavlink is merged now. Update the mavlink submodule",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "ThomasDebrunner",
          "created_at": "2023-11-08T15:19:11Z",
          "body": "I assume this will have to be changed to upstream mavlink, once it is merged in upstream mavliink, right? (Before we merge here)",
          "path": ".gitmodules",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "ThomasDebrunner",
          "created_at": "2023-11-08T15:19:53Z",
          "body": "That would now be \"if changed\" and not \"if increased\", right?",
          "path": "msg/Mission.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "ThomasDebrunner",
          "created_at": "2023-11-08T15:23:11Z",
          "body": "Why is this needed?",
          "path": "src/modules/mavlink/mavlink_mission.cpp",
          "position": 223,
          "type": "review_comment"
        },
        {
          "author": "ThomasDebrunner",
          "created_at": "2023-11-08T15:24:21Z",
          "body": "I misunderstood this as some sort of CRC for the current mission item (e.g. waypoint or something). Maybe rename to \"current_mission_type_crc\" or similar?",
          "path": "src/modules/mavlink/mavlink_mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-10T08:46:01Z",
          "body": "Exactly, this PR will stay in draft because of this. I need to update this as soon as it is merged on Mavlink",
          "path": ".gitmodules",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-10T08:59:51Z",
          "body": "The mission current has now the IDs which should be periodically send. That means it should send it periodically as well, when there is no mission available, so that the ground station is informed when the mission is cleared.",
          "path": "src/modules/mavlink/mavlink_mission.cpp",
          "position": 223,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "ThomasDebrunner",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR implements a new MAVLink feature (opaque IDs for mission/geofence/rally) and replaces the mission counter for protocol compatibility. The description and comments indicate an added capability and protocol update rather than correcting incorrect program behavior or fixing a bug, so it is an enhancement rather than a logic-error fix.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 3,
        "changes": 31,
        "patch": "@@ -40,8 +40,10 @@\n  */\n #include \"geofence.h\"\n #include \"navigator.h\"\n+#include \"navigation.h\"\n \n #include <ctype.h>\n+#include <crc32.h>\n \n #include <dataman_client/DatamanClient.hpp>\n #include <drivers/drv_hrt.h>\n@@ -51,6 +53,27 @@\n \n #include \"navigator.h\"\n \n+static uint32_t crc32_for_fence_point(const mission_fence_point_s &fence_point, uint32_t prev_crc32)\n+{\n+\tunion {\n+\t\tCrcMissionItem_t item;\n+\t\tuint8_t raw[sizeof(CrcMissionItem_t)];\n+\t} u;\n+\n+\tu.item.frame = fence_point.frame;\n+\tu.item.command = fence_point.nav_cmd;\n+\tu.item.autocontinue = 0U;\n+\tu.item.params[0] = 0.f;\n+\tu.item.params[1] = 0.f;\n+\tu.item.params[2] = 0.f;\n+\tu.item.params[3] = 0.f;\n+\tu.item.params[4] = static_cast<float>(fence_point.lat);\n+\tu.item.params[5] = static_cast<float>(fence_point.lon);\n+\tu.item.params[6] = fence_point.alt;\n+\n+\treturn crc32part(u.raw, sizeof(u), prev_crc32);\n+}\n+\n Geofence::Geofence(Navigator *navigator) :\n \tModuleParams(navigator),\n \t_navigator(navigator)\n@@ -105,9 +128,9 @@ void Geofence::run()\n \t\t\t\t_error_state = DatamanState::ReadWait;\n \t\t\t\t_dataman_state = DatamanState::Error;\n \n-\t\t\t} else if (_update_counter != _stats.update_counter) {\n+\t\t\t} else if (_opaque_id != _stats.opaque_id) {\n \n-\t\t\t\t_update_counter = _stats.update_counter;\n+\t\t\t\t_opaque_id = _stats.opaque_id;\n \t\t\t\t_fence_updated = false;\n \n \t\t\t\t_dataman_cache.invalidate();\n@@ -559,6 +582,7 @@ Geofence::loadFromFile(const char *filename)\n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Geofence imported\\t\");\n \t\tevents::send(events::ID(\"navigator_geofence_imported\"), events::Log::Info, \"Geofence imported\");\n \t\tret_val = PX4_ERROR;\n+\t\tuint32_t crc32{0U};\n \n \t\t/* do a second pass, now that we know the number of vertices */\n \t\tfor (int seq = 1; seq <= pointCounter; ++seq) {\n@@ -569,14 +593,15 @@ Geofence::loadFromFile(const char *filename)\n \n \t\t\tif (success) {\n \t\t\t\tmission_fence_point.vertex_count = pointCounter;\n+\t\t\t\tcrc32 = crc32_for_fence_point(mission_fence_point, crc32);\n \t\t\t\t_dataman_client.writeSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n \t\t\t\t\t\t\t  sizeof(mission_fence_point_s));\n \t\t\t}\n \t\t}\n \n \t\tmission_stats_entry_s stats;\n \t\tstats.num_items = pointCounter;\n-\t\tstats.update_counter = _update_counter + 1;\n+\t\tstats.opaque_id = crc32;\n \n \t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&stats),\n \t\t\t\tsizeof(mission_stats_entry_s));",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -183,8 +183,7 @@ class Geofence : public ModuleParams\n \n \tMapProjection _projection_reference{}; ///< class to convert (lon, lat) to local [m]\n \n-\n-\tuint16_t _update_counter{0}; ///< dataman update counter: if it does not match, polygon data was updated\n+\tuint32_t _opaque_id{0}; ///< dataman geofence id: if it does not match, the polygon data was updated\n \tbool _fence_updated{true};  ///< flag indicating if fence are updated to dataman cache\n \tbool _initiate_fence_updated{true}; ///< flag indicating if fence updated is needed\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -473,7 +473,7 @@ Mission::save_mission_state()\n \tif (success) {\n \t\t/* data read successfully, check dataman ID and items count */\n \t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count\n-\t\t    && mission_state.mission_update_counter == _mission.mission_update_counter) {\n+\t\t    && mission_state.mission_id == _mission.mission_id) {\n \t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n \t\t\tif (mission_state.current_seq != _mission.current_seq) {\n \t\t\t\tmission_state = _mission;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -114,7 +114,7 @@ void MissionBase::updateMavlinkMission()\n \t\tif (isMissionValid(new_mission)) {\n \t\t\t/* Relevant mission items updated externally*/\n \t\t\tif (checkMissionDataChanged(new_mission)) {\n-\t\t\t\tbool mission_items_changed = (new_mission.mission_update_counter != _mission.mission_update_counter);\n+\t\t\t\tbool mission_items_changed = (new_mission.mission_id != _mission.mission_id);\n \n \t\t\t\tif (new_mission.current_seq < 0) {\n \t\t\t\t\tnew_mission.current_seq = math::max(math::min(_mission.current_seq, static_cast<int32_t>(new_mission.count) - 1),\n@@ -689,12 +689,12 @@ MissionBase::checkMissionRestart()\n void\n MissionBase::check_mission_valid()\n {\n-\tif ((_navigator->get_mission_result()->mission_update_counter != _mission.mission_update_counter)\n-\t    || (_navigator->get_mission_result()->geofence_update_counter != _mission.geofence_update_counter)\n+\tif ((_navigator->get_mission_result()->mission_id != _mission.mission_id)\n+\t    || (_navigator->get_mission_result()->geofence_id != _mission.geofence_id)\n \t    || (_navigator->get_mission_result()->home_position_counter != _navigator->get_home_position()->update_count)) {\n \n-\t\t_navigator->get_mission_result()->mission_update_counter = _mission.mission_update_counter;\n-\t\t_navigator->get_mission_result()->geofence_update_counter = _mission.geofence_update_counter;\n+\t\t_navigator->get_mission_result()->mission_id = _mission.mission_id;\n+\t\t_navigator->get_mission_result()->geofence_id = _mission.geofence_id;\n \t\t_navigator->get_mission_result()->home_position_counter = _navigator->get_home_position()->update_count;\n \n \t\tMissionFeasibilityChecker missionFeasibilityChecker(_navigator, _dataman_client);\n@@ -1153,7 +1153,7 @@ void MissionBase::resetMission()\n \tnew_mission.land_start_index = -1;\n \tnew_mission.land_index = -1;\n \tnew_mission.count = 0u;\n-\tnew_mission.mission_update_counter = _mission.mission_update_counter + 1;\n+\tnew_mission.mission_id = 0u;\n \tnew_mission.dataman_id = _mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ? DM_KEY_WAYPOINTS_OFFBOARD_1 :\n \t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_0;\n \n@@ -1355,8 +1355,8 @@ void MissionBase::checkClimbRequired(int32_t mission_item_index)\n \n bool MissionBase::checkMissionDataChanged(mission_s new_mission)\n {\n-\t/* count and land_index are the same if the mission_counter did not change. We do not care about changes in geofence or rally counters.*/\n+\t/* count and land_index are the same if the mission_id did not change. We do not care about changes in geofence or rally counters.*/\n \treturn ((new_mission.dataman_id != _mission.dataman_id) ||\n-\t\t(new_mission.mission_update_counter != _mission.mission_update_counter) ||\n+\t\t(new_mission.mission_id != _mission.mission_id) ||\n \t\t(new_mission.current_seq != _mission.current_seq));\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 14,
        "deletions": 1,
        "changes": 15,
        "patch": "@@ -203,8 +203,9 @@ struct mission_item_s {\n  * Corresponds to the first dataman entry of DM_KEY_FENCE_POINTS and DM_KEY_SAFE_POINTS\n  */\n struct mission_stats_entry_s {\n+\tuint32_t opaque_id;\t\t\t/**< opaque identifier for current stored mission stats */\n \tuint16_t num_items;\t\t\t/**< total number of items stored (excluding this one) */\n-\tuint16_t update_counter;\t\t\t/**< This counter is increased when (some) items change (this can wrap) */\n+\tuint8_t padding[2];\n };\n \n /**\n@@ -239,6 +240,18 @@ struct DestinationPosition {\n \tfloat yaw;\t/**< final yaw when landed [rad].*/\n };\n \n+\n+/**\n+ * Crc32 mission item struct.\n+ * Used to pack relevant mission item ifnromation for us in crc32 mission calculation.\n+ */\n+typedef struct __attribute__((packed)) CrcMissionItem {\n+\tuint8_t frame;\n+\tuint16_t command;\n+\tuint8_t autocontinue;\n+\tfloat params[7];\n+} CrcMissionItem_t;\n+\n #if (__GNUC__ >= 5) || __clang__\n #pragma GCC diagnostic pop\n #endif // GCC >= 5 || Clang",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -249,7 +249,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \torb_advert_t *get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n-\tint mission_instance_count() const { return _mission_result.mission_update_counter; }\n+\tint mission_instance_count() const { return _mission_result.mission_id; }\n \n \tvoid set_mission_failure_heading_timeout();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -171,8 +171,8 @@ void Navigator::run()\n \tfds[2].fd = _mission_sub;\n \tfds[2].events = POLLIN;\n \n-\tuint16_t geofence_update_counter{0};\n-\tuint16_t safe_points_update_counter{0};\n+\tuint32_t geofence_id{0};\n+\tuint32_t safe_points_id{0};\n \n \t/* rate-limit position subscription to 20 Hz / 50 ms */\n \torb_set_interval(_local_pos_sub, 50);\n@@ -201,13 +201,13 @@ void Navigator::run()\n \t\t\tmission_s mission;\n \t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n \n-\t\t\tif (mission.geofence_update_counter != geofence_update_counter) {\n-\t\t\t\tgeofence_update_counter = mission.geofence_update_counter;\n+\t\t\tif (mission.geofence_id != geofence_id) {\n+\t\t\t\tgeofence_id = mission.geofence_id;\n \t\t\t\t_geofence.updateFence();\n \t\t\t}\n \n-\t\t\tif (mission.safe_points_update_counter != safe_points_update_counter) {\n-\t\t\t\tsafe_points_update_counter = mission.safe_points_update_counter;\n+\t\t\tif (mission.safe_points_id != safe_points_id) {\n+\t\t\t\tsafe_points_id = mission.safe_points_id;\n \t\t\t\t_rtl.updateSafePoints();\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -99,9 +99,9 @@ void RTL::updateDatamanCache()\n \t\t\t\t_error_state = DatamanState::ReadWait;\n \t\t\t\t_dataman_state = DatamanState::Error;\n \n-\t\t\t} else if (_update_counter != _stats.update_counter) {\n+\t\t\t} else if (_opaque_id != _stats.opaque_id) {\n \n-\t\t\t\t_update_counter = _stats.update_counter;\n+\t\t\t\t_opaque_id = _stats.opaque_id;\n \t\t\t\t_safe_points_updated = false;\n \n \t\t\t\t_dataman_cache_safepoint.invalidate();\n@@ -144,8 +144,8 @@ void RTL::updateDatamanCache()\n \n \t}\n \n-\tif (_mission_counter != _mission_sub.get().mission_update_counter) {\n-\t\t_mission_counter = _mission_sub.get().mission_update_counter;\n+\tif (_mission_id != _mission_sub.get().mission_id) {\n+\t\t_mission_id = _mission_sub.get().mission_id;\n \t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().dataman_id);\n \t\t_dataman_cache_landItem.invalidate();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -190,13 +190,13 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tDatamanState _dataman_state{DatamanState::UpdateRequestWait};\n \tDatamanState _error_state{DatamanState::UpdateRequestWait};\n-\tuint16_t _update_counter{0}; ///< dataman update counter: if it does not match, safe points data was updated\n+\tuint32_t _opaque_id{0}; ///< dataman safepoint id: if it does not match, safe points data was updated\n \tbool _safe_points_updated{false}; ///< flag indicating if safe points are updated to dataman cache\n \tmutable DatamanCache _dataman_cache_safepoint{\"rtl_dm_cache_miss_geo\", 4};\n \tDatamanClient\t&_dataman_client_safepoint = _dataman_cache_safepoint.client();\n \tbool _initiate_safe_points_updated{true}; ///< flag indicating if safe points update is needed\n \tmutable DatamanCache _dataman_cache_landItem{\"rtl_dm_cache_miss_land\", 2};\n-\tint16_t _mission_counter = -1;\n+\tuint32_t _mission_id = 0u;\n \n \tmission_stats_entry_s _stats;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/096098bb727e0b79797391b95c163cb47c168c6e/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::updateMavlinkMission",
        "Mission::save_mission_state",
        "Geofence::run",
        "MissionBase::checkMissionRestart",
        "Navigator::run",
        "RTL::updateDatamanCache",
        "MissionBase::checkClimbRequired",
        "MissionBase::resetMission",
        "mission_instance_count",
        "Geofence::loadFromFile"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::loadFromFile",
          "Geofence::run"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::save_mission_state"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::checkClimbRequired",
          "MissionBase::checkMissionRestart",
          "MissionBase::updateMavlinkMission",
          "MissionBase::resetMission"
        ],
        "src/modules/navigator/navigator.h": [
          "mission_instance_count"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::updateDatamanCache"
        ]
      }
    }
  },
  {
    "title": "geofence: fix altitude change fence check",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21806",
    "number": 21806,
    "created_at": "2023-07-05T14:11:45Z",
    "merged": true,
    "merged_at": "2023-07-07T02:39:40Z",
    "state": "closed",
    "conversation": {
      "author": "bresch",
      "body": "\r\n\r\n<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen asking for an altitude change only, the lat/lon is NAN and that makes the geofence check pass regardless of the change in altitude, allowing the drone to climb above the fence.\r\n\r\n### Solution\r\nSet the lat/lon to the current position if NAN\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFix geofence when changing altitude through reposition.\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\nSITL tests\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes incorrect handling of NaN latitude/longitude which caused the geofence check to be bypassed for altitude-only reposition requests, allowing unintended climbs beyond the fence. Replacing NaNs with the current position corrects the conditional/state handling and prevents the incorrect behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "patch": "@@ -257,8 +257,16 @@ void Navigator::run()\n \t\t\t\tbool reposition_valid = true;\n \n \t\t\t\tvehicle_global_position_s position_setpoint{};\n-\t\t\t\tposition_setpoint.lat = cmd.param5;\n-\t\t\t\tposition_setpoint.lon = cmd.param6;\n+\n+\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n+\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n+\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n+\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n+\t\t\t\t}\n+\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n \n \t\t\t\tif (have_geofence_position_data) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8595bbf6576c27302bd661bd35d844e70ce55c34/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Navigator: Loiter: always establish new Loiter with center at currentâ€¦",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/21798",
    "number": 21798,
    "created_at": "2023-07-04T08:06:08Z",
    "merged": true,
    "merged_at": "2023-07-04T15:03:14Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Port of https://github.com/PX4/PX4-Autopilot/pull/21775 to 1.14",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title indicates a behavioral change to always establish a new Loiter with its center at the current position, which suggests it corrects incorrect state initialization or transition (loiter center being stale or set incorrectly). Porting the fix to a release branch implies this addresses an unintended/incorrect runtime behavior rather than a syntax or style issue.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "patch": "@@ -61,6 +61,7 @@ Loiter::on_activation()\n \t\treposition();\n \n \t} else {\n+\t\t// this is executed when the flight mode is switched to Hold manually, not through a reposition\n \t\tset_loiter_position();\n \t}\n \n@@ -109,16 +110,11 @@ Loiter::set_loiter_position()\n \t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n \n \t} else {\n-\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n-\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n \n \t\t} else {\n-\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n-\n-\t\t\t} else {\n-\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n-\t\t\t}\n+\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n \t\t}\n \n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fcc78b93c3b0a2b1e7f8f7da314bad4329a7362a/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::set_loiter_position",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::set_loiter_position",
          "Loiter::on_activation"
        ]
      }
    }
  },
  {
    "title": "Double storage for rally points and geofence",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22533",
    "number": 22533,
    "created_at": "2023-12-13T13:50:03Z",
    "merged": true,
    "merged_at": "2024-01-30T16:25:37Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nIf there is an error during uploading of the rally points or geofence, the old fence points get overwritten and are not accessible anymore.\r\n\r\n### Solution\r\n- Extend dataman to have double storage for rally points and geofence the same way as is already done for missions\r\n- On upload write the uploaded points t othe inactive slot and switch at the end when upload was successful.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Enable double storage slots for rally points and geofence\r\n```\r\n\r\n### Test coverage\r\n- Tested in SITL while observing the mission topic when uploading rally points and missions.\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2023-12-14T01:31:39Z",
          "body": "What's the memory cost?",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-12-14T14:41:16Z",
          "body": "@dagar I tested on the fmu_v5x with SYS_AUTOSTART 1100 in SIH:\r\nWhen using the SDCard:\r\nmain:\r\n![Screenshot from 2023-12-14 10-40-24](https://github.com/PX4/PX4-Autopilot/assets/98741601/2355db04-bfd0-42c1-bd70-eae9986f22c8)\r\nPR:\r\n![Screenshot from 2023-12-14 15-20-01](https://github.com/PX4/PX4-Autopilot/assets/98741601/ec3c4da8-c492-43d4-a95a-501e07f1910d)\r\n\r\nWhen writing mission on RAM:\r\nmain:\r\n![Screenshot from 2023-12-14 15-33-26](https://github.com/PX4/PX4-Autopilot/assets/98741601/ec337a76-8ff1-447d-a0c9-b03fd07f445b)\r\n\r\n\r\nPR:\r\n![Screenshot from 2023-12-14 15-26-16](https://github.com/PX4/PX4-Autopilot/assets/98741601/a52f8aa6-2be2-41a9-9ff8-25d1cc1aec0f)\r\n\r\nSo around 200 Bytes for SD Card, an around 4.5 KBytes when mission is in RAM. Do you think this is an issue?\r\n",
          "type": "issue_comment"
        },
        {
          "author": "mcsauder",
          "created_at": "2023-12-14T14:44:19Z",
          "body": "The memory cost goes up with each point on the polygon, correct? Factor of N?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2023-12-14T15:40:54Z",
          "body": "> Do you think this is an issue?\r\n\r\nNope, just wanted to make sure we're keeping an eye on it (memory is very tight on older STM32F4 boards).",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-12-18T07:50:55Z",
          "body": "> The memory cost goes up with each point on the polygon, correct? Factor of N?\r\n\r\nSorry for the late reply @mcsauder depends on what you mean. For the mission in RAM the memory for the maximum mission/geofence/rally points is already reserved, so there wont be any additional memory cost there (and that is the reason for the difference between this PR and main, since we need to reserve double the storage in memory for geofence and rally points). When the mission is written on the SDcard, the dataman module does not need more memory depending on the mission. The only thing that is taking currently more memory when you upload bigger geofences and rally points is that the geofence and RTL mode cache all the points in memory (mission only caches the next 10 points irrespecitve of length). But that is the same both for the PR and main. So the memory difference is still the same.",
          "type": "issue_comment"
        },
        {
          "author": "mcsauder",
          "created_at": "2023-12-18T08:17:32Z",
          "body": "That makes sense to me. Are you able to demonstrate that a high degree polynomial geofence doesn't create a RAM problem? I haven't tried lately, but that was an issue I ran into.\r\n\r\n-Mark",
          "type": "issue_comment"
        },
        {
          "author": "mcsauder",
          "created_at": "2023-12-18T08:20:11Z",
          "body": "Sorry. NM, you've already addressed that.",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-12-18T08:25:45Z",
          "body": "> That makes sense to me. Are you able to demonstrate that a high degree polynomial geofence doesn't create a RAM problem? I haven't tried lately, but that was an issue I ran into.\r\n> \r\n> -Mark\r\n\r\nWell not completely but it is hard to check for all the different hardware and configs (the v5x i am testing on has still some margins at least for MC). That's why i checked the relative RAM difference but i do not know how close we already are for the other hardware and configs. ",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-23T08:14:56Z",
          "body": "rebased on main",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "Looks good, I did not spot anything.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: previously uploads overwrote the active rally/geofence storage before the upload completed, causing loss of the previous valid state on upload failure. The change implements double-buffering (write to inactive slot and switch only on successful completion), which corrects the improper state transition/data-loss behavior.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 23,
        "changes": 50,
        "patch": "@@ -108,7 +108,7 @@ void Geofence::run()\n \tcase DatamanState::Read:\n \n \t\t_dataman_state = DatamanState::ReadWait;\n-\t\tsuccess = _dataman_client.readAsync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n+\t\tsuccess = _dataman_client.readAsync(DM_KEY_FENCE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&_stats),\n \t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n \n \t\tif (!success) {\n@@ -139,8 +139,8 @@ void Geofence::run()\n \t\t\t\t\t_dataman_cache.resize(_stats.num_items);\n \t\t\t\t}\n \n-\t\t\t\tfor (int index = 1; index <= _dataman_cache.size(); ++index) {\n-\t\t\t\t\t_dataman_cache.load(DM_KEY_FENCE_POINTS, index);\n+\t\t\t\tfor (int index = 0; index < _dataman_cache.size(); ++index) {\n+\t\t\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_stats.dataman_id), index);\n \t\t\t\t}\n \n \t\t\t\t_dataman_state = DatamanState::Load;\n@@ -187,11 +187,11 @@ void Geofence::_updateFence()\n \n \t// iterate over all polygons and store their starting vertices\n \t_num_polygons = 0;\n-\tint current_seq = 1;\n+\tint current_seq = 0;\n \n-\twhile (current_seq <= _dataman_cache.size()) {\n+\twhile (current_seq < _dataman_cache.size()) {\n \n-\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, current_seq,\n+\t\tbool success = _dataman_cache.loadWait(static_cast<dm_item_t>(_stats.dataman_id), current_seq,\n \t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n \t\t\t\t\t\t       sizeof(mission_fence_point_s));\n \n@@ -412,14 +412,15 @@ bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon,\n \n \tfor (unsigned i = 0, j = polygon.vertex_count - 1; i < polygon.vertex_count; j = i++) {\n \n-\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index + i,\n+\t\tdm_item_t fence_dataman_id{static_cast<dm_item_t>(_stats.dataman_id)};\n+\t\tbool success = _dataman_cache.loadWait(fence_dataman_id, polygon.dataman_index + i,\n \t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&temp_vertex_i), sizeof(mission_fence_point_s));\n \n \t\tif (!success) {\n \t\t\tbreak;\n \t\t}\n \n-\t\tsuccess = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index + j,\n+\t\tsuccess = _dataman_cache.loadWait(fence_dataman_id, polygon.dataman_index + j,\n \t\t\t\t\t\t  reinterpret_cast<uint8_t *>(&temp_vertex_j), sizeof(mission_fence_point_s));\n \n \t\tif (!success) {\n@@ -448,7 +449,7 @@ bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon,\n {\n \n \tmission_fence_point_s circle_point{};\n-\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index,\n+\tbool success = _dataman_cache.loadWait(static_cast<dm_item_t>(_stats.dataman_id), polygon.dataman_index,\n \t\t\t\t\t       reinterpret_cast<uint8_t *>(&circle_point), sizeof(mission_fence_point_s));\n \n \tif (!success) {\n@@ -491,8 +492,18 @@ Geofence::loadFromFile(const char *filename)\n \tconst char commentChar = '#';\n \tint ret_val = PX4_ERROR;\n \n-\t/* Make sure no data is left in the datamanager */\n-\tclearDm();\n+\tmission_stats_entry_s stat;\n+\t{\n+\t\tconst bool success = _dataman_client.readAsync(DM_KEY_FENCE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&stat),\n+\t\t\t\t     sizeof(mission_stats_entry_s));\n+\n+\t\tif (!success) {\n+\t\t\tPX4_ERR(\"Could not read fence dataman state\");\n+\t\t\treturn PX4_ERROR;\n+\t\t}\n+\t}\n+\n+\tdm_item_t write_fence_dataman_id{static_cast<dm_item_t>(stat.dataman_id) == DM_KEY_FENCE_POINTS_0 ? DM_KEY_FENCE_POINTS_1 : DM_KEY_FENCE_POINTS_0};\n \n \t/* open the mixer definition file */\n \tfp = fopen(GEOFENCE_FILENAME, \"r\");\n@@ -554,7 +565,7 @@ Geofence::loadFromFile(const char *filename)\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, pointCounter + 1, reinterpret_cast<uint8_t *>(&vertex),\n+\t\t\tbool success = _dataman_client.writeSync(write_fence_dataman_id, pointCounter, reinterpret_cast<uint8_t *>(&vertex),\n \t\t\t\t\tsizeof(vertex));\n \n \t\t\tif (!success) {\n@@ -585,16 +596,16 @@ Geofence::loadFromFile(const char *filename)\n \t\tuint32_t crc32{0U};\n \n \t\t/* do a second pass, now that we know the number of vertices */\n-\t\tfor (int seq = 1; seq <= pointCounter; ++seq) {\n+\t\tfor (int seq = 0; seq < pointCounter; ++seq) {\n \t\t\tmission_fence_point_s mission_fence_point;\n \n-\t\t\tbool success = _dataman_client.readSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n+\t\t\tbool success = _dataman_client.readSync(write_fence_dataman_id, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n \t\t\t\t\t\t\t\tsizeof(mission_fence_point_s));\n \n \t\t\tif (success) {\n \t\t\t\tmission_fence_point.vertex_count = pointCounter;\n \t\t\t\tcrc32 = crc32_for_fence_point(mission_fence_point, crc32);\n-\t\t\t\t_dataman_client.writeSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n+\t\t\t\t_dataman_client.writeSync(write_fence_dataman_id, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n \t\t\t\t\t\t\t  sizeof(mission_fence_point_s));\n \t\t\t}\n \t\t}\n@@ -603,7 +614,7 @@ Geofence::loadFromFile(const char *filename)\n \t\tstats.num_items = pointCounter;\n \t\tstats.opaque_id = crc32;\n \n-\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&stats),\n+\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&stats),\n \t\t\t\tsizeof(mission_stats_entry_s));\n \n \t\tif (success) {\n@@ -622,13 +633,6 @@ Geofence::loadFromFile(const char *filename)\n \treturn ret_val;\n }\n \n-int Geofence::clearDm()\n-{\n-\t_dataman_client.clearSync(DM_KEY_FENCE_POINTS);\n-\tupdateFence();\n-\treturn PX4_OK;\n-}\n-\n bool Geofence::isHomeRequired()\n {\n \tbool max_horizontal_enabled = (_param_gf_max_hor_dist.get() > FLT_EPSILON);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -108,8 +108,6 @@ class Geofence : public ModuleParams\n \n \tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n \n-\tint clearDm();\n-\n \tbool valid();\n \n \t/**",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -192,11 +192,11 @@ void Mission::setActiveMissionItems()\n \tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n \n \tmission_item_s next_mission_items[max_num_next_items];\n-\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \n \tfor (size_t i = 0U; i < num_found_items; i++) {\n \t\tmission_item_s next_mission_item;\n-\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_items_index[i],\n+\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_items_index[i],\n \t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n \n \t\tif (success) {\n@@ -459,7 +459,7 @@ Mission::save_mission_state()\n \n \tif (success) {\n \t\t/* data read successfully, check dataman ID and items count */\n-\t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count\n+\t\tif (mission_state.mission_dataman_id == _mission.mission_dataman_id && mission_state.count == _mission.count\n \t\t    && mission_state.mission_id == _mission.mission_id) {\n \t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n \t\t\tif (mission_state.current_seq != _mission.current_seq) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 31,
        "changes": 68,
        "patch": "@@ -96,7 +96,7 @@ MissionBase::updateDatamanCache()\n \n \t\tfor (int32_t index = start_index; index != end_index; index += math::signNoZero(_dataman_cache_size_signed)) {\n \n-\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.dataman_id), index);\n+\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.mission_dataman_id), index);\n \t\t}\n \n \t\t_load_mission_index = _mission.current_seq;\n@@ -111,20 +111,22 @@ void MissionBase::updateMavlinkMission()\n \t\tmission_s new_mission;\n \t\t_mission_sub.update(&new_mission);\n \n-\t\tif (isMissionValid(new_mission)) {\n-\t\t\t/* Relevant mission items updated externally*/\n-\t\t\tif (checkMissionDataChanged(new_mission)) {\n-\t\t\t\tbool mission_items_changed = (new_mission.mission_id != _mission.mission_id);\n+\t\tconst bool mission_items_changed = (new_mission.mission_id != _mission.mission_id);\n+\t\tconst bool mission_data_changed = checkMissionDataChanged(new_mission);\n \n-\t\t\t\tif (new_mission.current_seq < 0) {\n-\t\t\t\t\tnew_mission.current_seq = math::max(math::min(_mission.current_seq, static_cast<int32_t>(new_mission.count) - 1),\n-\t\t\t\t\t\t\t\t\t    INT32_C(0));\n-\t\t\t\t}\n+\t\tif (new_mission.current_seq < 0) {\n+\t\t\tnew_mission.current_seq = math::max(math::min(_mission.current_seq, static_cast<int32_t>(new_mission.count) - 1),\n+\t\t\t\t\t\t\t    INT32_C(0));\n+\t\t}\n \n-\t\t\t\t_mission = new_mission;\n+\t\t_mission = new_mission;\n \n-\t\t\t\tonMissionUpdate(mission_items_changed);\n-\t\t\t}\n+\t\t_is_current_planned_mission_item_valid = isMissionValid(_mission);\n+\n+\t\t/* Relevant mission items updated externally*/\n+\t\tif (mission_data_changed) {\n+\n+\t\t\tonMissionUpdate(mission_items_changed);\n \t\t}\n \t}\n }\n@@ -274,8 +276,8 @@ MissionBase::on_active()\n \n \t\tif (num_found_items == 1U && !PX4_ISFINITE(_mission_item.yaw)) {\n \t\t\tmission_item_s next_position_mission_item;\n-\t\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n-\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index,\n+\t\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n+\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_item_index,\n \t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_position_mission_item), sizeof(next_position_mission_item), MAX_DATAMAN_LOAD_WAIT);\n \n \t\t\tif (success) {\n@@ -460,7 +462,7 @@ MissionBase::set_mission_items()\n \n void MissionBase::loadCurrentMissionItem()\n {\n-\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission.dataman_id);\n+\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \tbool success = _dataman_cache.loadWait(dm_item, _mission.current_seq, reinterpret_cast<uint8_t *>(&_mission_item),\n \t\t\t\t\t       sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n \n@@ -833,7 +835,7 @@ MissionBase::do_abort_landing()\n \n \t} else {\n \t\t// move mission index back (landing approach point)\n-\t\t_is_current_planned_mission_item_valid = goToPreviousItem(false);\n+\t\t_is_current_planned_mission_item_valid = (goToPreviousItem(false) == PX4_OK);\n \t}\n \n \t// send reposition cmd to get out of mission\n@@ -884,7 +886,8 @@ bool MissionBase::isMissionValid(mission_s &mission) const\n \tbool ret_val{false};\n \n \tif (((mission.current_seq < mission.count) || (mission.count == 0U && mission.current_seq <= 0)) &&\n-\t    (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) &&\n+\t    (mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0\n+\t     || mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) &&\n \t    (mission.timestamp != 0u)) {\n \t\tret_val = true;\n \n@@ -900,13 +903,13 @@ int MissionBase::getNonJumpItem(int32_t &mission_index, mission_item_s &mission,\n \t\treturn PX4_ERROR;\n \t}\n \n-\tconst dm_item_t dataman_id = (dm_item_t)_mission.dataman_id;\n+\tconst dm_item_t mission_dataman_id = (dm_item_t)_mission.mission_dataman_id;\n \tint32_t new_mission_index{mission_index};\n \tmission_item_s new_mission;\n \n \tfor (uint16_t jump_count = 0u; jump_count < MAX_JUMP_ITERATION; jump_count++) {\n \t\t/* read mission item from datamanager */\n-\t\tbool success = _dataman_cache.loadWait(dataman_id, new_mission_index, reinterpret_cast<uint8_t *>(&new_mission),\n+\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, new_mission_index, reinterpret_cast<uint8_t *>(&new_mission),\n \t\t\t\t\t\t       sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n \n \t\tif (!success) {\n@@ -926,7 +929,7 @@ int MissionBase::getNonJumpItem(int32_t &mission_index, mission_item_s &mission,\n \t\t\tif ((new_mission.do_jump_current_count < new_mission.do_jump_repeat_count) && execute_jump) {\n \t\t\t\tif (write_jumps) {\n \t\t\t\t\tnew_mission.do_jump_current_count++;\n-\t\t\t\t\tsuccess = _dataman_cache.writeWait(dataman_id, new_mission_index, reinterpret_cast<uint8_t *>(&new_mission),\n+\t\t\t\t\tsuccess = _dataman_cache.writeWait(mission_dataman_id, new_mission_index, reinterpret_cast<uint8_t *>(&new_mission),\n \t\t\t\t\t\t\t\t\t   sizeof(struct mission_item_s));\n \n \t\t\t\t\tif (!success) {\n@@ -1099,12 +1102,12 @@ int MissionBase::setMissionToClosestItem(double lat, double lon, float alt, floa\n {\n \tint32_t min_dist_index(-1);\n \tfloat min_dist(FLT_MAX), dist_xy(FLT_MAX), dist_z(FLT_MAX);\n-\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \n \tfor (int32_t mission_item_index = 0; mission_item_index < _mission.count; mission_item_index++) {\n \t\tmission_item_s mission;\n \n-\t\tbool success = _dataman_cache.loadWait(dataman_id, mission_item_index, reinterpret_cast<uint8_t *>(&mission),\n+\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, mission_item_index, reinterpret_cast<uint8_t *>(&mission),\n \t\t\t\t\t\t       sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n \n \t\tif (!success) {\n@@ -1155,8 +1158,9 @@ void MissionBase::resetMission()\n \tnew_mission.land_index = -1;\n \tnew_mission.count = 0u;\n \tnew_mission.mission_id = 0u;\n-\tnew_mission.dataman_id = _mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ? DM_KEY_WAYPOINTS_OFFBOARD_1 :\n-\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_0;\n+\tnew_mission.mission_dataman_id = _mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ?\n+\t\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_1 :\n+\t\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_0;\n \n \tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&new_mission),\n \t\t\tsizeof(mission_s));\n@@ -1172,12 +1176,12 @@ void MissionBase::resetMission()\n \n void MissionBase::resetMissionJumpCounter()\n {\n-\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \n \tfor (size_t mission_index = 0u; mission_index < _mission.count; mission_index++) {\n \t\tmission_item_s mission_item;\n \n-\t\tbool success = _dataman_client.readSync(dataman_id, mission_index, reinterpret_cast<uint8_t *>(&mission_item),\n+\t\tbool success = _dataman_client.readSync(mission_dataman_id, mission_index, reinterpret_cast<uint8_t *>(&mission_item),\n \t\t\t\t\t\t\tsizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n \n \t\tif (!success) {\n@@ -1191,7 +1195,8 @@ void MissionBase::resetMissionJumpCounter()\n \t\tif (mission_item.nav_cmd == NAV_CMD_DO_JUMP) {\n \t\t\tmission_item.do_jump_current_count = 0u;\n \n-\t\t\tbool write_success = _dataman_cache.writeWait(dataman_id, mission_index, reinterpret_cast<uint8_t *>(&mission_item),\n+\t\t\tbool write_success = _dataman_cache.writeWait(mission_dataman_id, mission_index,\n+\t\t\t\t\t     reinterpret_cast<uint8_t *>(&mission_item),\n \t\t\t\t\t     sizeof(struct mission_item_s));\n \n \t\t\tif (!write_success) {\n@@ -1300,7 +1305,7 @@ void MissionBase::updateCachedItemsUpToIndex(const int end_index)\n {\n \tfor (int i = 0; i <= end_index; i++) {\n \t\tmission_item_s mission_item;\n-\t\tconst dm_item_t dm_current = (dm_item_t)_mission.dataman_id;\n+\t\tconst dm_item_t dm_current = (dm_item_t)_mission.mission_dataman_id;\n \t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&mission_item),\n \t\t\t\t\t\t\tsizeof(mission_item), 500_ms);\n \n@@ -1330,11 +1335,12 @@ void MissionBase::checkClimbRequired(int32_t mission_item_index)\n \n \tif (num_found_items > 0U) {\n \n-\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \t\tmission_item_s mission;\n \t\t_mission_init_climb_altitude_amsl = NAN; // default to NAN, overwrite below if applicable\n \n-\t\tconst bool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index, reinterpret_cast<uint8_t *>(&mission),\n+\t\tconst bool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_item_index,\n+\t\t\t\t     reinterpret_cast<uint8_t *>(&mission),\n \t\t\t\t     sizeof(mission), MAX_DATAMAN_LOAD_WAIT);\n \n \t\tconst bool is_fw_and_takeoff = mission.nav_cmd == NAV_CMD_TAKEOFF\n@@ -1357,7 +1363,7 @@ void MissionBase::checkClimbRequired(int32_t mission_item_index)\n bool MissionBase::checkMissionDataChanged(mission_s new_mission)\n {\n \t/* count and land_index are the same if the mission_id did not change. We do not care about changes in geofence or rally counters.*/\n-\treturn ((new_mission.dataman_id != _mission.dataman_id) ||\n+\treturn ((new_mission.mission_dataman_id != _mission.mission_dataman_id) ||\n \t\t(new_mission.mission_id != _mission.mission_id) ||\n \t\t(new_mission.current_seq != _mission.current_seq));\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -79,7 +79,8 @@ MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission)\n \tfor (size_t i = 0; i < mission.count; i++) {\n \t\tstruct mission_item_s missionitem = {};\n \n-\t\tbool success = _dataman_client.readSync((dm_item_t)mission.dataman_id, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\tbool success = _dataman_client.readSync((dm_item_t)mission.mission_dataman_id, i,\n+\t\t\t\t\t\t\treinterpret_cast<uint8_t *>(&missionitem),\n \t\t\t\t\t\t\tsizeof(mission_item_s));\n \n \t\tif (!success) {\n@@ -119,7 +120,8 @@ MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission,\n \t\tfor (size_t i = 0; i < mission.count; i++) {\n \t\t\tstruct mission_item_s missionitem = {};\n \n-\t\t\tbool success = _dataman_client.readSync((dm_item_t)mission.dataman_id, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\t\tbool success = _dataman_client.readSync((dm_item_t)mission.mission_dataman_id, i,\n+\t\t\t\t\t\t\t\treinterpret_cast<uint8_t *>(&missionitem),\n \t\t\t\t\t\t\t\tsizeof(mission_item_s));\n \n \t\t\tif (!success) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "patch": "@@ -200,17 +200,18 @@ struct mission_item_s {\n \n /**\n  * dataman housekeeping information for a specific item.\n- * Corresponds to the first dataman entry of DM_KEY_FENCE_POINTS and DM_KEY_SAFE_POINTS\n+ * Corresponds to the dataman entry of DM_KEY_FENCE_POINTS_STATE and DM_KEY_SAFE_POINTS_STATE\n  */\n struct mission_stats_entry_s {\n \tuint32_t opaque_id;\t\t\t/**< opaque identifier for current stored mission stats */\n \tuint16_t num_items;\t\t\t/**< total number of items stored (excluding this one) */\n-\tuint8_t padding[2];\n+\tuint8_t dataman_id;\t\t\t/**< dm_item_t storage place*/\n+\tuint8_t padding[1];\n };\n \n /**\n  * Geofence vertex point.\n- * Corresponds to the DM_KEY_FENCE_POINTS dataman item\n+ * Corresponds to the DM_KEY_FENCE_POINTS_0 dataman item\n  */\n struct mission_fence_point_s {\n \tdouble lat;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "patch": "@@ -79,7 +79,7 @@ void RTL::updateDatamanCache()\n \tcase DatamanState::Read:\n \n \t\t_dataman_state\t= DatamanState::ReadWait;\n-\t\tsuccess = _dataman_client_safepoint.readAsync(DM_KEY_SAFE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n+\t\tsuccess = _dataman_client_safepoint.readAsync(DM_KEY_SAFE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&_stats),\n \t\t\t\tsizeof(mission_stats_entry_s));\n \n \t\tif (!success) {\n@@ -110,8 +110,8 @@ void RTL::updateDatamanCache()\n \t\t\t\t\t_dataman_cache_safepoint.resize(_stats.num_items);\n \t\t\t\t}\n \n-\t\t\t\tfor (int index = 1; index <= _dataman_cache_safepoint.size(); ++index) {\n-\t\t\t\t\t_dataman_cache_safepoint.load(DM_KEY_SAFE_POINTS, index);\n+\t\t\t\tfor (int index = 0; index < _dataman_cache_safepoint.size(); ++index) {\n+\t\t\t\t\t_dataman_cache_safepoint.load(static_cast<dm_item_t>(_stats.dataman_id), index);\n \t\t\t\t}\n \n \t\t\t\t_dataman_state = DatamanState::Load;\n@@ -146,7 +146,7 @@ void RTL::updateDatamanCache()\n \n \tif (_mission_id != _mission_sub.get().mission_id) {\n \t\t_mission_id = _mission_sub.get().mission_id;\n-\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().dataman_id);\n+\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().mission_dataman_id);\n \t\t_dataman_cache_landItem.invalidate();\n \n \t\tif (_mission_sub.get().land_index > 0) {\n@@ -365,7 +365,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosit\n \tif (((_param_rtl_type.get() == 1) || (_param_rtl_type.get() == 3) || (fabsf(FLT_MAX - min_dist) < FLT_EPSILON))\n \t    && hasMissionLandStart()) {\n \t\tmission_item_s land_mission_item;\n-\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().dataman_id);\n+\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().mission_dataman_id);\n \t\tbool success = _dataman_cache_landItem.loadWait(dm_item, _mission_sub.get().land_index,\n \t\t\t\treinterpret_cast<uint8_t *>(&land_mission_item), sizeof(mission_item_s), 500_ms);\n \n@@ -394,10 +394,10 @@ void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosit\n \n \tif (_safe_points_updated) {\n \n-\t\tfor (int current_seq = 1; current_seq <= _dataman_cache_safepoint.size(); ++current_seq) {\n+\t\tfor (int current_seq = 0; current_seq < _dataman_cache_safepoint.size(); ++current_seq) {\n \t\t\tmission_item_s mission_safe_point;\n \n-\t\t\tbool success = _dataman_cache_safepoint.loadWait(DM_KEY_SAFE_POINTS, current_seq,\n+\t\t\tbool success = _dataman_cache_safepoint.loadWait(static_cast<dm_item_t>(_stats.dataman_id), current_seq,\n \t\t\t\t\treinterpret_cast<uint8_t *>(&mission_safe_point),\n \t\t\t\t\tsizeof(mission_item_s), 500_ms);\n \n@@ -626,10 +626,10 @@ land_approaches_s RTL::readVtolLandApproaches(DestinationPosition rtl_position)\n \tbool foundHomeLandApproaches = false;\n \tuint8_t sector_counter = 0;\n \n-\tfor (int current_seq = 1; current_seq <= _stats.num_items; ++current_seq) {\n+\tfor (int current_seq = 0; current_seq < _stats.num_items; ++current_seq) {\n \t\tmission_item_s mission_item{};\n \n-\t\tbool success_mission_item = _dataman_cache_safepoint.loadWait(DM_KEY_SAFE_POINTS, current_seq,\n+\t\tbool success_mission_item = _dataman_cache_safepoint.loadWait(static_cast<dm_item_t>(_stats.dataman_id), current_seq,\n \t\t\t\t\t    reinterpret_cast<uint8_t *>(&mission_item),\n \t\t\t\t\t    sizeof(mission_item_s));\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -146,11 +146,11 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \t\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n \n \t\tmission_item_s next_mission_items[max_num_next_items];\n-\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \n \t\tfor (size_t i = 0U; i < num_found_items; i++) {\n \t\t\tmission_item_s next_mission_item;\n-\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_items_index[i],\n+\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_items_index[i],\n \t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n \n \t\t\tif (success) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -97,11 +97,11 @@ void RtlMissionFast::setActiveMissionItems()\n \t\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n \n \t\tmission_item_s next_mission_items[max_num_next_items];\n-\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \n \t\tfor (size_t i = 0U; i < num_found_items; i++) {\n \t\t\tmission_item_s next_mission_item;\n-\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_items_index[i],\n+\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_items_index[i],\n \t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n \n \t\t\tif (success) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -120,9 +120,9 @@ void RtlMissionFastReverse::setActiveMissionItems()\n \n \t\tif (num_found_items > 0) {\n \n-\t\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n+\t\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \t\t\tmission_item_s next_mission_item;\n-\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index,\n+\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_item_index,\n \t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n \n \t\t\tif (success) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eae4ce36a146b535f3b286f39daf898d61a5dbe8/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::updateCachedItemsUpToIndex",
        "Mission::save_mission_state",
        "MissionBase::set_mission_items",
        "RTL::updateDatamanCache",
        "MissionBase::checkClimbRequired",
        "Mission::setActiveMissionItems",
        "math::max",
        "MissionBase::updateDatamanCache",
        "MissionFeasibilityChecker::checkMissionAgainstGeofence",
        "Geofence::insideCircle",
        "MissionBase::do_abort_landing",
        "clearDm",
        "MissionBase::on_active",
        "MissionBase::isMissionValid",
        "Geofence::_updateFence",
        "MissionBase::getNonJumpItem",
        "RTL::readVtolLandApproaches",
        "RTL::findRtlDestination",
        "RtlMissionFast::setActiveMissionItems",
        "RtlMissionFastReverse::setActiveMissionItems",
        "MissionBase::updateMavlinkMission",
        "Geofence::clearDm",
        "Geofence::run",
        "MissionFeasibilityChecker::checkMissionFeasible",
        "Geofence::insidePolygon",
        "MissionBase::resetMissionJumpCounter",
        "MissionBase::resetMission",
        "Geofence::loadFromFile",
        "RtlDirectMissionLand::setActiveMissionItems",
        "MissionBase::setMissionToClosestItem"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::clearDm",
          "Geofence::run",
          "Geofence::insidePolygon",
          "Geofence::insideCircle",
          "Geofence::loadFromFile",
          "Geofence::_updateFence"
        ],
        "src/modules/navigator/geofence.h": [
          "clearDm"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::save_mission_state",
          "Mission::setActiveMissionItems"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::updateCachedItemsUpToIndex",
          "MissionBase::updateMavlinkMission",
          "MissionBase::set_mission_items",
          "MissionBase::do_abort_landing",
          "MissionBase::checkClimbRequired",
          "math::max",
          "MissionBase::updateDatamanCache",
          "MissionBase::resetMission",
          "MissionBase::resetMissionJumpCounter",
          "MissionBase::on_active",
          "MissionBase::setMissionToClosestItem",
          "MissionBase::getNonJumpItem",
          "MissionBase::isMissionValid"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionAgainstGeofence",
          "MissionFeasibilityChecker::checkMissionFeasible"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::readVtolLandApproaches",
          "RTL::updateDatamanCache",
          "RTL::findRtlDestination"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast.cpp": [
          "RtlMissionFast::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "Navigator/FlightTaskAuto yaw handling improvements/simplifications",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22532",
    "number": 22532,
    "created_at": "2023-12-13T13:32:42Z",
    "merged": true,
    "merged_at": "2023-12-21T15:50:13Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nFixes https://github.com/PX4/PX4-Autopilot/pull/22413\r\nAlternative to https://github.com/PX4/PX4-Autopilot/pull/22455\r\n\r\nBeside it's also a proposal to make the logic around yaw setpoints in the Navigator vs FlightTasks simpler and cleaner.\r\n\r\n### Solution\r\nStrictly use the following concept: If Navigator publishes a finite yaw setpoint (`position_setpoint_tripplet.current.yaw`), then disable weather vane. This should be used if waypoints have an associated yaw setpoint (eg landings, VTOL transitions or waypoint mission items with the yaw field set). Otherwise leave authority over yaw to the FlightTask - it can then set it e.g. to direction of the next waypoint, to current yaw, or point the vehicle into the wind with the use of weather vane. \r\n\r\nThat allows us to remove the `disable_weather_vane` field from the position_setpoint.\r\n\r\nAdditionally I propose to thin out the position_setpoint topic and remove unnecessary fields: \r\n- `yaw_valid` (yaw is declared valid when `yaw` field is finite) --> we should init the yaw field to NAN ideally\r\n- `yawspeed` (doesn't seem to be used)\r\n- `yawspeed_valid`\r\n\r\nThere's also some other small cleanup proposal, check commits. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: FlightTaskAuto: disable wather vane if position setpoint contains yaw setpoint.\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\nSITL tested for MC and VTOL. \r\nMC test:\r\n- Start the windy gazebo environment: `make px4_sitl gazebo_iris__windy`\r\n- Enable parameter `WV_EN`\r\n- Takeoff and RTL --> on current main it is stuck, doesn't RTL. With the fix here sets the yaw to the home_position.yaw, disables weather vane because the yaw field is finite, aligns yaw and descends. \r\n\r\n\r\n### Context\r\nWe should remove the yaw field of the Takeoff mission item in QGC, it has no effect (already previously to this PR).  Conceptionally I don't see the need of a yaw attribute to a MC takeoff, and wouldn't know what to expect (yaw once takeoff altitude achieved? Or already when climbing?)\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/26798987/971572b0-f998-42fd-9547-192d3e4d8b69)\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-12-14T12:19:13Z",
          "body": "@MaEtUgR addressed your comments and additionally fixed the init of the triplet.yaw to NAN.\r\nThe mission_item should already be correctly initialized through `MissionBlock::initialize()`.",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-12-15T11:52:46Z",
          "body": "Hi @sfuhrer, thanks for taking the time to look at this issue, I just tested it and it solves the problem I was having (#22413). I did have one thought regarding this solution:\r\n\r\nIf weather vane is disabled when a finite yaw setpoint is given, it will always be disabled during RTL, as there is currently always a yaw setpoint given. This may be a problem in the case of an asymetric airframe or a vehicle with a lifting surface, where it may be desirable to point into the direction of the wind the entire time. A parameter to not provide a yaw setpoint (enable weather vane) during RTL might be useful in some use cases. Hope this makes sence.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-15T13:21:19Z",
          "body": "\r\n> If weather vane is disabled when a finite yaw setpoint is given, it will always be disabled during RTL, as there is currently always a yaw setpoint given. \r\n\r\nValid input! I already kicked off the discussion about removing the special yaw handling for RTL, see https://github.com/PX4/PX4-Autopilot/pull/18170#issuecomment-1852019861. Though maybe we should remove it, but instead add a new option for RTL_HDG_MD, \"no yaw setpoint\"? Then the FlightTask would decide on the yaw setpoint, and if WV is enabled it would keep working.\r\n",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-12-18T09:47:10Z",
          "body": "A new \"no yaw setpoint\" option for RTL_HDG_MD  sounds good to me. \r\nAs for removing the current yaw handling, using the home heading for RTL can be useful as its much easier/safer take over control during take off and landing when the vehicle is facing away from you. ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-21T15:54:09Z",
          "body": "> A new \"no yaw setpoint\" option for RTL_HDG_MD sounds good to me.\r\n\r\n@TedObrien could you take over the implementation?",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-12-21T16:29:19Z",
          "body": "@sfuhrer Happy to give it a go, should have some time in the new year.\r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2023-12-13T15:44:13Z",
          "body": "```suggestion\r\nfloat32 yaw\t\t\t# yaw (only in hover), in rad [-PI..PI), NaN = leave to flight task\r\n```",
          "path": "msg/PositionSetpoint.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2023-12-13T15:52:15Z",
          "body": "```suggestion\r\n```\r\n\r\nGot obsolete.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2023-12-13T15:56:09Z",
          "body": "Also remove `yaw = get_local_position()->heading;` from `calculate_breaking_stop()`",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2023-12-13T16:05:04Z",
          "body": "```suggestion\r\n\t\t\t\trep->current.yaw = NAN;\r\n```",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-14T12:17:04Z",
          "body": "done in 7c9aebe0497f504ae8a7afa1c06d0f578bdc70a8",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-14T12:17:35Z",
          "body": "done in 83f23912bf7fa37859b92f28d66100bca756eb93, and made sure it's set to NAN instead in 81e2662fea71d1f95f113de51c8f381472310a05",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-14T12:17:49Z",
          "body": "done in 81e2662fea71d1f95f113de51c8f381472310a05",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "Really nice cleanup. Instead of hardcoding a heading for each waypoint from the current vehicle state (ignoring resets) let the trajectory handle the yaw if there's no specific absolute desired heading ðŸ‘ \r\n\r\nLet's make sure it gets reset to NAN in all those cases otherwise it takes the previous heading.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "Thanks, everything I saw in my review was addressed.\r\nIt's a good step forward allowing to have the controller handle yaw if it's not explicitly set to a certain angle.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect yaw/authority logic that caused unintended behavior (e.g. RTL getting stuck because weather vane and Navigator yaw authority conflicted). It unifies the rule (finite yaw setpoint -> disable weather vane), removes/cleans redundant fields, and initializes yaw to NaN to prevent stale yaw values from producing incorrect control decisions.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 15,
        "changes": 17,
        "patch": "@@ -322,8 +322,7 @@ void Mission::handleTakeoff(WorkItemType &new_work_item_type, mission_item_s nex\n \n \t\t_mission_item.lat = _global_pos_sub.get().lat;\n \t\t_mission_item.lon = _global_pos_sub.get().lon;\n-\t\t/* hold heading for takeoff items */\n-\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n+\t\t_mission_item.yaw = NAN; // FlightTaskAuto handles yaw directly\n \t\t_mission_item.altitude = _mission_init_climb_altitude_amsl;\n \t\t_mission_item.altitude_is_relative = false;\n \t\t_mission_item.autocontinue = true;\n@@ -366,9 +365,6 @@ void Mission::handleTakeoff(WorkItemType &new_work_item_type, mission_item_s nex\n \t    _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n \t    !_land_detected_sub.get().landed) {\n \n-\t\t/* disable weathervane before front transition for allowing yaw to align */\n-\t\tpos_sp_triplet->current.disable_weather_vane = true;\n-\n \t\t/* set yaw setpoint to heading of VTOL_TAKEOFF wp against current position */\n \t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n \t\t\t\t\t    _global_pos_sub.get().lat, _global_pos_sub.get().lon,\n@@ -389,16 +385,13 @@ void Mission::handleTakeoff(WorkItemType &new_work_item_type, mission_item_s nex\n \t    _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n \t    !_land_detected_sub.get().landed) {\n \n-\t\t/* re-enable weather vane again after alignment */\n-\t\tpos_sp_triplet->current.disable_weather_vane = false;\n-\n \t\t/* check if the vtol_takeoff waypoint is on top of us */\n \t\tif (do_need_move_to_takeoff()) {\n \t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n \t\t}\n \n \t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n-\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n+\t\t_mission_item.yaw = NAN;\n \n \t\t// keep current setpoints (FW position controller generates wp to track during transition)\n \t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n@@ -428,9 +421,6 @@ void Mission::handleVtolTransition(WorkItemType &new_work_item_type, mission_ite\n \t    && !_land_detected_sub.get().landed\n \t    && (num_found_items > 0u)) {\n \n-\t\t/* disable weathervane before front transition for allowing yaw to align */\n-\t\tpos_sp_triplet->current.disable_weather_vane = true;\n-\n \t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING;\n \n \t\tset_align_mission_item(&_mission_item, &next_mission_items[0u]);\n@@ -445,9 +435,6 @@ void Mission::handleVtolTransition(WorkItemType &new_work_item_type, mission_ite\n \n \t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n \n-\t\t/* re-enable weather vane again after alignment */\n-\t\tpos_sp_triplet->current.disable_weather_vane = false;\n-\n \t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n \t\t// keep current setpoints (FW position controller generates wp to track during transition)\n \t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 7,
        "changes": 9,
        "patch": "@@ -654,9 +654,6 @@ bool MissionBase::position_setpoint_equal(const position_setpoint_s *p1, const p\n \t\t(fabs(p1->lon - p2->lon) < DBL_EPSILON) &&\n \t\t(fabsf(p1->alt - p2->alt) < FLT_EPSILON) &&\n \t\t((fabsf(p1->yaw - p2->yaw) < FLT_EPSILON) || (!PX4_ISFINITE(p1->yaw) && !PX4_ISFINITE(p2->yaw))) &&\n-\t\t(p1->yaw_valid == p2->yaw_valid) &&\n-\t\t(fabsf(p1->yawspeed - p2->yawspeed) < FLT_EPSILON) &&\n-\t\t(p1->yawspeed_valid == p2->yawspeed_valid) &&\n \t\t(fabsf(p1->loiter_radius - p2->loiter_radius) < FLT_EPSILON) &&\n \t\t(p1->loiter_direction_counter_clockwise == p2->loiter_direction_counter_clockwise) &&\n \t\t(fabsf(p1->acceptance_radius - p2->acceptance_radius) < FLT_EPSILON) &&\n@@ -773,13 +770,11 @@ MissionBase::heading_sp_update()\n \n \t\t\t_mission_item.yaw = yaw;\n \t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\t\t\tpos_sp_triplet->current.yaw_valid = true;\n \n \t\t} else {\n-\t\t\tif (!pos_sp_triplet->current.yaw_valid) {\n-\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n+\t\t\tif (!PX4_ISFINITE(pos_sp_triplet->current.yaw)) {\n+\t\t\t\t_mission_item.yaw = NAN;\n \t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\t\t\t\tpos_sp_triplet->current.yaw_valid = true;\n \t\t\t}\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 22,
        "changes": 34,
        "patch": "@@ -411,7 +411,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n \n \t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n-\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))\n+\t\t    && _navigator->get_yaw_to_be_accepted(_mission_item.yaw)\n \t\t    && _navigator->get_local_position()->heading_good_for_control) {\n \n \t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n@@ -423,14 +423,6 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t_waypoint_yaw_reached = true;\n \t\t\t}\n \n-\t\t\t// Always accept yaw during takeoff\n-\t\t\t// TODO: Ideally Navigator would handle a yaw reset and adjust its yaw setpoint, making the\n-\t\t\t// following no longer necessary.\n-\t\t\t// FlightTaskAuto is currently also ignoring the yaw setpoint during takeoff and thus \"handling\" it.\n-\t\t\tif (_mission_item.nav_cmd == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n-\t\t\t\t_waypoint_yaw_reached = true;\n-\t\t\t}\n-\n \t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n \t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n \t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n@@ -668,7 +660,6 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tsp->lon = item.lon;\n \tsp->alt = get_absolute_altitude_for_item(item);\n \tsp->yaw = item.yaw;\n-\tsp->yaw_valid = PX4_ISFINITE(item.yaw);\n \tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n \t\t\t    _navigator->get_loiter_radius();\n \tsp->loiter_direction_counter_clockwise = item.loiter_radius < 0;\n@@ -704,6 +695,10 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \n \t\t} else {\n \t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n+\n+\t\t\t// Don't set a yaw setpoint for takeoff, as Navigator doesn't handle the yaw reset.\n+\t\t\t// The yaw setpoint generation is handled by FlightTaskAuto.\n+\t\t\tsp->yaw = NAN;\n \t\t}\n \n \t\tbreak;\n@@ -746,6 +741,7 @@ MissionBlock::setLoiterItemFromCurrentPositionSetpoint(struct mission_item_s *it\n \titem->altitude = pos_sp_triplet->current.alt;\n \titem->loiter_radius = pos_sp_triplet->current.loiter_direction_counter_clockwise ?\n \t\t\t      -pos_sp_triplet->current.loiter_radius : pos_sp_triplet->current.loiter_radius;\n+\titem->yaw = pos_sp_triplet->current.yaw;\n }\n \n void\n@@ -765,19 +761,20 @@ MissionBlock::setLoiterItemFromCurrentPosition(struct mission_item_s *item)\n \t}\n \n \titem->altitude = loiter_altitude_amsl;\n-\n \titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->yaw = NAN;\n }\n \n void\n MissionBlock::setLoiterItemFromCurrentPositionWithBreaking(struct mission_item_s *item)\n {\n \tsetLoiterItemCommonFields(item);\n \n-\t_navigator->calculate_breaking_stop(item->lat, item->lon, item->yaw);\n+\t_navigator->calculate_breaking_stop(item->lat, item->lon);\n \n \titem->altitude = _navigator->get_global_position()->alt;\n \titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->yaw = NAN;\n }\n \n void\n@@ -801,7 +798,7 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float abs_altitude)\n \t/* use current position */\n \titem->lat = _navigator->get_global_position()->lat;\n \titem->lon = _navigator->get_global_position()->lon;\n-\titem->yaw = _navigator->get_local_position()->heading;\n+\titem->yaw = NAN;\n \n \titem->altitude = abs_altitude;\n \titem->altitude_is_relative = false;\n@@ -831,7 +828,7 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \t// set land item to current position\n \titem->lat = _navigator->get_global_position()->lat;\n \titem->lon = _navigator->get_global_position()->lon;\n-\titem->yaw = _navigator->get_local_position()->heading;\n+\titem->yaw = NAN;\n \n \titem->altitude = 0;\n \titem->altitude_is_relative = false;\n@@ -863,14 +860,7 @@ MissionBlock::set_vtol_transition_item(struct mission_item_s *item, const uint8_\n {\n \titem->nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n \titem->params[0] = (float) new_mode;\n-\titem->params[1] = 0.0f;\n-\n-\t// Keep yaw from previous mission item if valid, as that is containing the transition heading.\n-\t// If not valid use current yaw as yaw setpoint\n-\tif (!PX4_ISFINITE(item->yaw)) {\n-\t\titem->yaw = _navigator->get_local_position()->heading; // ideally that would be course and not heading\n-\t}\n-\n+\titem->params[1] = 0.0f; // not immediate transition\n \titem->autocontinue = true;\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "patch": "@@ -239,14 +239,13 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvoid set_cruising_throttle(float throttle = NAN) { _mission_throttle = throttle; }\n \n \t/**\n-\t * Get the yaw acceptance given the current mission item\n+\t * Get if the yaw acceptance is required at the current mission item\n \t *\n \t * @param mission_item_yaw the yaw to use in case the controller-derived radius is finite\n \t *\n-\t * @return the yaw at which the next waypoint should be used or NaN if the yaw at a waypoint\n-\t * should be ignored\n+\t * @return true if the yaw acceptance is required, false if not required\n \t */\n-\tfloat get_yaw_acceptance(float mission_item_yaw);\n+\tbool get_yaw_to_be_accepted(float mission_item_yaw);\n \n \torb_advert_t *get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n@@ -279,7 +278,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvoid release_gimbal_control();\n \tvoid set_gimbal_neutral();\n \n-\tvoid calculate_breaking_stop(double &lat, double &lon, float &yaw);\n+\tvoid calculate_breaking_stop(double &lat, double &lon);\n \n \tvoid stop_capturing_images();\n \tvoid disable_camera_trigger();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 22,
        "changes": 36,
        "patch": "@@ -309,11 +309,9 @@ void Navigator::run()\n \t\t\t\t\t// Go on and check which changes had been requested\n \t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n \t\t\t\t\t\trep->current.yaw = cmd.param4;\n-\t\t\t\t\t\trep->current.yaw_valid = true;\n \n \t\t\t\t\t} else {\n \t\t\t\t\t\trep->current.yaw = NAN;\n-\t\t\t\t\t\trep->current.yaw_valid = false;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n@@ -348,8 +346,7 @@ void Navigator::run()\n \t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n \t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n \n-\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n-\t\t\t\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n \n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n@@ -446,7 +443,6 @@ void Navigator::run()\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n \t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n \t\t\t\t\trep->current.yaw = NAN;\n-\t\t\t\t\trep->current.yaw_valid = false;\n \n \t\t\t\t\t// Position is not changing, thus we keep the setpoint\n \t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n@@ -458,8 +454,7 @@ void Navigator::run()\n \t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n \t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n \n-\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n-\t\t\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n@@ -599,19 +594,18 @@ void Navigator::run()\n \t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n \n \t\t\t\tif (home_global_position_valid()) {\n-\t\t\t\t\t// Only set yaw if we know the true heading\n-\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n-\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n-\t\t\t\t\trep->current.yaw = cmd.param4;\n \n \t\t\t\t\trep->previous.valid = true;\n \t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n \n \t\t\t\t} else {\n-\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n \t\t\t\t\trep->previous.valid = false;\n \t\t\t\t}\n \n+\t\t\t\t// Don't set a yaw setpoint for takeoff, as Navigator doesn't handle the yaw reset.\n+\t\t\t\t// The yaw setpoint generation is handled by FlightTaskAuto.\n+\t\t\t\trep->current.yaw = NAN;\n+\n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n \t\t\t\t\trep->current.lat = cmd.param5;\n \t\t\t\t\trep->current.lon = cmd.param6;\n@@ -1039,8 +1033,7 @@ void Navigator::geofence_breach_check()\n \t\t\t\t}\n \n \t\t\t\trep->current.timestamp = hrt_absolute_time();\n-\t\t\t\trep->current.yaw = get_local_position()->heading;\n-\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\trep->current.yaw = NAN;\n \t\t\t\trep->current.lat = loiter_latitude;\n \t\t\t\trep->current.lon = loiter_longitude;\n \t\t\t\trep->current.alt = loiter_altitude_amsl;\n@@ -1157,13 +1150,13 @@ void Navigator::reset_position_setpoint(position_setpoint_s &sp)\n \tsp.timestamp = hrt_absolute_time();\n \tsp.lat = static_cast<double>(NAN);\n \tsp.lon = static_cast<double>(NAN);\n+\tsp.yaw = NAN;\n \tsp.loiter_radius = get_loiter_radius();\n \tsp.acceptance_radius = get_default_acceptance_radius();\n \tsp.cruising_speed = get_cruising_speed();\n \tsp.cruising_throttle = get_cruising_throttle();\n \tsp.valid = false;\n \tsp.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n-\tsp.disable_weather_vane = false;\n \tsp.loiter_direction_counter_clockwise = false;\n }\n \n@@ -1193,7 +1186,7 @@ float Navigator::get_acceptance_radius()\n \treturn acceptance_radius;\n }\n \n-float Navigator::get_yaw_acceptance(float mission_item_yaw)\n+bool Navigator::get_yaw_to_be_accepted(float mission_item_yaw)\n {\n \tfloat yaw = mission_item_yaw;\n \n@@ -1205,7 +1198,7 @@ float Navigator::get_yaw_acceptance(float mission_item_yaw)\n \t\tyaw = pos_ctrl_status.yaw_acceptance;\n \t}\n \n-\treturn yaw;\n+\treturn PX4_ISFINITE(yaw);\n }\n \n void Navigator::load_fence_from_file(const char *filename)\n@@ -1470,21 +1463,20 @@ bool Navigator::geofence_allows_position(const vehicle_global_position_s &pos)\n \treturn true;\n }\n \n-void Navigator::calculate_breaking_stop(double &lat, double &lon, float &yaw)\n+void Navigator::calculate_breaking_stop(double &lat, double &lon)\n {\n \t// For multirotors we need to account for the braking distance, otherwise the vehicle will overshoot and go back\n-\tfloat course_over_ground = atan2f(_local_pos.vy, _local_pos.vx);\n+\tconst float course_over_ground = atan2f(_local_pos.vy, _local_pos.vx);\n \n \t// predict braking distance\n \n \tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n \n-\tfloat multirotor_braking_distance = math::trajectory::computeBrakingDistanceFromVelocity(velocity_hor_abs,\n-\t\t\t\t\t    _param_mpc_jerk_auto, _param_mpc_acc_hor, 0.6f * _param_mpc_jerk_auto);\n+\tconst float multirotor_braking_distance = math::trajectory::computeBrakingDistanceFromVelocity(velocity_hor_abs,\n+\t\t\t_param_mpc_jerk_auto, _param_mpc_acc_hor, 0.6f * _param_mpc_jerk_auto);\n \n \twaypoint_from_heading_and_distance(get_global_position()->lat, get_global_position()->lon, course_over_ground,\n \t\t\t\t\t   multirotor_braking_distance, &lat, &lon);\n-\tyaw = get_local_position()->heading;\n }\n \n void Navigator::mode_completed(uint8_t nav_state, uint8_t result)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -130,7 +130,6 @@ Takeoff::set_takeoff_position()\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \tpos_sp_triplet->previous.valid = false;\n-\tpos_sp_triplet->current.yaw_valid = true;\n \tpos_sp_triplet->next.valid = false;\n \n \tif (rep->current.valid) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -75,7 +75,6 @@ VtolTakeoff::on_active()\n \t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n \t\t\t\t_mission_item.force_heading = true;\n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n-\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n \t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n \t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n \n@@ -182,7 +181,6 @@ VtolTakeoff::set_takeoff_position()\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \tpos_sp_triplet->previous.valid = false;\n-\tpos_sp_triplet->current.yaw_valid = true;\n \tpos_sp_triplet->next.valid = false;\n \n \t_navigator->set_position_setpoint_triplet_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73b5cfe0d6432b3c3030fdfe6727bc7a7dd2f123/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::calculate_breaking_stop",
        "VtolTakeoff::on_active",
        "Mission::handleTakeoff",
        "MissionBlock::set_takeoff_item",
        "Takeoff::set_takeoff_position",
        "MissionBlock::set_land_item",
        "Navigator::get_yaw_acceptance",
        "MissionBlock::set_vtol_transition_item",
        "VtolTakeoff::set_takeoff_position",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::setLoiterItemFromCurrentPositionSetpoint",
        "MissionBlock::setLoiterItemFromCurrentPosition",
        "Navigator::run",
        "MissionBase::heading_sp_update",
        "Navigator::geofence_allows_position",
        "calculate_breaking_stop",
        "Navigator::geofence_breach_check",
        "get_yaw_acceptance",
        "Navigator::reset_position_setpoint",
        "PX4_ISFINITE",
        "MissionBase::position_setpoint_equal",
        "MissionBlock::is_mission_item_reached_or_completed",
        "Navigator::get_acceptance_radius",
        "Mission::handleVtolTransition"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::handleVtolTransition",
          "Mission::handleTakeoff"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::position_setpoint_equal",
          "MissionBase::heading_sp_update"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::setLoiterItemFromCurrentPosition",
          "MissionBlock::set_takeoff_item",
          "MissionBlock::set_land_item",
          "MissionBlock::set_vtol_transition_item",
          "PX4_ISFINITE",
          "MissionBlock::is_mission_item_reached_or_completed",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::setLoiterItemFromCurrentPositionSetpoint"
        ],
        "src/modules/navigator/navigator.h": [
          "calculate_breaking_stop",
          "get_yaw_acceptance"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::calculate_breaking_stop",
          "Navigator::run",
          "Navigator::geofence_allows_position",
          "Navigator::geofence_breach_check",
          "Navigator::reset_position_setpoint",
          "Navigator::get_yaw_acceptance",
          "Navigator::get_acceptance_radius"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::set_takeoff_position"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::set_takeoff_position",
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Add mission point check when update the geofence",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22531",
    "number": 22531,
    "created_at": "2023-12-13T06:41:05Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "Drone-Lab",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\n\r\n1.  https://github.com/PX4/PX4-Autopilot/blob/c5101c70b31aa0c1454162c6ad1420e5af8086b2/src/modules/navigator/mission_feasibility_checker.cpp#L108 I've found that the MissionFeasibilityChecker()  is only triggered correctly when updating a mission.  when only updating a geofence,user need to click upload twice to invoke check function. Currently, the geofence update only checks the origin and the current position associated with the geofence, and I've added a check for mission waypoints to make the check on upload more complete.The problem is related to the state machine and asynchronous message reading in geofence.cpp.The checkMissionAgainstGeofence() is written in the mission and the geofence is still being read when the mission has finished uploading and checking.\r\n \r\n![%`%3Z`6)VGYLVSF_)N0L{BT](https://github.com/PX4/PX4-Autopilot/assets/151698793/38b3fe89-4ed8-47d7-8822-c5254984f679)\r\n\r\nFixes #{#22362}\r\nIn this bug issue , @czbxzm said ,\"1. When swapping the order, uploading the mission waypoint routes first and then plotting the no-fly zones does not trigger any checks, even if there is an overlap between the two;\"Actually this check triggers, but requires a second click on upload.(in the version reporting this bug issue)\r\n\r\n\r\n### Solution\r\n\r\n1. I've added a check for mission waypoints when update geofence.\r\n \r\n![95$0I@SC~0)3RA G`Q2XMCR](https://github.com/PX4/PX4-Autopilot/assets/151698793/d96db40e-0b0e-4061-9a9c-358a5bde2268)\r\n\r\n\r\n### Test coverage\r\n\r\n test on jmavsim/gz_x500 and QGC\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-12-22T12:31:10Z",
          "body": "I think this could be fine. It would make you change the mission first if it would validate the planned GF, and then you can also update the GF.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-22T12:31:31Z",
          "body": "Curious for other inputs though, @dagar @MaEtUgR ?",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-18T01:42:55Z",
          "body": "Thank you for your advice.\r\n> it is checked again before the mission is executed and a geofence violation is caught at that time (though you don't have immediate feedback in QGC). \r\n\r\nI don't consider this to be a reasonable solution. And we've had discussions about it before,  it could pose issues in certain scenarios.https://github.com/PX4/PX4-Autopilot/pull/22394#issuecomment-1858063715\r\n\r\n> Also to not have a data race by writing and reading to the fence on the same time, there is another PR to add double geofence storage here: #22533. \r\n\r\nI agree with you that the drone needs double storage for geofence to separate checking and runing.\r\n\r\n> Further you could call check_mission_valid https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_base.cpp#L696 periodically as this checks if the geofence is changed since the last evaluation and runs it again.\r\n\r\nI'm concerned that periodically calling this function might introduce unnecessary overhead.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-18T08:32:45Z",
          "body": "> > it is checked again before the mission is executed and a geofence violation is caught at that time (though you don't have immediate feedback in QGC).\r\n> \r\n> I don't consider this to be a reasonable solution. And we've had discussions about it before, it could pose issues in certain scenarios.[#22394 (comment)](https://github.com/PX4/PX4-Autopilot/pull/22394#issuecomment-1858063715)\r\n> \r\n\r\nI agree on this and we should change that, and it is good that you take some initiative here.\r\n\r\n> > Further you could call check_mission_valid https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_base.cpp#L696 periodically as this checks if the geofence is changed since the last evaluation and runs it again.\r\n> \r\n> I'm concerned that periodically calling this function might introduce unnecessary overhead.\r\n\r\nYeah it potentially does, But the check if the mission feasibility checker is with the most recent data should be minimal and other overheads might be the Same as your solution, no?\r\nAlso for short term fixes, i have no better idea. Your solution runs it drectly on upload which is preferable, but then you should reflect this evaluation in the mission result uorb topic as its done here https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_base.cpp#L702-L707 such that it is not run again by the mission feasibility checker. The problem is then, that if e.g. the home position is changed, it is still not run again, up until the mission is started. Also now, it is checked once the geofence is uploaded and once the mission is uploaded, which means if you upload a new mission with new geofence, it is evaluated once on outdated data, depending which one is uploaded first.\r\n\r\nI also already have though about how to do the checking properly, but the above problem makes it difficult. i think that QGC always send the mission, geofence, and rally points, irrespective of what you have actually changed. But with mavlink in general you should be able to send only what you actually have changed. Also if you change both and upload them, you would preferably run the check only once after both are uploaded, else you would do the evaluation on outdated data. But there is currently no way of knowing if another upload is pending except maybe waiting for a short amount of time and checking if another mission upload is in progress. Maybe there is also something mission in MAVLINK itself to solve this.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-18T13:25:33Z",
          "body": "> but then you should reflect this evaluation in the mission result uorb topic as its done here https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_base.cpp#L702-L707 such that it is not run again by the mission feasibility checker. \r\n\r\nIs the 'reflect' necessary here? I'm not sure about its intended meaning. Currently, this patch does not trigger a recheck of the geofence by the mission feasibility checker.Because if geofence not feasible,it will not be added.\r\n\r\n> The problem is then, that if e.g. the home position is changed, it is still not run again, up until the mission is started. \r\n\r\nWe have discussed this topic here.Welcome more advice.https://github.com/PX4/PX4-Autopilot/issues/22373\r\n\r\n> Also now, it is checked once the geofence is uploaded and once the mission is uploaded, which means if you upload a new mission with new geofence, it is evaluated once on outdated data, depending which one is uploaded first.\r\n\r\nI don't think this is a problem.The ultimate outcome remains: Illegal missions and geofences will be rejected.\r\n\r\n> IAlso if you change both and upload them, you would preferably run the check only once after both are uploaded, else you would do the evaluation on outdated data. \r\n\r\nI agree with you .As I mentioned, the checkMissionAgainstGeofence() is written in the mission module. I believe this is the root cause.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-18T14:12:38Z",
          "body": "> > but then you should reflect this evaluation in the mission result uorb topic as its done here https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_base.cpp#L702-L707 such that it is not run again by the mission feasibility checker.\r\n> \r\n> Is the 'reflect' necessary here? I'm not sure about its intended meaning. Currently, this patch does not trigger a recheck of the geofence by the mission feasibility checker.Because if geofence not feasible,it will not be added.\r\n\r\nAh, i missed that, so if the mission violates the geofence, the geofence is ignored, correct? The mission feasibility checker makes the opposite, it defines the mission as invalid and wont let you execute the mission. So what i meant with 'reflect' is if the geofence is violated, you should define the mission as invalid as well. So with your approach you would now get the warning in QGC but you could execute the mission and it would fly out of the geofence, if i'm understanding this correctly. That would lead to unsafe behavior.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-19T01:11:13Z",
          "body": "> So with your approach you would now get the warning in QGC but you could execute the mission and it would fly out of the geofence, if i'm understanding this correctly. That would lead to unsafe behavior.\r\n\r\nDon't  worry about the unmanned aerial vehicle carrying out the geofence breaching mission, as the mission always undergoes an feasibility check and upload process before the geofence.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-19T01:14:12Z",
          "body": "\r\nIf you are interested in \"the mission always before the geofence,\" you can obtain more details here. \r\n### Details\r\n\r\n1. When the ground control station upload mission or geofence to the drone.In geofence.cpp, there is a state machine designed to read geofence data from ourb and load it onto the drone, as illustrated in the following picture.\r\n   <p align=\"center\">\r\n     <img src=\"https://user-images.githubusercontent.com/151698793/294857321-53c6d894-448a-4130-85ae-30ab7e12e171.png\" width=\"622\" />\r\n   </p>\r\n   This functionality is called within a while(1) loop in navigator_main.cpp.\r\n\r\n   https://github.com/PX4/PX4-Autopilot/blob/cf840ff3731d8bebf65e79bd8c9c7bbd8d29d404/src/modules/navigator/navigator_main.cpp#L893  \r\nThe read and load operations within it utilize **asynchronous** reading, ensuring that they do not block the function loop.\r\nhttps://github.com/PX4/PX4-Autopilot/blob/cf840ff3731d8bebf65e79bd8c9c7bbd8d29d404/src/modules/navigator/geofence.cpp#L111-L112\r\nhttps://github.com/PX4/PX4-Autopilot/blob/cf840ff3731d8bebf65e79bd8c9c7bbd8d29d404/src/modules/navigator/geofence.cpp#L155-L163\r\n \r\n2. When the ground control station upload mission or geofence to the drone.In mission_feasibility_checker.cpp, **synchronous** reading is employed to retrieve updates for the mission, and to check for potential conflicts between the mission and geofence.\r\nhttps://github.com/PX4/PX4-Autopilot/blob/20129e63facab129ad31fa693d1397e7458afaa4/src/modules/navigator/mission_feasibility_checker.cpp#L122-L123\r\nThis functionality is called within a while(1) loop in navigator_main.cpp too.\r\nhttps://github.com/PX4/PX4-Autopilot/blob/20129e63facab129ad31fa693d1397e7458afaa4/src/modules/navigator/navigator_main.cpp#L873-L877\r\n\r\n3. This is the cause of the issue. When on the ground control station, both the geofence and mission are updated simultaneously. The geofence undergoes multiple state transitions through the state machine (with each state transition requiring the execution of a while(1) loop), and it is only after asynchronous reading that the geofence data can be loaded for the mission_feasibility_checker to examine.\r\nTherefore, when the mission_feasibility_checker utilizes synchronous reading to obtain mission data, the geofence data involved in the check has not yet been updated. Consequently, the check is performed with outdated geofence data, resulting in the failure of the checker.",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2024-01-30T16:38:39Z",
          "body": "Hey @KonradRudin can you please check-in with us on this one? we want to help move it forward and have a few ideas",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-02-05T12:26:49Z",
          "body": "Sorry, was away last week. So basically we need to make sure that the geofence module has already properly loaded the geofence data before we can test for it right? ",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-02-05T13:19:32Z",
          "body": "Alternatively, add a check after successful upload?",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-02-05T13:40:35Z",
          "body": "> Alternatively, add a check after successful upload?\r\n\r\nYou mean after successful loading into cache i presume? Yes, as a first step we can force it to check again after successfully loading the geofence.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-02-05T14:44:21Z",
          "body": "what's the further plans? making geofence sync read and adding locks or semaphores?\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-02-05T17:42:46Z",
          "body": "> what's the further plans? making geofence sync read and adding locks or semaphores?\r\n\r\nNo, the caching is fine. But the geofence should be more a service module as well as send an uorb message if it has loaded the new geofence set.\r\n\r\nMaybe for your short term problem we could add a new geofence uorb message, which sends the ID of the loaded geofence. And if this message is updated, other system like the mission feasibility checker know to recheck?",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-02-08T02:05:49Z",
          "body": "I agree with your opinion. Do you need me to further modify the pull request according to this requirement?",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-02-09T07:10:55Z",
          "body": "It depends on your timeline. I also would like to improve the mission feasibility checks a bit and make it independent of the mission, but i won't have time right now. So any help input is appreciated, and this would be a good first incremental step.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-01-17T15:16:59Z",
          "body": "Why not reuse the code from https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_feasibility_checker.cpp#L108-L109? This is harder to maintain and currently does not work with non position mission items. ",
          "path": "src/modules/navigator/geofence.cpp",
          "position": 17,
          "type": "review_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-18T01:35:46Z",
          "body": "> Why not reuse the code from https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_feasibility_checker.cpp#L108-L109? This is harder to maintain and currently does not work with non position mission items.\r\n\r\nI made partial modifications to the code based on reference here.The code here cannot be directly used. This is because it checks using the geofence that has already been successfully uploaded, while we now need to perform pre-upload checks for the geofence.",
          "path": "src/modules/navigator/geofence.cpp",
          "position": 17,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "",
          "body": "\r\nHey, i dont think this is the way to go. As you stated, there is already the check here https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_feasibility_checker.cpp#L108-L109 and your new function is basically a reimplementation of it. I know that this function is executed as soon as a mission is uploaded, and thus it could be that a geofence upload is in progress and the mission is not checked with the right geofence, which would result in a wrong evaluation. However, it is checked again before the mission is executed and a geofence violation is caught at that time (though you don't have immediate feedback in QGC). Also to not have a data race by writing and reading to the fence on the same time, there is another PR to add double geofence storage here: https://github.com/PX4/PX4-Autopilot/pull/22533. I think the way to go would be to decouple the mission feasibility checker from the mission and run the checks if the home position, geofence, or mission changed, and there is no mavlink mission upload in progress. As a short term fix i would suggest changing the order in which QGC is uploading the mission and make sure that the geofence are uploaded before the mission is uploaded. Further you could call check_mission_valid https://github.com/Drone-Lab/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src/modules/navigator/mission_base.cpp#L696 periodically as this checks if the geofence is changed since the last evaluation and runs it again.",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses a logic/state-timing bug: mission feasibility checks can run on stale geofence data (asynchronous geofence loading vs synchronous mission checking), producing incorrect behavior that requires a second upload. The change forces mission waypoint validation on geofence upload to avoid the missed check; reviewers call it a workaround rather than an ideal architectural fix, but the underlying issue is clearly a logic/race condition.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 1,
        "changes": 27,
        "patch": "@@ -258,8 +258,11 @@ void Geofence::_updateFence()\n \t\t\t\t// check if current position is inside the fence and vehicle is armed\n \t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n \n+\t\t\t\t//check if current mission point inside the geofence\n+\t\t\t\tconst bool current_mission_check_okay = checkMissionRequirementsForGeofence(polygon);\n+\n \t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n-\t\t\t\tif (home_check_okay && current_position_check_okay) {\n+\t\t\t\tif (home_check_okay && current_position_check_okay  && current_mission_check_okay) {\n \t\t\t\t\t++_num_polygons;\n \n \t\t\t\t}\n@@ -275,6 +278,28 @@ void Geofence::_updateFence()\n \t}\n }\n \n+bool Geofence::checkMissionRequirementsForGeofence(const PolygonInfo &polygon)\n+{\n+\tmission_s mission;\n+\t_dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission),sizeof(mission_s));\n+\tbool checks_pass = false;\n+\t//check all mission  against all geofence\n+\tfor (size_t i = 0; i < mission.count; i++) {\n+\t\tstruct mission_item_s missionitem = {};\n+\t\t_dataman_client.readSync((dm_item_t)mission.dataman_id, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\t\t\t\tsizeof(mission_item_s));\n+\t\t//missionitem.altitude = missionitem.altitude_is_relative ? missionitem.altitude + home_alt : missionitem.altitude;\n+\t\tchecks_pass = checkPointAgainstPolygonCircle(polygon,missionitem.lat, missionitem.lon, missionitem.altitude);\n+\t\tif (!checks_pass) {\n+\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence invalid, against mission waypoint %zu\\t\",i + 1);\n+\t\tevents::send<int16_t>(events::ID(\"navigator_geofence_invalid_against_mission\"), {events::Log::Critical, events::LogInternal::Warning},\n+\t\t\t     \"Geofence invalid, against mission waypoint {1} \",i + 1);\n+\t\tbreak;\n+\t\t}\n+\t}\n+\treturn  checks_pass;\n+}\n+\n bool Geofence::checkHomeRequirementsForGeofence(const PolygonInfo &polygon)\n {\n \tbool checks_pass = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -206,6 +206,12 @@ class Geofence : public ModuleParams\n \t */\n \tbool insideCircle(const PolygonInfo &polygon, double lat, double lon, float altitude);\n \n+\t/**\n+\t * Check polygon or circle geofence fullfills the requirements relative to the current mission.\n+\t * @return true if checks pass\n+\t */\n+\tbool checkMissionRequirementsForGeofence(const PolygonInfo &polygon);\n+\n \t/**\n \t * Check if a single point is within a polygon or circle\n \t * @return true if within polygon or circle",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5490f8913bd26ac04d59908271ce9c5e6a1bd414/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::_updateFence"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::_updateFence"
        ]
      }
    }
  },
  {
    "title": "Navigator: Avoid attitude stepoint resets by not going into Takeoff mode if VTOL_Takeoff is selected in-air",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22519",
    "number": 22519,
    "created_at": "2023-12-11T13:22:29Z",
    "merged": true,
    "merged_at": "2023-12-11T13:35:57Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Port of https://github.com/PX4/PX4-Autopilot/pull/22518",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR prevents an incorrect state transition (entering Takeoff mode while already airborne when VTOL_Takeoff is selected) that causes unintended attitude setpoint resets. This is a logic bug (improper state transition/boundary condition) and the change addresses that erroneous behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "patch": "@@ -694,6 +694,7 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \t\tbreak;\n \n \tcase NAV_CMD_TAKEOFF:\n+\tcase NAV_CMD_VTOL_TAKEOFF:\n \n \t\t// if already flying (armed and !landed) treat TAKEOFF like regular POSITION\n \t\tif ((_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED)\n@@ -707,10 +708,6 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \n \t\tbreak;\n \n-\tcase NAV_CMD_VTOL_TAKEOFF:\n-\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n-\t\tbreak;\n-\n \tcase NAV_CMD_LAND:\n \tcase NAV_CMD_VTOL_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d1ca2407d69f77d40f3e76fddb566c94a045a013/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "Navigator: Avoid attitude stepoint resets by not going into Takeoff mode if VTOL_Takeoff is selected in-air",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22518",
    "number": 22518,
    "created_at": "2023-12-11T10:33:40Z",
    "merged": true,
    "merged_at": "2023-12-11T13:18:22Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nAttitude resets happening when switching to Mission mode with VTOL_Takeoff selected in-air.\r\n\r\nChain:\r\n- Navigator sets the type to SETPOINT_TYPE_TAKEOFF for one sample\r\n- FW position controller goes into _control_mode_current= FW_POSCTRL_MODE_AUTO_TAKEOFF\r\n- FW position controller executes control_auto_takeoff() --> resets integrals [here](https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/fw_pos_control/FixedwingPositionControl.cpp#L1552)\r\n\r\n### Solution\r\nNavigator: Avoid attitude stepoint resets by not going into Takeoff mode if VTOL_Takeoff is selected in-air\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Navigator: Avoid attitude stepoint resets by not going into Takeoff mode if VTOL_Takeoff is selected in-air.\r\n```\r\n\r\n### Test coverage\r\nSITL\r\n\r\n### Context\r\nReproducible in SITL (start mission with VTOL_Takeoff, change mission in-air, re-upload, start mission again).\r\n\r\nWithout the fix: \r\n![image](https://github.com/Auterion/PX4_firmware_private/assets/26798987/30ae797d-3aff-4e5b-b89c-2e8cb82cd929)\r\n\r\nWith the fix:\r\n\r\n![image](https://github.com/Auterion/PX4_firmware_private/assets/26798987/cc97cc83-bbfd-46d9-b5d3-cefe0bd1b7ad)\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects an improper state transition in the Navigator that briefly sets SETPOINT_TYPE_TAKEOFF in-air, causing the fixed-wing position controller to enter AUTO_TAKEOFF and run control_auto_takeoff() which resets integrals and produces unintended attitude setpoint resets. The change prevents entering Takeoff mode when VTOL_Takeoff is selected in-air, addressing this incorrect behavior (a logic/state transition bug).",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "patch": "@@ -694,6 +694,7 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \t\tbreak;\n \n \tcase NAV_CMD_TAKEOFF:\n+\tcase NAV_CMD_VTOL_TAKEOFF:\n \n \t\t// if already flying (armed and !landed) treat TAKEOFF like regular POSITION\n \t\tif ((_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED)\n@@ -707,10 +708,6 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \n \t\tbreak;\n \n-\tcase NAV_CMD_VTOL_TAKEOFF:\n-\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n-\t\tbreak;\n-\n \tcase NAV_CMD_LAND:\n \tcase NAV_CMD_VTOL_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d7670a98bb61bc026f33df41d4a63f78b63c8f7/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "Navigator: mission_block: reduce margin to enforce aligned exit course to 105% of the loiter radius",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22511",
    "number": 22511,
    "created_at": "2023-12-08T10:43:56Z",
    "merged": true,
    "merged_at": "2023-12-21T15:58:22Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "This margin helps to not have a vehicle stuck at a loiter waypoint if it is not perfectly tracked, (vehicle outside of path setpoint) and the next waypoint is just at the border of the loiter.\r\nIt should though be as small as necessary, as otherwise, with good loiter tracking,  waypoints that are close but not right on the loiter radius are not enforcing the exit course neither.\r\n\r\nThe previous margin of 120% seems rather a bit too high, I propose 105% here.\r\n\r\nReduces the likelihood of ugly loiter exits like this one here, where the loiter radius is huge and the distance to the next WP is small:\r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/26798987/9b4d24f9-586c-451c-8587-387d8aa7c7eb)\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "Seems valid, but if it's an issue for anyone after this I suppose it needs to be configurable.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR adjusts a threshold/margin used to decide when to enforce an aligned exit course from a loiter. That threshold is part of conditional logic deciding behavior; the previous 120% margin allowed incorrect/undesired behavior (stuck or no enforced exit) in normal tracking, so reducing it to 105% corrects that faulty decision logic. Reviewer comments also treat this as behavioral correctness (with a note to make it configurable), supporting that this is a logic fix rather than a style change.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -473,8 +473,8 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t\t\t\t && curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER\n \t\t\t\t\t\t\t && (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n \n-\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint\n-\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.2f * curr_sp_new->loiter_radius;\n+\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint (with small margin)\n+\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.05f * curr_sp_new->loiter_radius;\n \n \t\t\tif (enforce_exit_course && exit_course_is_reachable) {\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/41a0b4ffb23257dbebc89cab91baaab3a428892b/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ]
      }
    }
  },
  {
    "title": "Add mission point check when update the geofence",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22469",
    "number": 22469,
    "created_at": "2023-11-30T17:06:48Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "Drone-Lab",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\n\r\n1.  https://github.com/PX4/PX4-Autopilot/blob/c5101c70b31aa0c1454162c6ad1420e5af8086b2/src/modules/navigator/mission_feasibility_checker.cpp#L108 I've found that the MissionFeasibilityChecker()  is only triggered correctly when updating a mission.  when only updating a geofence,user need to click upload twice to invoke check function. Currently, the geofence update only checks the origin and the current position associated with the geofence, and I've added a check for mission waypoints to make the check on upload more complete.The problem is related to the state machine and asynchronous message reading in geofence.cpp.The checkMissionAgainstGeofence() is written in the mission and the geofence is still being read when the mission has finished uploading and checking.\r\n \r\n![%`%3Z`6)VGYLVSF_)N0L{BT](https://github.com/PX4/PX4-Autopilot/assets/151698793/38b3fe89-4ed8-47d7-8822-c5254984f679)\r\n\r\n2. Regarding the issue of being unable to perform geofence breach checks for the home point using VEHICLE_CMD_DO_SET_HOME in commander.cpp due to geofence not being available in the navigator, the following solution is proposed:**When the drone switches to RTL mode, check whether the home point triggers a geofence breach.**\r\nHowever, at present, we only return the result and have successfully tested it. We have not yet implemented handling for the detected issues and event notifications because there may be some irregularities or issues in the code. We would appreciate your feedback on this matter.\r\n\r\nFixes #{#22362}\r\nIn this bug issue , @czbxzm said ,\"1. When swapping the order, uploading the mission waypoint routes first and then plotting the no-fly zones does not trigger any checks, even if there is an overlap between the two;\"Actually this check triggers, but requires a second click on upload.(in the version reporting this bug issue)\r\n\r\n#ï½›#22373ï½\r\nIn this bug issue, @BladeY1 said,\"In SITL simulation, we observed that the Home point can be arbitrarily set by the operator. Since Return to Launch (RTL) navigates the drone back to the Home point, inadvertent placement of the Home point within a no-fly zone can result in the drone breaching no-fly zone checks or entering the restricted area when the operator manually selects RTL. We validated this behavior using a drone equipped with PX4 flight control. It indeed demonstrated the ability to enter a no-fly zone through the aforementioned actions.We believe that operators typically intend to avoid their drones entering no-fly zones to prevent potential damage or safety incidents. No-fly zones, often manually designated by operators, are crucial in areas like airports, amusement parks with high-altitude ride systems, or locations with dense obstacles such as forests, lakes, and clusters of buildings.\"\r\n\r\n\r\n\r\n### Solution\r\n\r\n1. I've added a check for mission waypoints when update geofence.\r\n \r\n![95$0I@SC~0)3RA G`Q2XMCR](https://github.com/PX4/PX4-Autopilot/assets/151698793/d96db40e-0b0e-4061-9a9c-358a5bde2268)\r\n\r\n2. When the drone switches to RTL mode, check whether the home point triggers a geofence breach.\r\n\r\n\r\n### Test coverage\r\n\r\n test on jmavsim/gz_x500 and QGC\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "Drone-Lab",
          "created_at": "2023-12-01T01:17:22Z",
          "body": "Hello! @sfuhrer  83f3665d9576b453142196c2e4725e46728d1f46  I think this is an addition to this commit to make it more complete.",
          "type": "issue_comment"
        },
        {
          "author": "czbxzm",
          "created_at": "2023-12-01T09:04:31Z",
          "body": "It seems correct now. The system performs checks and displays a pop-up window when updating the geofence.(Previously, the pop-up window would only appear when updating the mission.)",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2023-12-03T02:11:28Z",
          "body": "@dagar  Let me know what you think about this ,thx.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect runtime behavior caused by missing checks and asynchronous/state handling. The bug caused geofence updates to skip mission waypoint checks (requiring a second upload) and missed home-point geofence checks on RTL; these are logic issues (timing/state/data-flow) rather than syntax/style errors, and the PR adds the appropriate checks to correct the program behavior.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 1,
        "changes": 29,
        "patch": "@@ -258,8 +258,11 @@ void Geofence::_updateFence()\n \t\t\t\t// check if current position is inside the fence and vehicle is armed\n \t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n \n+\t\t\t\t//check if current mission point inside the geofence\n+\t\t\t\tconst bool current_mission_check_okay = checkMissionRequirementsForGeofence(polygon);\n+\t\t\t\t\n \t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n-\t\t\t\tif (home_check_okay && current_position_check_okay) {\n+\t\t\t\tif (home_check_okay && current_position_check_okay && current_mission_check_okay) {\n \t\t\t\t\t++_num_polygons;\n \n \t\t\t\t}\n@@ -275,6 +278,30 @@ void Geofence::_updateFence()\n \t}\n }\n \n+bool Geofence::checkMissionRequirementsForGeofence(const PolygonInfo &polygon)\n+{\n+\tmission_s mission;\n+\t_dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission),sizeof(mission_s));\n+\tbool checks_pass = false;\n+\t//check all mission  against all geofence\n+\tfor (size_t i = 0; i < mission.count; i++) {\n+\t\tstruct mission_item_s missionitem = {};\n+\t\t_dataman_client.readSync((dm_item_t)mission.dataman_id, i, reinterpret_cast<uint8_t *>(&missionitem),\n+\t\t\t\t\tsizeof(mission_item_s));\n+\t\t//missionitem.altitude = missionitem.altitude_is_relative ? missionitem.altitude + home_alt : missionitem.altitude;\n+\t\tchecks_pass = checkPointAgainstPolygonCircle(polygon,missionitem.lat, missionitem.lon, missionitem.altitude);\n+\t\tif (!checks_pass) {\n+\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence invalid, against mission\\t\");\n+\t\tevents::send(events::ID(\"navigator_geofence_invalid_against_mission\"), {events::Log::Critical, events::LogInternal::Warning},\n+\t\t\t     \"Geofence invalid, against mission\");\n+\n+\n+\t\tbreak;\n+\t\t}\n+\t}\n+\treturn  checks_pass;\n+}\n+\n bool Geofence::checkHomeRequirementsForGeofence(const PolygonInfo &polygon)\n {\n \tbool checks_pass = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1f50fe5ff5043e0c420dcf407df52ae2e0b2ad38/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -206,6 +206,12 @@ class Geofence : public ModuleParams\n \t */\n \tbool insideCircle(const PolygonInfo &polygon, double lat, double lon, float altitude);\n \n+\t/**\n+\t * Check polygon or circle geofence fullfills the requirements relative to the current mission.\n+\t * @return true if checks pass\n+\t */\n+\tbool checkMissionRequirementsForGeofence(const PolygonInfo &polygon);\n+\n \t/**\n \t * Check if a single point is within a polygon or circle\n \t * @return true if within polygon or circle",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1f50fe5ff5043e0c420dcf407df52ae2e0b2ad38/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "patch": "@@ -240,6 +240,8 @@ void RTL::on_activation()\n {\n \tsetRtlTypeAndDestination();\n \n+\tbool check_home_result = check_home_valid();\n+\n \tswitch (_rtl_type) {\n \tcase RtlType::RTL_DIRECT_MISSION_LAND:\t// Fall through\n \tcase RtlType::RTL_MISSION_FAST: // Fall through\n@@ -662,3 +664,28 @@ land_approaches_s RTL::readVtolLandApproaches(DestinationPosition rtl_position)\n \n \treturn vtol_land_approaches;\n }\n+\n+\n+bool RTL::check_home_valid()\n+{\n+\t_home_pos_sub.update();\n+\tif (_navigator->get_geofence().valid()) {\n+\n+\t\t_vehicle_gps_position_sub.copy(&_home_check_gps_pos);\n+\n+\t\tvehicle_global_position_s home_pos_check{};\n+\n+\t\thome_pos_check.lat = _home_pos_sub.get().lat;\n+\t\thome_pos_check.lon = _home_pos_sub.get().lon;\n+\t\thome_pos_check.alt = _home_pos_sub.get().alt;\n+\n+\t\tif ((_navigator->get_geofence().getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n+\t\t(_navigator->get_geofence().getGeofenceAction() != geofence_result_s::GF_ACTION_WARN)) {\n+\t\t\tif (PX4_ISFINITE(_home_pos_sub.get().alt) && PX4_ISFINITE(_home_pos_sub.get().lon)) {\n+\t\t\t\treturn _navigator->get_geofence().check(home_pos_check, _home_check_gps_pos);\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\treturn true;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1f50fe5ff5043e0c420dcf407df52ae2e0b2ad38/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -59,6 +59,7 @@\n #include <uORB/topics/mission.h>\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/rtl_time_estimate.h>\n+#include <uORB/topics/sensor_gps.h>\n \n class Navigator;\n \n@@ -164,6 +165,12 @@ class RTL : public NavigatorMode, public ModuleParams\n \t */\n \tbool hasVtolLandApproach(const DestinationPosition &rtl_position) const;\n \n+\t/**\n+\t * @brief Check if the home point is valid when switching to RTL mode\n+\t *\n+\t */\n+\tbool check_home_valid();\n+\n \t/**\n \t * @brief Choose best landing approach\n \t *\n@@ -198,6 +205,8 @@ class RTL : public NavigatorMode, public ModuleParams\n \tmutable DatamanCache _dataman_cache_landItem{\"rtl_dm_cache_miss_land\", 2};\n \tuint32_t _mission_id = 0u;\n \n+\tsensor_gps_s\t\t\t\t_home_check_gps_pos{};\n+\n \tmission_stats_entry_s _stats;\n \n \tRtlDirect _rtl_direct;\n@@ -215,6 +224,8 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tuORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};\n \n+\tuORB::Subscription\t\t\t_vehicle_gps_position_sub{ORB_ID(vehicle_gps_position)};\n+\n \tuORB::SubscriptionData<vehicle_global_position_s> _global_pos_sub{ORB_ID(vehicle_global_position)};\t/**< global position subscription */\n \tuORB::SubscriptionData<vehicle_status_s> _vehicle_status_sub{ORB_ID(vehicle_status)};\t/**< vehicle status subscription */\n \tuORB::SubscriptionData<mission_s> _mission_sub{ORB_ID(mission)};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1f50fe5ff5043e0c420dcf407df52ae2e0b2ad38/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::readVtolLandApproaches",
        "RTL::on_activation",
        "Geofence::_updateFence"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::_updateFence"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::readVtolLandApproaches",
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Navigator: add set_gimbal_neutral() logic",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22458",
    "number": 22458,
    "created_at": "2023-11-29T14:54:23Z",
    "merged": true,
    "merged_at": "2023-12-01T12:19:09Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\n- cameras have higher chance to get damaged when pointing down (like they do while flying a survey)\r\n- on Holding a survey mission, most users seem to prefer to have the camera pan upwards such that they can look at the surroundings\r\n\r\n### Solution\r\nIntroduce set_gimabl_neutral() method that sets `gimbal_manager_set_attitude_s::GIMBAL_MANAGER_FLAGS_NEUTRAL`. Call it on entering RTL and Land flight modes, as well as when in a mission and the next item is Land, or on pausing a mission.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: set gimbal to neutral (horizontal) in Landing scenarios and on pausing a Mission\r\n```\r\n\r\n### Test coverage\r\nSITL tested. \r\n",
      "issue_comments": [
        {
          "author": "julianoes",
          "created_at": "2023-12-03T18:42:52Z",
          "body": "One thing to note is that this will set the gimbal to neutral even if it is controlled manually. I guess that's what we want, right?\r\n\r\nAnd also, to be pedantic, this should probably be [retracted](https://mavlink.io/en/messages/common.html#GIMBAL_DEVICE_FLAGS_RETRACT), however, that's not really implemented anywhere, or at least not any different from neutral, so :man_shrugging:.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-05T09:18:34Z",
          "body": ">One thing to note is that this will set the gimbal to neutral even if it is controlled manually. I guess that's what we want, right?\r\n\r\nThat's the feedback we got from users, yeah. Better be on the safe side and set it to neutral once too often than risking damage on the landing.\r\n\r\n> And also, to be pedantic, this should probably be [retracted](https://mavlink.io/en/messages/common.html#GIMBAL_DEVICE_FLAGS_RETRACT), however, that's not really implemented anywhere, or at least not any different from neutral, so ðŸ¤·â€â™‚ï¸.\r\n\r\nGood point. I guess not enough people care yet about the retraction.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes program logic around gimbal state transitions (entering RTL/Land, pausing or approaching a Land mission item) to force a neutral attitude. This corrects undesired behavior where the gimbal could remain pointed down during landing/survey operations and risk damage, i.e. an improper state transition/behavior fix rather than a cosmetic change.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -65,6 +65,12 @@ Land::on_activation()\n \n \t// reset cruising speed to default\n \t_navigator->reset_cruising_speed();\n+\n+\t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n+\t_navigator->acquire_gimbal_control();\n+\t_navigator->set_gimbal_neutral();\n+\t_navigator->release_gimbal_control();\n+\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/089ae4d13c04fbc8a082812a0e4284a2d01a38ee/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -189,6 +189,7 @@ MissionBase::on_inactivation()\n \t_navigator->disable_camera_trigger();\n \n \t_navigator->stop_capturing_images();\n+\t_navigator->set_gimbal_neutral(); // point forward\n \t_navigator->release_gimbal_control();\n \n \tif (_navigator->get_precland()->is_activated()) {\n@@ -619,6 +620,11 @@ void MissionBase::handleLanding(WorkItemType &new_work_item_type, mission_item_s\n \t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n \t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n \n+\t\t\t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n+\t\t\t_navigator->acquire_gimbal_control();\n+\t\t\t_navigator->set_gimbal_neutral();\n+\t\t\t_navigator->release_gimbal_control();\n+\n \t\t} else {\n \n \t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/089ae4d13c04fbc8a082812a0e4284a2d01a38ee/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -65,6 +65,7 @@\n #include <uORB/Subscription.hpp>\n #include <uORB/SubscriptionInterval.hpp>\n #include <uORB/topics/geofence_result.h>\n+#include <uORB/topics/gimbal_manager_set_attitude.h>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n@@ -276,6 +277,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tvoid acquire_gimbal_control();\n \tvoid release_gimbal_control();\n+\tvoid set_gimbal_neutral();\n \n \tvoid calculate_breaking_stop(double &lat, double &lon, float &yaw);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/089ae4d13c04fbc8a082812a0e4284a2d01a38ee/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "patch": "@@ -1508,6 +1508,18 @@ void Navigator::disable_camera_trigger()\n \tpublish_vehicle_cmd(&cmd);\n }\n \n+void Navigator::set_gimbal_neutral()\n+{\n+\tvehicle_command_s vcmd = {};\n+\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_PITCHYAW;\n+\tvcmd.param1 = NAN;\n+\tvcmd.param2 = NAN;\n+\tvcmd.param3 = NAN;\n+\tvcmd.param4 = NAN;\n+\tvcmd.param5 = gimbal_manager_set_attitude_s::GIMBAL_MANAGER_FLAGS_NEUTRAL;\n+\tpublish_vehicle_cmd(&vcmd);\n+}\n+\n int Navigator::print_usage(const char *reason)\n {\n \tif (reason) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/089ae4d13c04fbc8a082812a0e4284a2d01a38ee/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -256,6 +256,11 @@ void RTL::on_activation()\n \tdefault:\n \t\tbreak;\n \t}\n+\n+\t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n+\t_navigator->acquire_gimbal_control();\n+\t_navigator->set_gimbal_neutral();\n+\t_navigator->release_gimbal_control();\n }\n \n void RTL::on_active()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/089ae4d13c04fbc8a082812a0e4284a2d01a38ee/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_activation",
        "RTL::on_activation",
        "Navigator::disable_camera_trigger",
        "MissionBase::on_inactivation",
        "MissionBase::handleLanding"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_inactivation",
          "MissionBase::handleLanding"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::disable_camera_trigger"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Ignore mission yaw setpoints in WV_EN enabled",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22455",
    "number": 22455,
    "created_at": "2023-11-29T10:02:29Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "TedObrien",
      "body": "Remade PR #22413 on main as requested.\r\n\r\nSee #22413 for further details",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-12-13T13:46:58Z",
          "body": "Thanks for your contribution @TedObrien ! It's a very good point that you raised, and while looking at your proposal I saw some fundamental flaws in the current architecture that I propose to fix in https://github.com/PX4/PX4-Autopilot/pull/22532. In case that comes in we can close that one here. Please feel free to test it yourself and comment on it!",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-12-21T16:30:09Z",
          "body": "fixed in #22532",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes behavior to ignore mission yaw setpoints when WV_EN (windâ€‘vane) is enabled, which corrects incorrect control logic/state handling (wrong conditional/behavioral outcome). Reviewer and author comments indicate this was addressing a bug and later incorporated into a follow-up fix, confirming it fixes unintended behavior rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -439,6 +439,13 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t_navigator->set_mission_failure_heading_timeout();\n \t\t\t}\n \n+\t\t\t// If Weathervane is enabled, ignore yaw setpoint\n+\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t\t\tif (_navigator->get_weathervane_enabled() && !pos_sp_triplet->current.disable_weather_vane) {\n+\t\t\t\t_waypoint_yaw_reached = true;\n+\t\t\t}\n+\n \t\t} else {\n \t\t\t_waypoint_yaw_reached = true;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d6204fedf2317e6ac8cbcac502e8d9f1f2a6a856/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -268,6 +268,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat get_param_mis_takeoff_alt() const { return _param_mis_takeoff_alt.get(); }\n \tint  get_takeoff_land_required() const { return _para_mis_takeoff_land_req.get(); }\n \tfloat get_yaw_timeout() const { return _param_mis_yaw_tmt.get(); }\n+\tbool get_weathervane_enabled() const { return _param_wv_en.get(); }\n \tfloat get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n \n \tfloat get_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss; }\n@@ -406,6 +407,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamInt<px4::params::MIS_TKO_LAND_REQ>)  _para_mis_takeoff_land_req,\n \t\t(ParamFloat<px4::params::MIS_YAW_TMT>)     _param_mis_yaw_tmt,\n \t\t(ParamFloat<px4::params::MIS_YAW_ERR>)     _param_mis_yaw_err,\n+\t\t(ParamBool<px4::params::WV_EN>)\t           _param_wv_en,\n \t\t(ParamFloat<px4::params::MIS_PD_TO>)       _param_mis_payload_delivery_timeout,\n \t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)  _param_mis_lnd_abrt_alt\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d6204fedf2317e6ac8cbcac502e8d9f1f2a6a856/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ]
      }
    }
  },
  {
    "title": "Minor mission fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22434",
    "number": 22434,
    "created_at": "2023-11-23T08:35:36Z",
    "merged": true,
    "merged_at": "2023-11-24T07:10:07Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "2 smaller things I found when going through the code:\r\n- [fix comparison logic for saving mission state](https://github.com/PX4/PX4-Autopilot/commit/96c2b51a9b5c32684699b1a47ae21554bc68c8cf)\r\n- [publish mission after updating dataman](https://github.com/PX4/PX4-Autopilot/commit/d982dde3d181b22d140af3e5d811a243333a2f4a)",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR explicitly fixes a faulty comparison used when deciding to save mission state (an incorrect conditional/logic), and changes the update sequence to publish the mission after updating dataman (fixing an incorrect state/flow). Both changes address incorrect program behavior/state handling rather than syntax or style, so they are logic error fixes.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -473,7 +473,7 @@ Mission::save_mission_state()\n \tif (success) {\n \t\t/* data read successfully, check dataman ID and items count */\n \t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count\n-\t\t    && mission_state.mission_update_counter && _mission.mission_update_counter) {\n+\t\t    && mission_state.mission_update_counter == _mission.mission_update_counter) {\n \t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n \t\t\tif (mission_state.current_seq != _mission.current_seq) {\n \t\t\t\tmission_state = _mission;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d982dde3d181b22d140af3e5d811a243333a2f4a/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::save_mission_state"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::save_mission_state"
        ]
      }
    }
  },
  {
    "title": "Ignore mission yaw setpoints in `WV_EN` enabled",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22413",
    "number": 22413,
    "created_at": "2023-11-20T14:27:31Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "TedObrien",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nIn mission mode or return mode, weather-vaning can cause the drones' heading to change by more than MIS_YAW_ERROR. This causes the drone to remain at its current mission setpoint indefinitely.\r\n\r\nFixes #22355\r\n\r\n### Solution\r\nAdded a conditional to make `_waypoint_yaw_reached = true` if `WV_EN` is enabled and `position_setpoint.disable_weather_vane=false`\r\n\r\n### Test coverage\r\n- Tested in sitl with the windy environment. \r\n- Ran a mission specifying yaw setpoints at each waypoint\r\n- with `WV_EN=1` vehicle ignored yaw setpoints and completed the mission pointing into the wind (https://review.px4.io/plot_app?log=f0720db6-dd2e-486d-8d38-dfa08e58048f)\r\n- with  `WV_EN=0` the vehicle follows yaw setpoints specified in the mission (https://review.px4.io/plot_app?log=f95a52a1-3710-491d-a8d1-3655c709ccb9)\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "danielhonies",
          "created_at": "2023-11-21T16:42:07Z",
          "body": "Thanks for the PR, I would recommend to write this one line a bit cleaner. ",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-11-22T09:54:39Z",
          "body": "Good call, just modified that line.\r\n\r\nThanks",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-11-28T11:11:47Z",
          "body": "Can you first make the PR again `main`? And then we can port it to the release branch (1.14) as well. \r\n\r\nI'm curious for the use case: why do you want to specify yaw angles at the waypoints AND enable weather-vane? And shouldn't in that case the right thing be to fix the broken `position_setpoint.disable_weather_vane` reporting (if the waypoint enforces a yaw then this setpoint flag should be set to true )?\r\n",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-11-28T17:29:15Z",
          "body": "Hello, I encountered a problem initially (#22355), where the drone would sometimes loiter indefinitely during RTL due to the heading not meeting the acceptable yaw error (caused by weather-vaning). Although my usage doesn't involve setting specific yaw angles at mission waypoints, RTL mode appears to use mission setpoints with specified yaw angles that prevents the drone's progression to the next phase of RTL.\r\n\r\nFor context, my application involves a multi-copter equipped with an anemometer, requiring alignment with the wind direction.  Using `position_setpoint.disable_weather_vane` for landing purposes works well in this scenario. However, for a vehicle with a lifting surface, maintaining the current heading into the wind during RTL might be more appropriate.\r\n\r\nHopefully this makes sense, I'll redo the PR on main.\r\n\r\nThanks\r\n",
          "type": "issue_comment"
        },
        {
          "author": "TedObrien",
          "created_at": "2023-11-29T10:03:13Z",
          "body": "Just made a new PR from main #22455",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "danielhonies",
          "created_at": "",
          "body": "(_navigator->get_weathervane_enabled() == true) && (pos_sp_triplet->current.disable_weather_vane == false) -> _navigator->get_weathervane_enabled() &&  ! pos_sp_triplet->current.disable_weather_vane ",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error. Previously the navigator could never mark mission yaw as reached when weather-vaning changed the heading beyond MIS_YAW_ERROR, causing the vehicle to stall at a waypoint; the change forces _waypoint_yaw_reached=true when weather-vane is enabled and not disabled by the setpoint, restoring the correct state transition and mission progression.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -439,6 +439,13 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t_navigator->set_mission_failure_heading_timeout();\n \t\t\t}\n \n+\t\t\t// If Weathervane is enabled, ignore yaw setpoint\n+\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t\t\tif (_navigator->get_weathervane_enabled() && !pos_sp_triplet->current.disable_weather_vane) {\n+\t\t\t\t_waypoint_yaw_reached = true;\n+\t\t\t}\n+\n \t\t} else {\n \t\t\t_waypoint_yaw_reached = true;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ddb51ea0d68cd427b985f73e07b2f0426ab95238/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -292,6 +292,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat get_takeoff_min_alt() const { return _param_mis_takeoff_alt.get(); }\n \tint  get_takeoff_land_required() const { return _para_mis_takeoff_land_req.get(); }\n \tfloat get_yaw_timeout() const { return _param_mis_yaw_tmt.get(); }\n+\tbool get_weathervane_enabled() const { return _param_wv_en.get(); }\n \tfloat get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n \tfloat get_lndmc_alt_max() const { return _param_lndmc_alt_max.get(); }\n \n@@ -432,6 +433,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamInt<px4::params::MIS_TKO_LAND_REQ>)  _para_mis_takeoff_land_req,\n \t\t(ParamFloat<px4::params::MIS_YAW_TMT>)     _param_mis_yaw_tmt,\n \t\t(ParamFloat<px4::params::MIS_YAW_ERR>)     _param_mis_yaw_err,\n+\t\t(ParamBool<px4::params::WV_EN>)\t\t_param_wv_en,\n \t\t(ParamFloat<px4::params::MIS_PD_TO>)       _param_mis_payload_delivery_timeout,\n \t\t(ParamFloat<px4::params::LNDMC_ALT_MAX>)   _param_lndmc_alt_max,\n \t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)  _param_mis_lnd_abrt_alt",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ddb51ea0d68cd427b985f73e07b2f0426ab95238/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ]
      }
    }
  },
  {
    "title": "Navigator: Geofence improvements",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22394",
    "number": 22394,
    "created_at": "2023-11-16T15:20:26Z",
    "merged": true,
    "merged_at": "2023-11-23T02:45:02Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\n\r\nFixes: \r\n1) listen to GF_SOURCE (fixes https://github.com/PX4/PX4-Autopilot/issues/20677)\r\n2) do not constantly send new reposition waypoints when GF is breached as a fixed-wing\r\n\r\nNew features:\r\n3) if armed, do not allow to upload GF that would immediately trigger\r\n4) do not allow to upload GF if it doesn't contain Home (to not break RTL)\r\n\r\nFunctional changes (neither new features nor fixes):\r\n5) has to be in all inclusion GF \r\n6) remove GF_ALTMODE (with the big baro offset usually present this is quite unusable)\r\n7) remove GF_COUNT (don't see need, don't find it intuitive)\r\n8) change messaging\r\n9) some code cleanup\r\n\r\n### Solution\r\n1) correctly listen to it.\r\n2) if GF_ACTION is HOLD, and GF is breached: stay in the \"GF breached mode\" until the current loiter is changed (through new reposition or change of mode) --> see https://github.com/PX4/PX4-Autopilot/commit/66ca5c294952689e0775c5136ad0d7f6604a2d17\r\n3) check GF breach in update function, and stop updating the current GF if it would immediately get breached --> see https://github.com/PX4/PX4-Autopilot/commit/83f3665d9576b453142196c2e4725e46728d1f46\r\n4) check GF breach in update function, and stop updating the current GF if it doesn't contain Home --> see https://github.com/PX4/PX4-Autopilot/commit/83f3665d9576b453142196c2e4725e46728d1f46\r\n5) Change logic that all GF action already gets triggered when the GF leaves one inclusion GF, not only when outside of all inclusion GF. \r\nI'm not entirely sure what we want, but for me it seems cleaner that way.\r\n6) remove it.\r\n7) remote it.\r\n8) see https://github.com/PX4/PX4-Autopilot/commit/8e1c3e8093e3da0dbe9a276eb01d2672d7cd190b:\r\n - geofence_result.cpp contains to contain separate fields for the 3 geofence types\r\n -  remote \"primary\" from messages, as we don't distinguish primary vs secondary etc\r\n - do all user notification due to GF breach from Commander\r\n9) various \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Geofence: correctly listen to GF_SOURCE\r\nBugfix: Geofence: do not constantly send new reposition waypoints when GF is breached as a fixed-wing\r\nFeature: Geofence: if armed, do not allow to upload GF that would immediately trigger\r\nFeature: Geofence: do not allow to upload GF if it doesn't contain Home (to not break RTL)\r\nDocumentation: TODO\r\n```\r\n\r\n### Alternatives\r\nWe should also fix the pre-emptive geofence triggering (GF_PREDICT=1). I haven't touched that in this PR, and even split it up further (without GF_PREDICT=1 it will now always set the Hold point at the position it is currently at).\r\n\r\n### Test coverage\r\nSITL tested\r\n\r\n### Context\r\nScreen recording with current main, where issues 4) and 2) are visible:\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/assets/26798987/87cd8a30-1768-493f-afa6-9ce8dc84ac27\r\n\r\nScreen recording of this PR, where the new features 3) and 4) are shown, plus fixed 2):\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/assets/26798987/2469124f-63e4-4f1e-9ac4-5315b2d020da\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2023-11-21T16:48:02Z",
          "body": "Maintainers call: Would be nice to have an automated test for this e.g. MAVSDK test using https://github.com/mavlink/MAVSDK/blob/main/examples/geofence/geofence.cpp",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-15T15:08:42Z",
          "body": "> Hello @sfuhrer ! It appears there might be a potential issue with the invocation of the checkMissionAgainstGeofence() function when only the geofence undergoes an update [484a44e](https://github.com/PX4/PX4-Autopilot/commit/484a44e5e97c24ef74d108d26725d38f73db5e39) . The problem is related to the state machine and asynchronous message reading in geofence.cpp.I'm here to assist further if needed.\r\n\r\nHi! Do you mean that when you update the geofence, you would want the mission feasibility checks to be run immediately against it, and then\r\n- (A) reject the geofence update if the mission feasibility check then would fail\r\n- (B) make the mission invalid\r\n\r\n?\r\n",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2023-12-15T15:29:08Z",
          "body": "\r\n> Hi! Do you mean that when you update the geofence, you would want the mission feasibility checks to be run immediately against it, and then\r\n> \r\n> * reject the geofence update if the mission feasibility check then would fail\r\n> * make the mission invalid\r\n\r\nYes.\r\n\r\nCurrently, the same upload button doesn't trigger a check when updating only the fence, only updating the mission triggers a check, which I think is patently unreasonable.\r\n\r\nFor example, a scenario like this: a user plans a task in advance and passes the check, is ready to execute it some time later, but doesn't get a notification that the task is not compliant until just before execution.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-22T11:36:18Z",
          "body": ">Yes.\r\n\r\nIt wasn't a yes/no question :sweat_smile: \r\nWhich of the two options would you prefer? A or B? Before we decide on that we cannot implement anything. ",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2023-12-22T12:18:10Z",
          "body": "> It wasn't a yes/no question ðŸ˜… Which of the two options would you prefer? A or B? Before we decide on that we cannot implement anything.\r\n\r\nwhen I update the geofence, I need the mission feasibility checks to be run immediately.\r\nSince the geofence and mission updates are under the same button \"upload\", we just need to reject this update(include geofence and mission if they have been updated) and leave it as it was before we clicked upload.So,it is a yes/no question.ðŸ˜€\r\n\r\n\r\nSince now there is already a feasibility check in the module of the mission, when a new upload of a new mission is not available, it will be rejected.\r\nWe can accomplish the above by simply adding the same check to the geofence.Like this:https://github.com/PX4/PX4-Autopilot/pull/22531\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-12-22T12:29:57Z",
          "body": "> > It wasn't a yes/no question ðŸ˜… Which of the two options would you prefer? A or B? Before we decide on that we cannot implement anything.\r\n> \r\n> when I update the geofence, I need the mission feasibility checks to be run immediately. Since the geofence and mission updates are under the same button \"upload\", we just need to reject this update(include geofence and mission if they have been updated) and leave it as it was before we clicked upload.So,it is a yes/no question.ðŸ˜€\r\n> \r\n> Since now there is already a feasibility check in the module of the mission, when a new upload of a new mission is not available, it will be rejected. We can accomplish the above by simply adding the same check to the geofence.Like this:#22531\r\n\r\nBut isn't that exactly option A? You propose to reject the GF if it's not compatible with the mission.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2023-12-22T12:53:36Z",
          "body": "> But isn't that exactly option A? You propose to reject the GF if it's not compatible with the mission.\r\n\r\nYes,you are right!\r\nI want to reject a whole round of uploads that aren't feasible, and if the upload only updates the geofence, it's case A.",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2024-07-25T01:09:08Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-v1-15-public-changes-what-needs-docs/39850/1\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "mcsauder",
          "created_at": "",
          "body": "This is a nice simplification and improvement.  Thanks @sfuhrer !",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "Drone-Lab",
          "created_at": "",
          "body": " Hello @sfuhrer  ! It appears there might be a potential issue with the invocation of the checkMissionAgainstGeofence() function when only the geofence undergoes an update 484a44e5e97c24ef74d108d26725d38f73db5e39 .  The problem is related to the state machine and asynchronous message reading in geofence.cpp.I'm here to assist further if needed. ",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes multiple incorrect behaviors in geofence handling (e.g. not listening to GF_SOURCE, repeatedly sending reposition waypoints for fixedâ€‘wing when breached, incorrect triggering when crossing inclusion boundaries, and missing checks that allow uploading a geofence that would immediately trigger). These are logic-level bugs (state-machine/conditional and data-flow issues) that cause incorrect runtime behavior without crashing. Note: reviewers also flagged a related asynchronous/state-machine invocation (checkMissionAgainstGeofence on fence-only updates) that may need further attention or tests.",
    "patches": {
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2020 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2020-2023 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -75,7 +75,6 @@ void GeofenceBreachAvoidance::setHomePosition(double lat, double lon, float alt)\n {\n \t_home_lat_lon(0) = lat;\n \t_home_lat_lon(1) = lon;\n-\t_home_alt_amsl = alt;\n }\n \n matrix::Vector2<double> GeofenceBreachAvoidance::waypointFromBearingAndDistance(matrix::Vector2<double>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.cpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2020 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2020-2023 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -39,7 +39,7 @@\n \n class Geofence;\n \n-#define GEOFENCE_CHECK_INTERVAL_US 200000\n+#define GEOFENCE_CHECK_INTERVAL_US 200000 // 0.2s\n \n union geofence_violation_type_u {\n \tstruct {\n@@ -95,8 +95,6 @@ class GeofenceBreachAvoidance : public ModuleParams\n \n \tvoid setMaxHorDistHome(float dist) { _max_hor_dist_home = dist; }\n \n-\tvoid setMaxVerDistHome(float dist) { _max_ver_dist_home = dist; }\n-\n \tvoid updateParameters();\n \n private:\n@@ -134,10 +132,8 @@ class GeofenceBreachAvoidance : public ModuleParams\n \n \tmatrix::Vector2<double> _current_pos_lat_lon{};\n \tmatrix::Vector2<double> _home_lat_lon {};\n-\tfloat _home_alt_amsl{0.0f};\n \n \tfloat _max_hor_dist_home{0.0f};\n-\tfloat _max_ver_dist_home{0.0f};\n \n \tvoid updateMinHorDistToFenceMultirotor();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.h"
      },
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 124,
        "changes": 193,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2013,2017 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2013-2023 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -51,12 +51,9 @@\n \n #include \"navigator.h\"\n \n-#define GEOFENCE_RANGE_WARNING_LIMIT 5000000\n-\n Geofence::Geofence(Navigator *navigator) :\n \tModuleParams(navigator),\n-\t_navigator(navigator),\n-\t_sub_airdata(ORB_ID(vehicle_air_data))\n+\t_navigator(navigator)\n {\n \tif (_navigator != nullptr) {\n \t\tupdateFence();\n@@ -232,7 +229,17 @@ void Geofence::_updateFence()\n \t\t\t\t\tcurrent_seq += mission_fence_point.vertex_count;\n \t\t\t\t}\n \n-\t\t\t\t++_num_polygons;\n+\t\t\t\t// check if requiremetns for Home location are met\n+\t\t\t\tconst bool home_check_okay = checkHomeRequirementsForGeofence(polygon);\n+\n+\t\t\t\t// check if current position is inside the fence and vehicle is armed\n+\t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n+\n+\t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n+\t\t\t\tif (home_check_okay && current_position_check_okay) {\n+\t\t\t\t\t++_num_polygons;\n+\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tbreak;\n@@ -245,100 +252,66 @@ void Geofence::_updateFence()\n \t}\n }\n \n-bool Geofence::checkAll(const struct vehicle_global_position_s &global_position)\n+bool Geofence::checkHomeRequirementsForGeofence(const PolygonInfo &polygon)\n {\n-\treturn checkAll(global_position.lat, global_position.lon, global_position.alt);\n-}\n-\n-bool Geofence::checkAll(const struct vehicle_global_position_s &global_position, const float alt)\n-{\n-\treturn checkAll(global_position.lat, global_position.lon, alt);\n-}\n-\n-bool Geofence::checkAll(double lat, double lon, float altitude)\n-{\n-\tbool inside_fence = isCloserThanMaxDistToHome(lat, lon, altitude);\n-\n-\tinside_fence = inside_fence && isBelowMaxAltitude(altitude);\n-\n-\t// to be inside the geofence both fences have to report being inside\n-\t// as they both report being inside when not enabled\n-\tinside_fence = inside_fence && isInsidePolygonOrCircle(lat, lon, altitude);\n+\tbool checks_pass = true;\n \n-\tif (inside_fence) {\n-\t\t_outside_counter = 0;\n-\t\treturn inside_fence;\n-\n-\t} else {\n-\t\t_outside_counter++;\n+\tif (_navigator->home_global_position_valid()) {\n+\t\tchecks_pass = checkPointAgainstPolygonCircle(polygon, _navigator->get_home_position()->lat,\n+\t\t\t\t_navigator->get_home_position()->lon,\n+\t\t\t\t_navigator->get_home_position()->alt);\n+\t}\n \n-\t\tif (_outside_counter > _param_gf_count.get()) {\n-\t\t\treturn inside_fence;\n \n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n+\tif (!checks_pass) {\n+\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence invalid, doesn't contain Home position\\t\");\n+\t\tevents::send(events::ID(\"navigator_geofence_invalid_against_home\"), {events::Log::Critical, events::LogInternal::Warning},\n+\t\t\t     \"Geofence invalid, doesn't contain Home position\");\n \t}\n+\n+\treturn checks_pass;\n }\n \n-bool Geofence::check(const vehicle_global_position_s &global_position, const sensor_gps_s &gps_position)\n+bool Geofence::checkCurrentPositionRequirementsForGeofence(const PolygonInfo &polygon)\n {\n-\tif (_param_gf_altmode.get() == Geofence::GF_ALT_MODE_WGS84) {\n-\t\tif (getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n-\t\t\treturn checkAll(global_position);\n+\tbool checks_pass = true;\n \n-\t\t} else {\n-\t\t\treturn checkAll(gps_position.latitude_deg, gps_position.longitude_deg, gps_position.altitude_msl_m);\n-\t\t}\n-\n-\t} else {\n-\t\t// get baro altitude\n-\t\t_sub_airdata.update();\n-\t\tconst float baro_altitude_amsl = _sub_airdata.get().baro_alt_meter;\n-\n-\t\tif (getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n-\t\t\treturn checkAll(global_position, baro_altitude_amsl);\n+\t// do not allow upload of geofence if vehicle is flying and current geofence would be immediately violated\n+\tif (getGeofenceAction() != geofence_result_s::GF_ACTION_NONE && !_navigator->get_land_detected()->landed) {\n+\t\tchecks_pass = checkPointAgainstPolygonCircle(polygon, _navigator->get_global_position()->lat,\n+\t\t\t\t_navigator->get_global_position()->lon, _navigator->get_global_position()->alt);\n+\t}\n \n-\t\t} else {\n-\t\t\treturn checkAll(gps_position.latitude_deg, gps_position.longitude_deg, baro_altitude_amsl);\n-\t\t}\n+\tif (!checks_pass) {\n+\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence invalid, doesn't contain current vehicle position\\t\");\n+\t\tevents::send(events::ID(\"navigator_geofence_invalid_against_cur_pos\"), {events::Log::Critical, events::LogInternal::Warning},\n+\t\t\t     \"Geofence invalid, doesn't contain current vehicle position\");\n \t}\n+\n+\treturn checks_pass;\n }\n \n-bool Geofence::check(const struct mission_item_s &mission_item)\n+\n+bool Geofence::checkPointAgainstAllGeofences(double lat, double lon, float altitude)\n {\n-\treturn checkAll(mission_item.lat, mission_item.lon, mission_item.altitude);\n+\tconst bool inside_fence = isCloserThanMaxDistToHome(lat, lon, altitude) && isBelowMaxAltitude(altitude)\n+\t\t\t\t  && isInsidePolygonOrCircle(lat, lon, altitude);\n+\treturn inside_fence;\n }\n \n bool Geofence::isCloserThanMaxDistToHome(double lat, double lon, float altitude)\n {\n \tbool inside_fence = true;\n \n-\tif (isHomeRequired() && _navigator->home_global_position_valid()) {\n-\n-\t\tconst float max_horizontal_distance = _param_gf_max_hor_dist.get();\n-\n-\t\tconst double home_lat = _navigator->get_home_position()->lat;\n-\t\tconst double home_lon = _navigator->get_home_position()->lon;\n-\t\tconst float home_alt = _navigator->get_home_position()->alt;\n+\tif (_param_gf_max_hor_dist.get() > FLT_EPSILON && _navigator->home_global_position_valid()) {\n \n \t\tfloat dist_xy = -1.0f;\n \t\tfloat dist_z = -1.0f;\n \n-\t\tget_distance_to_point_global_wgs84(lat, lon, altitude, home_lat, home_lon, home_alt, &dist_xy, &dist_z);\n+\t\tget_distance_to_point_global_wgs84(lat, lon, altitude, _navigator->get_home_position()->lat,\n+\t\t\t\t\t\t   _navigator->get_home_position()->lon, _navigator->get_home_position()->alt, &dist_xy, &dist_z);\n \n-\t\tif (max_horizontal_distance > FLT_EPSILON && (dist_xy > max_horizontal_distance)) {\n-\t\t\tif (hrt_elapsed_time(&_last_horizontal_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum distance from home reached (%.5f)\\t\",\n-\t\t\t\t\t\t     (double)max_horizontal_distance);\n-\t\t\t\tevents::send<float>(events::ID(\"navigator_geofence_max_dist_from_home\"), {events::Log::Critical, events::LogInternal::Warning},\n-\t\t\t\t\t\t    \"Geofence: maximum distance from home reached ({1:.0m})\",\n-\t\t\t\t\t\t    max_horizontal_distance);\n-\t\t\t\t_last_horizontal_range_warning = hrt_absolute_time();\n-\t\t\t}\n-\n-\t\t\tinside_fence = false;\n-\t\t}\n+\t\tinside_fence = dist_xy < _param_gf_max_hor_dist.get();\n \t}\n \n \treturn inside_fence;\n@@ -348,25 +321,10 @@ bool Geofence::isBelowMaxAltitude(float altitude)\n {\n \tbool inside_fence = true;\n \n-\tif (isHomeRequired() && _navigator->home_alt_valid()) {\n-\n-\t\tconst float max_vertical_distance = _param_gf_max_ver_dist.get();\n-\t\tconst float home_alt = _navigator->get_home_position()->alt;\n-\n-\t\tfloat dist_z = altitude - home_alt;\n-\n-\t\tif (max_vertical_distance > FLT_EPSILON && (dist_z > max_vertical_distance)) {\n-\t\t\tif (hrt_elapsed_time(&_last_vertical_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum altitude above home reached (%.5f)\\t\",\n-\t\t\t\t\t\t     (double)max_vertical_distance);\n-\t\t\t\tevents::send<float>(events::ID(\"navigator_geofence_max_alt_from_home\"), {events::Log::Critical, events::LogInternal::Warning},\n-\t\t\t\t\t\t    \"Geofence: maximum altitude above home reached ({1:.0m_v})\",\n-\t\t\t\t\t\t    max_vertical_distance);\n-\t\t\t\t_last_vertical_range_warning = hrt_absolute_time();\n-\t\t\t}\n+\tif (_param_gf_max_ver_dist.get() > FLT_EPSILON && _navigator->home_alt_valid()) {\n \n-\t\t\tinside_fence = false;\n-\t\t}\n+\t\tconst float dist_z = altitude - _navigator->get_home_position()->alt;\n+\t\tinside_fence = dist_z < _param_gf_max_ver_dist.get();\n \t}\n \n \treturn inside_fence;\n@@ -387,46 +345,33 @@ bool Geofence::isInsidePolygonOrCircle(double lat, double lon, float altitude)\n \t}\n \n \t/* Horizontal check: iterate all polygons & circles */\n-\tbool outside_exclusion = true;\n-\tbool inside_inclusion = false;\n-\tbool had_inclusion_areas = false;\n+\tbool checksPass = true;\n \n \tfor (int polygon_index = 0; polygon_index < _num_polygons; ++polygon_index) {\n-\t\tif (_polygons[polygon_index].fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n-\t\t\tbool inside = insideCircle(_polygons[polygon_index], lat, lon, altitude);\n-\n-\t\t\tif (inside) {\n-\t\t\t\tinside_inclusion = true;\n-\t\t\t}\n-\n-\t\t\thad_inclusion_areas = true;\n+\t\tchecksPass &= checkPointAgainstPolygonCircle(_polygons[polygon_index], lat, lon, altitude);\n+\t}\n \n-\t\t} else if (_polygons[polygon_index].fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n-\t\t\tbool inside = insideCircle(_polygons[polygon_index], lat, lon, altitude);\n+\treturn checksPass;\n+}\n \n-\t\t\tif (inside) {\n-\t\t\t\toutside_exclusion = false;\n-\t\t\t}\n+bool Geofence::checkPointAgainstPolygonCircle(const PolygonInfo &polygon, double lat, double lon, float altitude)\n+{\n+\tbool checksPass = true;\n \n-\t\t} else { // it's a polygon\n-\t\t\tbool inside = insidePolygon(_polygons[polygon_index], lat, lon, altitude);\n+\tif (polygon.fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n+\t\tchecksPass &= insideCircle(polygon, lat, lon, altitude);\n \n-\t\t\tif (_polygons[polygon_index].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n-\t\t\t\tif (inside) {\n-\t\t\t\t\tinside_inclusion = true;\n-\t\t\t\t}\n+\t} else if (polygon.fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n+\t\tchecksPass &= !insideCircle(polygon, lat, lon, altitude);\n \n-\t\t\t\thad_inclusion_areas = true;\n+\t} else if (polygon.fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n+\t\tchecksPass &= insidePolygon(polygon, lat, lon, altitude);\n \n-\t\t\t} else { // exclusion\n-\t\t\t\tif (inside) {\n-\t\t\t\t\toutside_exclusion = false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t} else if (polygon.fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION) {\n+\t\tchecksPass &= !insidePolygon(polygon, lat, lon, altitude);\n \t}\n \n-\treturn (!had_inclusion_areas || inside_inclusion) && outside_exclusion;\n+\treturn checksPass;\n }\n \n bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon, float altitude)\n@@ -693,7 +638,7 @@ void Geofence::printStatus()\n \t\t}\n \t}\n \n-\tPX4_INFO(\"Geofence: %i inclusion, %i exclusion polygons, %i inclusion, %i exclusion circles, %i total vertices\",\n+\tPX4_INFO(\"Geofence: %i inclusion, %i exclusion polygons, %i inclusion circles, %i exclusion circles, %i total vertices\",\n \t\t num_inclusion_polygons, num_exclusion_polygons, num_inclusion_circles, num_exclusion_circles,\n \t\t total_num_vertices);\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 32,
        "deletions": 45,
        "changes": 77,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2013 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2013-2023 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -52,7 +52,6 @@\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/sensor_gps.h>\n-#include <uORB/topics/vehicle_air_data.h>\n \n #define GEOFENCE_FILENAME PX4_STORAGEDIR\"/etc/geofence.txt\"\n \n@@ -66,12 +65,6 @@ class Geofence : public ModuleParams\n \tGeofence &operator=(const Geofence &) = delete;\n \tvirtual ~Geofence();\n \n-\t/* Altitude mode, corresponding to the param GF_ALTMODE */\n-\tenum {\n-\t\tGF_ALT_MODE_WGS84 = 0,\n-\t\tGF_ALT_MODE_AMSL = 1\n-\t};\n-\n \t/* Source, corresponding to the param GF_SOURCE */\n \tenum {\n \t\tGF_SOURCE_GLOBALPOS = 0,\n@@ -88,30 +81,29 @@ class Geofence : public ModuleParams\n \t */\n \tvoid updateFence();\n \n+\n \t/**\n-\t * Return whether the system obeys the geofence.\n+\t * Check if a 3D point passes the Geofence test.\n+\t * Checks max distance, max altitude, inside polygon or circle.\n+\t * In addition to checkPolygons(), this takes all additional parameters into account.\n \t *\n-\t * @return true: system is obeying fence, false: system is violating fence\n+\t * @return false for a geofence violation\n \t */\n-\tbool check(const vehicle_global_position_s &global_position, const sensor_gps_s &gps_position);\n+\tbool checkPointAgainstAllGeofences(double lat, double lon, float altitude);\n \n \t/**\n-\t * Return whether a mission item obeys the geofence.\n+\t * @brief check if the horizontal distance to Home is greater than the maximum allowed distance\n \t *\n-\t * @return true: system is obeying fence, false: system is violating fence\n+\t * @return true if the horizontal distance to Home is smaller than the maximum allowed distance\n \t */\n-\tbool check(const struct mission_item_s &mission_item);\n+\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n+\n \n \t/**\n-\t * Check if a point passes the Geofence test.\n-\t * In addition to checkPolygons(), this takes all additional parameters into account.\n+\t * @brief check if the altitude above Home is greater than the maximum allowed altitude\n \t *\n-\t * @return false for a geofence violation\n+\t * @return true if the altitude above Home is smaller than the maximum allowed altitude\n \t */\n-\tbool checkAll(double lat, double lon, float altitude);\n-\n-\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n-\n \tbool isBelowMaxAltitude(float altitude);\n \n \tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n@@ -147,7 +139,6 @@ class Geofence : public ModuleParams\n \tint getGeofenceAction() { return _param_gf_action.get(); }\n \n \tfloat getMaxHorDistanceHome() { return _param_gf_max_hor_dist.get(); }\n-\tfloat getMaxVerDistanceHome() { return _param_gf_max_ver_dist.get(); }\n \tbool getPredict() { return _param_gf_predict.get(); }\n \n \tbool isHomeRequired();\n@@ -185,19 +176,14 @@ class Geofence : public ModuleParams\n \tDatamanCache _dataman_cache{\"geofence_dm_cache_miss\", 4};\n \tDatamanClient\t&_dataman_client = _dataman_cache.client();\n \n-\thrt_abstime _last_horizontal_range_warning{0};\n-\thrt_abstime _last_vertical_range_warning{0};\n-\n \tfloat _altitude_min{0.0f};\n \tfloat _altitude_max{0.0f};\n \n \tint _num_polygons{0};\n \n \tMapProjection _projection_reference{}; ///< class to convert (lon, lat) to local [m]\n \n-\tuORB::SubscriptionData<vehicle_air_data_s> _sub_airdata;\n \n-\tint _outside_counter{0};\n \tuint16_t _update_counter{0}; ///< dataman update counter: if it does not match, polygon data was updated\n \tbool _fence_updated{true};  ///< flag indicating if fence are updated to dataman cache\n \tbool _initiate_fence_updated{true}; ///< flag indicating if fence updated is needed\n@@ -207,22 +193,6 @@ class Geofence : public ModuleParams\n \t */\n \tvoid _updateFence();\n \n-\t/**\n-\t * Check if a point passes the Geofence test.\n-\t * This takes all polygons and minimum & maximum altitude into account\n-\t *\n-\t * The check passes if: (inside(polygon_inclusion_1) || inside(polygon_inclusion_2) || ... ) &&\n-\t *                       !inside(polygon_exclusion_1) && !inside(polygon_exclusion_2) && ...\n-\t *                       && (altitude within [min, max])\n-\t *                  or: no polygon configured\n-\t * @return result of the check above (false for a geofence violation)\n-\t */\n-\tbool checkPolygons(double lat, double lon, float altitude);\n-\n-\n-\n-\tbool checkAll(const vehicle_global_position_s &global_position);\n-\tbool checkAll(const vehicle_global_position_s &global_position, float baro_altitude_amsl);\n \n \t/**\n \t * Check if a single point is within a polygon\n@@ -237,11 +207,28 @@ class Geofence : public ModuleParams\n \t */\n \tbool insideCircle(const PolygonInfo &polygon, double lat, double lon, float altitude);\n \n+\t/**\n+\t * Check if a single point is within a polygon or circle\n+\t * @return true if within polygon or circle\n+\t */\n+\n+\tbool checkPointAgainstPolygonCircle(const PolygonInfo &polygon, double lat, double lon, float altitude);\n+\n+\t/**\n+\t * Check polygon or circle geofence fullfills the requirements relative to Home.\n+\t * @return true if checks pass\n+\t */\n+\tbool checkHomeRequirementsForGeofence(const PolygonInfo &polygon);\n+\n+\t/**\n+\t * Check polygon or circle geofence fullfills the requirements relative to the current vehicle position.\n+\t * @return true if checks pass\n+\t */\n+\tbool checkCurrentPositionRequirementsForGeofence(const PolygonInfo &polygon);\n+\n \tDEFINE_PARAMETERS(\n \t\t(ParamInt<px4::params::GF_ACTION>)         _param_gf_action,\n-\t\t(ParamInt<px4::params::GF_ALTMODE>)        _param_gf_altmode,\n \t\t(ParamInt<px4::params::GF_SOURCE>)         _param_gf_source,\n-\t\t(ParamInt<px4::params::GF_COUNT>)          _param_gf_count,\n \t\t(ParamFloat<px4::params::GF_MAX_HOR_DIST>) _param_gf_max_hor_dist,\n \t\t(ParamFloat<px4::params::GF_MAX_VER_DIST>) _param_gf_max_ver_dist,\n \t\t(ParamBool<px4::params::GF_PREDICT>)       _param_gf_predict",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 8,
        "deletions": 31,
        "changes": 39,
        "patch": "@@ -61,19 +61,6 @@\n  */\n PARAM_DEFINE_INT32(GF_ACTION, 2);\n \n-/**\n- * Geofence altitude mode\n- *\n- * Select which altitude (AMSL) source should be used for geofence calculations.\n- *\n- * @min 0\n- * @max 1\n- * @value 0 Autopilot estimator global position altitude (GPS)\n- * @value 1 Raw barometer altitude (assuming standard atmospheric pressure)\n- * @group Geofence\n- */\n-PARAM_DEFINE_INT32(GF_ALTMODE, 0);\n-\n /**\n  * Geofence source\n  *\n@@ -90,42 +77,32 @@ PARAM_DEFINE_INT32(GF_ALTMODE, 0);\n PARAM_DEFINE_INT32(GF_SOURCE, 0);\n \n /**\n- * Geofence counter limit\n- *\n- * Set how many subsequent position measurements outside of the fence are needed before geofence violation is triggered\n- *\n- * @min -1\n- * @max 10\n- * @increment 1\n- * @group Geofence\n- */\n-PARAM_DEFINE_INT32(GF_COUNT, -1);\n-\n-/**\n- * Max horizontal distance in meters.\n+ * Max horizontal distance from Home\n  *\n- * Maximum horizontal distance in meters the vehicle can be from home before triggering a geofence action. Disabled if 0.\n+ * Maximum horizontal distance in meters the vehicle can be from Home before triggering a geofence action.\n+ * Disabled if 0.\n  *\n  * @unit m\n  * @min 0\n  * @max 10000\n  * @increment 1\n  * @group Geofence\n  */\n-PARAM_DEFINE_FLOAT(GF_MAX_HOR_DIST, 0);\n+PARAM_DEFINE_FLOAT(GF_MAX_HOR_DIST, 0.0f);\n \n /**\n- * Max vertical distance in meters.\n+ * Max vertical distance from Home\n  *\n- * Maximum vertical distance in meters the vehicle can be from home before triggering a geofence action. Disabled if 0.\n+ * Maximum vertical distance in meters the vehicle can be from Home before triggering a geofence action.\n+ * Disabled if 0.\n  *\n  * @unit m\n  * @min 0\n  * @max 10000\n  * @increment 1\n  * @group Geofence\n  */\n-PARAM_DEFINE_FLOAT(GF_MAX_VER_DIST, 0);\n+PARAM_DEFINE_FLOAT(GF_MAX_VER_DIST, 0.0f);\n \n /**\n  * [EXPERIMENTAL] Use Pre-emptive geofence triggering",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "patch": "@@ -97,15 +97,15 @@ MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission)\n \n \tfailed |= _feasibility_checker.someCheckFailed();\n \n-\tfailed |= !checkGeofence(mission, _navigator->get_home_position()->alt, home_valid);\n+\tfailed |= !checkMissionAgainstGeofence(mission, _navigator->get_home_position()->alt, home_valid);\n \n \t_navigator->get_mission_result()->warning = failed;\n \n \treturn !failed;\n }\n \n bool\n-MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_alt, bool home_valid)\n+MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission, float home_alt, bool home_valid)\n {\n \tif (_navigator->get_geofence().isHomeRequired() && !home_valid) {\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\\t\");\n@@ -137,7 +137,8 @@ MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_al\n \t\t\t// Geofence function checks against home altitude amsl\n \t\t\tmissionitem.altitude = missionitem.altitude_is_relative ? missionitem.altitude + home_alt : missionitem.altitude;\n \n-\t\t\tif (MissionBlock::item_contains_position(missionitem) && !_navigator->get_geofence().check(missionitem)) {\n+\t\t\tif (MissionBlock::item_contains_position(missionitem) && !_navigator->get_geofence().checkPointAgainstAllGeofences(\n+\t\t\t\t    missionitem.lat, missionitem.lon, missionitem.altitude)) {\n \n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %zu\\t\", i + 1);\n \t\t\t\tevents::send<int16_t>(events::ID(\"navigator_mis_geofence_violation\"), {events::Log::Error, events::LogInternal::Info},",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -47,7 +47,6 @@\n #include <px4_platform_common/module_params.h>\n #include \"MissionFeasibility/FeasibilityChecker.hpp\"\n \n-class Geofence;\n class Navigator;\n \n class MissionFeasibilityChecker: public ModuleParams\n@@ -57,7 +56,7 @@ class MissionFeasibilityChecker: public ModuleParams\n \tDatamanClient &_dataman_client;\n \tFeasibilityChecker _feasibility_checker;\n \n-\tbool checkGeofence(const mission_s &mission, float home_alt, bool home_valid);\n+\tbool checkMissionAgainstGeofence(const mission_s &mission, float home_alt, bool home_valid);\n \n public:\n \tMissionFeasibilityChecker(Navigator *navigator, DatamanClient &dataman_client) :",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -260,7 +260,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool abort_landing();\n \n-\tvoid geofence_breach_check(bool &have_geofence_position_data);\n+\tvoid geofence_breach_check();\n \n \t// Param access\n \tint get_loiter_min_alt() const { return _param_min_ltr_alt.get(); }\n@@ -335,7 +335,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tGeofenceBreachAvoidance _gf_breach_avoidance;\n \thrt_abstime _last_geofence_check = 0;\n \n-\tbool\t\t_geofence_violation_warning_sent{false};\t/**< prevents spaming to mavlink */\n+\tbool\t\t_geofence_reposition_sent{false};\t\t/**< flag if reposition command has been sent for current geofence breach*/\n+\thrt_abstime\t_time_loitering_after_gf_breach{0};\t\t/**< timestamp of when loitering after a geofence breach was started */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t\t/**< flags if position SP triplet needs to be published */\n \tbool \t\t_pos_sp_triplet_published_invalid_once{false};\t/**< flags if position SP triplet has been published once to UORB */\n \tbool\t\t_mission_result_updated{false};\t\t\t/**< flags if mission result has seen an update */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 96,
        "deletions": 104,
        "changes": 200,
        "patch": "@@ -148,7 +148,6 @@ void Navigator::params_update()\n \n void Navigator::run()\n {\n-\tbool have_geofence_position_data = false;\n \n \t/* Try to load the geofence:\n \t * if /fs/microsd/etc/geofence.txt load from this file */\n@@ -216,19 +215,11 @@ void Navigator::run()\n \t\t/* gps updated */\n \t\tif (_gps_pos_sub.updated()) {\n \t\t\t_gps_pos_sub.copy(&_gps_pos);\n-\n-\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n-\t\t\t\thave_geofence_position_data = true;\n-\t\t\t}\n \t\t}\n \n \t\t/* global position updated */\n \t\tif (_global_pos_sub.updated()) {\n \t\t\t_global_pos_sub.copy(&_global_pos);\n-\n-\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n-\t\t\t\thave_geofence_position_data = true;\n-\t\t\t}\n \t\t}\n \n \t\t/* check for parameter updates */\n@@ -270,8 +261,6 @@ void Navigator::run()\n \t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n \t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n \n-\t\t\t\tbool reposition_valid = true;\n-\n \t\t\t\tvehicle_global_position_s position_setpoint{};\n \n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n@@ -285,11 +274,7 @@ void Navigator::run()\n \n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n \n-\t\t\t\tif (have_geofence_position_data) {\n-\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n-\t\t\t\t}\n-\n-\t\t\t\tif (reposition_valid) {\n+\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n \n@@ -413,6 +398,8 @@ void Navigator::run()\n \n \t\t\t\t\trep->next.valid = false;\n \n+\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n+\n \t\t\t\t} else {\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n \t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n@@ -431,18 +418,12 @@ void Navigator::run()\n \n \t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n \n-\t\t\t\tbool change_altitude_valid = true;\n-\n \t\t\t\tvehicle_global_position_s position_setpoint{};\n \t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n \t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n \n-\t\t\t\tif (have_geofence_position_data) {\n-\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n-\t\t\t\t}\n-\n-\t\t\t\tif (change_altitude_valid) {\n+\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n \n@@ -497,6 +478,8 @@ void Navigator::run()\n \n \t\t\t\t\trep->next.valid = false;\n \n+\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n+\n \t\t\t\t} else {\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n \t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n@@ -510,18 +493,12 @@ void Navigator::run()\n \n \t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n \n-\t\t\t\tbool orbit_location_valid = true;\n-\n \t\t\t\tvehicle_global_position_s position_setpoint{};\n \t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n \t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n \n-\t\t\t\tif (have_geofence_position_data) {\n-\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n-\t\t\t\t}\n-\n-\t\t\t\tif (orbit_location_valid) {\n+\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n@@ -550,6 +527,8 @@ void Navigator::run()\n \t\t\t\t\trep->current.valid = true;\n \t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n \n+\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n+\n \t\t\t\t} else {\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n \t\t\t\t}\n@@ -559,18 +538,12 @@ void Navigator::run()\n #ifdef CONFIG_FIGURE_OF_EIGHT\n \t\t\t\t// Only valid for fixed wing mode\n \n-\t\t\t\tbool orbit_location_valid = true;\n-\n \t\t\t\tvehicle_global_position_s position_setpoint{};\n \t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n \t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n \n-\t\t\t\tif (have_geofence_position_data) {\n-\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n-\t\t\t\t}\n-\n-\t\t\t\tif (orbit_location_valid) {\n+\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n@@ -603,6 +576,8 @@ void Navigator::run()\n \t\t\t\t\trep->current.valid = true;\n \t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n \n+\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n+\n \t\t\t\t} else {\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n \t\t\t\t}\n@@ -772,7 +747,7 @@ void Navigator::run()\n \t\tcheck_traffic();\n \n \t\t/* Check geofence violation */\n-\t\tgeofence_breach_check(have_geofence_position_data);\n+\t\tgeofence_breach_check();\n \n \t\t/* Do stuff according to navigation state set by commander */\n \t\tNavigatorMode *navigation_mode_new{nullptr};\n@@ -927,15 +902,19 @@ void Navigator::run()\n \t}\n }\n \n-void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n+void Navigator::geofence_breach_check()\n {\n-\tif (have_geofence_position_data &&\n-\t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n+\t// reset the _time_loitering_after_gf_breach time if no longer in LOITER (and 100ms after it was triggered)\n+\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER\n+\t    && hrt_elapsed_time(&_time_loitering_after_gf_breach) > 100_ms) {\n+\t\t_time_loitering_after_gf_breach = 0;\n+\t}\n+\n+\tif ((_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n \t    (hrt_elapsed_time(&_last_geofence_check) > GEOFENCE_CHECK_INTERVAL_US)) {\n \n \t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n \n-\t\tmatrix::Vector2<double> fence_violation_test_point;\n \t\tgeofence_violation_type_u gf_violation_type{};\n \t\tfloat test_point_bearing;\n \t\tfloat test_point_distance;\n@@ -961,111 +940,124 @@ void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n \t\t\t}\n \t\t}\n \n+\t\tdouble current_latitude = _global_pos.lat;\n+\t\tdouble current_longitude = _global_pos.lon;\n+\t\tfloat current_altitude = _global_pos.alt;\n+\t\tbool position_valid = _global_pos.timestamp > 0;\n+\n+\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n+\t\t\tcurrent_latitude = _gps_pos.latitude_deg;\n+\t\t\tcurrent_longitude = _gps_pos.longitude_deg;\n+\t\t\tcurrent_altitude = _gps_pos.altitude_msl_m;\n+\t\t\tposition_valid = _global_pos.timestamp > 0;\n+\t\t}\n+\n+\t\tif (!position_valid) {\n+\t\t\t// we don't have a valid position yet, so we can't check for geofence violations\n+\t\t\treturn;\n+\t\t}\n+\n \t\t_gf_breach_avoidance.setHorizontalTestPointDistance(test_point_distance);\n \t\t_gf_breach_avoidance.setVerticalTestPointDistance(vertical_test_point_distance);\n \t\t_gf_breach_avoidance.setTestPointBearing(test_point_bearing);\n-\t\t_gf_breach_avoidance.setCurrentPosition(_global_pos.lat, _global_pos.lon, _global_pos.alt);\n+\t\t_gf_breach_avoidance.setCurrentPosition(current_latitude, current_longitude, current_altitude);\n \t\t_gf_breach_avoidance.setMaxHorDistHome(_geofence.getMaxHorDistanceHome());\n-\t\t_gf_breach_avoidance.setMaxVerDistHome(_geofence.getMaxVerDistanceHome());\n \n \t\tif (home_global_position_valid()) {\n \t\t\t_gf_breach_avoidance.setHomePosition(_home_pos.lat, _home_pos.lon, _home_pos.alt);\n \t\t}\n \n-\t\tif (_geofence.getPredict()) {\n-\t\t\tfence_violation_test_point = _gf_breach_avoidance.getFenceViolationTestPoint();\n+\t\tdouble test_point_latitude = current_latitude;\n+\t\tdouble test_point_longitude = current_longitude;\n+\t\tfloat test_point_altitude = current_altitude;\n \n-\t\t} else {\n-\t\t\tfence_violation_test_point = matrix::Vector2d(_global_pos.lat, _global_pos.lon);\n-\t\t\tvertical_test_point_distance = 0;\n+\t\tif (_geofence.getPredict()) {\n+\t\t\tmatrix::Vector2<double>fence_violation_test_point = _gf_breach_avoidance.getFenceViolationTestPoint();\n+\t\t\ttest_point_latitude = fence_violation_test_point(0);\n+\t\t\ttest_point_longitude = fence_violation_test_point(1);\n+\t\t\ttest_point_altitude = current_altitude + vertical_test_point_distance;\n \t\t}\n \n-\t\tgf_violation_type.flags.dist_to_home_exceeded = !_geofence.isCloserThanMaxDistToHome(fence_violation_test_point(0),\n-\t\t\t\tfence_violation_test_point(1),\n-\t\t\t\t_global_pos.alt);\n+\t\tif (_time_loitering_after_gf_breach > 0) {\n+\t\t\t// if we are in the loitering state after breaching a GF, only allow new ones to be set, but not unset\n+\t\t\t_geofence_result.geofence_max_dist_triggered |= !_geofence.isCloserThanMaxDistToHome(test_point_latitude,\n+\t\t\t\t\ttest_point_longitude, test_point_altitude);\n+\t\t\t_geofence_result.geofence_max_alt_triggered |= !_geofence.isBelowMaxAltitude(test_point_altitude);\n+\t\t\t_geofence_result.geofence_custom_fence_triggered |= !_geofence.isInsidePolygonOrCircle(test_point_latitude,\n+\t\t\t\t\ttest_point_longitude, test_point_altitude);\n \n-\t\tgf_violation_type.flags.max_altitude_exceeded = !_geofence.isBelowMaxAltitude(_global_pos.alt +\n-\t\t\t\tvertical_test_point_distance);\n-\n-\t\tgf_violation_type.flags.fence_violation = !_geofence.isInsidePolygonOrCircle(fence_violation_test_point(0),\n-\t\t\t\tfence_violation_test_point(1),\n-\t\t\t\t_global_pos.alt);\n+\t\t} else {\n+\t\t\t_geofence_result.geofence_max_dist_triggered = !_geofence.isCloserThanMaxDistToHome(test_point_latitude,\n+\t\t\t\t\ttest_point_longitude, test_point_altitude);\n+\t\t\t_geofence_result.geofence_max_alt_triggered = !_geofence.isBelowMaxAltitude(test_point_altitude);\n+\t\t\t_geofence_result.geofence_custom_fence_triggered = !_geofence.isInsidePolygonOrCircle(test_point_latitude,\n+\t\t\t\t\ttest_point_longitude, test_point_altitude);\n+\t\t}\n \n \t\t_last_geofence_check = hrt_absolute_time();\n-\t\thave_geofence_position_data = false;\n \n \t\t_geofence_result.timestamp = hrt_absolute_time();\n-\t\t_geofence_result.primary_geofence_action = _geofence.getGeofenceAction();\n-\t\t_geofence_result.home_required = _geofence.isHomeRequired();\n-\n-\t\tif (gf_violation_type.value) {\n-\t\t\t/* inform other apps via the mission result */\n-\t\t\t_geofence_result.primary_geofence_breached = true;\n-\n-\t\t\tusing geofence_violation_reason_t = events::px4::enums::geofence_violation_reason_t;\n+\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n \n-\t\t\tif (gf_violation_type.flags.fence_violation) {\n-\t\t\t\t_geofence_result.geofence_violation_reason = (uint8_t)geofence_violation_reason_t::fence_violation;\n-\n-\t\t\t} else if (gf_violation_type.flags.max_altitude_exceeded) {\n-\t\t\t\t_geofence_result.geofence_violation_reason = (uint8_t)geofence_violation_reason_t::max_altitude_exceeded;\n-\n-\t\t\t} else if (gf_violation_type.flags.dist_to_home_exceeded) {\n-\t\t\t\t_geofence_result.geofence_violation_reason = (uint8_t)geofence_violation_reason_t::dist_to_home_exceeded;\n-\n-\t\t\t}\n+\t\tif (_geofence_result.geofence_max_dist_triggered || _geofence_result.geofence_max_alt_triggered ||\n+\t\t    _geofence_result.geofence_custom_fence_triggered) {\n \n \t\t\t/* Issue a warning about the geofence violation once and only if we are armed */\n-\t\t\tif (!_geofence_violation_warning_sent && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n+\t\t\tif (!_geofence_reposition_sent && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED\n+\t\t\t    && _geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n \n \t\t\t\t// we have predicted a geofence violation and if the action is to loiter then\n \t\t\t\t// demand a reposition to a location which is inside the geofence\n-\t\t\t\tif (_geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n-\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \n-\t\t\t\t\tmatrix::Vector2<double> loiter_center_lat_lon;\n-\t\t\t\t\tmatrix::Vector2<double> current_pos_lat_lon(_global_pos.lat, _global_pos.lon);\n-\t\t\t\t\tfloat loiter_altitude_amsl = _global_pos.alt;\n+\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n+\n+\t\t\t\tmatrix::Vector2<double> loiter_center_lat_lon;\n \n+\t\t\t\tfloat loiter_altitude_amsl = current_altitude;\n+\t\t\t\tdouble loiter_latitude = current_latitude;\n+\t\t\t\tdouble loiter_longitude = current_longitude;\n \n+\t\t\t\tif (_geofence.getPredict()) {\n \t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n \t\t\t\t\t\t// the computation of the braking distance does not match the actual braking distance. Until we have a better model\n \t\t\t\t\t\t// we set the loiter point to the current position, that will make sure that the vehicle will loiter inside the fence\n \t\t\t\t\t\tloiter_center_lat_lon =  _gf_breach_avoidance.generateLoiterPointForMultirotor(gf_violation_type,\n \t\t\t\t\t\t\t\t\t &_geofence);\n+\t\t\t\t\t\tloiter_latitude = loiter_center_lat_lon(0);\n+\t\t\t\t\t\tloiter_longitude = loiter_center_lat_lon(1);\n \n \t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForMulticopter(gf_violation_type);\n \n \t\t\t\t\t} else {\n \n \t\t\t\t\t\tloiter_center_lat_lon = _gf_breach_avoidance.generateLoiterPointForFixedWing(gf_violation_type, &_geofence);\n+\t\t\t\t\t\tloiter_latitude = loiter_center_lat_lon(0);\n+\t\t\t\t\t\tloiter_longitude = loiter_center_lat_lon(1);\n+\n \t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForFixedWing(gf_violation_type);\n \t\t\t\t\t}\n-\n-\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n-\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n-\t\t\t\t\trep->current.yaw_valid = true;\n-\t\t\t\t\trep->current.lat = loiter_center_lat_lon(0);\n-\t\t\t\t\trep->current.lon = loiter_center_lat_lon(1);\n-\t\t\t\t\trep->current.alt = loiter_altitude_amsl;\n-\t\t\t\t\trep->current.valid = true;\n-\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n-\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n-\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n-\n \t\t\t\t}\n \n-\t\t\t\t_geofence_violation_warning_sent = true;\n+\t\t\t\trep->current.timestamp = hrt_absolute_time();\n+\t\t\t\trep->current.yaw = get_local_position()->heading;\n+\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\trep->current.lat = loiter_latitude;\n+\t\t\t\trep->current.lon = loiter_longitude;\n+\t\t\t\trep->current.alt = loiter_altitude_amsl;\n+\t\t\t\trep->current.valid = true;\n+\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n+\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n+\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\n+\t\t\t\t_geofence_reposition_sent = true;\n+\t\t\t\t_time_loitering_after_gf_breach = hrt_absolute_time();\n \t\t\t}\n \n \t\t} else {\n-\t\t\t/* inform other apps via the mission result */\n-\t\t\t_geofence_result.primary_geofence_breached = false;\n \n-\t\t\t/* Reset the _geofence_violation_warning_sent field */\n-\t\t\t_geofence_violation_warning_sent = false;\n+\t\t\t_geofence_reposition_sent = false;\n \t\t}\n \n \t\t_geofence_result_pub.publish(_geofence_result);\n@@ -1470,8 +1462,8 @@ bool Navigator::geofence_allows_position(const vehicle_global_position_s &pos)\n \tif ((_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n \t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_WARN)) {\n \n-\t\tif (PX4_ISFINITE(pos.lat) && PX4_ISFINITE(pos.lon)) {\n-\t\t\treturn _geofence.check(pos, _gps_pos);\n+\t\tif (PX4_ISFINITE(pos.lat) && PX4_ISFINITE(pos.lon) && PX4_ISFINITE(pos.alt)) {\n+\t\t\treturn _geofence.checkPointAgainstAllGeofences(pos.lat, pos.lon, pos.alt);\n \t\t}\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0e1e471791e8771027b4d9b89e923b10e795e86/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "matrix::Vector2d",
        "setMaxVerDistHome",
        "Geofence::printStatus",
        "check",
        "altitude",
        "MissionFeasibilityChecker::checkGeofence",
        "Geofence::_updateFence",
        "Geofence::isBelowMaxAltitude",
        "Navigator::params_update",
        "isCloserThanMaxDistToHome",
        "getMaxVerDistanceHome",
        "checkGeofence",
        "geofence_breach_check",
        "checkAll",
        "Navigator::run",
        "Navigator::geofence_allows_position",
        "Copyright",
        "Geofence::checkAll",
        "Geofence::check",
        "MissionFeasibilityChecker::checkMissionFeasible",
        "checkPolygons",
        "Navigator::geofence_breach_check",
        "Geofence::isInsidePolygonOrCircle",
        "GeofenceBreachAvoidance::setHomePosition"
      ],
      "by_file": {
        "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": [
          "GeofenceBreachAvoidance::setHomePosition",
          "Copyright"
        ],
        "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h": [
          "setMaxVerDistHome",
          "Copyright"
        ],
        "src/modules/navigator/geofence.cpp": [
          "checkAll",
          "Copyright",
          "Geofence::checkAll",
          "Geofence::check",
          "Geofence::printStatus",
          "Geofence::isInsidePolygonOrCircle",
          "Geofence::_updateFence",
          "Geofence::isBelowMaxAltitude"
        ],
        "src/modules/navigator/geofence.h": [
          "isCloserThanMaxDistToHome",
          "getMaxVerDistanceHome",
          "checkAll",
          "Copyright",
          "checkPolygons",
          "check"
        ],
        "src/modules/navigator/geofence_params.c": [
          "altitude"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkGeofence",
          "MissionFeasibilityChecker::checkMissionFeasible"
        ],
        "src/modules/navigator/mission_feasibility_checker.h": [
          "checkGeofence"
        ],
        "src/modules/navigator/navigator.h": [
          "geofence_breach_check"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "matrix::Vector2d",
          "Navigator::run",
          "Navigator::geofence_allows_position",
          "Navigator::geofence_breach_check",
          "Navigator::params_update"
        ]
      }
    }
  },
  {
    "title": "Remove LNDMC_ALT_MAX",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22376",
    "number": 22376,
    "created_at": "2023-11-15T14:03:51Z",
    "merged": true,
    "merged_at": "2023-11-20T13:52:35Z",
    "state": "closed",
    "conversation": {
      "author": "MaEtUgR",
      "body": "### Solved Problem\r\nWhen discussing with @sfuhrer about geofence improvements he mentioned again the overlap between `LNDMC_ALT_MAX` and `GF_MAX_VER_DIST`. I know @dagar was bringing this up many times.\r\n\r\nI think now is the right time to remove it since I'm not aware who is using that functionality right now and @sfuhrer is working on geofence improvements which should allow us to forward users to using `GF_MAX_VER_DIST`.\r\n\r\nFixes #13345\r\n\r\n### Solution\r\nI remove `LNDMC_ALT_MAX` completely.\r\nIt was introduced here: https://github.com/PX4/PX4-Autopilot/pull/6679\r\nextended to shift down mission items here: https://github.com/PX4/PX4-Autopilot/pull/8048\r\n\r\n### Changelog Entry\r\n```\r\nCleanup: Remove LNDMC_ALT_MAX, use GF_MAX_VER_DIST instead\r\n```\r\n\r\n### Alternatives\r\nWe could use `GF_MAX_VER_DIST` in place of how `LNDMC_ALT_MAX` is currently used but:\r\n- On multicopter it prevents breaching the altitude in any climb rate enabled mode which we should achieve with the geofence.\r\n- On any vehicle, all mission items just get silently repositioned to be lower which was a hack to still allow RTL even if the return altitude is higher than the allowed altitude but flying lower than planned is not generally a safe thing to do. The check for the return altitude being lower than the maximum altitude should be done explicitly.\r\n\r\n### Test coverage\r\nI did not specifically test this but the functionality was removed and it still compiles.",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2023-11-15T14:39:34Z",
          "body": "Note: this would require a docs update (remove deprecated param).",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2023-11-20T13:59:18Z",
          "body": "> this would require a docs update\r\n\r\nIt was actually never documented explicitly but only in the autogenerated reference ðŸ˜… \r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/4668506/4b118d52-fc5a-47a2-83a9-8e4276da1dce)\r\n",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2024-07-25T01:09:07Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-v1-15-public-changes-what-needs-docs/39850/1\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "For me this is a second implementation of a geofence feature, and thus support its removal. \r\nIf manufacturers want to implement a hard altitude limit that the user cannot overwrite then they can set GF_MAX_VER_DIST and GF_ACTION and do not give the user the ability to change them.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR removes a redundant parameter and related behavior that caused mission items to be silently lowered (LNDMC_ALT_MAX) and overlapped with GF_MAX_VER_DIST. That silent repositioning was an undesirable/hacky runtime behavior (incorrect program behavior), so removing it addresses a logic/design bug rather than a mere stylistic change.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -58,7 +58,6 @@ Land::on_activation()\n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \tpos_sp_triplet->previous.valid = false;\n-\tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->next.valid = false;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -119,7 +119,6 @@ Loiter::set_loiter_position()\n \n \t// convert mission item to current setpoint\n \tpos_sp_triplet->previous.valid = false;\n-\tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->next.valid = false;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -222,7 +222,6 @@ void Mission::setActiveMissionItems()\n \n \t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n \t\tif (new_work_item_type != WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n-\t\t\tmission_apply_limitation(_mission_item);\n \t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t}\n \n@@ -256,13 +255,11 @@ void Mission::setActiveMissionItems()\n \n \t\tif (num_found_items > 0u) {\n \t\t\t// We have a position, convert it to the setpoint and update setpoint triplet\n-\t\t\tmission_apply_limitation(next_mission_items[0u]);\n \t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->current);\n \t\t}\n \n \t\tif (num_found_items >= 2u) {\n \t\t\t/* got next mission item, update setpoint triplet */\n-\t\t\tmission_apply_limitation(next_mission_items[1u]);\n \t\t\tmission_item_to_position_setpoint(next_mission_items[1u], &pos_sp_triplet->next);\n \n \t\t} else {\n@@ -439,7 +436,6 @@ void Mission::handleVtolTransition(WorkItemType &new_work_item_type, mission_ite\n \t\tset_align_mission_item(&_mission_item, &next_mission_items[0u]);\n \n \t\t/* set position setpoint to target during the transition */\n-\t\tmission_apply_limitation(_mission_item);\n \t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->current);\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "patch": "@@ -285,7 +285,6 @@ MissionBase::on_active()\n \t\t\t}\n \t\t}\n \n-\t\tmission_apply_limitation(_mission_item);\n \t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n \n \t\treset_mission_item_reached();\n@@ -490,7 +489,6 @@ void MissionBase::setEndOfMissionItems()\n \n \t/* update position setpoint triplet  */\n \tpos_sp_triplet->previous.valid = false;\n-\tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->next.valid = false;\n \n@@ -808,7 +806,6 @@ MissionBase::do_abort_landing()\n \t_mission_item.autocontinue = false;\n \t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n \n \t// XXX: this is a hack to invalidate the \"next\" position setpoint for the fixed-wing position controller during",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "patch": "@@ -877,29 +877,6 @@ MissionBlock::set_vtol_transition_item(struct mission_item_s *item, const uint8_\n \titem->autocontinue = true;\n }\n \n-void\n-MissionBlock::mission_apply_limitation(mission_item_s &item)\n-{\n-\t// Limit altitude\n-\tconst float maximum_altitude = _navigator->get_lndmc_alt_max();\n-\n-\t/* do nothing if altitude max is negative */\n-\tif (maximum_altitude > 0.0f) {\n-\n-\t\t/* absolute altitude */\n-\t\tfloat altitude_abs = item.altitude_is_relative\n-\t\t\t\t     ? item.altitude + _navigator->get_home_position()->alt\n-\t\t\t\t     : item.altitude;\n-\n-\t\t/* limit altitude to maximum allowed altitude */\n-\t\tif ((maximum_altitude + _navigator->get_home_position()->alt) < altitude_abs) {\n-\t\t\titem.altitude = item.altitude_is_relative ?\n-\t\t\t\t\tmaximum_altitude :\n-\t\t\t\t\tmaximum_altitude + _navigator->get_home_position()->alt;\n-\t\t}\n-\t}\n-}\n-\n float\n MissionBlock::get_absolute_altitude_for_item(const mission_item_s &mission_item) const\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "patch": "@@ -205,11 +205,6 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_vtol_transition_item(struct mission_item_s *item, const uint8_t new_mode);\n \n-\t/**\n-\t * General function used to adjust the mission item based on vehicle specific limitations\n-\t */\n-\tvoid mission_apply_limitation(mission_item_s &item);\n-\n \tvoid setLoiterToAltMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_radius,\n \t\t\t\t       HeadingMode heading_mode) const;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -269,7 +269,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tint  get_takeoff_land_required() const { return _para_mis_takeoff_land_req.get(); }\n \tfloat get_yaw_timeout() const { return _param_mis_yaw_tmt.get(); }\n \tfloat get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n-\tfloat get_lndmc_alt_max() const { return _param_lndmc_alt_max.get(); }\n \n \tfloat get_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss; }\n \n@@ -407,7 +406,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamFloat<px4::params::MIS_YAW_TMT>)     _param_mis_yaw_tmt,\n \t\t(ParamFloat<px4::params::MIS_YAW_ERR>)     _param_mis_yaw_err,\n \t\t(ParamFloat<px4::params::MIS_PD_TO>)       _param_mis_payload_delivery_timeout,\n-\t\t(ParamFloat<px4::params::LNDMC_ALT_MAX>)   _param_lndmc_alt_max,\n \t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)  _param_mis_lnd_abrt_alt\n \t)\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -349,8 +349,6 @@ void RtlDirect::set_rtl_item()\n \n \t} else {\n \t\t// Convert mission item to current position setpoint and make it valid.\n-\t\tmission_apply_limitation(_mission_item);\n-\n \t\tif (mission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current)) {\n \t\t\t_navigator->set_position_setpoint_triplet_updated();\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "patch": "@@ -122,7 +122,6 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \t\t\t\t      (int32_t)ceilf(_rtl_alt));\n \n \t\t_needs_climbing = false;\n-\t\tmission_apply_limitation(_mission_item);\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_CLIMB;\n@@ -180,11 +179,9 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \t\t}\n \n \t\tif (num_found_items > 0) {\n-\t\t\tmission_apply_limitation(next_mission_items[0u]);\n \t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n \t\t}\n \n-\t\tmission_apply_limitation(_mission_item);\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -132,11 +132,9 @@ void RtlMissionFast::setActiveMissionItems()\n \n \n \t\tif (num_found_items > 0) {\n-\t\t\tmission_apply_limitation(next_mission_items[0u]);\n \t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n \t\t}\n \n-\t\tmission_apply_limitation(_mission_item);\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -126,12 +126,10 @@ void RtlMissionFastReverse::setActiveMissionItems()\n \t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n \n \t\t\tif (success) {\n-\t\t\t\tmission_apply_limitation(next_mission_item);\n \t\t\t\tmission_item_to_position_setpoint(next_mission_item, &pos_sp_triplet->next);\n \t\t\t}\n \t\t}\n \n-\t\tmission_apply_limitation(_mission_item);\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "patch": "@@ -85,8 +85,6 @@ Takeoff::on_active()\n \t\t\t}\n \t\t}\n \n-\t\tmission_apply_limitation(_mission_item);\n-\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \t\t_navigator->set_position_setpoint_triplet_updated();\n@@ -129,7 +127,6 @@ Takeoff::set_takeoff_position()\n \n \t// convert mission item to current setpoint\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \tpos_sp_triplet->previous.valid = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -74,7 +74,6 @@ VtolTakeoff::on_active()\n \t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat,\n \t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n \t\t\t\t_mission_item.force_heading = true;\n-\t\t\t\tmission_apply_limitation(_mission_item);\n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n \t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n@@ -180,7 +179,6 @@ VtolTakeoff::set_takeoff_position()\n \n \t// convert mission item to current setpoint\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \tpos_sp_triplet->previous.valid = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bbe1094e5f1171a4bd23e7d78dd01fe8f6d3ed7d/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::setEndOfMissionItems",
        "VtolTakeoff::on_active",
        "mission_apply_limitation",
        "get_lndmc_alt_max",
        "MissionBase::on_active",
        "Land::on_activation",
        "Takeoff::on_active",
        "Mission::setActiveMissionItems",
        "RtlDirect::set_rtl_item",
        "Takeoff::set_takeoff_position",
        "MissionBlock::set_vtol_transition_item",
        "VtolTakeoff::set_takeoff_position",
        "MissionBase::do_abort_landing",
        "RtlDirectMissionLand::setActiveMissionItems",
        "RtlMissionFastReverse::setActiveMissionItems",
        "RtlMissionFast::setActiveMissionItems",
        "Loiter::set_loiter_position",
        "Mission::handleVtolTransition"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ],
        "src/modules/navigator/loiter.cpp": [
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::setActiveMissionItems",
          "Mission::handleVtolTransition"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::do_abort_landing",
          "MissionBase::setEndOfMissionItems"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_vtol_transition_item"
        ],
        "src/modules/navigator/mission_block.h": [
          "mission_apply_limitation"
        ],
        "src/modules/navigator/navigator.h": [
          "get_lndmc_alt_max"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast.cpp": [
          "RtlMissionFast::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::setActiveMissionItems"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active",
          "Takeoff::set_takeoff_position"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::set_takeoff_position",
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Mission feasibility checks with changing home",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22346",
    "number": 22346,
    "created_at": "2023-11-11T16:43:55Z",
    "merged": true,
    "merged_at": "2023-11-24T07:11:42Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nMisison feasibility was not checked again, if the home position or the geofence changed after it was checked once. Further, if the mission was invalid during upload (e.g. home position not valid yet) the mission is cleared.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- Remove clearing the mission when the mission is invalid during mission upload.\r\n- Mission feasibility checks also checks if the geofence counter or the home position timestamp has changed since last check.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Do not clear invalid mission after upload\r\nBugfix: Mission feasibility checks also checks if the geofence counter or the home position timestamp has changed since last check\r\n```\r\n\r\n### Alternatives\r\nThe mission feasibility checks should be moved to another location instead of being performed in the mission mode. They should be moved to the mavlink_mission class where it can be recalculated directly after a mission or geofence is uploaded.\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-12T14:06:35Z",
          "body": "Hi @bkueng ,\r\n\r\nI believe that in this pull request, the root cause is not the following:\r\n> Mission feasibility was not checked again if the home position or the geofence changed after it was checked once.\r\n\r\nInstead, the issue seems to be related to a Multi-Threaded Race Condition.\r\nhttps://github.com/PX4/PX4-Autopilot/security/advisories/GHSA-p74g-gvg5-6pgc\r\nI would appreciate your perspective\r\n\r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bkueng",
          "created_at": "2023-11-13T13:10:56Z",
          "body": "You can use the existing home position:\r\n```\r\n_navigator->get_mission_result()->home_position_timestamp = _navigator->get_home_position()->timestamp;\r\n```",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-11-13T13:16:35Z",
          "body": "It's not an issue now, as `check_mission_valid` isn't called regularly, but should we change that, and there's a situation where home position is published frequently, the checks will be executed at that rate as well.\r\nSo a bit better would be to check if the `valid` flags change.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-20T13:11:03Z",
          "body": "That means that we would tie this class again closer to the navigator module, although it might be decoupled in the future? Else i will apply your solution.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-20T13:11:53Z",
          "body": "@bkueng as discussed, i added a counter to the home position. What do you think of the implementation now?",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-11-23T08:29:49Z",
          "body": "Maybe this is a bit more clear?\r\n```suggestion\r\nuint32 update_count \t# update counter of the home position\r\n```",
          "path": "msg/HomePosition.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2023-11-23T08:32:23Z",
          "body": "I'm fine with it, but I also think this is easy to replace when the time comes to move it out.\r\nI'm mostly concerned with having many `SubscriptionData` around, which can become expensive in terms of memory.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-23T15:53:06Z",
          "body": "@bkueng Yeah since memory can be a problem i fixed it to your solution",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect program behavior: missions were being cleared during upload when temporarily invalid and feasibility wasn't re-evaluated when home or geofence changed. Those are logic errors (improper state transitions / missing condition checks) that produce unintended behavior. Note: a reviewer suggested the underlying root cause may be a multithreaded race condition, so while this PR fixes the observable incorrect behavior it's possible the deeper concurrency issue remains.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "patch": "@@ -142,7 +142,6 @@ void MissionBase::onMissionUpdate(bool has_mission_items_changed)\n \t\t// only warn if the check failed on merit\n \t\tif ((!_navigator->get_mission_result()->valid) && _mission.count > 0U) {\n \t\t\tPX4_WARN(\"mission check failed\");\n-\t\t\tresetMission();\n \t\t}\n \t}\n \n@@ -692,17 +691,20 @@ MissionBase::checkMissionRestart()\n void\n MissionBase::check_mission_valid()\n {\n-\tif (_navigator->get_mission_result()->instance_count != _mission.mission_update_counter) {\n-\t\tMissionFeasibilityChecker missionFeasibilityChecker(_navigator, _dataman_client);\n+\tif ((_navigator->get_mission_result()->mission_update_counter != _mission.mission_update_counter)\n+\t    || (_navigator->get_mission_result()->geofence_update_counter != _mission.geofence_update_counter)\n+\t    || (_navigator->get_mission_result()->home_position_counter != _navigator->get_home_position()->update_count)) {\n \n-\t\tbool is_mission_valid =\n-\t\t\tmissionFeasibilityChecker.checkMissionFeasible(_mission);\n+\t\t_navigator->get_mission_result()->mission_update_counter = _mission.mission_update_counter;\n+\t\t_navigator->get_mission_result()->geofence_update_counter = _mission.geofence_update_counter;\n+\t\t_navigator->get_mission_result()->home_position_counter = _navigator->get_home_position()->update_count;\n \n-\t\t_navigator->get_mission_result()->valid = is_mission_valid;\n-\t\t_navigator->get_mission_result()->instance_count = _mission.mission_update_counter;\n+\t\tMissionFeasibilityChecker missionFeasibilityChecker(_navigator, _dataman_client);\n+\t\t_navigator->get_mission_result()->valid = missionFeasibilityChecker.checkMissionFeasible(_mission);\n \t\t_navigator->get_mission_result()->seq_total = _mission.count;\n \t\t_navigator->get_mission_result()->seq_reached = -1;\n \t\t_navigator->get_mission_result()->failure = false;\n+\n \t\tset_mission_result();\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/15aa56b2bb70b7b292191ccc6d6f66d142826018/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -249,7 +249,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \torb_advert_t *get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n-\tint mission_instance_count() const { return _mission_result.instance_count; }\n+\tint mission_instance_count() const { return _mission_result.mission_update_counter; }\n \n \tvoid set_mission_failure_heading_timeout();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/15aa56b2bb70b7b292191ccc6d6f66d142826018/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::checkMissionRestart",
        "missionFeasibilityChecker",
        "MissionBase::onMissionUpdate",
        "mission_instance_count"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::checkMissionRestart",
          "missionFeasibilityChecker",
          "MissionBase::onMissionUpdate"
        ],
        "src/modules/navigator/navigator.h": [
          "mission_instance_count"
        ]
      }
    }
  },
  {
    "title": "rtl: Only use approaches for vtols in fixed wing mode",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22341",
    "number": 22341,
    "created_at": "2023-11-10T08:03:30Z",
    "merged": true,
    "merged_at": "2023-11-12T14:41:29Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nCurrently if a VTOl is in multicopter mode or a multicopter is used, the RTL still uses and loiter to alt approach for RTL, if it was uploaded. For multicopter and VTOL in RW mode, we want the system to directly fly to the home or RTL destination without using approaches.\r\n\r\n### Solution\r\n- Only use approaches when it is reported that the system is a vtol and in fixed wing mode.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix Only use RTL approaches for vtols in fixed wing mode\r\n```\r\n### Test coverage\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "Tested in SITL, I can't reproduce te issue anymore with this PR.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect operational behavior caused by wrong conditional logic: approaches were used even when the vehicle was a multicopter or a VTOL in multicopter/rotary-wing mode. Restricting approaches to VTOLs in fixed-wing mode corrects the state check and prevents unintended RTL approach behavior.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "patch": "@@ -313,7 +313,9 @@ void RTL::setRtlTypeAndDestination()\n \n \t\t\tland_approaches_s rtl_land_approaches{readVtolLandApproaches(rtl_position)};\n \n-\t\t\tif (rtl_land_approaches.isAnyApproachValid()) {\n+\t\t\tif (_vehicle_status_sub.get().is_vtol\n+\t\t\t    && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING)\n+\t\t\t    && rtl_land_approaches.isAnyApproachValid()) {\n \t\t\t\tlanding_loiter = chooseBestLandingApproach(rtl_land_approaches);\n \t\t\t}\n \n@@ -338,13 +340,16 @@ void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosit\n \tconst bool vtol_in_rw_mode = _vehicle_status_sub.get().is_vtol\n \t\t\t\t     && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING);\n \n+\tconst bool vtol_in_fw_mode = _vehicle_status_sub.get().is_vtol\n+\t\t\t\t     && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING);\n+\n \t// get distance to home position\n \tfloat home_dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, rtl_position.lat, rtl_position.lon)};\n \tfloat min_dist;\n \n-\tif (((_param_rtl_type.get() == 1) && !vtol_in_rw_mode) || ((_param_rtl_approach_force.get() == 1)\n+\tif (((_param_rtl_type.get() == 1) && !vtol_in_rw_mode) || (vtol_in_fw_mode && (_param_rtl_approach_force.get() == 1)\n \t\t\t&& !hasVtolLandApproach(rtl_position))) {\n-\t\t// Set minimum distance to maximum value when RTL_TYPE is set to 1 and we are not in RW mode or we forces approach landing and it is not defined for home.\n+\t\t// Set minimum distance to maximum value when RTL_TYPE is set to 1 and we are not in RW mode or we forces approach landing for vtol in fw and it is not defined for home.\n \t\tmin_dist = FLT_MAX;\n \n \t} else {\n@@ -406,7 +411,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosit\n \t\t\t\tDestinationPosition safepoint_position;\n \t\t\t\tsetSafepointAsDestination(safepoint_position, mission_safe_point);\n \n-\t\t\t\tif (((dist + MIN_DIST_THRESHOLD) < min_dist) && ((_param_rtl_approach_force.get() == 0)\n+\t\t\t\tif (((dist + MIN_DIST_THRESHOLD) < min_dist) && (!vtol_in_fw_mode || (_param_rtl_approach_force.get() == 0)\n \t\t\t\t\t\t|| hasVtolLandApproach(safepoint_position))) {\n \t\t\t\t\tmin_dist = dist;\n \t\t\t\t\trtl_position = safepoint_position;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/84fb79d8ff7ec17ca25910a14620d0849ef08598/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::setRtlTypeAndDestination",
        "RTL::findRtlDestination"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::setRtlTypeAndDestination",
          "RTL::findRtlDestination"
        ]
      }
    }
  },
  {
    "title": "VTOL takeoff: do not change loiter location after VTOL takeoff completed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22305",
    "number": 22305,
    "created_at": "2023-11-03T11:08:52Z",
    "merged": true,
    "merged_at": "2023-11-13T11:43:58Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen using a VTOL takeoff, a loiter location can be set. when the system reaches the takeoff altitude, it starts loitering at the current position instead of continuing at the loiter location defined in the VTOL takeoff. \r\n\r\n### Solution\r\n- Check in the loiter activation is the current position setpoint is a valid loiter point. If this is true and no reposition is active, set the loiter position to the loiter position item.\r\n- Refactor ...\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix VTOL takeoff: do not change loiter location after VTOL takeoff completed.\r\n```\r\n### Test coverage\r\n- Simulation tests: using gazebo-classic_standard_vtol.\r\n  - Check correct loiter location for vtol takeoff.\r\n  - Check correct functionality for hold when currently flying to an orbit/mission orbit\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2023-11-03T12:52:09Z",
          "body": "@KonradRudin Just an idea, should we add a protection for loiter points which are too far away from the vehicle?",
          "path": "src/modules/navigator/loiter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-03T12:54:38Z",
          "body": "hmm, i thought of making a check to only take it if we are on the loiter. So distance from vehicle to center point should be less than loiter_radius + acceptance_radius. That should do the trick, right?",
          "path": "src/modules/navigator/loiter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2023-11-03T12:56:51Z",
          "body": "@KonradRudin Yes, that's exactly what I meant",
          "path": "src/modules/navigator/loiter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2023-11-03T14:05:09Z",
          "body": "I have a new proposal just commited. @RomanBapst can you review again please?",
          "path": "src/modules/navigator/loiter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2023-11-12T14:28:53Z",
          "body": "@RomanBapst ping",
          "path": "src/modules/navigator/loiter.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect runtime behavior where the loiter setpoint was overwritten with the current position after VTOL takeoff completes, causing the vehicle to loiter at the wrong location. The change guards loiter activation with checks for a valid loiter point and reposition state, correcting an improper state/conditional transition (logic) rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "patch": "@@ -94,7 +94,21 @@ Loiter::set_loiter_position()\n \t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n \n \t} else {\n-\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t// Check if we already loiter on a circle and are on the loiter pattern.\n+\t\tbool on_loiter{false};\n+\n+\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER\n+\t\t    && pos_sp_triplet->current.loiter_pattern == position_setpoint_s::LOITER_TYPE_ORBIT) {\n+\t\t\tconst float d_current = get_distance_to_next_waypoint(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon,\n+\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\t\t\ton_loiter = d_current <= (_navigator->get_acceptance_radius() + pos_sp_triplet->current.loiter_radius);\n+\n+\t\t}\n+\n+\t\tif (on_loiter) {\n+\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\n+\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n \t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n \n \t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/79342d8b3c8b141c5f3fb519558c2f29b2f61b88/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -747,7 +747,8 @@ MissionBlock::setLoiterItemFromCurrentPositionSetpoint(struct mission_item_s *it\n \titem->lat = pos_sp_triplet->current.lat;\n \titem->lon = pos_sp_triplet->current.lon;\n \titem->altitude = pos_sp_triplet->current.alt;\n-\titem->loiter_radius = pos_sp_triplet->current.loiter_radius;\n+\titem->loiter_radius = pos_sp_triplet->current.loiter_direction_counter_clockwise ?\n+\t\t\t      -pos_sp_triplet->current.loiter_radius : pos_sp_triplet->current.loiter_radius;\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/79342d8b3c8b141c5f3fb519558c2f29b2f61b88/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::setLoiterItemFromCurrentPositionSetpoint",
        "Loiter::set_loiter_position"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::setLoiterItemFromCurrentPositionSetpoint"
        ]
      }
    }
  },
  {
    "title": "rc.fw_defaults param fix",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4121",
    "number": 4121,
    "created_at": "2016-03-30T16:25:38Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-30T16:27:31Z",
          "body": "Thanks!\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-30T16:30:46Z",
          "body": "Applied to master!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title 'rc.fw_defaults param fix' and the use of the word 'fix' indicate it addresses incorrect behavior around parameter handling (rc.fw_defaults), which is characteristic of a logic bug. There is no PR body or diff provided, so while it's very likely a logic issue affecting parameter defaults or handling, the lack of details prevents higher confidence.",
    "patches": {
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -73,7 +73,7 @@ PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n  * RTL delay\n  *\n  * Delay after descend before landing in RTL mode.\n- * If set to -1 the system will not land but loiter at NAV_LAND_ALT.\n+ * If set to -1 the system will not land but loiter at RTL_DESCEND_ALT.\n  *\n  * @unit s\n  * @min -1",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6338fadb36393f3fa1a035f3a641f438b8867f05/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "fixing possible safety issue with altitude",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4081",
    "number": 4081,
    "created_at": "2016-03-26T02:38:11Z",
    "merged": true,
    "merged_at": "2016-03-26T13:36:34Z",
    "state": "closed",
    "conversation": {
      "author": "catch-twenty-two",
      "body": "Ignoring requested altitude from target for now.\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and body indicate a behavioral change to address a 'possible safety issue with altitude' by ignoring a target's requested altitude. That phrasing and the alteration of decision logic around which altitude to use point to correcting incorrect or unsafe program behavior (a logic error) rather than a syntax/style change. Confidence is medium because no code or detailed discussion is provided to fully verify the exact faulty logic being fixed.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "patch": "@@ -449,10 +449,11 @@ MissionBlock::set_follow_target_item(struct mission_item_s *item, float min_clea\n \n \t\titem->lat = target.lat;\n \t\titem->lon = target.lon;\n-\t\titem->altitude = target.alt + _navigator->get_home_position()->alt;\n \n-\t\tif (((min_clearance > 0.0f) && (item->altitude < _navigator->get_home_position()->alt + min_clearance)) || PX4_ISFINITE(target.alt)) {\n-\t\t\titem->altitude = _navigator->get_home_position()->alt + min_clearance;\n+\t\titem->altitude = _navigator->get_global_position()->alt;\n+\n+\t\tif (min_clearance > 0.0f) {\n+\t\t\titem->altitude += min_clearance;\n \t\t}\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/328f73a47b648a054c28b1f78ff23b3f9a21b247/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_follow_target_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_follow_target_item"
        ]
      }
    }
  },
  {
    "title": "more param metadata cleanup",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4078",
    "number": 4078,
    "created_at": "2016-03-25T20:30:01Z",
    "merged": true,
    "merged_at": "2016-03-26T11:17:52Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "There is insufficient information in the PR (no description, comments, or reviews) to identify a specific incorrect behavior being fixed. The title 'more param metadata cleanup' suggests refactoring/cleanup rather than a correction of program logic, but without details this cannot be confirmed.",
    "patches": {
      "src/modules/navigator/datalinkloss_params.c": {
        "filename": "src/modules/navigator/datalinkloss_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -119,6 +119,6 @@ PARAM_DEFINE_INT32(NAV_DLL_N, 2);\n  * airfield home\n  *\n  * @group Data Link Loss\n- * @unit boolean\n+ * @boolean\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CHSK, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff75b8bb8f0511feddfd8a921940421ec7630af5/src%2Fmodules%2Fnavigator%2Fdatalinkloss_params.c"
      },
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "patch": "@@ -48,14 +48,13 @@\n  *\n  * 0 = none, 1 = warning (default), 2 = loiter, 3 = return to launch, 4 = fight termination\n  *\n- * @unit enum\n  * @min 0\n  * @max 4\n- * @value 0 none\n- * @value 1 warning\n- * @value 2 loiter\n- * @value 3 return\n- * @value 4 terminate\n+ * @value 0 None\n+ * @value 1 Warning\n+ * @value 2 Loiter\n+ * @value 3 Return\n+ * @value 4 Terminate\n  * @group Geofence\n  */\n PARAM_DEFINE_INT32(GF_ACTION, 1);\n@@ -66,7 +65,6 @@ PARAM_DEFINE_INT32(GF_ACTION, 1);\n  * Select which altitude reference should be used\n  * 0 = WGS84, 1 = AMSL\n  *\n- * @unit enum\n  * @min 0\n  * @max 1\n  * @value 0 WGS84\n@@ -82,7 +80,6 @@ PARAM_DEFINE_INT32(GF_ALTMODE, 0);\n  * no dependence on the position estimator\n  * 0 = global position, 1 = GPS\n  *\n- * @unit enum\n  * @min 0\n  * @max 1\n  * @value 0 GPOS",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff75b8bb8f0511feddfd8a921940421ec7630af5/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 2,
        "deletions": 17,
        "changes": 19,
        "patch": "@@ -73,7 +73,7 @@ PARAM_DEFINE_FLOAT(MIS_LTRMIN_ALT, 1.2f);\n  * When enabled, missions that have been uploaded by the GCS are stored\n  * and reloaded after reboot persistently.\n  *\n- * @unit boolean\n+ * @boolean\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_ONBOARD_EN, 1);\n@@ -99,16 +99,10 @@ PARAM_DEFINE_FLOAT(MIS_DIST_1WP, 900);\n  * 1: the system will follow a first order hold altitude setpoint\n  * values follow the definition in enum mission_altitude_mode\n  *\n- * @unit enum\n  * @min 0\n  * @max 1\n-<<<<<<< e22e0b28b61a7b4f7d10756678b8f4b533b3622e\n  * @value 0 Zero Order Hold\n  * @value 1 First Order Hold\n-=======\n- * @value 0 zero order\n- * @value 1 first order\n->>>>>>> mission param @unit\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n@@ -118,20 +112,12 @@ PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n  *\n  * The values are defined in the enum mission_altitude_mode\n  *\n- * @unit enum\n  * @min 0\n  * @max 3\n-<<<<<<< e22e0b28b61a7b4f7d10756678b8f4b533b3622e\n  * @value 0 Heading as set by waypoint\n  * @value 1 Heading towards waypoint\n  * @value 2 Heading towards home\n  * @value 3 Heading away from home\n-=======\n- * @value 0 destination\n- * @value 1 next\n- * @value 2 home\n- * @value 3 home back\n->>>>>>> mission param @unit\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n@@ -144,9 +130,9 @@ PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n  * Mainly useful for VTOLs that have less yaw authority and might not reach target\n  * yaw in wind. Disabled by default.\n  *\n+ * @unit s\n  * @min -1\n  * @max 20\n- * @unit second\n  * @increment 1\n  * @group Mission\n  */\n@@ -158,7 +144,6 @@ PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n  * @unit deg\n  * @min 0\n  * @max 90\n- * @unit degree\n  * @increment 1\n  * @group Mission\n  */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff75b8bb8f0511feddfd8a921940421ec7630af5/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -69,7 +69,7 @@ PARAM_DEFINE_FLOAT(NAV_ACC_RAD, 10.0f);\n  *\n  * If set to 1 the behaviour on data link loss is set to a mode according to the Outback Challenge (OBC) rules\n  *\n- * @unit boolean\n+ * @boolean\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(NAV_DLL_OBC, 0);\n@@ -79,7 +79,7 @@ PARAM_DEFINE_INT32(NAV_DLL_OBC, 0);\n  *\n  * If set to 1 the behaviour on data link loss is set to a mode according to the Outback Challenge (OBC) rules\n  *\n- * @unit boolean\n+ * @boolean\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(NAV_RCL_OBC, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff75b8bb8f0511feddfd8a921940421ec7630af5/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "added descend into navigator",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4068",
    "number": 4068,
    "created_at": "2016-03-23T21:53:09Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "pickledgator",
      "body": "Descend was unimplemented in navigator, and thus had no effect when the navigation state was changed. Utilized same land helper. Downstream logic in pos_control and commander successfully ignore position data that is applied in the setpoint message. Tested in gazebo for multi-rotors.\n",
      "issue_comments": [
        {
          "author": "julianoes",
          "created_at": "2016-03-24T08:11:05Z",
          "body": "Nice catch. How did you find this, in which scenario did the bug show up?\n",
          "type": "issue_comment"
        },
        {
          "author": "pickledgator",
          "created_at": "2016-03-24T22:41:56Z",
          "body": "To support development, I needed a way to trigger a failsafe landing without xy position control, even when position data is available in the filter (eg., bad VO). Descend nav state provides the control mechanism that I desired, and I piped an RC channel to a new failsafe main state to trigger the Descend.\n",
          "type": "issue_comment"
        },
        {
          "author": "mhkabir",
          "created_at": "2016-03-25T00:23:40Z",
          "body": "@pickledgator Sounds nice! Would you be able to send in a PR with the rest of your changes ? It would be very useful for others using VO too :)\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-28T10:27:37Z",
          "body": "Rebased and applied, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR implements a previously unimplemented 'Descend' navigation state so changing to that state had no effect, which is a logic error (incorrect state transition/unintended behavior). The change wires Descend into the navigator using the existing land helper so the navigation state now produces the intended control behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -493,6 +493,10 @@ Navigator::task_main()\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\t_navigation_mode = &_land;\n \t\t\t\tbreak;\n+\t\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n+\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n+\t\t\t\t_navigation_mode = &_land;\n+\t\t\t\tbreak;\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n \t\t\t\t/* Use complex data link loss mode only when enabled via param\n \t\t\t\t* otherwise use rtl */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/696431c77a6f3894c0d2123ac5e1df3832666c01/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "Follow me",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4065",
    "number": 4065,
    "created_at": "2016-03-23T19:14:10Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "@catch-twenty-two Replacing your PR with this rebased and formatted version.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-23T19:38:15Z",
          "body": "@catch-twenty-two What is the current state of this right now? Do you have an updated video?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-23T19:39:30Z",
          "body": "Matching QGC PR, not merged yet and with CI errors: https://github.com/mavlink/qgroundcontrol/pull/2817\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-23T21:19:59Z",
          "body": "@LorenzMeier Great thanks for doing that, No updated video yet. I did go out with friend to test it on a bicycle so I could see how well it tracked a fast moving object and all went well.  I'll do one more test tomorrow with all the updated changes and then call it good.  I'll also I'll see if I can get some more video if possible.\n",
          "type": "issue_comment"
        },
        {
          "author": "liang-tang",
          "created_at": "2016-03-24T07:33:01Z",
          "body": "@catch-twenty-two Is there a bug?\n\n``` javascript\nvoid FollowTarget::update_position_sp(bool use_velocity, bool use_position)\n{\n    // convert mission item to current setpoint\n\n    struct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n    // activate line following in pos control if position is valid\n\n    pos_sp_triplet->previous.valid = use_position;\n    pos_sp_triplet->previous = pos_sp_triplet->current;\n    mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n    pos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_FOLLOW_TARGET;\n    pos_sp_triplet->current.position_valid = use_position;\n    pos_sp_triplet->current.velocity_valid = use_velocity;\n    pos_sp_triplet->current.vx = _current_vel(0);\n    pos_sp_triplet->current.vy = _current_vel(1);\n    pos_sp_triplet->next.valid = false;\n    _navigator->set_position_setpoint_triplet_updated();\n}\n```\n\n   pos_sp_triplet->current.valid is miss? control_auto couldn't work well if we missed it. when i switch to follow target mode, the vehicle isn't moving at all.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-24T19:53:45Z",
          "body": "@LorenzMeier Happy to report I went out today and everything worked great.  I have some video but my I'll have to see if it's worth posting.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-24T20:04:58Z",
          "body": "> pos_sp_triplet->current.valid is miss? control_auto couldn't work well if we missed it. when i switch to follow target mode, the vehicle isn't moving at all.\n\nHmmm...you are right.  I'm actually surprised my tests went okay today, odd.... Good catch.  I'll have to fix it and retest tomorrow. \n\nNevermind see here where the sp is marked as valid:\n\nhttps://github.com/PX4/Firmware/pull/4065/files#diff-c8b2face30ea93f334a64cf7f9aff096L83\n\nThere could possibly be something wrong with your gps...Do you have another phone you can try?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T20:13:09Z",
          "body": "I always love videos, so I hope it turns out well!\n",
          "type": "issue_comment"
        },
        {
          "author": "DonLakeFlyer",
          "created_at": "2016-03-24T22:20:28Z",
          "body": "My suggestion for basic follow me support would be to maintain the current height of the Vehicle. Also mantain the current distance/positioning from the target calculated from the first follow me message.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-25T03:40:04Z",
          "body": "I'm no filmmaker... which is very apparent from this video, it contains:\n\n1) Me walking with follow me mode activated.\n2) My mother who I recruited to help me, walking with follow me mode activated (all the rest of my friends are at work on weekday mornings, imagine that! :) )\n3) Me riding my Xooter Scooter that I use to get around San Francisco, with follow me activated. At this point I was actually brave enough to set the RC down so I had no safety net (if anything were to go wrong) and let my code do it's work....\n\nThere was a slight wind blowing probably around 7-10 mph the frame type is a DJI style 330. \n\n> I always love videos, so I hope it turns out well!\n\n@LorenzMeier Did it turn out well?  Not really. But hopefully your love of videos makes up for that. lol!\n\nhttps://youtu.be/RxDL4CtkzAQ\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-27T10:17:47Z",
          "body": "Awesome, merged! Now on to the QGC merge, @DonLakeFlyer!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the discussion and code show incorrect state updates (ordering error and missing validity flag) that produce incorrect behavior. Specifically, previous.valid is set before previous is overwritten by current (so the value is lost), and current.valid was initially missing which would prevent control_auto from acting; the PR fixes these incorrect state transitions so the vehicle follows as expected.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -52,6 +52,7 @@ px4_add_module(\n \t\trcloss.cpp\n \t\tenginefailure.cpp\n \t\tgpsfailure.cpp\n+\t\tfollow_target.cpp\n \tDEPENDS\n \t\tplatforms__common\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "added",
        "additions": 279,
        "deletions": 0,
        "changes": 279,
        "patch": "@@ -0,0 +1,279 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2013-2016 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file followme.cpp\n+ *\n+ * Helper class to track and follow a given position\n+ *\n+ * @author Jimmy Johnson <catch22@fastmail.net>\n+ */\n+\n+#include \"follow_target.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <math.h>\n+#include <fcntl.h>\n+\n+#include <mavlink/mavlink_log.h>\n+#include <systemlib/err.h>\n+\n+#include <uORB/uORB.h>\n+#include <uORB/topics/position_setpoint_triplet.h>\n+#include <uORB/topics/follow_target.h>\n+#include <lib/geo/geo.h>\n+\n+#include \"navigator.h\"\n+\n+FollowTarget::FollowTarget(Navigator *navigator, const char *name) :\n+\tMissionBlock(navigator, name),\n+\t_navigator(navigator),\n+\t_param_min_alt(this, \"MIS_TAKEOFF_ALT\", false),\n+\t_follow_target_state(WAIT_FOR_TARGET_POSITION),\n+\t_follow_target_sub(-1),\n+\t_step_time_in_ms(0.0f),\n+\t_target_updates(0),\n+\t_last_update_time(0),\n+\t_current_target_motion( {}),\n+\t\t\t_previous_target_motion({})\n+{\n+\tupdateParams();\n+\t_current_vel.zero();\n+\t_step_vel.zero();\n+\t_target_vel.zero();\n+\t_target_distance.zero();\n+}\n+\n+FollowTarget::~FollowTarget()\n+{\n+}\n+\n+void FollowTarget::on_inactive()\n+{\n+\treset_target_validity();\n+}\n+\n+void FollowTarget::on_activation()\n+{\n+\tif (_follow_target_sub < 0) {\n+\t\t_follow_target_sub = orb_subscribe(ORB_ID(follow_target));\n+\t}\n+}\n+\n+void FollowTarget::on_active()\n+{\n+\tstruct map_projection_reference_s target_ref;\n+\tmath::Vector<3> target_position(0, 0, 0);\n+\tuint64_t current_time = hrt_absolute_time();\n+\tbool _radius_entered = false;\n+\tbool _radius_exited = false;\n+\tbool updated = false;\n+\tfloat dt_ms = 0;\n+\n+\torb_check(_follow_target_sub, &updated);\n+\n+\tif (updated) {\n+\n+\t\t_target_updates++;\n+\n+\t\t// save last known motion topic\n+\n+\t\t_previous_target_motion = _current_target_motion;\n+\n+\t\torb_copy(ORB_ID(follow_target), _follow_target_sub, &_current_target_motion);\n+\n+\t} else if (((current_time - _previous_target_motion.timestamp) / 1000 / 1000) > TARGET_TIMEOUT_S\n+\t\t   && target_velocity_valid()) {\n+\t\treset_target_validity();\n+\t}\n+\n+\t// update target velocity\n+\n+\tif (target_velocity_valid() && updated) {\n+\n+\t\tdt_ms = ((_current_target_motion.timestamp - _previous_target_motion.timestamp) / 1000);\n+\n+\t\t// get last gps known reference for target\n+\n+\t\tmap_projection_init(&target_ref, _previous_target_motion.lat, _previous_target_motion.lon);\n+\n+\t\t// calculate distance the target has moved\n+\n+\t\tmap_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &(target_position(0)),\n+\t\t\t\t       &(target_position(1)));\n+\n+\t\t// update the average velocity of the target based on the position\n+\n+\t\t_target_vel = target_position / (dt_ms / 1000.0f);\n+\n+\t\t// to keep the velocity increase/decrease smooth\n+\t\t// calculate how many velocity increments/decrements\n+\t\t// it will take to reach the targets velocity\n+\t\t// with the given amount of steps also add a feed forward input that adjusts the\n+\t\t// velocity as the position gap increases since\n+\t\t// just traveling at the exact velocity of the target will not\n+\t\t// get any closer to the target\n+\n+\t\t_step_vel = (_target_vel - _current_vel) + _target_distance * FF_K;\n+\t\t_step_vel /= (dt_ms / 1000.0f * (float) INTERPOLATION_PNTS);\n+\t\t_step_time_in_ms = dt_ms / (float) INTERPOLATION_PNTS;\n+\t}\n+\n+\t// update distance to target\n+\n+\tif (target_position_valid()) {\n+\n+\t\t// get distance to target\n+\n+\t\tmap_projection_init(&target_ref, _navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\t\tmap_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &_target_distance(0),\n+\t\t\t\t       &_target_distance(1));\n+\n+\t\t// are we within the target acceptance radius?\n+\t\t// give a buffer to exit/enter the radius to give the velocity controller\n+\t\t// a chance to catch up\n+\n+\t\t_radius_exited = (_target_distance.length() > (float) TARGET_ACCEPTANCE_RADIUS_M * 1.5f);\n+\t\t_radius_entered = (_target_distance.length() < (float) TARGET_ACCEPTANCE_RADIUS_M);\n+\t}\n+\n+\t// update state machine\n+\n+\tswitch (_follow_target_state) {\n+\n+\tcase TRACK_POSITION: {\n+\n+\t\t\tif (_radius_entered == true) {\n+\t\t\t\t_follow_target_state = TRACK_VELOCITY;\n+\n+\t\t\t} else if (target_velocity_valid()) {\n+\t\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), _current_target_motion, NAN);\n+\t\t\t\t// keep the current velocity updated with the target velocity for when it's needed\n+\t\t\t\t_current_vel = _target_vel;\n+\t\t\t\tupdate_position_sp(true, true);\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\n+\tcase TRACK_VELOCITY: {\n+\n+\t\t\tif (_radius_exited == true) {\n+\t\t\t\t_follow_target_state = TRACK_POSITION;\n+\n+\t\t\t} else if (target_velocity_valid()) {\n+\t\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), _current_target_motion, NAN);\n+\n+\t\t\t\tif ((current_time - _last_update_time) / 1000 >= _step_time_in_ms) {\n+\t\t\t\t\t_current_vel += _step_vel;\n+\t\t\t\t\t_last_update_time = current_time;\n+\t\t\t\t}\n+\n+\t\t\t\tupdate_position_sp(true, false);\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\n+\tcase WAIT_FOR_TARGET_POSITION: {\n+\n+\t\t\t// Climb to the minimum altitude\n+\t\t\t// and wait until a position is received\n+\n+\t\t\tfollow_target_s target = { };\n+\n+\t\t\t// for now set the target at the minimum height above the uav\n+\n+\t\t\ttarget.lat = _navigator->get_global_position()->lat;\n+\t\t\ttarget.lon = _navigator->get_global_position()->lon;\n+\t\t\ttarget.alt = 0.0F;\n+\n+\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), target, NAN);\n+\n+\t\t\tupdate_position_sp(false, false);\n+\n+\t\t\tif (is_mission_item_reached() && target_velocity_valid()) {\n+\t\t\t\t_follow_target_state = TRACK_POSITION;\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+\n+void FollowTarget::update_position_sp(bool use_velocity, bool use_position)\n+{\n+\t// convert mission item to current setpoint\n+\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t// activate line following in pos control if position is valid\n+\n+\tpos_sp_triplet->previous.valid = use_position;\n+\tpos_sp_triplet->previous = pos_sp_triplet->current;\n+\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_FOLLOW_TARGET;\n+\tpos_sp_triplet->current.position_valid = use_position;\n+\tpos_sp_triplet->current.velocity_valid = use_velocity;\n+\tpos_sp_triplet->current.vx = _current_vel(0);\n+\tpos_sp_triplet->current.vy = _current_vel(1);\n+\tpos_sp_triplet->next.valid = false;\n+\n+\t_navigator->set_position_setpoint_triplet_updated();\n+}\n+\n+void FollowTarget::reset_target_validity()\n+{\n+\t_previous_target_motion = {};\n+\t_current_target_motion = {};\n+\t_target_updates = 0;\n+\t_current_vel.zero();\n+\t_step_vel.zero();\n+\t_target_vel.zero();\n+\t_target_distance.zero();\n+\treset_mission_item_reached();\n+\t_follow_target_state = WAIT_FOR_TARGET_POSITION;\n+}\n+\n+bool FollowTarget::target_velocity_valid()\n+{\n+\t// need at least 2 data points for velocity estimate\n+\treturn (_target_updates >= 2);\n+}\n+\n+bool FollowTarget::target_position_valid()\n+{\n+\t// need at least 1 data point for position estimate\n+\treturn (_target_updates >= 1);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/follow_target.h": {
        "filename": "src/modules/navigator/follow_target.h",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "patch": "@@ -0,0 +1,100 @@\n+/***************************************************************************\n+ *\n+ *   Copyright (c) 2016 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file followme.cpp\n+ *\n+ * Helper class to track and follow a given position\n+ *\n+ * @author Jimmy Johnson <catch22@fastmail.net>\n+ */\n+\n+#pragma once\n+\n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+#include <lib/mathlib/math/Vector.hpp>\n+\n+#include \"navigator_mode.h\"\n+#include \"mission_block.h\"\n+\n+class FollowTarget : public MissionBlock\n+{\n+\n+public:\n+\tFollowTarget(Navigator *navigator, const char *name);\n+\t~FollowTarget();\n+\n+\tvoid on_inactive() override;\n+\tvoid on_activation() override;\n+\tvoid on_active() override;\n+\n+private:\n+\n+\tstatic constexpr int TARGET_TIMEOUT_S = 5;\n+\tstatic constexpr int TARGET_ACCEPTANCE_RADIUS_M = 5;\n+\tstatic constexpr int INTERPOLATION_PNTS = 20;\n+\tstatic constexpr float FF_K = .15f;\n+\n+\tenum FollowTargetState {\n+\t\tTRACK_POSITION,\n+\t\tTRACK_VELOCITY,\n+\t\tWAIT_FOR_TARGET_POSITION\n+\t};\n+\n+\tNavigator *_navigator;\n+\tcontrol::BlockParamFloat _param_min_alt;\n+\tFollowTargetState _follow_target_state;\n+\tint _follow_target_sub;\n+\tfloat _step_time_in_ms;\n+\n+\tuint64_t _target_updates;\n+\n+\tuint64_t _last_update_time;\n+\n+\tmath::Vector<3> _current_vel;\n+\tmath::Vector<3> _step_vel;\n+\tmath::Vector<3> _target_vel;\n+\tmath::Vector<3> _target_distance;\n+\n+\tfollow_target_s _current_target_motion;\n+\tfollow_target_s _previous_target_motion;\n+\n+\tvoid track_target_position();\n+\tvoid track_target_velocity();\n+\tbool target_velocity_valid();\n+\tbool target_position_valid();\n+\tvoid reset_target_validity();\n+\tvoid update_position_sp(bool velocity_valid, bool position_valid);\n+\tvoid update_target_motion();\n+\tvoid update_target_velocity();\n+};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Ffollow_target.h"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -79,6 +79,7 @@ Loiter::on_activation()\n \n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tpos_sp_triplet->current.velocity_valid = false;\n \tpos_sp_triplet->previous.valid = false;\n \tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->next.valid = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "patch": "@@ -434,6 +434,41 @@ MissionBlock::set_loiter_item(struct mission_item_s *item, float min_clearance)\n \t}\n }\n \n+void\n+MissionBlock::set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s & target, float yaw)\n+{\n+\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\t/* landed, don't takeoff, but switch to IDLE mode */\n+\t\titem->nav_cmd = NAV_CMD_IDLE;\n+\n+\t} else {\n+\n+\t\titem->nav_cmd = NAV_CMD_FOLLOW_TARGET;\n+\n+\t\t/* use current target position */\n+\n+\t\titem->lat = target.lat;\n+\t\titem->lon = target.lon;\n+\t\titem->altitude = _navigator->get_home_position()->alt;\n+\n+\t\tif (min_clearance > 0.0f) {\n+\t\t\titem->altitude += min_clearance;\n+\t\t} else {\n+\t\t\titem->altitude += 8.0f; // if min clearance is bad set it to 8.0 meters (well above the average height of a person)\n+\t\t}\n+\t}\n+\n+\titem->altitude_is_relative = false;\n+\titem->yaw = yaw;\n+\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_direction = 1;\n+\titem->acceptance_radius = _navigator->get_acceptance_radius();\n+\titem->time_inside = 0.0f;\n+\titem->pitch_min = 0.0f;\n+\titem->autocontinue = false;\n+\titem->origin = ORIGIN_ONBOARD;\n+}\n+\n void\n MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance, float min_pitch)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -49,6 +49,7 @@\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/actuator_controls.h>\n+#include <uORB/topics/follow_target.h>\n \n #include \"navigator_mode.h\"\n \n@@ -121,6 +122,11 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n \n+\t/**\n+\t * Set follow_target item\n+\t */\n+\tvoid set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s & target, float yaw);\n+\n \tvoid issue_command(const struct mission_item_s *item);\n \n \tmission_item_s _mission_item;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -53,7 +53,7 @@\n  * @max 80\n  * @group Mission\n  */\n-PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 1.8f);\n+PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 10.0f);\n \n /**\n  * Minimum Loiter altitude",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -61,6 +61,8 @@ enum NAV_CMD {\n \tNAV_CMD_TAKEOFF = 22,\n \tNAV_CMD_ROI = 80,\n \tNAV_CMD_PATHPLANNING = 81,\n+\tNAV_CMD_FOLLOW_TARGET = 194, // temporary placeholder\n+\tNAV_CMD_GOTO_TAREGT = 195,\n \tNAV_CMD_DO_JUMP = 177,\n \tNAV_CMD_DO_CHANGE_SPEED = 178,\n \tNAV_CMD_DO_SET_SERVO=183,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -66,14 +66,15 @@\n #include \"rtl.h\"\n #include \"datalinkloss.h\"\n #include \"enginefailure.h\"\n+#include \"follow_target.h\"\n #include \"gpsfailure.h\"\n #include \"rcloss.h\"\n #include \"geofence.h\"\n \n /**\n  * Number of navigation modes that need on_active/on_inactive calls\n  */\n-#define NAVIGATOR_MODE_ARRAY_SIZE 9\n+#define NAVIGATOR_MODE_ARRAY_SIZE 10\n \n class Navigator : public control::SuperBlock\n {\n@@ -250,6 +251,8 @@ class Navigator : public control::SuperBlock\n \t\t\t\t\t\t\t  (FW only!) */\n \tGpsFailure\t_gpsFailure;\t\t\t/**< class that handles the OBC gpsfailure loss mode */\n \n+\tFollowTarget _follow_target;\n+\n \tNavigatorMode *_navigation_mode_array[NAVIGATOR_MODE_ARRAY_SIZE];\t/**< array of navigation modes */\n \n \tcontrol::BlockParamFloat _param_loiter_radius;\t/**< loiter radius for fixedwing */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -148,6 +148,7 @@ Navigator::Navigator() :\n \t_dataLinkLoss(this, \"DLL\"),\n \t_engineFailure(this, \"EF\"),\n \t_gpsFailure(this, \"GPSF\"),\n+\t_follow_target(this, \"TAR\"),\n \t_param_loiter_radius(this, \"LOITER_RAD\"),\n \t_param_acceptance_radius(this, \"ACC_RAD\"),\n \t_param_datalinkloss_obc(this, \"DLL_OBC\"),\n@@ -166,6 +167,7 @@ Navigator::Navigator() :\n \t_navigation_mode_array[6] = &_rcLoss;\n \t_navigation_mode_array[7] = &_takeoff;\n \t_navigation_mode_array[8] = &_land;\n+\t_navigation_mode_array[9] = &_follow_target;\n \n \tupdateParams();\n }\n@@ -511,6 +513,10 @@ Navigator::task_main()\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\t_navigation_mode = &_gpsFailure;\n \t\t\t\tbreak;\n+\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n+\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n+\t\t\t\t_navigation_mode = &_follow_target;\n+\t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\t_navigation_mode = nullptr;\n \t\t\t\t_can_loiter_at_sp = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4ce52c80235ddd49c2033bc2afdd65480fb17bbd/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::Navigator",
        "control::SuperBlock",
        "MissionBlock::set_loiter_item",
        "Navigator::task_main",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_activation"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_loiter_item"
        ],
        "src/modules/navigator/navigator.h": [
          "control::SuperBlock"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "VTOL_TAKEOFF, VTOL_LAND commands and VT_FORCE_VTOL param",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4055",
    "number": 4055,
    "created_at": "2016-03-22T10:30:16Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "support for MAV_CMD_NAV_VTOL_TAKEOFF and MAV_CMD_NAV_VTOL_LAND \nAlso implement VT_FORCE_VTOL to force land as VTOL\nreplaces https://github.com/PX4/Firmware/pull/3720\n\nFixes #3492\nFixes #3712\n",
      "issue_comments": [
        {
          "author": "sanderux",
          "created_at": "2016-03-24T00:14:26Z",
          "body": "@AndreasAntener I cleaned up the mission code, sanitized the functionality, improved back transition behavior, fixed alignment and implemented force_vtol procedure.\nSITL tested all reasonable scenarios and regression tested on the old procedure (takeoff -> trans -> wp -> trans -> land).\n\nI'm especially happy with the back transition improvement, we could see if the basis could change from time to velocity but for now this seems to be a big improvement.\n\nI will test fly this tree soon but i think it is ready to rebase and merge as i see no possible regression and it only implements previously unsupported functionality.\n\nSomehow this tagged along through a submodule init and causes travis to fail: https://github.com/PX4/Firmware/pull/4055/files#diff-d62dbab64e619e0e5926b64585204efdR1\nI think that should be resolved by rebasing but i'm not sure.\n\n/cc @LorenzMeier @tumbili \n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-24T09:04:46Z",
          "body": "@sanderux Could you rebase and squash the development commits? There are also wrong indentations in the mission code it seems\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T11:02:40Z",
          "body": "@AndreasAntener @sanderux There is a 15 character limit on parameter length, what I proposed works, what you proposed doesn't.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-24T11:11:00Z",
          "body": "@LorenzMeier I tested VT_NAV_FORCE_VTL as param and that works. Do you want me to change it?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T11:13:09Z",
          "body": "16 is the hard limit without NUL-termination. It should work, but you can get yourself into corner cases in downstream implementations. I suggest to use VT_NAV_FORCE_VT instead.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-24T11:20:04Z",
          "body": "ready to merge\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T12:03:20Z",
          "body": "Is this state SITL and outdoor tested? I think it should be, as the changes are significant.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-24T12:10:05Z",
          "body": "Sitl is tested, outdoor tomorrow\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-25T20:34:02Z",
          "body": "Outdoor tested in quite strong wind. \nhttp://logs.uaventure.com/view/JRG4pRghKoV3RK8eS3o75k#AS_Yaw_PLOT\n\n1 There was a sudden unintended yaw action when front transition started, see yaw setpoint change\n2 Very smooth back transition but quite a high time and in strong winds it drifts a lot \n3 During lading it weathervaned and got lift from it's wings, it therefor acted up a little.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-25T21:49:39Z",
          "body": "Here is a second log:\nhttp://logs.uaventure.com/view/PJYu2ARidpuQyFsX9qxdKm\n\nThe yaw setpoint issue is consistent\nThe airspeed sensor for the quadranger acted up here (turned out to be the radio telem being too close)\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-26T18:04:08Z",
          "body": "This should fix the yaw issue during transition\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-27T01:13:09Z",
          "body": "@sanderux before I forget, mission item reached: one reason to not wait on the transition to be finished is that the position controller won't know the next waypoint and therefore cannot control the position during the transition in case we later implement this. haven't thought about it in detail though.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-27T08:16:59Z",
          "body": "the advantage of this command is that the user can point the vehicle into the wind. It is basically the autonomous equivlant of flicking the aux1 switch.\n\nFor position control it should hold altitude and heading until ttansition has completed or timeout occurs. \n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-27T09:34:31Z",
          "body": "Sure but it's changing the behaviour in general, also for the separate transitions (not part of VTOL tko/lnd). What we talked about yesterday, if we want the FW position controller to guide it through blending, it needs to know the next waypoint. If it doesn't get the actual next mission waypoint, we need to generate a temporary waypoint that lies in the direction of the target transition heading. Another option would be to look at the \"next\" waypoint in the triplet, which contains the next position during the transition. Ok, I think we have 2 good options here so it's fine.\n\nNote: simply holding heading and attitude is not going to work, it will drift off path.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-27T09:45:41Z",
          "body": "Yes your right, i think a temp waypoint would be a good idea.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-27T10:27:38Z",
          "body": "Waiting for conclusive test flights to merge this.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-27T10:31:39Z",
          "body": "I did a sitl test to check on the Z velocity issue that i see in your log from #4079:\n\n<img width=\"1368\" alt=\"screen shot 2016-03-27 at 12 15 55\" src=\"https://cloud.githubusercontent.com/assets/5750020/14064961/98febe76-f416-11e5-9277-f6557dca7d42.png\">\n\nThe position controller still sees a takeoff type setpoint during the transition. Needs to be reset, should be a small fix.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-27T23:48:12Z",
          "body": "@AndreasAntener do you agree on the location of setting the setpoint type?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-29T21:06:49Z",
          "body": "@AndreasAntener i added the virtual waypoint in front of the takeoff item. This should work fine now with your transition position holding\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-30T11:51:22Z",
          "body": "Here is a log for a SITL flight based on this branch combined with https://github.com/PX4/Firmware/pull/4093. looks very smooth and functions as expected.\nhttp://logs.uaventure.com/view/VXJnLmimbG8px8aiuPtBja\n\n![image](https://cloud.githubusercontent.com/assets/14801663/14141202/fab81b6c-f67d-11e5-8f05-aa66601c9d1f.png)\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-04-02T18:20:36Z",
          "body": "Outdoor tested, looking good:\nhttp://logs.uaventure.com/view/jg2rHZDRmAboYLiqyFVuge\nVideo: https://drive.google.com/file/d/0B27AvDmVit4KQlpCMllyaDVxQmM/view?usp=sharing\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-04-02T20:29:55Z",
          "body": "Rebased and applied, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T08:31:49Z",
          "body": "This should be defined in the navigator params, (NAV_FORCE_VTOL), as its only used there.\n",
          "path": "src/modules/vtol_att_control/vtol_att_control_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-03-24T08:59:09Z",
          "body": "All vtol related params start with VT_ perhaps VT_NAV_FORCE_VTOL ?\n",
          "path": "src/modules/vtol_att_control/vtol_att_control_params.c",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior in VTOL mission and transition logic (improper setpoint type during transitions, unintended yaw setpoint changes, and missing handling that prevented the position controller from guiding through blending). It implements correct VTOL takeoff/land commands, a force-VTOL parameter, and adds virtual waypoint/transition handling to fix state/setpoint and mission-flow errors.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 140,
        "deletions": 61,
        "changes": 201,
        "patch": "@@ -41,6 +41,7 @@\n  * @author Ban Siesta <bansiesta@gmail.com>\n  * @author Simon Wilks <simon@uaventure.com>\n  * @author Andreas Antener <andreas@uaventure.com>\n+ * @author Sander Smeets <sander@droneslab.com>\n  */\n \n #include <sys/types.h>\n@@ -72,6 +73,7 @@ Mission::Mission(Navigator *navigator, const char *name) :\n \t_param_dist_1wp(this, \"MIS_DIST_1WP\", false),\n \t_param_altmode(this, \"MIS_ALTMODE\", false),\n \t_param_yawmode(this, \"MIS_YAWMODE\", false),\n+\t_param_force_vtol(this, \"VT_NAV_FORCE_VT\", false),\n \t_onboard_mission{},\n \t_offboard_mission{},\n \t_current_onboard_mission_index(-1),\n@@ -430,8 +432,16 @@ Mission::set_mission_items()\n \t/*********************************** handle mission item *********************************************/\n \n \t/* handle position mission items */\n+\n+\n \tif (item_contains_position(&_mission_item)) {\n \n+\t\t/* force vtol land */\n+\t\tif(_mission_item.nav_cmd == NAV_CMD_LAND && _param_force_vtol.get()\n+\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing){\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n+\t\t}\n+\n \t\t/* we have a new position item so set previous position setpoint to current */\n \t\tset_previous_pos_setpoint();\n \n@@ -461,14 +471,76 @@ Mission::set_mission_items()\n \n \t\t/* if we just did a takeoff navigate to the actual waypoint now */\n \t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n+\n+\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n+\t\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t\t&& has_next_position_item) {\n+\t\t\t\t/* check if the vtol_takeoff command is on top of us */\n+\t\t\t\tif(do_need_move_to_takeoff()){\n+\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF;\n+\t\t\t\t} else {\n+\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t\t\t}\n+\n+\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\t\t\t_mission_item.params[0] = vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n+\t\t\t\t_mission_item.yaw = _navigator->get_global_position()->yaw;\n+\t\t\t} else {\n+\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n+\t\t\t\t_mission_item.yaw = NAN;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n+\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF) {\n+\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n-\t\t\t_mission_item.yaw = NAN;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0.0f;\n+\t\t}\n+\n+\t\t/* move to land wp as fixed wing */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n+\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_DEFAULT\n+\t\t\t\t&& !_navigator->get_vstatus()->condition_landed) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n+\t\t\t/* use current mission item as next position item */\n+\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n+\t\t\thas_next_position_item = true;\n+\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n+\t\t\tif (pos_sp_triplet->current.valid) {\n+\t\t\t\taltitude = pos_sp_triplet->current.alt;\n+\t\t\t}\n+\n+\t\t\t_mission_item.altitude = altitude;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n+\t\t}\n+\n+\t\t/* transition to MC */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n+\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n+\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !_navigator->get_vstatus()->condition_landed) {\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\t\t_mission_item.params[0] = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n \t\t}\n \n \t\t/* move to landing waypoint before descent if necessary */\n-\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n+\t\tif (do_need_move_to_land() &&\n+\t\t\t\t(_work_item_type == WORK_ITEM_TYPE_DEFAULT ||\n+\t\t\t\t _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION)) {\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n \n \t\t\t/* use current mission item as next position item */\n@@ -495,14 +567,17 @@ Mission::set_mission_items()\n \t\t}\n \n \t\t/* we just moved to the landing waypoint, now descend */\n-\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n+\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing) {\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \t\t}\n \n+\n+\n \t\t/* ignore yaw for landing items */\n \t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n \t\t * that aligns the vehicle first */\n-\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND ) {\n \t\t\t_mission_item.yaw = NAN;\n \t\t}\n \n@@ -517,46 +592,14 @@ Mission::set_mission_items()\n \t\t\t\t&& has_next_position_item) {\n \n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n-\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\tcopy_positon_if_valid(_mission_item, pos_sp_triplet->current);\n-\t\t\t_mission_item.autocontinue = true;\n-\t\t\t_mission_item.time_inside = 0;\n-\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t_navigator->get_global_position()->lat,\n-\t\t\t\t_navigator->get_global_position()->lon,\n-\t\t\t\tmission_item_next_position.lat,\n-\t\t\t\tmission_item_next_position.lon);\n-\t\t\t_mission_item.force_heading = true;\n+\t\t\tset_align_mission_item(&_mission_item, &mission_item_next_position);\n \t\t}\n \n \t\t/* yaw is aligned now */\n \t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \t\t}\n \n-\t\t/* don't advance mission after FW to MC command */\n-\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n-\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n-\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n-\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n-\t\t\t\t&& pos_sp_triplet->current.valid) {\n-\n-\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n-\t\t}\n-\n-\t\t/* after FW to MC transition finish moving to the waypoint */\n-\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n-\t\t\t\t&& pos_sp_triplet->current.valid) {\n-\n-\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n-\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\tcopy_positon_if_valid(_mission_item, pos_sp_triplet->current);\n-\t\t\t_mission_item.autocontinue = true;\n-\t\t\t_mission_item.time_inside = 0;\n-\t\t}\n-\n \t}\n \n \t/*********************************** set setpoints and check next *********************************************/\n@@ -611,23 +654,6 @@ Mission::set_mission_items()\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n-void\n-Mission::copy_positon_if_valid(struct mission_item_s &mission_item, struct position_setpoint_s &setpoint)\n-{\n-\tif (setpoint.valid) {\n-\t\t_mission_item.lat = setpoint.lat;\n-\t\t_mission_item.lon = setpoint.lon;\n-\t\t_mission_item.altitude = setpoint.alt;\n-\n-\t} else {\n-\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n-\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n-\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n-\t}\n-\n-\t_mission_item.altitude_is_relative = false;\n-}\n-\n bool\n Mission::do_need_takeoff()\n {\n@@ -647,6 +673,7 @@ Mission::do_need_takeoff()\n \t\tif (_need_takeoff && (\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n@@ -663,7 +690,21 @@ Mission::do_need_takeoff()\n bool\n Mission::do_need_move_to_land()\n {\n-\tif (_navigator->get_vstatus()->is_rotary_wing && _mission_item.nav_cmd == NAV_CMD_LAND) {\n+\tif (_navigator->get_vstatus()->is_rotary_wing && (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND)) {\n+\n+\t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\n+\t\treturn d_current > _navigator->get_acceptance_radius();\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool\n+Mission::do_need_move_to_takeoff()\n+{\n+\tif (_navigator->get_vstatus()->is_rotary_wing && _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF) {\n \n \t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n \t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n@@ -674,6 +715,39 @@ Mission::do_need_move_to_land()\n \treturn false;\n }\n \n+void\n+Mission::copy_positon_if_valid(struct mission_item_s *mission_item, struct position_setpoint_s *setpoint)\n+{\n+\tif (setpoint->valid) {\n+\t\tmission_item->lat = setpoint->lat;\n+\t\tmission_item->lon = setpoint->lon;\n+\t\tmission_item->altitude = setpoint->alt;\n+\n+\t} else {\n+\t\tmission_item->lat = _navigator->get_global_position()->lat;\n+\t\tmission_item->lon = _navigator->get_global_position()->lon;\n+\t\tmission_item->altitude = _navigator->get_global_position()->alt;\n+\t}\n+\n+\tmission_item->altitude_is_relative = false;\n+}\n+\n+void\n+Mission::set_align_mission_item(struct mission_item_s *mission_item, struct mission_item_s *mission_item_next)\n+{\n+\tmission_item->nav_cmd = NAV_CMD_WAYPOINT;\n+\tcopy_positon_if_valid(mission_item, &(_navigator->get_position_setpoint_triplet()->current));\n+\tmission_item->altitude_is_relative = false;\n+\tmission_item->autocontinue = true;\n+\tmission_item->time_inside = 0;\n+\tmission_item->yaw = get_bearing_to_next_waypoint(\n+\t\t_navigator->get_global_position()->lat,\n+\t\t_navigator->get_global_position()->lon,\n+\t\tmission_item_next->lat,\n+\t\tmission_item_next->lon);\n+\tmission_item->force_heading = true;\n+}\n+\n float\n Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n {\n@@ -696,7 +770,10 @@ Mission::heading_sp_update()\n {\n \t/* we don't want to be yawing during takeoff, landing or aligning for a transition */\n \tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n \t\t\t|| _mission_item.nav_cmd == NAV_CMD_LAND\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n \t\t\t|| _work_item_type == WORK_ITEM_TYPE_ALIGN) {\n \t\treturn;\n \t}\n@@ -781,13 +858,15 @@ Mission::altitude_sp_foh_update()\n \t}\n \n \t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n-\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < 0.0f) {\n+\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < FLT_EPSILON) {\n \t\treturn;\n \t}\n \n \t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n \t * and the FW controller has a custom landing logic */\n-\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n+\tif (_mission_item.nav_cmd == NAV_CMD_LAND\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n \t\treturn;\n \t}\n \n@@ -916,14 +995,14 @@ Mission::read_mission_item(bool onboard, int offset, struct mission_item_s *miss\n \t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n \t\t\t\t\t/* save repeat count */\n \t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, DM_PERSIST_POWER_ON_RESET,\n-\t\t\t\t\t    &mission_item_tmp, len) != len) {\n+\t\t\t\t\t\t&mission_item_tmp, len) != len) {\n \t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the\n \t\t\t\t\t\t * dataman */\n \t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"ERROR DO JUMP waypoint could not be written\");\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t\treport_do_jump_mission_changed(*mission_index_ptr,\n-\t\t\t\t\t\t\t\t       mission_item_tmp.do_jump_repeat_count);\n+\t\t\t\t\t\t\t\t\t   mission_item_tmp.do_jump_repeat_count);\n \t\t\t\t}\n \t\t\t\t/* set new mission item index and repeat\n \t\t\t\t* we don't have to validate here, if it's invalid, we should realize this later .*/\n@@ -1080,7 +1159,7 @@ Mission::reset_offboard_mission(struct mission_s &mission)\n \t\t\t\t\t\titem.do_jump_current_count = 0;\n \n \t\t\t\t\t\tif (dm_write(dm_current, index, DM_PERSIST_POWER_ON_RESET,\n-\t\t\t\t\t\t\t     &item, len) != len) {\n+\t\t\t\t\t\t\t\t &item, len) != len) {\n \t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/36fdf72a1840c5645bd6c2d74e7068d66b855a83/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 20,
        "deletions": 6,
        "changes": 26,
        "patch": "@@ -119,11 +119,6 @@ class Mission : public MissionBlock\n \t */\n \tvoid set_mission_items();\n \n-\t/**\n-\t * Copies position from setpoint if valid, otherwise copies current position\n-\t */\n-\tvoid copy_positon_if_valid(struct mission_item_s &mission_item, struct position_setpoint_s &setpoint);\n-\n \t/**\n \t * Returns true if we need to do a takeoff at the current state\n \t */\n@@ -134,6 +129,21 @@ class Mission : public MissionBlock\n \t */\n \tbool do_need_move_to_land();\n \n+\t/**\n+\t * Returns true if we need to move to waypoint location after vtol takeoff\n+\t */\n+\tbool do_need_move_to_takeoff();\n+\n+\t/**\n+\t * Copies position from setpoint if valid, otherwise copies current position\n+\t */\n+\tvoid copy_positon_if_valid(struct mission_item_s *mission_item, struct position_setpoint_s *setpoint);\n+\n+\t/**\n+\t * Create mission item to align towards next waypoint\n+\t */\n+\tvoid set_align_mission_item(struct mission_item_s *mission_item, struct mission_item_s *mission_item_next);\n+\n \t/**\n \t * Calculate takeoff height for mission item considering ground clearance\n \t */\n@@ -218,6 +228,7 @@ class Mission : public MissionBlock\n \tcontrol::BlockParamFloat _param_dist_1wp;\n \tcontrol::BlockParamInt _param_altmode;\n \tcontrol::BlockParamInt _param_yawmode;\n+\tcontrol::BlockParamInt _param_force_vtol;\n \n \tstruct mission_s _onboard_mission;\n \tstruct mission_s _offboard_mission;\n@@ -250,7 +261,10 @@ class Mission : public MissionBlock\n \t\tWORK_ITEM_TYPE_TAKEOFF,\t\t/**< takeoff before moving to waypoint */\n \t\tWORK_ITEM_TYPE_MOVE_TO_LAND,\t/**< move to land waypoint before descent */\n \t\tWORK_ITEM_TYPE_ALIGN,\t\t/**< align for next waypoint */\n-\t\tWORK_ITEM_TYPE_CMD_BEFORE_MOVE\t/**<  */\n+\t\tWORK_ITEM_TYPE_CMD_BEFORE_MOVE,\t/**<  */\n+\t\tWORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF,\t/**<  */\n+\t\tWORK_ITEM_TYPE_TRANSITON_BEFORE_LAND,\t/**<  */\n+\t\tWORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION\t/**<  */\n \t} _work_item_type;\t/**< current type of work to do (sub mission item) */\n \n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/36fdf72a1840c5645bd6c2d74e7068d66b855a83/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 7,
        "changes": 30,
        "patch": "@@ -93,7 +93,8 @@ MissionBlock::is_mission_item_reached()\n \t\tcase NAV_CMD_DO_SET_SERVO:\n \t\t\treturn true;\n \n-\t\tcase NAV_CMD_LAND:\n+\t\tcase NAV_CMD_LAND: /* fall through */\n+\t\tcase NAV_CMD_VTOL_LAND:\n \t\t\treturn _navigator->get_vstatus()->condition_landed;\n \n \t\t/* TODO: count turns */\n@@ -109,14 +110,12 @@ MissionBlock::is_mission_item_reached()\n \t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n \t\t\t/*\n \t\t\t * We wait half a second to give the transition command time to propagate.\n-\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n+\t\t\t * Then monitor the transition status for completion.\n \t\t\t */\n-\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n-\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n+\t\t\tif (hrt_absolute_time() - _action_start > 500000 &&\n+\t\t\t\t\t!_navigator->get_vstatus()->in_transition_mode) {\n \t\t\t\t_action_start = 0;\n-\n \t\t\t\treturn true;\n-\n \t\t\t} else {\n \t\t\t\treturn false;\n \t\t\t}\n@@ -154,7 +153,8 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n \t\t\t\t&dist_xy, &dist_z);\n \n-\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n+\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n+\t\t\t&& _navigator->get_vstatus()->is_rotary_wing) {\n \t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n \t\t\tif (_navigator->get_global_position()->alt >\n \t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n@@ -334,6 +334,20 @@ MissionBlock::item_contains_position(const struct mission_item_s *item)\n void\n MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n {\n+\t/* set the correct setpoint for vtol transition */\n+\n+\tif(item->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION && PX4_ISFINITE(item->yaw)) {\n+\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t\twaypoint_from_heading_and_distance(_navigator->get_global_position()->lat,\n+\t\t\t\t\t\t\t\t\t\t   _navigator->get_global_position()->lon,\n+\t\t\t\t\t\t\t\t\t\t   item->yaw,\n+\t\t\t\t\t\t\t\t\t\t   1000000.0f,\n+\t\t\t\t\t\t\t\t\t\t   &sp->lat,\n+\t\t\t\t\t\t\t\t\t\t   &sp->lon);\n+\t\tsp->alt = _navigator->get_global_position()->alt;\n+\t}\n+\n+\n \t/* don't change the setpoint for non-position items */\n \tif (!item_contains_position(item)) {\n \t\treturn;\n@@ -358,10 +372,12 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \t\tbreak;\n \n \tcase NAV_CMD_TAKEOFF:\n+\tcase NAV_CMD_VTOL_TAKEOFF:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n \t\tbreak;\n \n \tcase NAV_CMD_LAND:\n+\tcase NAV_CMD_VTOL_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n \t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n \t\t\tsp->disable_mc_yaw_control = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/36fdf72a1840c5645bd6c2d74e7068d66b855a83/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -242,6 +242,8 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_LAND &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_LAND &&\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_TAKEOFF &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/36fdf72a1840c5645bd6c2d74e7068d66b855a83/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -63,6 +63,8 @@ enum NAV_CMD {\n \tNAV_CMD_PATHPLANNING = 81,\n \tNAV_CMD_FOLLOW_TARGET = 194, // temporary placeholder\n \tNAV_CMD_GOTO_TAREGT = 195,\n+\tNAV_CMD_VTOL_TAKEOFF = 84,\n+\tNAV_CMD_VTOL_LAND = 85,\n \tNAV_CMD_DO_JUMP = 177,\n \tNAV_CMD_DO_CHANGE_SPEED = 178,\n \tNAV_CMD_DO_SET_SERVO=183,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/36fdf72a1840c5645bd6c2d74e7068d66b855a83/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::altitude_sp_foh_update",
        "MissionBlock::item_contains_position",
        "Mission::reset_offboard_mission",
        "Mission::read_mission_item",
        "Mission::do_need_move_to_land",
        "MissionBlock::is_mission_item_reached",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "copy_positon_if_valid",
        "MissionBlock::mission_item_to_position_setpoint",
        "Mission::heading_sp_update",
        "Mission::do_need_takeoff",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::altitude_sp_foh_update",
          "Mission::reset_offboard_mission",
          "Mission::read_mission_item",
          "Mission::do_need_move_to_land",
          "Mission::heading_sp_update",
          "Mission::do_need_takeoff",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission.h": [
          "copy_positon_if_valid"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::item_contains_position",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionItemValidity"
        ]
      }
    }
  },
  {
    "title": "MissionFeasibilityChecker geofence ignore NAV_CMD_DO_*",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4046",
    "number": 4046,
    "created_at": "2016-03-21T03:39:11Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "-closes #4040\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2016-03-21T14:59:29Z",
          "body": "Thanks @AndreasAntener \nIs there a better place a helper like item_contains_position() could live in navigator? At the moment I made it public and static within MissionBlock so it was accessible from MissionFeasibilityChecker.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-21T19:24:30Z",
          "body": "Only idea I'd have would be to add a helper class, but it's a bit overkill atm for one method. Maybe add a comment about it.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-22T00:21:41Z",
          "body": "Added todo\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-22T05:56:18Z",
          "body": "Thanks, applied\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-21T13:10:07Z",
          "body": "We could use https://github.com/PX4/Firmware/blob/master/src/modules/navigator/mission_block.cpp#L318 and also add NAV_CMD_DO_JUMP to the list there (it's currently not because it's handled separately in missions but adding it won't have any other effect)\n",
          "path": "src/modules/navigator/mission_feasibility_checker.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes MissionFeasibilityChecker behavior to ignore NAV_CMD_DO_* commands for geofence checks, which corrects incorrect runtime behavior (wrong geofence enforcement). The discussion about adding a helper (item_contains_position) and making it accessible indicates the change is about program logic/state handling rather than style, so this is a logic bug fix.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "patch": "@@ -318,11 +318,13 @@ bool\n MissionBlock::item_contains_position(const struct mission_item_s *item)\n {\n \t// XXX: maybe extend that check onto item properties\n-\tif (item->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n-\t\t\titem->nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST ||\n-\t\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION ||\n-\t\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO ||\n-\t\t\titem->nav_cmd == NAV_CMD_DO_CHANGE_SPEED) {\n+\tif (item->nav_cmd == NAV_CMD_DO_JUMP ||\n+\t\titem->nav_cmd == NAV_CMD_DO_CHANGE_SPEED ||\n+\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO ||\n+\t\titem->nav_cmd == NAV_CMD_DO_REPEAT_SERVO ||\n+\t\titem->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n+\t\titem->nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST ||\n+\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION) {\n \t\treturn false;\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c4f35015260e8a0f2d454b49939cc3c0a0a10fc1/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -67,6 +67,9 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvirtual ~MissionBlock();\n \n+\t/* TODO: move this to a helper class in navigator */\n+\tstatic bool item_contains_position(const struct mission_item_s *item);\n+\n protected:\n \t/**\n \t * Check if mission item has been reached\n@@ -78,8 +81,6 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid reset_mission_item_reached();\n \n-\tbool item_contains_position(const struct mission_item_s *item);\n-\n \t/**\n \t * Convert a mission item to a position setpoint\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c4f35015260e8a0f2d454b49939cc3c0a0a10fc1/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -41,6 +41,7 @@\n \n #include \"mission_feasibility_checker.h\"\n \n+#include \"mission_block.h\"\n #include <geo/geo.h>\n #include <math.h>\n #include <mathlib/mathlib.h>\n@@ -161,7 +162,9 @@ bool MissionFeasibilityChecker::checkGeofence(dm_item_t dm_current, size_t nMiss\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tif (!geofence.inside_polygon(missionitem.lat, missionitem.lon, missionitem.altitude)) {\n+\t\t\tif (MissionBlock::item_contains_position(&missionitem) &&\n+\t\t\t\t!geofence.inside_polygon(missionitem.lat, missionitem.lon, missionitem.altitude)) {\n+\n \t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation for waypoint %d\", i);\n \t\t\t\treturn false;\n \t\t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c4f35015260e8a0f2d454b49939cc3c0a0a10fc1/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "item_contains_position",
        "MissionBlock::item_contains_position",
        "MissionFeasibilityChecker::checkGeofence"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::item_contains_position"
        ],
        "src/modules/navigator/mission_block.h": [
          "item_contains_position"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkGeofence"
        ]
      }
    }
  },
  {
    "title": "reset mission after vehicle was in mission and then disarms",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4043",
    "number": 4043,
    "created_at": "2016-03-20T13:46:35Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "Fixes #3978 , SITL tested\nPlease review\n\nNote: I had the reset code in commander first but that didn't feel right so I moved it to mission. There might be a better way to trigger the reset instead via the `offboard_mission` topic.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-20T13:56:32Z",
          "body": "Changes / architecture looks good.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T14:06:58Z",
          "body": "I commented on this. I think it needs to be done solely in the navigator without intervention from the commander.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-25T09:25:53Z",
          "body": "@LorenzMeier makes sense, will fix this\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-27T02:02:24Z",
          "body": "Updated, SITL tested.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-27T10:27:01Z",
          "body": "Looked good, sane and safe, so I applied it to master, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T14:05:18Z",
          "body": "Why is this logic in the commander after all? Can't the navigator just do this by itself, since it knows the current flight mode?\n",
          "path": "src/modules/commander/commander.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T14:05:49Z",
          "body": "This introduces a race with the mavlink app, which also publishes this topic. If we publish something from the commander, it would need to be done on a different topic.\n",
          "path": "src/modules/commander/commander.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T14:06:28Z",
          "body": "Would prefer to trigger this on a vehicle status change with state == mission and disarmed.\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect state handling when a vehicle that was executing a mission is disarmed but the mission state is not properly reset. This is a logic-level fix (improper state transition) that changes where the reset is triggered to ensure correct behavior after disarm.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "patch": "@@ -80,6 +80,7 @@ Mission::Mission(Navigator *navigator, const char *name) :\n \t_mission_type(MISSION_TYPE_NONE),\n \t_inited(false),\n \t_home_inited(false),\n+\t_need_mission_reset(false),\n \t_missionFeasibilityChecker(),\n \t_min_current_sp_distance_xy(FLT_MAX),\n \t_mission_item_previous_alt(NAN),\n@@ -111,6 +112,12 @@ Mission::on_inactive()\n \t\t\tupdate_offboard_mission();\n \t\t}\n \n+\t\t/* reset the current offboard mission if needed */\n+\t\tif (need_to_reset_mission(false)) {\n+\t\t\treset_offboard_mission(_offboard_mission);\n+\t\t\tupdate_offboard_mission();\n+\t\t}\n+\n \t} else {\n \n \t\t/* load missions from storage */\n@@ -164,6 +171,13 @@ Mission::on_active()\n \t\tupdate_offboard_mission();\n \t}\n \n+\t/* reset the current offboard mission if needed */\n+\tif (need_to_reset_mission(true)) {\n+\t\treset_offboard_mission(_offboard_mission);\n+\t\tupdate_offboard_mission();\n+\t\toffboard_updated = true;\n+\t}\n+\n \t/* reset mission items if needed */\n \tif (onboard_updated || offboard_updated) {\n \t\tset_mission_items();\n@@ -1038,3 +1052,71 @@ Mission::check_mission_valid()\n \n \treturn _navigator->get_mission_result()->valid;\n }\n+\n+void\n+Mission::reset_offboard_mission(struct mission_s &mission)\n+{\n+\tdm_lock(DM_KEY_MISSION_STATE);\n+\n+\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s)) == sizeof(mission_s)) {\n+\t\tif (mission.dataman_id >= 0 && mission.dataman_id <= 1) {\n+\t\t\t/* set current item to 0 */\n+\t\t\tmission.current_seq = 0;\n+\n+\t\t\t/* reset jump counters */\n+\t\t\tif (mission.count > 0) {\n+\t\t\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(mission.dataman_id);\n+\n+\t\t\t\tfor (int index = 0; index < mission.count; index++) {\n+\t\t\t\t\tstruct mission_item_s item;\n+\t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n+\n+\t\t\t\t\tif (dm_read(dm_current, index, &item, len) != len) {\n+\t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n+\t\t\t\t\t\titem.do_jump_current_count = 0;\n+\n+\t\t\t\t\t\tif (dm_write(dm_current, index, DM_PERSIST_POWER_ON_RESET,\n+\t\t\t\t\t\t\t     &item, len) != len) {\n+\t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_fd(), \"ERROR: could not read mission\");\n+\n+\t\t\t/* initialize mission state in dataman */\n+\t\t\tmission.dataman_id = 0;\n+\t\t\tmission.count = 0;\n+\t\t\tmission.current_seq = 0;\n+\t\t}\n+\n+\t\tdm_write(DM_KEY_MISSION_STATE, 0, DM_PERSIST_POWER_ON_RESET, &mission, sizeof(mission_s));\n+\n+\t\tmavlink_and_console_log_info(_navigator->get_mavlink_fd(), \"mission reset\");\n+\t}\n+\n+\tdm_unlock(DM_KEY_MISSION_STATE);\n+}\n+\n+bool\n+Mission::need_to_reset_mission(bool active)\n+{\n+\t/* reset mission state when disarmed */\n+\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED && _need_mission_reset) {\n+\t\t_need_mission_reset = false;\n+\t\treturn true;\n+\n+\t} else if (_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED && active) {\n+\t\t/* mission is running, need reset after disarm */\n+\t\t_need_mission_reset = true;\n+\t}\n+\n+\treturn false;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e629d27c4cf414eb0b1a0cdaa50825343c2ebaa0/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -203,6 +203,16 @@ class Mission : public MissionBlock\n \t */\n \tbool check_mission_valid();\n \n+\t/**\n+\t * Reset offboard mission\n+\t */\n+\tvoid reset_offboard_mission(struct mission_s &mission);\n+\n+\t/**\n+\t * Returns true if we need to reset the mission\n+\t */\n+\tbool need_to_reset_mission(bool active);\n+\n \tcontrol::BlockParamInt _param_onboard_enabled;\n \tcontrol::BlockParamFloat _param_takeoff_alt;\n \tcontrol::BlockParamFloat _param_dist_1wp;\n@@ -224,6 +234,7 @@ class Mission : public MissionBlock\n \n \tbool _inited;\n \tbool _home_inited;\n+\tbool _need_mission_reset;\n \n \tMissionFeasibilityChecker _missionFeasibilityChecker; /**< class that checks if a mission is feasible */\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e629d27c4cf414eb0b1a0cdaa50825343c2ebaa0/src%2Fmodules%2Fnavigator%2Fmission.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::on_inactive",
        "Mission::on_active",
        "Mission::check_mission_valid"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::on_inactive",
          "Mission::on_active",
          "Mission::check_mission_valid"
        ]
      }
    }
  },
  {
    "title": "Reset current setpoint when entering RTL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4012",
    "number": 4012,
    "created_at": "2016-03-14T21:53:11Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "Fixes #3844 \nSITL tested\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-14T22:08:12Z",
          "body": "Sounds like we should merge this once Travis passes.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-14T22:38:15Z",
          "body": "Rebased, I was a bit out of date..\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-19T15:30:39Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes behavior on mode transition (entering RTL) by resetting the current setpoint, which addresses an incorrect program state remaining across a state transition. That is a classical logic error (improper state handling) and the change fixes unintended behavior reported in issue #3844.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "patch": "@@ -503,6 +503,24 @@ MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_locatio\n \titem->origin = ORIGIN_ONBOARD;\n }\n \n+void\n+MissionBlock::set_current_position_item(struct mission_item_s *item)\n+{\n+\titem->nav_cmd = NAV_CMD_WAYPOINT;\n+\titem->lat = _navigator->get_global_position()->lat;\n+\titem->lon = _navigator->get_global_position()->lon;\n+\titem->altitude_is_relative = false;\n+\titem->altitude = _navigator->get_global_position()->alt;\n+\titem->yaw = NAN;\n+\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_direction = 1;\n+\titem->acceptance_radius = _navigator->get_acceptance_radius();\n+\titem->time_inside = 0.0f;\n+\titem->pitch_min = 0.0f;\n+\titem->autocontinue = true;\n+\titem->origin = ORIGIN_ONBOARD;\n+}\n+\n void\n MissionBlock::set_idle_item(struct mission_item_s *item)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3b7c039bdc936d180638de2785cdfefde6ac48c/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -108,6 +108,8 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_land_item(struct mission_item_s *item, bool at_current_location);\n \n+\tvoid set_current_position_item(struct mission_item_s *item);\n+\n \t/**\n \t * Set idle mission item\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3b7c039bdc936d180638de2785cdfefde6ac48c/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "patch": "@@ -85,6 +85,12 @@ RTL::on_inactive()\n void\n RTL::on_activation()\n {\n+\t/* reset starting point so we override what the triplet contained from the previous navigation state */\n+\t_rtl_start_lock = false;\n+\tset_current_position_item(&_mission_item);\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\n \t/* decide where to enter the RTL procedure when we switch into it */\n \tif (_rtl_state == RTL_STATE_NONE) {\n \t\t/* for safety reasons don't go into RTL if landed */\n@@ -96,15 +102,13 @@ RTL::on_activation()\n \t\t} else if (_navigator->get_global_position()->alt < _navigator->get_home_position()->alt\n \t\t\t   + _param_return_alt.get()) {\n \t\t\t_rtl_state = RTL_STATE_CLIMB;\n-\t\t\t_rtl_start_lock = false;\n \n \t\t/* otherwise go straight to return */\n \t\t} else {\n \t\t\t/* set altitude setpoint to current altitude */\n \t\t\t_rtl_state = RTL_STATE_RETURN;\n \t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n-\t\t\t_rtl_start_lock = false;\n \t\t}\n \n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3b7c039bdc936d180638de2785cdfefde6ac48c/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_land_item",
        "RTL::on_inactive",
        "RTL::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_land_item"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_inactive",
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Param unit cleanup",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4000",
    "number": 4000,
    "created_at": "2016-03-13T18:28:53Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2016-03-13T20:46:47Z",
          "body": "@LorenzMeier @DonLakeFlyer ready for review please\n\nCurrent @unit usage\n\n```\n  4  * @unit 1/s\n  1  * @unit A\n  1  * @unit bit/s\n 44  * @unit boolean\n 40  * @unit deg\n  4  * @unit deg * 1e7\n 19  * @unit deg/s\n 54  * @unit enum\n  1  * @unit Gauss\n  1  * @unit Gauss/s\n  1  * @unit hPa\n  5  * @unit Hz\n  1  * @unit kg\n  3  * @unit kg*m^2\n 47  * @unit m\n  1  * @unit m^2\n  1  * @unit mA\n  1  * @unit min\n  1  * @unit m/m\n 12  * @unit ms\n  1  * @unit m-s\n 35  * @unit m/s\n  2  * @unit (m/s)-s\n 10  * @unit m/s/s\n  1  * @unit (m/s/s)-s\n  1  * @unit rad\n  8  * @unit rad/s\n 26  * @unit s\n  7  * @unit SD\n 66  * @unit us\n  3  * @unit V\n  1  * @unit W\n```\n",
          "type": "issue_comment"
        },
        {
          "author": "DonLakeFlyer",
          "created_at": "2016-03-13T20:54:19Z",
          "body": "I'd probably change the seconds ones to secs, msecs, usecs. A little more clear. What is SD?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-13T20:59:14Z",
          "body": "It's in ekf2 so I left it alone. Standard deviation?\nhttps://github.com/PX4/Firmware/blob/cecec86081566f243a0dec33b9dedc3dd1624f58/src/modules/ekf2/ekf2_params.c#L316\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-13T21:22:40Z",
          "body": "I used s, ms, us to stick to SI, but if you want the abbreviation I'll change them.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-14T08:13:14Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR appears to be a cleanup of parameter unit annotations (changing unit strings like s/ms/us), which is documentation/metadata rather than program logic. There is no indication of fixes to conditionals, state transitions, algorithms, or behavior-changing code, so it does not address a logic error.",
    "patches": {
      "src/modules/navigator/datalinkloss_params.c": {
        "filename": "src/modules/navigator/datalinkloss_params.c",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "patch": "@@ -48,7 +48,7 @@\n  *\n  * The amount of time in seconds the system should wait at the comms hold waypoint\n  *\n- * @unit seconds\n+ * @unit s\n  * @min 0.0\n  * @group Data Link Loss\n  */\n@@ -59,7 +59,7 @@ PARAM_DEFINE_FLOAT(NAV_DLL_CH_T, 120.0f);\n  *\n  * Latitude of comms hold waypoint\n  *\n- * @unit degrees * 1e7\n+ * @unit deg * 1e7\n  * @min -900000000\n  * @max 900000000\n  * @group Data Link Loss\n@@ -71,7 +71,7 @@ PARAM_DEFINE_INT32(NAV_DLL_CH_LAT, -266072120);\n  *\n  * Longitude of comms hold waypoint\n  *\n- * @unit degrees * 1e7\n+ * @unit deg * 1e7\n  * @min -1800000000\n  * @max 1800000000\n  * @group Data Link Loss\n@@ -95,7 +95,7 @@ PARAM_DEFINE_FLOAT(NAV_DLL_CH_ALT, 600.0f);\n  *\n  * The amount of time in seconds the system should wait at the airfield home waypoint\n  *\n- * @unit seconds\n+ * @unit s\n  * @min 0.0\n  * @group Data Link Loss\n  */\n@@ -119,7 +119,6 @@ PARAM_DEFINE_INT32(NAV_DLL_N, 2);\n  * airfield home\n  *\n  * @group Data Link Loss\n- * @min 0\n- * @max 1\n+ * @unit boolean\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CHSK, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Fdatalinkloss_params.c"
      },
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "patch": "@@ -48,8 +48,14 @@\n  *\n  * 0 = none, 1 = warning (default), 2 = loiter, 3 = return to launch, 4 = fight termination\n  *\n+ * @unit enum\n  * @min 0\n  * @max 4\n+ * @value 0 none\n+ * @value 1 warning\n+ * @value 2 loiter\n+ * @value 3 return\n+ * @value 4 terminate\n  * @group Geofence\n  */\n PARAM_DEFINE_INT32(GF_ACTION, 1);\n@@ -60,8 +66,11 @@ PARAM_DEFINE_INT32(GF_ACTION, 1);\n  * Select which altitude reference should be used\n  * 0 = WGS84, 1 = AMSL\n  *\n+ * @unit enum\n  * @min 0\n  * @max 1\n+ * @value 0 WGS84\n+ * @value 1 AMSL\n  * @group Geofence\n  */\n PARAM_DEFINE_INT32(GF_ALTMODE, 0);\n@@ -73,8 +82,11 @@ PARAM_DEFINE_INT32(GF_ALTMODE, 0);\n  * no dependence on the position estimator\n  * 0 = global position, 1 = GPS\n  *\n+ * @unit enum\n  * @min 0\n  * @max 1\n+ * @value 0 GPOS\n+ * @value 1 GPS\n  * @group Geofence\n  */\n PARAM_DEFINE_INT32(GF_SOURCE, 0);\n@@ -95,7 +107,7 @@ PARAM_DEFINE_INT32(GF_COUNT, -1);\n  *\n  * Set to > 0 to activate a geofence action if horizontal distance to home exceeds this value.\n  *\n- * @unit meters\n+ * @unit m\n  * @min -1\n  * @group Geofence\n  */\n@@ -106,7 +118,7 @@ PARAM_DEFINE_INT32(GF_MAX_HOR_DIST, -1);\n  *\n  * Set to > 0 to activate a geofence action if vertical distance to home exceeds this value.\n  *\n- * @unit meters\n+ * @unit m\n  * @min -1\n  * @group Geofence\n  */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      },
      "src/modules/navigator/gpsfailure_params.c": {
        "filename": "src/modules/navigator/gpsfailure_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "patch": "@@ -49,7 +49,7 @@\n  * The amount of time in seconds the system should do open loop loiter and wait for gps recovery\n  * before it goes into flight termination.\n  *\n- * @unit seconds\n+ * @unit s\n  * @min 0.0\n  * @group GPS Failure Navigation\n  */\n@@ -89,5 +89,3 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_P, 0.0f);\n  * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_TR, 0.7f);\n-\n-",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Fgpsfailure_params.c"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "patch": "@@ -49,7 +49,9 @@\n  * Even if first waypoint has altitude less then MIS_TAKEOFF_ALT above home position, system will climb to\n  * MIS_TAKEOFF_ALT on takeoff, then go to waypoint.\n  *\n- * @unit meters\n+ * @unit m\n+ * @min 0\n+ * @max 1000\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n@@ -60,8 +62,7 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n  * When enabled, missions that have been uploaded by the GCS are stored\n  * and reloaded after reboot persistently.\n  *\n- * @min 0\n- * @max 1\n+ * @unit boolean\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_ONBOARD_EN, 1);\n@@ -73,6 +74,7 @@ PARAM_DEFINE_INT32(MIS_ONBOARD_EN, 1);\n  * Set a value of zero or less to disable. The mission will not be started if the current\n  * waypoint is more distant than MIS_DIS_1WP from the current position.\n  *\n+ * @unit m\n  * @min 0\n  * @max 1000\n  * @group Mission\n@@ -86,8 +88,11 @@ PARAM_DEFINE_FLOAT(MIS_DIST_1WP, 900);\n  * 1: the system will follow a first order hold altitude setpoint\n  * values follow the definition in enum mission_altitude_mode\n  *\n+ * @unit enum\n  * @min 0\n  * @max 1\n+ * @value 0 zero order\n+ * @value 1 first order\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n@@ -102,8 +107,13 @@ PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n  *\n  * The values are defined in the enum mission_altitude_mode\n  *\n+ * @unit enum\n  * @min 0\n  * @max 3\n+ * @value 0 destination\n+ * @value 1 next\n+ * @value 2 home\n+ * @value 3 home back\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n@@ -125,6 +135,7 @@ PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n /**\n  * Max yaw error in degree needed for waypoint heading acceptance.\n  *\n+ * @unit deg\n  * @min 0\n  * @max 90\n  * @group Mission",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "patch": "@@ -45,7 +45,7 @@\n  *\n  * Default value of loiter radius for missions, loiter, RTL, etc. (fixedwing only).\n  *\n- * @unit meter\n+ * @unit m\n  * @min 25\n  * @max 1000\n  * @group Mission\n@@ -57,7 +57,7 @@ PARAM_DEFINE_FLOAT(NAV_LOITER_RAD, 50.0f);\n  *\n  * Default acceptance radius, overridden by acceptance radius of waypoint if set.\n  *\n- * @unit meter\n+ * @unit m\n  * @min 0.05\n  * @max 200.0\n  * @group Mission\n@@ -67,21 +67,19 @@ PARAM_DEFINE_FLOAT(NAV_ACC_RAD, 10.0f);\n /**\n  * Set OBC mode for data link loss\n  *\n- * If set to 1 the behaviour on data link loss is set to a mode according to the OBC rules\n+ * If set to 1 the behaviour on data link loss is set to a mode according to the Outback Challenge (OBC) rules\n  *\n- * @min 0\n- * @max 1\n+ * @unit boolean\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(NAV_DLL_OBC, 0);\n \n /**\n  * Set OBC mode for rc loss\n  *\n- * If set to 1 the behaviour on data link loss is set to a mode according to the OBC rules\n+ * If set to 1 the behaviour on data link loss is set to a mode according to the Outback Challenge (OBC) rules\n  *\n- * @min 0\n- * @max 1\n+ * @unit boolean\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(NAV_RCL_OBC, 0);\n@@ -91,7 +89,7 @@ PARAM_DEFINE_INT32(NAV_RCL_OBC, 0);\n  *\n  * Latitude of airfield home waypoint\n  *\n- * @unit degrees * 1e7\n+ * @unit deg * 1e7\n  * @min -900000000\n  * @max 900000000\n  * @group Data Link Loss\n@@ -103,7 +101,7 @@ PARAM_DEFINE_INT32(NAV_AH_LAT, -265847810);\n  *\n  * Longitude of airfield home waypoint\n  *\n- * @unit degrees * 1e7\n+ * @unit deg * 1e7\n  * @min -1800000000\n  * @max 1800000000\n  * @group Data Link Loss",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rcloss_params.c": {
        "filename": "src/modules/navigator/rcloss_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -49,7 +49,7 @@\n  * The amount of time in seconds the system should loiter at current position before termination\n  * Set to -1 to make the system skip loitering\n  *\n- * @unit seconds\n+ * @unit s\n  * @min -1.0\n  * @group Radio Signal Loss\n  */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Frcloss_params.c"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -48,7 +48,7 @@\n  *\n  * Altitude to fly back in RTL in meters\n  *\n- * @unit meters\n+ * @unit m\n  * @min 0\n  * @max 150\n  * @group Return To Land\n@@ -62,7 +62,7 @@ PARAM_DEFINE_FLOAT(RTL_RETURN_ALT, 60);\n  * Stay at this altitude above home position after RTL descending.\n  * Land (i.e. slowly descend) from this altitude if autolanding allowed.\n  *\n- * @unit meters\n+ * @unit m\n  * @min 2\n  * @max 100\n  * @group Return To Land\n@@ -75,7 +75,7 @@ PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n  * Delay after descend before landing in RTL mode.\n  * If set to -1 the system will not land but loiter at NAV_LAND_ALT.\n  *\n- * @unit seconds\n+ * @unit s\n  * @min -1\n  * @max 300\n  * @group Return To Land",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8c0e82cb6bbdd1ec54545fb47ae6ab4c0ad9432f/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Mode switch fix",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3998",
    "number": 3998,
    "created_at": "2016-03-13T10:49:13Z",
    "merged": true,
    "merged_at": "2016-03-13T14:55:11Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "",
      "issue_comments": [
        {
          "author": "kd0aij",
          "created_at": "2016-03-13T12:54:57Z",
          "body": "Very nice, the comments will be very valuable to future maintenance coders.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title ('Mode switch fix') and use of the word 'fix' suggest it addresses incorrect behavior in mode switching (a logic-level issue). However, there is no PR description, diff, or technical discussionâ€”only a comment praising added commentsâ€”so there is insufficient evidence to be certain this change corrects a logic error.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -486,7 +486,7 @@ Navigator::task_main()\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\t_navigation_mode = &_takeoff;\n \t\t\t\tbreak;\n-\t\t\tcase vehicle_status_s::NAVIGATION_STATE_LAND:\n+\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\t_navigation_mode = &_land;\n \t\t\t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6b10d2b8e16d1df64ff68e9213b0ccd77287f156/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "FW navigator accept TAKEOFF waypoint like MC (alt only)",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3922",
    "number": 3922,
    "created_at": "2016-03-04T20:36:10Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "I think this makes the most sense for fixed wing behaviour. You're still flying towards the takeoff waypoint, but once you actually hit the altitude (within NAV_ACC_RAD) you're ready to proceed with the mission. \n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2016-03-04T21:24:06Z",
          "body": "I was also thinking about updating MissionFeasibilityChecker. What would be appropriate?\n\n-require altitude greater than: At least home + climbout_diff + nav_acc_rad or MIS_TAKEOFF_ALT?\n-minimum distance >= FW_AIRSPEED_TRIM \\* FW_T_CLMB_MAX meters from home.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T10:35:21Z",
          "body": "Both options are not ideal. Caring for horizontal position might make it turn too soon, caring for altitude might make it spiral where you don't want it. At least with the way it is now you know what it will do (because you have the next waypoint in mind). The spiral might be completely unexpected. But other than that I can't really argue for one or the other.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-05T14:19:03Z",
          "body": "I'm more concerned with the current situation making it accept too soon when you should still be climbing with roll constrained and TECS in climbout mode. With the roll limited to [-15, 15] during altitude_error > _parameters.climbout_diff the potential spiral is pretty limited depending on your FW_CLMBOUT_DIFF and NAV_ACC_RAD.\n\nA fairly common situation is hand launching into wind where the plane climbs quickly and easily hits the takeoff altitude early. Why fly to a fairly low waypoint instead of continuing the mission?\n\nThink of the takeoff waypoint as more of a cmd to launch + climb with its location not necessarily important.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T14:48:38Z",
          "body": "You can't just assume that the takeoff position is not important to the user.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T14:50:09Z",
          "body": "What your thinking off is not flying a mission but just flying manually where only the climbout diff is relevant.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-05T16:16:53Z",
          "body": "It's not necessarily assuming the takeoff position isn't important to the user (it would still be mostly respected if climbout diff > accept radius), but rather I'm trying to tweak what we already have to get the behaviour I want. Maybe that's the wrong approach.\n\nSo let's take a step back and have the proper discussion. I want to hand launch in AUTO, sometimes with launch detect, sometimes without and have that launch do nothing but safely climb in the direction I throw until a certain altitude, and then continue/start the mission. How could we accomplish this while still having the option of respecting a takeoff waypoint position?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T17:17:20Z",
          "body": "Ok. Wasn't it your plan to reuse the runway takeoff code for hand launch too? I believe it would give you exactly what you want. In \"heading mode\" it will takeoff to climbout alt in the direction you threw it, and then navigate towards takeoff wp. In \"wp mode\" will directly try to navigate towards the takeoff waypoint (which is the default behaviour at the moment I guess?).\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-05T18:04:24Z",
          "body": "You're right that will probably be exactly what I want in most cases if I just treat the takeoff waypoint like my first regular waypoint. My only concern then is the possibility that the waypoint could be accepted before RunwayTakeoffState::FLY. What would be the best way to prevent that?\n\nAdditionally check climbout diff to accept NAV_CMD_TAKEOFF or actually publish takeoff state?\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes the waypoint-acceptance logic for fixed-wing TAKEOFF to use altitude-only acceptance, addressing incorrect mission progression where the navigator could accept the takeoff waypoint at the wrong time (a flawed acceptance/state-transition condition). The discussion shows this is a behavioral bug (undesired/unsafe output) rather than a style/syntax change, so it qualifies as a logic error fix.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "patch": "@@ -145,15 +145,9 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n \t\t\t\t&dist_xy, &dist_z);\n \n-\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n-\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n-\t\t\tif (_navigator->get_global_position()->alt >\n-\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n-\t\t\t\t_waypoint_position_reached = true;\n-\t\t\t}\n-\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n-\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n-\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n+\t\t\t/* require only altitude for takeoff */\n+\t\t\tif (_navigator->get_global_position()->alt > altitude_amsl - _navigator->get_acceptance_height()) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/672efc817f2eed29ce18de60a2b843f4b307dd00/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -164,6 +164,14 @@ class Navigator : public control::SuperBlock\n \t * @return the distance at which the next waypoint should be used\n \t */\n \tfloat\t\tget_acceptance_radius(float mission_item_radius);\n+\n+\t/**\n+\t * Get the acceptance height\n+\t *\n+\t * @return the vertical distance at which the next waypoint should be used\n+\t */\n+\tfloat\t\tget_acceptance_height();\n+\n \tint\t\tget_mavlink_fd() { return _mavlink_fd; }\n \n \tvoid\t\tincrement_mission_instance_count() { _mission_instance_count++; }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/672efc817f2eed29ce18de60a2b843f4b307dd00/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -633,6 +633,12 @@ Navigator::get_acceptance_radius(float mission_item_radius)\n \treturn radius;\n }\n \n+float\n+Navigator::get_acceptance_height()\n+{\n+\treturn _param_acceptance_radius.get();\n+}\n+\n void Navigator::add_fence_point(int argc, char *argv[])\n {\n \t_geofence.addPoint(argc, argv);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/672efc817f2eed29ce18de60a2b843f4b307dd00/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::get_acceptance_radius",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "navigator only accept waypoint if !landed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3908",
    "number": 3908,
    "created_at": "2016-03-02T15:17:42Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This also includes a minor fw_pos_control_l1 cleanup where the const arg pos_sp_triplet and _pos_sp_triplet were being used interchangeably.\n\nPossible fix for #3902\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-03T09:10:41Z",
          "body": "Looking good to me. It still will require putting takeoff waypoints at a suitable minimum distance - which probably needs to be fixed in the GCS.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-03T09:16:06Z",
          "body": "The change looked anyway good, so I cherry-picked it it onto master. Closing.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the navigator to only accept waypoints when the vehicle is not landed, which corrects an incorrect state transition/acceptance condition. The discussion and cherry-pick indicate this fixes unintended behavior (issue #3902); the other changes are minor API/const cleanups and not relevant to the logic fix.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -128,7 +128,9 @@ MissionBlock::is_mission_item_reached()\n \n \thrt_abstime now = hrt_absolute_time();\n \n-\tif (!_waypoint_position_reached) {\n+\tif ((_navigator->get_vstatus()->condition_landed == false)\n+\t\t&& !_waypoint_position_reached) {\n+\n \t\tfloat dist = -1.0f;\n \t\tfloat dist_xy = -1.0f;\n \t\tfloat dist_z = -1.0f;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/84acefe9135aa0c4a39f0b138832a67143ef50f4/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "Loiter min altitude: Differentiate between loiter and takeoff",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3880",
    "number": 3880,
    "created_at": "2016-02-28T19:34:17Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "This should help with suddenly rising systems.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-14T08:05:44Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and description indicate a behavioral change that distinguishes loiter from takeoff when computing minimum altitude, addressing issues with \"suddenly rising systems.\" That change targets incorrect behavior/state handling (misclassification of flight phase and resulting altitude logic), which fits the definition of a logic error.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -56,7 +56,7 @@\n \n Loiter::Loiter(Navigator *navigator, const char *name) :\n \tMissionBlock(navigator, name),\n-\t_param_min_alt(this, \"MIS_TAKEOFF_ALT\", false)\n+\t_param_min_alt(this, \"MIS_LTRMIN_ALT\", false)\n {\n \t/* load initial params */\n \tupdateParams();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0cb79f62211f9e8936ec4d4cc3e4d637441fc123/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 28,
        "deletions": 7,
        "changes": 35,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2014 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2014-2015 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -50,9 +50,23 @@\n  * MIS_TAKEOFF_ALT on takeoff, then go to waypoint.\n  *\n  * @unit meters\n+ * @min 0\n+ * @max 80\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 1.2f);\n+\n+/**\n+ * Minimum Loiter altitude\n+ *\n+ * This is the minimum altitude the system will always obey. The intent is to stay out of ground effect.\n+ *\n+ * @unit meters\n+ * @min 0\n+ * @max 80\n  * @group Mission\n  */\n-PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n+PARAM_DEFINE_FLOAT(MIS_LTRMIN_ALT, 1.2f);\n \n /**\n  * Enable persistent onboard mission storage\n@@ -62,6 +76,8 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n  *\n  * @min 0\n  * @max 1\n+ * @value 0 Disabled\n+ * @value 1 Enabled\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_ONBOARD_EN, 1);\n@@ -88,22 +104,23 @@ PARAM_DEFINE_FLOAT(MIS_DIST_1WP, 900);\n  *\n  * @min 0\n  * @max 1\n+ * @value 0 Zero Order Hold\n+ * @value 1 First Order Hold\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n \n /**\n  * Multirotor only. Yaw setpoint mode.\n  *\n- * 0: Set the yaw heading to the yaw value specified for the destination waypoint.\n- * 1: Maintain a yaw heading pointing towards the next waypoint.\n- * 2: Maintain a yaw heading that always points to the home location.\n- * 3: Maintain a yaw heading that always points away from the home location (ie: back always faces home).\n- *\n  * The values are defined in the enum mission_altitude_mode\n  *\n  * @min 0\n  * @max 3\n+ * @value 0 Heading as set by waypoint\n+ * @value 1 Heading towards waypoint\n+ * @value 2 Heading towards home\n+ * @value 3 Heading away from home\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n@@ -118,6 +135,8 @@ PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n  *\n  * @min -1\n  * @max 20\n+ * @unit second\n+ * @increment 1\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n@@ -127,6 +146,8 @@ PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n  *\n  * @min 0\n  * @max 90\n+ * @unit degree\n+ * @increment 1\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_YAW_ERR, 12.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0cb79f62211f9e8936ec4d4cc3e4d637441fc123/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::Loiter",
        "location",
        "Copyright"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::Loiter"
        ],
        "src/modules/navigator/mission_params.c": [
          "location",
          "Copyright"
        ]
      }
    }
  },
  {
    "title": "FW airspeed mode",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3861",
    "number": 3861,
    "created_at": "2016-02-25T22:54:46Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This pull request introduces fixed wing airspeed mode. Airspeed mode is the minimum manual mode that's appropriate (safe) for an operator without RC experience.\nIt's a stabilized mode with manual throttle and airspeed controlled with the pitchstick. It feels similar to STAB, but you can't stall the plane.\n\n**Questions**\n- ~~where should this fit in with the existing modes and switches?~~\n- ~~this mode is much better with the TECS time constant significantly reduced, could it scale automatically?~~ You just need to properly tune TECS\n- ~~this doesn't currently work with mTecs, does anyone use it?~~\n- ~~should this mode respect FW_THR_MIN/FW_THR_MAX?~~\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2016-02-26T21:46:05Z",
          "body": "I tested most combinations of mode transitions to and from airspeed mode HIL today and didn't see any obvious problems.\nLog muncher might be broken: http://logs.uaventure.com/view/GcnQdeGGB4qgMJDwX8HQng\n\nReinitializing TECS between airspeed mode and any other TECS mode is a bit abrupt, I'm going to try just resetting speed weight and the underspeed check instead.\n\nI'll try an actual flight next week.\n",
          "type": "issue_comment"
        },
        {
          "author": "SimonWilks",
          "created_at": "2016-02-26T22:36:31Z",
          "body": "Logmuncher is working again for this log. Something odd happened with it.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-26T23:04:18Z",
          "body": "The throttle transition from airspeed mode full throttle to altctl is pretty bad. Rethinking the way I'm abusing TECS.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-27T19:35:36Z",
          "body": "Ok, back to where I started. TECS is completely reset between AIRSPEED and ALTCTL/POSCTL/AUTO. It's no worse than switching from MAN/STAB to those modes.\n\nI still want to think about automatically reducing the TECS time constant just in this mode, but I'm otherwise happy with the state of this during HIL testing and ready for an actual flight test.\n\n@LorenzMeier would you recommend flying master as of today, or should I cherry-pick this to stable?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-28T20:39:41Z",
          "body": "I've cherry-picked to stable for flight testing. https://github.com/PX4/Firmware/compare/stable...dagar:fw_airspeed_mode-stable?expand=1\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-01T01:59:31Z",
          "body": "@SimonWilks is this new mode killing logmuncher? http://logs.uaventure.com/view/tNysut35PRAqfF8qe2xhr7\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-02T19:38:08Z",
          "body": "Here's a plot from a successful flight of airspeed mode (ported to stable). The plot shows airspeed setpoint changing with elevator input, and manual throttle. This section of the flight was ALTCLT -> AIRSPEED -> ALTCTL with no problems. Altitude is scaled by 0.1.\n\n![airspeed_1](https://cloud.githubusercontent.com/assets/84712/13472651/da1750cc-e083-11e5-8311-97aa4b797d38.png)\n\n@LorenzMeier what are the next steps? What testing would you like to see?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-02T20:15:34Z",
          "body": "This confused me a bit so I hope you don't mind my questions. I had to look in the code to understand how this is supposed to work ;).\n\nHow is this different from altitude control from the users perspective? Maybe you could explain a bit where the need for this mode is coming from?\n\nDon't you have 2 inputs that have an effect on altitude now? So I'm assuming thrust is your main altitude control now (with speed-weight 2). But also if you change the airspeed setpoint TECS will have to dive/climb (because it has no other means anymore of matching the speed)?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-02T20:56:18Z",
          "body": "Think of it as a safe manual mode. Similar to stabilized mode, but the autopilot maintains a safe airspeed [FW_AIRSPEED_MIN, FW_AIRSPEED_MAX] at all times to prevent the vehicle from stalling. It's very useful for manually landing a UAV. In a locked down configuration for a user this would be their manual mode (which they wouldn't expect to hold altitude).\n\nThis airspeed mode is actually what several commercial UAVs and autopilots refer to as manual mode.\n\nYou should try it in a simulator with appropriate min, trim, and max airspeeds and possibly reducing the TECS time constant. It feels like flying in stabilize mode, but the pitch responds a bit slower.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-02T21:39:04Z",
          "body": "Landing, that's interesting. I mean, you have the same problem here as in alt/posctl: you cannot flare. How does the stick movement look for a landing? Wouldn't you want to reduce airspeed AND throttle for a landing?\n\nNaive question: have you tried plain altitude control with a reduced TECS time constant? I know you don't have manual throttle there, just wondering if the control feeling would already be better then.\n\n> This airspeed mode is actually what several commercial UAVs and autopilots refer to as manual mode.\n\nCould you give me an example? (because I'm curious, not because I don't believe you :))\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-04T16:45:49Z",
          "body": "Actually you can flare by pulling the pitch stick completely back, assuming you approach above min airspeed. Having direct control over throttle makes this mode much safer than ALTCTL for handling on the ground at launch or landing.\n\nI haven't tried ALTCTL with a reduced TECS time constant, but I generally use it when I want to just stay at the same altitude and not think about it.\n\nThe Procerus Kestrel autopilot (acquired by Lockheed) and fixed wing UAVs from AeroVironment refer to this as manual mode.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-09T20:52:36Z",
          "body": "@LorenzMeier @AndreasAntener do you have any other questions? What's the path forward for getting this merged? \n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-15T01:13:55Z",
          "body": "Rebased and resolved conflict.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-20T18:36:48Z",
          "body": "<a href=\"https:&#x2F;&#x2F;trello.com&#x2F;c&#x2F;IvXjv34B&#x2F;723-px4-airspeed-mode-test\"><img src=\"https:&#x2F;&#x2F;github.trello.services&#x2F;images&#x2F;trello-icon.png\" width=\"12\" height=\"12\"> PX4 airspeed mode test</a>\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T15:24:59Z",
          "body": "@dagar I can't access that Trello card.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-03-24T15:29:02Z",
          "body": "Whoops, sorry that's my personal todo list that I had no idea was posting on my behalf.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-24T15:29:07Z",
          "body": "Another rebase would be great, and more clarity on testing - would it be possible for you to test this, position control, altitude control and an auto mission? I would also love to understand the time constant change you mentioned.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-04-02T16:16:37Z",
          "body": "I've flown this a couple times and it works as intended with no problems, but the airspeed response isn't great. I've been having a hard time tuning TECS to respond nicely for this mode, but still work well normally.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-04-04T07:36:58Z",
          "body": "@dagar What about leaving airspeed control away if within min/max? There is a lot of talk about stall prevention ATM. I believe your reasoning behind this \"airspeed\" mode is not different from people simply requesting stall prevention methods. Maybe it could be more of a mix, having manual throttle/pitch/roll control, but start limiting pitch/roll when airspeed gets borderline, and use TECS to pitch down if airspeed falls below min.\n",
          "type": "issue_comment"
        },
        {
          "author": "tubeme",
          "created_at": "2016-04-04T22:16:18Z",
          "body": "@dagar Sounds very promising.\n\n@AndersonRayner Here is what the APM is doing about stall:\n\n> when in roll controlled modes the autopilot will monitor your demanded bank angle and airspeed and work out if you have sufficient margin above the stall speed to turn at the demanded bank angle. If you donâ€™t then the turn will be limited to the safe limit, but it will always allow a bank of at least 25 degrees (to ensure you can still maneuver if your airspeed estimate is badly off).\n\nWe've seen this technique in other two more simpler controllers and it works.\n\n> when in auto-throttle modes the autopilot will also raise the minimum airspeed in the TECS system to the level at which the current demanded bank angle can be safely achieved. So it will add more engine power or lower the nose to raise the airspeed so that the bank angle that the navigation controller is demanding can be achieved without a stall\n\nThey use these two parameters:\n\n> The **STALL_PREVENTION** parameter. If this is set to zero then no stall prevention is done. This may be useful if you have no airspeed sensor and the synthetic airspeed estimate is not good \n> enough\n> \n> The **ARSPD_FBW_MIN** parameter, which is the configured minimum airspeed for level flight. It is this value that is scaled with the bank angle to calculate the safe airspeed for any demanded bank angle\n\nI'm not saying we have to copy, but there is not a big choice of approaches toward stall. It is classical physics.  \n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-04-05T03:01:31Z",
          "body": "@AndreasAntener how would we keep TECS happy/initialized in between?\n\nHopefully I'll have some time to play around again later this week. I'll provide some plots of pitch input and response. It should be possible to get it to respond nicely when you're within the airspeed limits. Worst case I'll try doing airspeed control with only pitch outside of TECS.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-04-13T22:28:47Z",
          "body": "Rebased on master. I've been trying to gain a better understanding of TECS so that I can figure out how to make this mode work nicely. Update coming soon.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-22T10:35:10Z",
          "body": "@dagar Where is this standing?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-22T18:35:47Z",
          "body": "Waiting for me to actually go to the field and fly.\n",
          "type": "issue_comment"
        },
        {
          "author": "jcooper21",
          "created_at": "2016-05-27T05:29:49Z",
          "body": "This looks like a great mode. I may have some spare time coming up to test this mode and provide feedback. Is it in PX4 beta or master build and in the daily build of QGC?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-28T18:24:03Z",
          "body": "TODO - only allow transition to this mode for fixed wing\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-28T18:27:35Z",
          "body": "@jcooper21 this hasn't been tested since a large rebase so I need to spend some time at the field.\n\nIf you haven't already I'd suggest you thoroughly tune TECS.\n\nhttps://pixhawk.org/users/fixedwing_pid_tuning#tecs_tuning_altitude\n\nThe ArduPlane documentation is good, but many of the params are named differently.\nhttp://ardupilot.org/plane/docs/tecs-total-energy-control-system-for-speed-height-tuning-guide.html\n",
          "type": "issue_comment"
        },
        {
          "author": "jcooper21",
          "created_at": "2016-05-28T19:05:13Z",
          "body": "My tuning should be good. I'll test this when I get back from my vacation in a while. I'd this going to be the new stabalize mode? Also if it controls min air speed how do I land?\n",
          "type": "issue_comment"
        },
        {
          "author": "jcooper21",
          "created_at": "2016-05-28T19:58:53Z",
          "body": "Is this in QGC daily and px4 matter so I can set it up to test?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-06-05T23:03:57Z",
          "body": "I'll reopen this once I've had a few thorough flight tests with data and it's ready to be merged immediately.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR implements a new fixed-wing 'airspeed' flight mode (a feature) and focuses on TECS tuning and mode-transition behavior. The discussion centers on design, tuning, and expected behavior (preventing stalls), not on correcting an existing incorrect algorithm or unintended logic; any TECS reset changes are behavioral/tuning decisions rather than fixes of a stated logic bug.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -518,6 +518,7 @@ Navigator::task_main()\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n+\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AIRSPD:\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b96c0726ca8eaa9903e982522c7919b9dfad3fca/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "Clean up vehicle_status message",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3846",
    "number": 3846,
    "created_at": "2016-02-24T18:17:26Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "julianoes",
      "body": "Do not merge yet, untested, just for review.\n\nThis is work in progress trying to clean up the vehicle_status message.\nCurrent changes include:\n- Remove circuit breakers from vehicle_status\n- Delete mavlink compatible fields which were not in sync anymore.\n- Move vtol_vehicle_status enum to vtol_status topic.\n- Move battery calculations to the respective drivers (sensors.cpp and px4io.cpp).\n- Move battery data to battery_status topic.\n- Internalize condition bools into commander and out of vehicle_status.\n- Use land_detected message everywhere instead of the landed bool in vehicle_status.\n\nFor more detailed explanations, please read through the commit messages.\n\nThis PR is now on top of #3857.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-24T18:24:59Z",
          "body": "Architectural implications / cleanup looks good.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-26T13:04:28Z",
          "body": "@LorenzMeier Any idea why the mavlink include doesn't work in travis:\nhttps://travis-ci.org/PX4/Firmware/jobs/111996908#L625\n\nIf I use the exact same command on my machine, it works.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-26T15:48:27Z",
          "body": "Have you tried `#include <v1.0/common/mavlink.h>`?\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-26T16:07:52Z",
          "body": "@dagar thanks, I'll give it a try.\n",
          "type": "issue_comment"
        },
        {
          "author": "jschall",
          "created_at": "2016-02-27T00:36:09Z",
          "body": "@julianoes looks like there's some ros stuff failing CI tests (src/platforms/ros/nodes/commander/commander.cpp). Looks like it is simple to fix. Should I address problems with it? Can I be made a collaborator here so that I can push to the branch?\n\n@LorenzMeier what is the timeline like for getting this pushed in once it passes CI tests?\n\n@liamstask fyi\n",
          "type": "issue_comment"
        },
        {
          "author": "jschall",
          "created_at": "2016-02-27T00:43:44Z",
          "body": "Which target should I build to reproduce the error? I tried ros_sitl_default but it said that target was deprecated and to use posix_sitl_default (which works)\n",
          "type": "issue_comment"
        },
        {
          "author": "liamstask",
          "created_at": "2016-02-28T01:04:46Z",
          "body": "@LorenzMeier any pointers on debugging the travis failures per @jschall's questions above?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-28T02:46:23Z",
          "body": "@jschall you can open a pull request onto this branch. It looks like you just need to update the ros commander node to use the new commander_state.\n",
          "type": "issue_comment"
        },
        {
          "author": "jschall",
          "created_at": "2016-02-29T07:30:06Z",
          "body": "There's a new \"commander_state\" message but no one publishes it as far as I can tell.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-29T09:22:30Z",
          "body": "@jschall :\n\n> looks like there's some ros stuff failing CI tests (src/platforms/ros/nodes/commander/commander.cpp). Looks like it is simple to fix. Should I address problems with it? Can I be made a collaborator here so that I can push to the branch?\n\nI didn't know about this ROS stuff, let me have a look.\n\n> There's a new \"commander_state\" message but no one publishes it as far as I can tell.\n\nOh, good catch. I'll add that.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-29T16:47:58Z",
          "body": "Jenkins: test this please\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-03-03T13:24:53Z",
          "body": "I rebased this once again on master. Every time there is some conflicts, so it would be good to flight test this and merge as soon as possible.\n\n@tumbili any chance you could give this a flight test (in the snow :smile:)?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-04-08T08:12:17Z",
          "body": "Jenkins: test this please\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-04-08T13:49:52Z",
          "body": "@LorenzMeier and @liamstask\n\nThis would be ready to be merged, I've test flown it today. However, I'd like to hold off the merge until Monday in case it breaks somebody's setup because I'll be offline and not able to resolve conflicts or help debug problems.\n",
          "type": "issue_comment"
        },
        {
          "author": "liamstask",
          "created_at": "2016-04-08T15:09:05Z",
          "body": "sounds good!\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-04-11T16:42:21Z",
          "body": "Rebased and applied!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR removes duplicated/out-of-sync fields, moves battery calculations to the drivers, and internalizes condition booleans into the commander, all of which address incorrect program state and unintended/duplicated outputs. Those changes correct data-flow and state-management problems (e.g. stale mavlink-compatible fields and misplaced battery logic) that would lead to incorrect behavior rather than syntax/runtime failures.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "patch": "@@ -144,7 +144,7 @@ Mission::on_inactive()\n \tcheck_mission_valid();\n \n \t/* require takeoff after non-loiter or landing */\n-\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_vstatus()->condition_landed) {\n+\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n \t\t_need_takeoff = true;\n \t}\n }\n@@ -278,7 +278,7 @@ Mission::update_offboard_mission()\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n \t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_default_acceptance_radius(),\n-\t\t\t\t_navigator->get_vstatus()->condition_landed);\n+\t\t\t\t_navigator->get_land_detected()->landed);\n \n \t\t_navigator->get_mission_result()->valid = !failed;\n \t\tif (!failed) {\n@@ -413,7 +413,7 @@ Mission::set_mission_items()\n \t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n \t\t\t */\n \n-\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\t\tif (_navigator->get_land_detected()->landed) {\n \t\t\t\t/* landed, refusing to take off without a mission */\n \n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"no valid mission available, refusing takeoff\");\n@@ -474,7 +474,7 @@ Mission::set_mission_items()\n \n \t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n \t\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n-\t\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t\t&& !_navigator->get_land_detected()->landed\n \t\t\t\t\t&& has_next_position_item) {\n \t\t\t\t/* check if the vtol_takeoff command is on top of us */\n \t\t\t\tif(do_need_move_to_takeoff()){\n@@ -485,7 +485,7 @@ Mission::set_mission_items()\n \n \n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n-\t\t\t\t_mission_item.params[0] = vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n+\t\t\t\t_mission_item.params[0] = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n \t\t\t\t_mission_item.yaw = _navigator->get_global_position()->yaw;\n \t\t\t} else {\n \t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n@@ -509,7 +509,7 @@ Mission::set_mission_items()\n \t\t/* move to land wp as fixed wing */\n \t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n \t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_DEFAULT\n-\t\t\t\t&& !_navigator->get_vstatus()->condition_landed) {\n+\t\t\t\t&& !_navigator->get_land_detected()->landed) {\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n \t\t\t/* use current mission item as next position item */\n \t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n@@ -530,9 +530,9 @@ Mission::set_mission_items()\n \t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n \t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n \t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n-\t\t\t\t&& !_navigator->get_vstatus()->condition_landed) {\n+\t\t\t\t&& !_navigator->get_land_detected()->landed) {\n \t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n-\t\t\t_mission_item.params[0] = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\t\t_mission_item.params[0] = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n \t\t\t_mission_item.autocontinue = true;\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n \t\t}\n@@ -585,7 +585,7 @@ Mission::set_mission_items()\n \t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n \t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n \t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n-\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t&& !_navigator->get_land_detected()->landed\n \t\t\t\t&& has_next_position_item) {\n \n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n@@ -658,7 +658,7 @@ Mission::do_need_takeoff()\n \t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n \n \t\t/* force takeoff if landed (additional protection) */\n-\t\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\tif (_navigator->get_land_detected()->landed) {\n \t\t\t_need_takeoff = true;\n \n \t\t/* if in-air and already above takeoff height, don't do takeoff */\n@@ -752,7 +752,7 @@ Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n \tfloat takeoff_alt = get_absolute_altitude_for_item(*mission_item);\n \n \t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n-\tif (_navigator->get_vstatus()->condition_landed) {\n+\tif (_navigator->get_land_detected()->landed) {\n \t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n \n \t} else {\n@@ -1118,7 +1118,7 @@ Mission::check_mission_valid()\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n \t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_default_acceptance_radius(),\n-\t\t\t\t_navigator->get_vstatus()->condition_landed);\n+\t\t\t\t_navigator->get_land_detected()->landed);\n \n \t\t_navigator->increment_mission_instance_count();\n \t\t_navigator->set_mission_result_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/aee5be0b845bd33093073a84c2cacc626fce49fb/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_offboard_mission",
        "Mission::check_mission_valid",
        "Mission::on_inactive",
        "Mission::do_need_takeoff",
        "Mission::calculate_takeoff_altitude",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_inactive",
          "Mission::update_offboard_mission",
          "Mission::check_mission_valid",
          "Mission::do_need_takeoff",
          "Mission::calculate_takeoff_altitude",
          "Mission::set_mission_items"
        ]
      }
    }
  },
  {
    "title": "Px4.enhancement.3760.implement auto follow me.wip [WIP do not merge]",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3814",
    "number": 3814,
    "created_at": "2016-02-21T03:50:56Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "catch-twenty-two",
      "body": "adds ability for px4 firmware to track a target.  Implements rudimentary following of target position in navigator.\n\nNote: this uses a new version of the mavlink library with the proposed follow target method, will not work with current mavlink library version.\n\nhttps://github.com/catch-twenty-two/mavlink\n\nAlso uses new version of qground control with follow me option implemented:\n\nhttps://github.com/mavlink/qgroundcontrol/pull/2817\n\nSome concerns:\n\nPlease comment on ideas for error checking on bad position sent from tracker.  (e.g. ignore tracker if new pos vector is x meters away and instead just loiter)\n\nDoes it make sense for the \"follow previous - current line\" following be activated for this?  (currently I have it activated) I guess this might come in handy for intermittent GPS being sent...\n\nIn both instances ( \"follow previous - current line\" on and off) the result is \"jumpy\" if the new sp is to close to the current set point. \n\nMaybe this entire follow feature needs to be treated more like an instance using the position control code, except instead of manual input it gets tracker input. Or maybe it needs to be some type of hybrid of both pos control and auto line/position following code.\n\nAnyways, just some ideas, I'd like to get other's suggestions. \n\n@LorenzMeier had suggested using a predictive model if we have the target velocity. (this doesn't seem to be an option on my nexus 7 as it doesn't seem to output gps velocity)\n\nHere is a video of the current implementation, Qground control has been coded to send out sinusoidal gps coors, you can see the jumpiness I am referring to:\n\nhttps://www.youtube.com/watch?v=qGC464eVI5E&feature=youtu.be\n",
      "issue_comments": [
        {
          "author": "devbharat",
          "created_at": "2016-02-21T08:37:25Z",
          "body": "This reminded me of the target following I had implemented in APM a few years ago (used the same fixed wing libraries (l1 with TECS) as we do now) and the issues I faced. I did it by setting the target's position as the waypoints for the 'follower' (also I think I overwrote the current target waypoint with the latest waypoint I received from the target. Otherwise, the follower's position oscillated heavily). \nThis strategy 'works' but you end up with steady state error between the target(say, moving in a straight line) and the follower (who never got directly in line behind the target, was always a bit to the left or the right). This can be seen in the following pic:\n\n![dsc_0615](https://cloud.githubusercontent.com/assets/3105122/13201714/9179428e-d87d-11e5-9f86-2a6d8ccab171.JPG)\n\nYou can see the green plane (fixed wing UAV) is following not directly behind the leader, but to the side. This was because unlike a single static waypoint, the waypoints in this case were constantly overwritten to the new target position values, with the controller never getting the time to correct the steady state error. This made me feel that, atleast for fixedwings, tracking moving targets required something more than just setting moving waypoints from the controls point of view.\n\nYou can see a mission with 3 aircrafts daisy-chained here:\n![3-ac-lf-2013-09-28 13_41_29](https://cloud.githubusercontent.com/assets/3105122/13201743/7d2f5934-d87e-11e5-85f1-1635b420890e.png)\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-22T11:58:54Z",
          "body": "Awesome! I'm not so worried about the back and forth as my intention was not to keep sending a specific setpoint all the time, but to implement a \"rubber-band\" controller in that navigator class which trades smoothness for accuracy and only updates the next position gradually.\n\nWhat I however indeed forgot is that we need to feed a desired velocity. That should be supported by the triplet as well. Or we can go straight to the position setpoint instead. I need to think about that and maybe we can discuss this on the dev call?\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-02-22T14:27:58Z",
          "body": "> What I however indeed forgot is that we need to feed a desired velocity. That should be supported by the triplet as well. Or we can go straight to the position setpoint instead. I need to think about that and maybe we can discuss this on the dev call?\n\nOkay sounds good. Ill be on the call this morning, interested in hearing more about the controller you have in mind.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-01T08:16:38Z",
          "body": "@catch-twenty-two Any update on the current state? Could you push your latest commits so others have a chance to review and join in?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-01T08:17:03Z",
          "body": "You also might want to rebase. We kept improving the sim, in particular Gazebo, quite a bit.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-12T22:16:07Z",
          "body": "@LorenzMeier Sorry your request got lost in all the noise of my email in box.  The first iteration of the px4 side of the firmware code should be complete now.  Over all operation is a lot smoother.\n",
          "type": "issue_comment"
        },
        {
          "author": "liang-tang",
          "created_at": "2016-03-14T06:56:16Z",
          "body": "@catch-twenty-two I reviewed your code. You can use a pixhawk & mavros to send waypoint message include gps velocity. run rosrun mavros gcs_bridge, roslaunch mavros px4.launch.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-14T07:44:34Z",
          "body": "@liang-tang You missed the intent of this PR. It does follow-me without a companion computer. So what you describe is not of interest here.\n",
          "type": "issue_comment"
        },
        {
          "author": "liang-tang",
          "created_at": "2016-03-15T10:01:32Z",
          "body": "@catch-twenty-two\n\n `if (_pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_FOLLOW_TARGET) {\n                    _vel_sp(0) = _pos_sp_triplet.current.vx;\n                    _vel_sp(1) = _pos_sp_triplet.current.vy;\n                } else if (vel_norm_xy > _params.vel_max(0)) {\n                    /* note assumes vel_max(0) == vel_max(1) */\n                    _vel_sp(0) = _vel_sp(0) * _params.vel_max(0) / vel_norm_xy;\n                    _vel_sp(1) = _vel_sp(1) * _params.vel_max(1) / vel_norm_xy;\n                }`\nThere is a bug that _pos_sp_triplet.current.valid should be valid.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-15T18:29:39Z",
          "body": "@liang-tang True probably better to double check than assume if you are in follow target mode you have a velocity to use.  I have since changed this entire statement to use the velocity setpoint type and made some other significant changes as well.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-17T16:23:41Z",
          "body": "Hello, this is ready for testing if anyone has some time available. Integration to get the system working can be a bit of a pain because it involves changes in qgc, mavlink and px4 fw.  It also requires an Android device with OTG and GPS capability. Let me know if you're interested. Thanks!\n\n@julianoes @tumbili: @LorenzMeier said I should request validation testing from you so we can pull this into master. \n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-17T19:13:17Z",
          "body": "CI failed, fix would be great. Can you also help to get the required PR for QGC through? Then it will be available on Android automatically.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-17T22:48:10Z",
          "body": "@LorenzMeier Sure will do\n",
          "type": "issue_comment"
        },
        {
          "author": "liang-tang",
          "created_at": "2016-03-18T01:05:05Z",
          "body": "@catch-twenty-two Testing is in process.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-18T03:44:10Z",
          "body": "@liang-tang Great thanks, make sure you grab the latest code, for now I have set the minimum altitude of follow me/missions to 10 meters above home for safety.  If you have changed the mission minimum altitude to something custom for now make sure it set to at least 10m. \n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-19T04:06:46Z",
          "body": "@LorenzMeier I was able to get the CI to pass by changing the mavlink submodule to point to a temporary branch with the new follow target messages...Once the pr with the new messages are approved in the mavlink repo here:\n\nhttps://github.com/mavlink/mavlink/pull/526\n\n can switch it back to pointing to the correct repo and it should build ok without the hack.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-19T07:27:40Z",
          "body": "@catch-twenty-two Will start to integrate this tonight, so will be done in your morning.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-19T14:28:26Z",
          "body": "MAVLink PR is in. Now moving on to do a final review here and get it in.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-19T14:48:19Z",
          "body": "Almost all changes look good, except for the multi rotor position control where I see changes which will affect the general flight behaviour. When this is resolved it should be good to go.\n\nI brought in the MAVLink changes in master (c27981d), please rebase.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-19T16:09:24Z",
          "body": "> Almost all changes look good, except for the multi rotor position control where I see changes which will affect the general flight behaviour. When this is resolved it should be good to go.\n> \n> I brought in the MAVLink changes in master (c27981d), please rebase.\n\nThanks, I addressed your concerns in the comments lmk what you think.  Will do the rebase asap.\n",
          "type": "issue_comment"
        },
        {
          "author": "liang-tang",
          "created_at": "2016-03-21T02:22:42Z",
          "body": "@catch-twenty-two  I have some advise to give you.\n\n``` ruby\nvoid FollowTarget::pause()\n{\n    //math::Vector<3> vel(0, 0, 0);\n    _current_vel.zero();\n\n    set_loiter_item(&_mission_item, _param_min_alt.get());\n\n    //update_position_sp(vel);\n\n    _previous_target_gps_pos_valid = false;\n    //_current_target_motion.lat = _navigator->get_global_position()->lat;\n    //_current_target_motion.lon = _navigator->get_global_position()->lon;\n    //mavlink_log_info(_navigator->get_mavlink_fd(),\"pause\");\n}\n```\n\nI think _previous_target_gps_pos_valid should reset to false when pause status, so _target_vel is really valid when update_target_velocity() next time.\n\n``` ruby\nvoid FollowTarget::update_target_motion()\n{\n    bool updated;\n\n    orb_check(_follow_target_sub, &updated);\n\n    if (updated) {\n\n        // save last known motion topic\n\n        _previous_target_motion = _current_target_motion;\n\n        orb_copy(ORB_ID(follow_target), _follow_target_sub, &_current_target_motion);\n\n        update_target_velocity();\n\n        if (_previous_target_gps_pos_valid == false) {\n            _previous_target_motion = _current_target_motion;\n            _previous_target_gps_pos_valid = true;\n        }\n```\n\n if  _current_target_motion is Null, _target_vel will be wrong when update_target_velocity(). So can it be modified like this?\n\n``` ruby\n        if (_previous_target_gps_pos_valid == false) {\n            _previous_target_motion = _current_target_motion;\n            _previous_target_gps_pos_valid = true;\n        }\n\n        update_target_velocity();\n```\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-21T15:45:43Z",
          "body": "@LorenzMeier Hey Lorenz,  I got rid of the SETPOINT_TYPE_VELOCITY statement by checking if the velocity or position setpoints are valid in the setpoint triplet.  This works the exact same way, and allows me to get rid of the statement for ignoring pos setpoint generated velocity if SETPOINT_TYPE_VELOCITY is the setpoint type.\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-22T19:40:20Z",
          "body": "@liang-tang I took some time to make the code more robust and readable overall.  It should address all of your concerns. Were you able to fly it at all?\n",
          "type": "issue_comment"
        },
        {
          "author": "liang-tang",
          "created_at": "2016-03-23T00:55:08Z",
          "body": "@catch-twenty-two I tested many times, i found it difficult to catch up with me, maybe gps data lost?\n",
          "type": "issue_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-23T02:42:23Z",
          "body": "@liang-tang Great thanks for testing... Yes, that might be the case, the 3dr radio interferes with my phone gps...  I have to hold it very far away from the phone to get it to work correctly...Once it works though it works well...I'm going to play around with it some more to find the optimal placement for the radio. My friend and  I were able to take turns riding our bikes while having it follow us.  We stopped and started abruptly and also looped back on ourselves over a fairly large parking lot and it stayed with in 5-10 meters of us the whole time. \n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-23T19:42:53Z",
          "body": "Replaced by https://github.com/PX4/Firmware/pull/4065/files\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-12T22:17:22Z",
          "body": "Don't require a home position\n",
          "path": "src/modules/commander/state_machine_helper.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-19T14:33:46Z",
          "body": "In the section below are changes which exceed the changes needed for follow-me. Either this is a bad merge or the conditioning is incorrect (they should be guarded by if == FOLLOW_TARGET).\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "catch-twenty-two",
          "created_at": "2016-03-19T15:57:50Z",
          "body": "The above code uses a combination of overriding the velocity set point when it is appropriate while still using the position set point when it's not so I can take advantage of the velocity braking code as the position set point error delta gets smaller.  The code below overrides the velocity set point at all times and ignores the position set point for when the follow target module is in velocity tracking mode.  I was going to make a new set point type for the code below but saw that the position set point type already defined a set point type for velocity only, it just wasn't being used in the code anywhere. I used both of these set point types for a smooth transition between following using position and the velocity only tracking mode. Let me know if you still think I need to fix something or possibly have a better idea for what I am trying to accomplish.\n\nHere is where I switch between the 2 tracking methods:\n\nhttps://github.com/PX4/Firmware/pull/3814/files?diff=unified#diff-35e82494becdfdcc5afaafb5b3f4e361R278\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The discussion references and fixes incorrect program logic (e.g., using velocity setpoints without checking _pos_sp_triplet.current.valid, calling update_target_velocity() in a sequence that can use null/invalid target data, and changes affecting multirotor position control). The author and reviewers iteratively adjusted checks and ordering to make the follow-target behavior robust, indicating the PR addresses actual logic errors rather than mere style/syntax issues.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -52,6 +52,7 @@ px4_add_module(\n \t\trcloss.cpp\n \t\tenginefailure.cpp\n \t\tgpsfailure.cpp\n+\t\tfollow_target.cpp\n \tDEPENDS\n \t\tplatforms__common\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "added",
        "additions": 271,
        "deletions": 0,
        "changes": 271,
        "patch": "@@ -0,0 +1,271 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2013-2016 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file followme.cpp\n+ *\n+ * Helper class to track and follow a given position\n+ *\n+ * @author Jimmy Johnson <catch22@fastmail.net>\n+ */\n+\n+#include \"follow_target.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <math.h>\n+#include <fcntl.h>\n+\n+#include <mavlink/mavlink_log.h>\n+#include <systemlib/err.h>\n+\n+#include <uORB/uORB.h>\n+#include <uORB/topics/position_setpoint_triplet.h>\n+#include <uORB/topics/follow_target.h>\n+#include <lib/geo/geo.h>\n+\n+#include \"navigator.h\"\n+\n+FollowTarget::FollowTarget(Navigator *navigator, const char *name) :\n+        MissionBlock(navigator, name),\n+        _navigator(navigator),\n+        _param_min_alt(this, \"MIS_TAKEOFF_ALT\", false),\n+        _follow_target_state(WAIT_FOR_TARGET_POSITION),\n+        _follow_target_sub(-1),\n+        _step_time_in_ms(0.0f),\n+        _target_updates(0),\n+        _last_update_time(0),\n+        _current_target_motion({}),\n+        _previous_target_motion({})\n+{\n+    updateParams();\n+    _current_vel.zero();\n+    _step_vel.zero();\n+    _target_vel.zero();\n+    _target_distance.zero();\n+}\n+\n+FollowTarget::~FollowTarget()\n+{\n+}\n+\n+void FollowTarget::on_inactive()\n+{\n+    reset_target_validity();\n+}\n+\n+void FollowTarget::on_activation()\n+{\n+    if (_follow_target_sub < 0) {\n+        _follow_target_sub = orb_subscribe(ORB_ID(follow_target));\n+    }\n+}\n+\n+void FollowTarget::on_active() {\n+    struct map_projection_reference_s target_ref;\n+    math::Vector<3> target_position(0, 0, 0);\n+    uint64_t current_time = hrt_absolute_time();\n+    bool _radius_entered = false;\n+    bool _radius_exited = false;\n+    bool updated = false;\n+    float dt_ms = 0;\n+\n+    orb_check(_follow_target_sub, &updated);\n+\n+    if (updated) {\n+\n+        _target_updates++;\n+\n+        // save last known motion topic\n+\n+        _previous_target_motion = _current_target_motion;\n+\n+        orb_copy(ORB_ID(follow_target), _follow_target_sub, &_current_target_motion);\n+\n+    } else if (((current_time - _previous_target_motion.timestamp) / 1000 / 1000) > TARGET_TIMEOUT_S && target_velocity_valid()) {\n+        reset_target_validity();\n+    }\n+\n+    // update target velocity\n+\n+    if (target_velocity_valid() && updated) {\n+\n+        dt_ms = ((_current_target_motion.timestamp - _previous_target_motion.timestamp) / 1000);\n+\n+        // get last gps known reference for target\n+\n+        map_projection_init(&target_ref, _previous_target_motion.lat, _previous_target_motion.lon);\n+\n+        // calculate distance the target has moved\n+\n+        map_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &(target_position(0)), &(target_position(1)));\n+\n+        // update the average velocity of the target based on the position\n+\n+        _target_vel = target_position / (dt_ms / 1000.0f);\n+\n+        // to keep the velocity increase/decrease smooth\n+        // calculate how many velocity increments/decrements\n+        // it will take to reach the targets velocity\n+        // with the given amount of steps also add a feed forward input that adjusts the\n+        // velocity as the position gap increases since\n+        // just traveling at the exact velocity of the target will not\n+        // get any closer to the target\n+\n+        _step_vel = (_target_vel - _current_vel) + _target_distance * FF_K;\n+        _step_vel /= (dt_ms / 1000.0f * (float) INTERPOLATION_PNTS);\n+        _step_time_in_ms = dt_ms / (float) INTERPOLATION_PNTS;\n+    }\n+\n+    // update distance to target\n+\n+    if (target_position_valid()) {\n+\n+        // get distance to target\n+\n+        map_projection_init(&target_ref, _navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+        map_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &_target_distance(0), &_target_distance(1));\n+\n+        // are we within the target acceptance radius?\n+        // give a buffer to exit/enter the radius to give the velocity controller\n+        // a chance to catch up\n+\n+        _radius_exited = (_target_distance.length() > (float) TARGET_ACCEPTANCE_RADIUS_M * 1.5f);\n+        _radius_entered = (_target_distance.length() < (float) TARGET_ACCEPTANCE_RADIUS_M);\n+    }\n+\n+    // update state machine\n+\n+    switch (_follow_target_state) {\n+\n+    case TRACK_POSITION: {\n+\n+        if (_radius_entered == true) {\n+            _follow_target_state = TRACK_VELOCITY;\n+        } else if (target_velocity_valid()) {\n+            set_follow_target_item(&_mission_item, _param_min_alt.get(), _current_target_motion, NAN);\n+            // keep the current velocity updated with the target velocity for when it's needed\n+            _current_vel = _target_vel;\n+            update_position_sp(true, true);\n+        }\n+\n+        break;\n+    }\n+\n+    case TRACK_VELOCITY: {\n+\n+        if (_radius_exited == true) {\n+            _follow_target_state = TRACK_POSITION;\n+        } else if (target_velocity_valid()) {\n+            set_follow_target_item(&_mission_item, _param_min_alt.get(), _current_target_motion, NAN);\n+            if ((current_time - _last_update_time) / 1000 >= _step_time_in_ms) {\n+                _current_vel += _step_vel;\n+                _last_update_time = current_time;\n+            }\n+            update_position_sp(true, false);\n+        }\n+\n+        break;\n+    }\n+\n+    case WAIT_FOR_TARGET_POSITION: {\n+\n+        // Climb to the minimum altitude\n+        // and wait until a position is received\n+\n+        follow_target_s target = { };\n+\n+        // for now set the target at the minimum height above the uav\n+\n+        target.lat = _navigator->get_global_position()->lat;\n+        target.lon = _navigator->get_global_position()->lon;\n+        target.alt = 0.0F;\n+\n+        set_follow_target_item(&_mission_item, _param_min_alt.get(), target, NAN);\n+\n+        update_position_sp(false, false);\n+\n+        if (is_mission_item_reached() && target_velocity_valid()) {\n+            _follow_target_state = TRACK_POSITION;\n+        }\n+\n+        break;\n+    }\n+    }\n+}\n+\n+void FollowTarget::update_position_sp(bool use_velocity, bool use_position)\n+{\n+    // convert mission item to current setpoint\n+\n+    struct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+    // activate line following in pos control if position is valid\n+\n+    pos_sp_triplet->previous.valid = use_position;\n+    pos_sp_triplet->previous = pos_sp_triplet->current;\n+    mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+    pos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_FOLLOW_TARGET;\n+    pos_sp_triplet->current.position_valid = use_position;\n+    pos_sp_triplet->current.velocity_valid = use_velocity;\n+    pos_sp_triplet->current.vx = _current_vel(0);\n+    pos_sp_triplet->current.vy = _current_vel(1);\n+    pos_sp_triplet->next.valid = false;\n+\n+    _navigator->set_position_setpoint_triplet_updated();\n+}\n+\n+void FollowTarget::reset_target_validity()\n+{\n+    _previous_target_motion = {};\n+    _current_target_motion = {};\n+    _target_updates = 0;\n+    _current_vel.zero();\n+    _step_vel.zero();\n+    _target_vel.zero();\n+    _target_distance.zero();\n+    reset_mission_item_reached();\n+    _follow_target_state = WAIT_FOR_TARGET_POSITION;\n+}\n+\n+bool FollowTarget::target_velocity_valid()\n+{\n+    // need at least 2 data points for velocity estimate\n+    return (_target_updates >= 2);\n+}\n+\n+bool FollowTarget::target_position_valid()\n+{\n+    // need at least 1 data point for position estimate\n+    return (_target_updates >= 1);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/follow_target.h": {
        "filename": "src/modules/navigator/follow_target.h",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "patch": "@@ -0,0 +1,100 @@\n+/***************************************************************************\n+ *\n+ *   Copyright (c) 2016 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file followme.cpp\n+ *\n+ * Helper class to track and follow a given position\n+ *\n+ * @author Jimmy Johnson <catch22@fastmail.net>\n+ */\n+\n+#pragma once\n+\n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+#include <lib/mathlib/math/Vector.hpp>\n+\n+#include \"navigator_mode.h\"\n+#include \"mission_block.h\"\n+\n+class FollowTarget : public MissionBlock\n+{\n+\n+public:\n+    FollowTarget(Navigator *navigator, const char *name);\n+    ~FollowTarget();\n+\n+    void on_inactive() override;\n+    void on_activation() override;\n+    void on_active() override;\n+\n+private:\n+\n+    static constexpr int TARGET_TIMEOUT_S = 5;\n+    static constexpr int TARGET_ACCEPTANCE_RADIUS_M = 5;\n+    static constexpr int INTERPOLATION_PNTS = 20;\n+    static constexpr float FF_K = .15f;\n+\n+    enum FollowTargetState {\n+        TRACK_POSITION,\n+        TRACK_VELOCITY,\n+        WAIT_FOR_TARGET_POSITION\n+    };\n+\n+    Navigator *_navigator;\n+    control::BlockParamFloat _param_min_alt;\n+    FollowTargetState _follow_target_state;\n+    int _follow_target_sub;\n+    float _step_time_in_ms;\n+\n+    uint64_t _target_updates;\n+\n+    uint64_t _last_update_time;\n+\n+    math::Vector<3> _current_vel;\n+    math::Vector<3> _step_vel;\n+    math::Vector<3> _target_vel;\n+    math::Vector<3> _target_distance;\n+\n+    follow_target_s _current_target_motion;\n+    follow_target_s _previous_target_motion;\n+\n+    void track_target_position();\n+    void track_target_velocity();\n+    bool target_velocity_valid();\n+    bool target_position_valid();\n+    void reset_target_validity();\n+    void update_position_sp(bool velocity_valid, bool position_valid);\n+    void update_target_motion();\n+    void update_target_velocity();\n+};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Ffollow_target.h"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -79,6 +79,7 @@ Loiter::on_activation()\n \n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+    pos_sp_triplet->current.velocity_valid = false;\n \tpos_sp_triplet->previous.valid = false;\n \tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->next.valid = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "patch": "@@ -228,7 +228,6 @@ MissionBlock::is_mission_item_reached()\n \n \t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n \tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n-\n \t\tif (_time_first_inside_orbit == 0) {\n \t\t\t_time_first_inside_orbit = now;\n \n@@ -434,6 +433,39 @@ MissionBlock::set_loiter_item(struct mission_item_s *item, float min_clearance)\n \t}\n }\n \n+void\n+MissionBlock::set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s & target, float yaw)\n+{\n+    if (_navigator->get_vstatus()->condition_landed) {\n+        /* landed, don't takeoff, but switch to IDLE mode */\n+        item->nav_cmd = NAV_CMD_IDLE;\n+\n+    } else {\n+        item->nav_cmd = NAV_CMD_FOLLOW_TARGET;\n+\n+        /* use current target position */\n+\n+        item->lat = target.lat;\n+        item->lon = target.lon;\n+        item->altitude = target.alt + _navigator->get_home_position()->alt;\n+\n+        if (((min_clearance > 0.0f) && (item->altitude < _navigator->get_home_position()->alt + min_clearance)) || PX4_ISFINITE(target.alt)) {\n+            item->altitude = _navigator->get_home_position()->alt + min_clearance;\n+        }\n+    }\n+\n+    item->altitude_is_relative = false;\n+    item->yaw = yaw;\n+    item->loiter_radius = _navigator->get_loiter_radius();\n+    item->loiter_direction = 1;\n+    item->acceptance_radius = _navigator->get_acceptance_radius();\n+    item->time_inside = 0.0f;\n+    item->pitch_min = 0.0f;\n+    item->autocontinue = false;\n+    item->origin = ORIGIN_ONBOARD;\n+}\n+\n+\n void\n MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance, float min_pitch)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "patch": "@@ -49,6 +49,7 @@\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/actuator_controls.h>\n+#include <uORB/topics/follow_target.h>\n \n #include \"navigator_mode.h\"\n \n@@ -116,10 +117,15 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_idle_item(struct mission_item_s *item);\n \n-\t/**\n-\t * Convert a mission item to a command\n-\t */\n-\tvoid mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n+    /**\n+     * Convert a mission item to a command\n+     */\n+    void mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n+\n+    /**\n+     * set follow_target item\n+     */\n+    void set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s & target, float yaw);\n \n \tvoid issue_command(const struct mission_item_s *item);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -53,7 +53,7 @@\n  * @max 80\n  * @group Mission\n  */\n-PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 1.8f);\n+PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 10.0f);\n \n /**\n  * Minimum Loiter altitude",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -61,6 +61,8 @@ enum NAV_CMD {\n \tNAV_CMD_TAKEOFF = 22,\n \tNAV_CMD_ROI = 80,\n \tNAV_CMD_PATHPLANNING = 81,\n+\tNAV_CMD_FOLLOW_TARGET = 194, // temporary placeholder\n+\tNAV_CMD_GOTO_TAREGT = 195,\n \tNAV_CMD_DO_JUMP = 177,\n \tNAV_CMD_DO_CHANGE_SPEED = 178,\n \tNAV_CMD_DO_SET_SERVO=183,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -66,14 +66,15 @@\n #include \"rtl.h\"\n #include \"datalinkloss.h\"\n #include \"enginefailure.h\"\n+#include \"follow_target.h\"\n #include \"gpsfailure.h\"\n #include \"rcloss.h\"\n #include \"geofence.h\"\n \n /**\n  * Number of navigation modes that need on_active/on_inactive calls\n  */\n-#define NAVIGATOR_MODE_ARRAY_SIZE 9\n+#define NAVIGATOR_MODE_ARRAY_SIZE 10\n \n class Navigator : public control::SuperBlock\n {\n@@ -250,6 +251,8 @@ class Navigator : public control::SuperBlock\n \t\t\t\t\t\t\t  (FW only!) */\n \tGpsFailure\t_gpsFailure;\t\t\t/**< class that handles the OBC gpsfailure loss mode */\n \n+\tFollowTarget _follow_target;\n+\n \tNavigatorMode *_navigation_mode_array[NAVIGATOR_MODE_ARRAY_SIZE];\t/**< array of navigation modes */\n \n \tcontrol::BlockParamFloat _param_loiter_radius;\t/**< loiter radius for fixedwing */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -148,6 +148,7 @@ Navigator::Navigator() :\n \t_dataLinkLoss(this, \"DLL\"),\n \t_engineFailure(this, \"EF\"),\n \t_gpsFailure(this, \"GPSF\"),\n+\t_follow_target(this, \"TAR\"),\n \t_param_loiter_radius(this, \"LOITER_RAD\"),\n \t_param_acceptance_radius(this, \"ACC_RAD\"),\n \t_param_datalinkloss_obc(this, \"DLL_OBC\"),\n@@ -166,6 +167,7 @@ Navigator::Navigator() :\n \t_navigation_mode_array[6] = &_rcLoss;\n \t_navigation_mode_array[7] = &_takeoff;\n \t_navigation_mode_array[8] = &_land;\n+\t_navigation_mode_array[9] = &_follow_target;\n \n \tupdateParams();\n }\n@@ -511,6 +513,10 @@ Navigator::task_main()\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\t_navigation_mode = &_gpsFailure;\n \t\t\t\tbreak;\n+\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n+\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n+\t\t\t\t_navigation_mode = &_follow_target;\n+\t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\t_navigation_mode = nullptr;\n \t\t\t\t_can_loiter_at_sp = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78531d8a1e07c608284cfd12ff9f4588a2044ffd/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::Navigator",
        "mission_item_to_vehicle_command",
        "control::SuperBlock",
        "MissionBlock::is_mission_item_reached",
        "MissionBlock::set_loiter_item",
        "Navigator::task_main",
        "Loiter::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_activation"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::set_loiter_item"
        ],
        "src/modules/navigator/mission_block.h": [
          "mission_item_to_vehicle_command"
        ],
        "src/modules/navigator/navigator.h": [
          "control::SuperBlock"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Yaw timeout for VTOL forwards transition",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3740",
    "number": 3740,
    "created_at": "2016-02-12T15:18:46Z",
    "merged": true,
    "merged_at": "2016-02-16T06:51:23Z",
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "This adds a yaw timeout on accepting the waypoint for the VTOL forwards transition because a VTOL might not reach yaw in wind. Fixes #3728\n\nMIS_YAW_TMT\n- default: -1\n- > 0: timeout active on waypoints which force heading, ignore heading for acceptance on normal waypoints\n\nMIS_YAW_TMT set to 10 seconds for default VTOL configurations\n",
      "issue_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-13T00:25:33Z",
          "body": "@LorenzMeier @sanderux timeout and forcing the heading for a transition added. How does this look?\n\nAlready flew the timeout in real, new is the mission failsafe. If this is how we want it for the moment we can merge I think.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-13T09:00:44Z",
          "body": "Reviewed, seems good other than the comment.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-13T09:11:33Z",
          "body": "Thanks @julianoes , I will push an update in a sec that also takes care of setting the failure state properly.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-15T12:54:51Z",
          "body": "Rebased on master\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-15T14:37:37Z",
          "body": "Just found one thing missing here, need to do one more commit.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-15T18:28:27Z",
          "body": "Anybody knows why px4-stm32f4discovery_default fails on Travis?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-16T06:52:50Z",
          "body": "Merged after SITL tests. @sanderux this will simplify testing this afternoon. Roman and I will rebase the TECS init, and also get the Kangaroo in before you go testing.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "julianoes",
          "created_at": "2016-02-13T08:58:29Z",
          "body": "Why -FLT_EPSILON? Shouldn't it be +FLT_EPSILON?\n\nAlso, please comment! How is a reader supposed to grasp what you're trying to achieve with this if...\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-13T08:59:47Z",
          "body": "Oh, I understand from reading the parameter. A timeout of 0 means, just continue.\nAs I said, please comment!\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect runtime behavior: VTOL could indefinitely wait for yaw alignment (or fail to transition) when wind prevents reaching the commanded heading. Adding a timeout and proper failure handling changes the waypoint acceptance/state-transition logic to avoid the unintended hang, which is a logic error.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 8,
        "changes": 34,
        "patch": "@@ -219,6 +219,8 @@ Mission::update_onboard_mission()\n \n \t\t// XXX check validity here as well\n \t\t_navigator->get_mission_result()->valid = true;\n+\t\t/* reset mission failure if we have an updated valid mission */\n+\t\t_navigator->get_mission_result()->mission_failure = false;\n \t\t_navigator->increment_mission_instance_count();\n \t\t_navigator->set_mission_result_updated();\n \n@@ -263,6 +265,10 @@ Mission::update_offboard_mission()\n \t\t\t\t_navigator->get_vstatus()->condition_landed);\n \n \t\t_navigator->get_mission_result()->valid = !failed;\n+\t\tif (!failed) {\n+\t\t\t/* reset mission failure if we have an updated valid mission */\n+\t\t\t_navigator->get_mission_result()->mission_failure = false;\n+\t\t}\n \t\t_navigator->increment_mission_instance_count();\n \t\t_navigator->set_mission_result_updated();\n \n@@ -499,17 +505,15 @@ Mission::set_mission_items()\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n \n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n-\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n-\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n-\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\tcopy_positon_if_valid(_mission_item, pos_sp_triplet->current);\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.time_inside = 0;\n \t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n \t\t\t\t_navigator->get_global_position()->lat,\n \t\t\t\t_navigator->get_global_position()->lon,\n \t\t\t\tmission_item_next_position.lat,\n \t\t\t\tmission_item_next_position.lon);\n+\t\t\t_mission_item.force_heading = true;\n \t\t}\n \n \t\t/* yaw is aligned now */\n@@ -534,10 +538,7 @@ Mission::set_mission_items()\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n-\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n-\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n-\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\tcopy_positon_if_valid(_mission_item, pos_sp_triplet->current);\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.time_inside = 0;\n \t\t}\n@@ -596,6 +597,23 @@ Mission::set_mission_items()\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n+void\n+Mission::copy_positon_if_valid(struct mission_item_s &mission_item, struct position_setpoint_s &setpoint)\n+{\n+\tif (setpoint.valid) {\n+\t\t_mission_item.lat = setpoint.lat;\n+\t\t_mission_item.lon = setpoint.lon;\n+\t\t_mission_item.altitude = setpoint.alt;\n+\n+\t} else {\n+\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n+\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n+\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n+\t}\n+\n+\t_mission_item.altitude_is_relative = false;\n+}\n+\n bool\n Mission::do_need_takeoff()\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -119,6 +119,11 @@ class Mission : public MissionBlock\n \t */\n \tvoid set_mission_items();\n \n+\t/**\n+\t * Copies position from setpoint if valid, otherwise copies current position\n+\t */\n+\tvoid copy_positon_if_valid(struct mission_item_s &mission_item, struct position_setpoint_s &setpoint);\n+\n \t/**\n \t * Returns true if we need to do a takeoff at the current state\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "patch": "@@ -49,6 +49,7 @@\n #include <systemlib/err.h>\n #include <geo/geo.h>\n #include <mavlink/mavlink_log.h>\n+#include <mathlib/mathlib.h>\n \n #include <uORB/uORB.h>\n #include <uORB/topics/actuator_controls.h>\n@@ -68,9 +69,12 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_waypoint_yaw_reached(false),\n \t_time_first_inside_orbit(0),\n \t_action_start(0),\n+\t_time_wp_reached(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n \t_cmd_pub(nullptr),\n+\t_param_yaw_timeout(this, \"MIS_YAW_TMT\", false),\n+\t_param_yaw_err(this, \"MIS_YAW_ERR\", false),\n \t_param_vtol_wv_land(this, \"VT_WV_LND_EN\", false),\n \t_param_vtol_wv_loiter(this, \"VT_WV_LTR_EN\", false)\n {\n@@ -174,6 +178,11 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \t\t}\n+\n+\t\tif (_waypoint_position_reached) {\n+\t\t\t// reached just now\n+\t\t\t_time_wp_reached = now;\n+\t\t}\n \t}\n \n \t/* Check if the waypoint and the requested yaw setpoint. */\n@@ -186,10 +195,19 @@ MissionBlock::is_mission_item_reached()\n \t\t\t/* check yaw if defined only for rotary wing except takeoff */\n \t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n \n-\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n+\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n+\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n+\t\t\t\t\t|| (_param_yaw_timeout.get() >= FLT_EPSILON && !_mission_item.force_heading)) {\n \t\t\t\t_waypoint_yaw_reached = true;\n \t\t\t}\n \n+\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n+\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n+\t\t\t\t\t\t_param_yaw_timeout.get() >= FLT_EPSILON &&\n+\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f) {\n+\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n+\t\t\t}\n+\n \t\t} else {\n \t\t\t_waypoint_yaw_reached = true;\n \t\t}\n@@ -221,6 +239,7 @@ MissionBlock::reset_mission_item_reached()\n \t_waypoint_position_reached = false;\n \t_waypoint_yaw_reached = false;\n \t_time_first_inside_orbit = 0;\n+\t_time_wp_reached = 0;\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "patch": "@@ -45,9 +45,6 @@\n \n #include <navigator/navigation.h>\n \n-#include <controllib/blocks.hpp>\n-#include <controllib/block/BlockParam.hpp>\n-\n #include <uORB/topics/mission.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n@@ -128,10 +125,14 @@ class MissionBlock : public NavigatorMode\n \tbool _waypoint_yaw_reached;\n \thrt_abstime _time_first_inside_orbit;\n \thrt_abstime _action_start;\n+\thrt_abstime _time_wp_reached;\n \n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n \torb_advert_t\t_cmd_pub;\n+\n+\tcontrol::BlockParamFloat _param_yaw_timeout;\n+\tcontrol::BlockParamFloat _param_yaw_err;\n \tcontrol::BlockParamInt _param_vtol_wv_land;\n \tcontrol::BlockParamInt _param_vtol_wv_loiter;\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "patch": "@@ -107,3 +107,26 @@ PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n+\n+/**\n+ * Time in seconds we wait on reaching target heading at a waypoint if it is forced.\n+ *\n+ * If set > 0 it will ignore the target heading for normal waypoint acceptance. If the\n+ * waypoint forces the heading the timeout will matter. For example on VTOL forwards transiton.\n+ * Mainly useful for VTOLs that have less yaw authority and might not reach target\n+ * yaw in wind. Disabled by default.\n+ *\n+ * @min -1\n+ * @max 20\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n+\n+/**\n+ * Max yaw error in degree needed for waypoint heading acceptance.\n+ *\n+ * @min 0\n+ * @max 90\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(MIS_YAW_ERR, 12.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -105,6 +105,7 @@ struct mission_item_s {\n \tunsigned do_jump_current_count;\t/**< count how many times the jump has been done\t*/\n \tfloat params[7];\t\t/**< array to store mission command values for MAV_FRAME_MISSION ***/\n \tint8_t frame;\t\t\t/**< mission frame ***/\n+\tbool force_heading;\t\t/**< heading needs to be reached ***/\n };\n #pragma pack(pop)\n #include <uORB/topics/mission.h>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -168,6 +168,8 @@ class Navigator : public control::SuperBlock\n \n \tvoid\t\tincrement_mission_instance_count() { _mission_instance_count++; }\n \n+\tvoid \t\tset_mission_failure(const char *reason);\n+\n private:\n \n \tbool\t\t_task_should_exit;\t\t/**< if true, sensor task should exit */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "patch": "@@ -750,3 +750,13 @@ Navigator::publish_att_sp()\n \t\t_att_sp_pub = orb_advertise(ORB_ID(vehicle_attitude_setpoint), &_att_sp);\n \t}\n }\n+\n+void\n+Navigator::set_mission_failure(const char* reason)\n+{\n+\tif (!_mission_result.mission_failure) {\n+\t\t_mission_result.mission_failure = true;\n+\t\tset_mission_result_updated();\n+\t\tmavlink_log_critical(_mavlink_fd, \"%s\", reason);\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/570fb97163e4a9c798c9f5d9db2109d874903879/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_offboard_mission",
        "Mission::update_onboard_mission",
        "MissionBlock::is_mission_item_reached",
        "Navigator::publish_att_sp",
        "MissionBlock::MissionBlock",
        "Mission::set_mission_items",
        "MissionBlock::reset_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::update_offboard_mission",
          "Mission::update_onboard_mission",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::MissionBlock",
          "MissionBlock::reset_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_att_sp"
        ]
      }
    }
  },
  {
    "title": "Vtol weathervane cleaned up history",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3736",
    "number": 3736,
    "created_at": "2016-02-12T11:42:50Z",
    "merged": true,
    "merged_at": "2016-02-15T08:50:32Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "Fixes https://github.com/PX4/Firmware/issues/3679\n@sanderux As discussed I cleaned up the history so that we only remain with three commits.\nThe diff to the old branch is zero so everything should be inside. Will give this a test in SITL and Ada can maybe test fly it today.\n@AndreasAntener  FYI\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T11:45:12Z",
          "body": "Please delete the old branch (referenced above ) if there aren't any objections.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-12T11:49:51Z",
          "body": "Done, looks good\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T14:54:08Z",
          "body": "@sanderux @AndreasAntener This is flight tested in SITL for both landing and loiter modes. Checked the log files, it seems to do the right thing.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T14:56:15Z",
          "body": "Rain just stopped me right after flashing this branch... I hope the weather is good for you Sander tomorrow :)\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-12T14:58:01Z",
          "body": "There is some wind but that would be the point for this pr. Should stay dry\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T15:06:42Z",
          "body": "@sanderux @AndreasAntener Parameters to activate this are\nVT_WV_LND_EN enable mode for landing waypoint\nVT_WV_LTR_EN enable mode for loiter items\nVT_WV_YAWR_SCL scale factor for desired yaw_rate setpoint\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T15:10:21Z",
          "body": "VT_WV_LTR_EN doesn't seem to be used anywhere\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T15:17:06Z",
          "body": "@AndreasAntener https://github.com/PX4/Firmware/blob/vtol_weather_vane/src/modules/navigator/mission_block.cpp#L75\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-12T15:18:09Z",
          "body": "In mission block\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T15:25:00Z",
          "body": "Funny, QGC didn't show me this on the field, anyway, it's there :) \n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T15:35:46Z",
          "body": "@AndreasAntener I pushed a late fix, probably you didn't have that one.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-14T13:30:38Z",
          "body": "Log from weathervane loiter test: http://logs.uaventure.com/view/t7a2AZB3WHgRZsDjGCEJpi\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-14T14:12:52Z",
          "body": "This looks good. Let's address my 2 comments. We should check it on landing as well even though I don't think it's problematic.\n<img width=\"1366\" alt=\"screen shot 2016-02-14 at 15 07 12\" src=\"https://cloud.githubusercontent.com/assets/5750020/13034114/d95b8a0e-d32c-11e5-817b-5842bf44f54d.png\">\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-14T14:37:08Z",
          "body": "Addressed comment 1\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-14T22:53:17Z",
          "body": "This should address the feed forward\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-15T08:50:41Z",
          "body": "Merged!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-13T10:11:32Z",
          "body": "we should change `_mode_auto` to `!_control_mode.flag_control_manual_enabled` so this also works in offboard and it's consistent with the other checks\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-14T13:53:11Z",
          "body": "@tumbili should we also remove the feed forward when we clamp the rate?\n",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 72,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect VTOL weathervane behavior (logic around enabling modes and yaw/feedâ€‘forward setpoints). Discussion notes an unused parameter, a late fix to use it, and SITL/flight logs confirming the corrected behavior, indicating this was an algorithmic/behavioral bug rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "patch": "@@ -70,7 +70,9 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_action_start(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n-\t_cmd_pub(nullptr)\n+\t_cmd_pub(nullptr),\n+\t_param_vtol_wv_land(this, \"VT_WV_LND_EN\", false),\n+\t_param_vtol_wv_loiter(this, \"VT_WV_LTR_EN\", false)\n {\n }\n \n@@ -175,6 +177,7 @@ MissionBlock::is_mission_item_reached()\n \t}\n \n \t/* Check if the waypoint and the requested yaw setpoint. */\n+\n \tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n \n \t\t/* TODO: removed takeoff, why? */\n@@ -310,6 +313,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->loiter_direction = item->loiter_direction;\n \tsp->pitch_min = item->pitch_min;\n \tsp->acceptance_radius = item->acceptance_radius;\n+\tsp->disable_mc_yaw_control = false;\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_IDLE:\n@@ -322,12 +326,18 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \n \tcase NAV_CMD_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n+\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n+\t\t\tsp->disable_mc_yaw_control = true;\n+\t\t}\n \t\tbreak;\n \n \tcase NAV_CMD_LOITER_TIME_LIMIT:\n \tcase NAV_CMD_LOITER_TURN_COUNT:\n \tcase NAV_CMD_LOITER_UNLIMITED:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_loiter.get()){\n+\t\t\tsp->disable_mc_yaw_control = true;\n+\t\t}\n \t\tbreak;\n \n \tdefault:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d5cf70e83a48c50c55ff3f541eedaffc2328a4c/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -45,6 +45,9 @@\n \n #include <navigator/navigation.h>\n \n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+\n #include <uORB/topics/mission.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n@@ -129,6 +132,8 @@ class MissionBlock : public NavigatorMode\n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n \torb_advert_t\t_cmd_pub;\n+\tcontrol::BlockParamInt _param_vtol_wv_land;\n+\tcontrol::BlockParamInt _param_vtol_wv_loiter;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d5cf70e83a48c50c55ff3f541eedaffc2328a4c/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::MissionBlock"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::MissionBlock"
        ]
      }
    }
  },
  {
    "title": "Fix for transition failsafe",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3730",
    "number": 3730,
    "created_at": "2016-02-11T22:40:16Z",
    "merged": true,
    "merged_at": "2016-02-11T23:24:48Z",
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "fixes https://github.com/PX4/Firmware/issues/3729\nonly transition to MC when not MC\n",
      "issue_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-11T23:24:58Z",
          "body": "Great, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes an incorrect state transition: it prevents transitioning to MC when already in MC. That addresses a faulty conditional/state-transition (a logic error) which could cause unintended failsafe behavior, so this change corrects program logic.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -421,7 +421,7 @@ MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_locatio\n {\n \n \t/* VTOL transition to RW before landing */\n-\tif(_navigator->get_vstatus()->is_vtol){\n+\tif(_navigator->get_vstatus()->is_vtol && !_navigator->get_vstatus()->is_rotary_wing){\n \t\tstruct vehicle_command_s cmd = {};\n \t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n \t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/581623cd482f27cf8925f77e37004951e9e98b6c/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_land_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_land_item"
        ]
      }
    }
  },
  {
    "title": "Mission takeoff yaw fix",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3724",
    "number": 3724,
    "created_at": "2016-02-11T14:58:14Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "Fixes yaw on takeoff over home location\nIncludes #3717\nIncreases stack for mc pos and fw pos controllers\n\nTest flown\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-11T15:02:58Z",
          "body": "Ok, will merge once the build passes.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-11T15:54:46Z",
          "body": "Done, on master, awesome! Thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and description explicitly state it 'Fixes yaw on takeoff over home location', which indicates it corrects incorrect runtime behavior (wrong orientation) rather than a syntax/style change. The change was test flown and merged, consistent with addressing a logic/behavioral bug in the control software.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -443,6 +443,8 @@ Mission::set_mission_items()\n \t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n \t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n+\t\t\t_mission_item.yaw = NAN;\n \t\t}\n \n \t\t/* move to landing waypoint before descent if necessary */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d0518fb23d2e4a78f7627df9ecafe2c979ba88a6/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ]
      }
    }
  },
  {
    "title": "WIP: VTOL weathervane",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3706",
    "number": 3706,
    "created_at": "2016-02-09T01:37:03Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes https://github.com/PX4/Firmware/issues/3679\ncherry-picked all commits onto new branch\n\nTo enable weathervane mode set param VT_OPT_WV_LND to 1\nThe VT_OPT_WV_RATE_D param defines the yaw dampening during landing\n\ntodo:\n- [x] Rename param to vtol_wv_yawrate_scale\n- [x] Disable MC_YAWRATE_I when weathervaning\n- [x] Add option to weathervane in loiter\n- [ ] Implement weathervane strategy when yaw is over-demanded during MC auto flight\n- [ ] flight test\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-02-10T13:54:40Z",
          "body": "@sanderux I fixed the naming. I guess you need to flight test this now.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-10T14:11:47Z",
          "body": "Thanks, i have a flight window saturday (as it is predicted now).\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-10T14:50:43Z",
          "body": "Looking forward to the testing. I think we should try to de-risk branches in SITL before and turn them into 2-3 test branches so the flight testing becomes tractable.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-11T14:22:01Z",
          "body": "@tumbili where did your commit go renaming the scale param?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-11T19:24:53Z",
          "body": "@AndreasAntener @sanderux sounds like we need this now to fix #3728. So should probably focus on this.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T08:23:07Z",
          "body": "@sanderux Seems like somebody forced pushed to this branch. I will need to push again from my private laptop.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-12T08:25:27Z",
          "body": "A force push would be visible in the timeline. Rather looks like they were not pushed at all, or to a different branch.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-12T08:26:21Z",
          "body": "@tumbili Since the commits are trivial please just quickly re-do them. Don't wait for tonight, as we miss a test window for @AndreasAntener. I want this to move faster now that you're back.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-12T11:43:16Z",
          "body": "Closing in favour of #3736\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-02-09T10:41:35Z",
          "body": "@sanderux you can zero the third component of the rates integral here.\n",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 53,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-09T10:43:57Z",
          "body": "@sanderux how about changing the name to vtol_wv_yawrate__max? It's not really damping anyway.\n",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-11T20:03:51Z",
          "body": "We should add this to is_reached() in the mission if the command is a normal waypoint and a 1-2 second timeout occurred.\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 31,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes control logic for VTOL weathervaning (enabling a weathervane mode, adding yaw-dampening parameter and disabling the MC_YAWRATE_I term when weathervaning), which targets incorrect/undesired yaw behaviour reported in the referenced issue. These are behavioral/control changes (not style/syntax) intended to correct how the system responds, though the change is WIP and appears to need flight testing before full verification.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "patch": "@@ -70,7 +70,9 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_action_start(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n-\t_cmd_pub(nullptr)\n+\t_cmd_pub(nullptr),\n+\t_param_vtol_wv_land(this, \"VT_OPT_WV_LND\", false),\n+\t_param_vtol_wv_loiter(this, \"VT_OPT_WV_LTR\", false)\n {\n }\n \n@@ -175,6 +177,7 @@ MissionBlock::is_mission_item_reached()\n \t}\n \n \t/* Check if the waypoint and the requested yaw setpoint. */\n+\n \tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n \n \t\t/* TODO: removed takeoff, why? */\n@@ -310,6 +313,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->loiter_direction = item->loiter_direction;\n \tsp->pitch_min = item->pitch_min;\n \tsp->acceptance_radius = item->acceptance_radius;\n+\tsp->disable_mc_yaw_control = false;\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_IDLE:\n@@ -322,12 +326,18 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \n \tcase NAV_CMD_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n+\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n+\t\t\tsp->disable_mc_yaw_control = true;\n+\t\t}\n \t\tbreak;\n \n \tcase NAV_CMD_LOITER_TIME_LIMIT:\n \tcase NAV_CMD_LOITER_TURN_COUNT:\n \tcase NAV_CMD_LOITER_UNLIMITED:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_loiter.get()){\n+\t\t\tsp->disable_mc_yaw_control = true;\n+\t\t}\n \t\tbreak;\n \n \tdefault:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e3cfe8638d49d3836baf48952aa57962385e35bb/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -45,6 +45,9 @@\n \n #include <navigator/navigation.h>\n \n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+\n #include <uORB/topics/mission.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n@@ -129,6 +132,8 @@ class MissionBlock : public NavigatorMode\n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n \torb_advert_t\t_cmd_pub;\n+\tcontrol::BlockParamInt _param_vtol_wv_land;\n+\tcontrol::BlockParamInt _param_vtol_wv_loiter;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e3cfe8638d49d3836baf48952aa57962385e35bb/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::MissionBlock"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::MissionBlock"
        ]
      }
    }
  },
  {
    "title": "WIP: VTOL_TAKEOFF and VTOL_LAND mission command support",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3699",
    "number": 3699,
    "created_at": "2016-02-07T23:47:48Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes: https://github.com/PX4/Firmware/issues/3492\nFixes: https://github.com/PX4/Firmware/issues/3414\nSupport for MAV_CMD_NAV_VTOL_TAKEOFF and MAV_CMD_NAV_VTOL_LAND\n\ntodo\n- [ ] Rebase and remove weathervane merge (maybe setup new branch)\n- [ ] Implement weathervane land for VTOL_LAND\n- [ ] Flight test\n",
      "issue_comments": [
        {
          "author": "sanderux",
          "created_at": "2016-02-07T23:50:57Z",
          "body": "@DonLakeFlyer these commands should be supported in QGC\nthey are in every sense similar to takeoff and land commands\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-07T23:55:24Z",
          "body": "Here's the test mission waypoint file\n[vtol takeoff and land.txt](https://github.com/PX4/Firmware/files/120995/vtol.takeoff.and.land.txt)\n\nThe vtol transition takeoff and land waypoints are displayed as mission frame commands. they are actually located near home. Takeoff a few meters north and land very close to home (where it lands)\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-08T18:08:08Z",
          "body": "whoops, merge was not intended\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-08T20:09:12Z",
          "body": "It's probably best to wait with this until the new mission handling is in (it's ready now, just needs a last flight test).\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-08T21:22:19Z",
          "body": "I'm going to reset this branch. @sanderux Please delete this branch locally and re-checkout it.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-08T21:22:58Z",
          "body": "No, actually not resetting. We'll deal with this later.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-08T22:06:49Z",
          "body": "Both these items need further testing in actual flight (mostly weathervane) because testing this in SITL is hard.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-08T22:10:38Z",
          "body": "@AndreasAntener i merged this code in your vtol_mission_fixes tree locally. works (much better).\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR adds proper handling for MAV_CMD_NAV_VTOL_TAKEOFF and MAV_CMD_NAV_VTOL_LAND which were previously treated incorrectly (displayed/handled as generic mission-frame commands and located near home). That produced incorrect mission behavior (wrong positions/frames and transitions) without crashes, so this change addresses a logic error in mission command handling.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 2,
        "changes": 23,
        "patch": "@@ -60,6 +60,7 @@\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n+#include <uORB/topics/vehicle_command.h>\n \n #include \"mission.h\"\n #include \"navigator.h\"\n@@ -418,6 +419,7 @@ Mission::set_mission_items()\n \t\t/* new current mission item set, check if we need takeoff */\n \t\tif (_need_takeoff && (\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n \t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n@@ -471,6 +473,20 @@ Mission::set_mission_items()\n \t}\n \n \tif (_takeoff_finished) {\n+\n+\t\t/* handle VTOL TAKEOFF command */\n+\t\tif(_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF){\n+\t\t\tstruct vehicle_command_s cmd = {};\n+\t\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n+\t\t\tif (_cmd_pub != nullptr) {\n+\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t\t} else {\n+\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t\t}\n+\t\t}\n+\n+\n \t\t/* we just finished takeoff */\n \t\t/* in case we still have to move to the takeoff waypoint we need a waypoint mission item */\n \t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n@@ -553,7 +569,7 @@ Mission::heading_sp_update()\n \t\t * For landing the last waypoint (= constant) is used to avoid excessive yawing near the ground\n \t\t */\n \t\tdouble point_from_latlon[2];\n-\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n \t\t\tpoint_from_latlon[0] = pos_sp_triplet->previous.lat;\n \t\t\tpoint_from_latlon[1] = pos_sp_triplet->previous.lon;\n \t\t} else {\n@@ -609,7 +625,10 @@ Mission::altitude_sp_foh_update()\n \n \t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n \t * and the FW controller has a custom landing logic */\n-\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n+\tif (_mission_item.nav_cmd == NAV_CMD_LAND ||\n+\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_LAND ||\n+\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n+\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF) {\n \t\treturn;\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0e3ae7e34bd18dc23f903414b6929730b3a35e/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 1,
        "changes": 24,
        "patch": "@@ -69,7 +69,8 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_time_first_inside_orbit(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n-\t_cmd_pub(nullptr)\n+\t_cmd_pub(nullptr),\n+\t_param_vtol_wv_land(this, \"VT_OPT_WV_LND\", false)\n {\n }\n \n@@ -180,7 +181,22 @@ MissionBlock::is_mission_item_reached()\n \t\t}\n \t}\n \n+\t/* handle VTOL_LAND command */\n+\tif(_waypoint_position_reached && _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n+\t\tstruct vehicle_command_s cmd = {};\n+\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\tif (_cmd_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t} else {\n+\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t}\n+\t\treturn _navigator->get_vstatus()->condition_landed;\n+\t}\n+\n+\n \t/* Check if the waypoint and the requested yaw setpoint. */\n+\n \tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n \n \t\t/* TODO: removed takeoff, why? */\n@@ -259,6 +275,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->loiter_direction = item->loiter_direction;\n \tsp->pitch_min = item->pitch_min;\n \tsp->acceptance_radius = item->acceptance_radius;\n+\tsp->disable_mc_yaw_control = false;\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_DO_SET_SERVO:\n@@ -273,11 +290,16 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \t\tbreak;\n \n \tcase NAV_CMD_TAKEOFF:\n+\tcase NAV_CMD_VTOL_TAKEOFF:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n \t\tbreak;\n \n \tcase NAV_CMD_LAND:\n+\tcase NAV_CMD_VTOL_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n+\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n+\t\t\tsp->disable_mc_yaw_control = true;\n+\t\t}\n \t\tbreak;\n \n \tcase NAV_CMD_LOITER_TIME_LIMIT:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0e3ae7e34bd18dc23f903414b6929730b3a35e/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -45,6 +45,9 @@\n \n #include <navigator/navigation.h>\n \n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+\n #include <uORB/topics/mission.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n@@ -124,6 +127,7 @@ class MissionBlock : public NavigatorMode\n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n \torb_advert_t\t_cmd_pub;\n+\tcontrol::BlockParamInt _param_vtol_wv_land;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0e3ae7e34bd18dc23f903414b6929730b3a35e/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "patch": "@@ -244,7 +244,9 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n-\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION &&\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_TAKEOFF &&\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_LAND) {\n \n \t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n \t\t\treturn false;\n@@ -407,7 +409,9 @@ MissionFeasibilityChecker::isPositionCommand(unsigned cmd){\n \t\tcmd == NAV_CMD_LOITER_TURN_COUNT ||\n \t\tcmd == NAV_CMD_LOITER_UNLIMITED ||\n \t\tcmd == NAV_CMD_TAKEOFF ||\n+\t\tcmd == NAV_CMD_VTOL_TAKEOFF ||\n \t\tcmd == NAV_CMD_LAND ||\n+\t\tcmd == NAV_CMD_VTOL_LAND ||\n \t\tcmd == NAV_CMD_PATHPLANNING) {\n \t\treturn true;\n \t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0e3ae7e34bd18dc23f903414b6929730b3a35e/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -61,6 +61,8 @@ enum NAV_CMD {\n \tNAV_CMD_TAKEOFF = 22,\n \tNAV_CMD_ROI = 80,\n \tNAV_CMD_PATHPLANNING = 81,\n+\tNAV_CMD_VTOL_TAKEOFF = 84,\n+\tNAV_CMD_VTOL_LAND = 85,\n \tNAV_CMD_DO_JUMP = 177,\n \tNAV_CMD_DO_SET_SERVO=183,\n \tNAV_CMD_DO_REPEAT_SERVO=184,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0e3ae7e34bd18dc23f903414b6929730b3a35e/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::altitude_sp_foh_update",
        "MissionFeasibilityChecker::isPositionCommand",
        "MissionBlock::is_mission_item_reached",
        "Mission::heading_sp_update",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::MissionBlock",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::heading_sp_update",
          "Mission::altitude_sp_foh_update",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::MissionBlock"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionItemValidity",
          "MissionFeasibilityChecker::isPositionCommand"
        ]
      }
    }
  },
  {
    "title": "Vtol weathervane",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3694",
    "number": 3694,
    "created_at": "2016-02-07T12:58:03Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "Fixes: https://github.com/PX4/Firmware/issues/3679\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T14:18:59Z",
          "body": "After reviewing this further, I believe we should clamp the yaw control demand, instead of disabling it completely. So that the system does only spend a little effort in maintaining heading. In light wind it will then maintain it, in heavy wind it will weather-vane.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-07T15:43:10Z",
          "body": "@LorenzMeier i agree, now it might be hard to understand what is going on in low wind conditions. How, and with what threshold should it disable control?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T15:52:59Z",
          "body": "10-20% of the maximum yaw demand might make sense, that would be 0.1-0.2 (you have to limit -0.2..0.2, since its symmetric around zero). That matches the intent to not give up too much control over roll and pitch for yaw.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-07T16:49:33Z",
          "body": "@LorenzMeier @sanderux I need to check the mixer if this would even make any sense. I believe yaw is mixed in at the very end so that it doesn't violate thrust, roll, pitch\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T16:52:34Z",
          "body": "@tumbili This discussion is not about yaw handling. Its about orienting the plane into the wind so that wind gusts do not completely ruin the position and attitude control response. Its very different from mixer limits.\n\nWe reserved a minimum for yaw. And it would put the motors at their maximum spread. It would mean that you would see the system constantly yaw in wind, coupled with roll and pitch. Two motors would run at their maximum capacity and overheat. We can't handle this on a best-effort basis in the mixer. We need to do this in the controller already, like Sander proposed.\n",
          "type": "issue_comment"
        },
        {
          "author": "tubeme",
          "created_at": "2016-02-07T19:32:42Z",
          "body": "This will apply only to QuadPlanes (classic plane with tail and rudder) not the quad delta wings, right? \n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-07T20:14:26Z",
          "body": "@tubeme \nIt will apply to all VTOL types where the setting is enabled. if you have a standard vtol on delta wing i would suggest leaving the VT_OPT_WV_LND set to 0 (default).\n",
          "type": "issue_comment"
        },
        {
          "author": "tubeme",
          "created_at": "2016-02-07T20:56:53Z",
          "body": "@sanderux OK I understand. Thanks.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-07T21:20:11Z",
          "body": "@LorenzMeier is this more what you had in mind?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-09T01:37:37Z",
          "body": "Replaced by https://github.com/PX4/Firmware/pull/3706\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-02-07T12:59:09Z",
          "body": "@sanderux Make sure to condition this on auto mode!\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 37,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T13:24:26Z",
          "body": "whitespace error\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T13:28:22Z",
          "body": "We probably need to add the ability to add only ORB_IDs. This fix won't work properly because now the length of the struct is not necessarily equal.\n",
          "path": "src/modules/vtol_att_control/vtol_att_control_main.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T14:13:51Z",
          "body": "Add the condition here: `!_control_mode.flag_control_manual_enabled &&` then you should be safe.\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T14:15:46Z",
          "body": "This is not the right way to do this. You can get into an increasing yaw rate this way. A simple wind gust would be sufficient to start the spiral of death. What you should do instead is to clamp the actuator control output for yaw.\n",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T14:16:44Z",
          "body": "It will look funny if the system is constantly yawing on land. It should instead be \"soft yaw control\" or something like that.\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes the controller decision logic for yaw during VTOL weathervaning (clamping yaw demand instead of disabling it), which addresses incorrect/undesired behavior (loss of heading control or motors driven to limits) under wind. This is a behavioral bug (improper control/state handling), so it constitutes a logic error fix.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 311,
        "deletions": 145,
        "changes": 456,
        "patch": "@@ -40,6 +40,7 @@\n  * @author Anton Babushkin <anton.babushkin@me.com>\n  * @author Ban Siesta <bansiesta@gmail.com>\n  * @author Simon Wilks <simon@uaventure.com>\n+ * @author Andreas Antener <andreas@uaventure.com>\n  */\n \n #include <sys/types.h>\n@@ -76,15 +77,14 @@ Mission::Mission(Navigator *navigator, const char *name) :\n \t_current_onboard_mission_index(-1),\n \t_current_offboard_mission_index(-1),\n \t_need_takeoff(true),\n-\t_takeoff(false),\n \t_mission_type(MISSION_TYPE_NONE),\n \t_inited(false),\n \t_home_inited(false),\n \t_missionFeasibilityChecker(),\n \t_min_current_sp_distance_xy(FLT_MAX),\n \t_mission_item_previous_alt(NAN),\n-  \t_on_arrival_yaw(NAN),\n-\t_distance_current_previous(0.0f)\n+\t_distance_current_previous(0.0f),\n+\t_work_item_type(WORK_ITEM_TYPE_DEFAULT)\n {\n \t/* load initial params */\n \tupdateParams();\n@@ -176,11 +176,11 @@ Mission::on_active()\n \t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n \t\t\tadvance_mission();\n \t\t\tset_mission_items();\n-\n \t\t}\n \n-\t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n+\t} else if (_mission_type != MISSION_TYPE_NONE && _param_altmode.get() == MISSION_ALTMODE_FOH) {\n \t\taltitude_sp_foh_update();\n+\n \t} else {\n \t\t/* if waypoint position reached allow loiter on the setpoint */\n \t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n@@ -285,24 +285,23 @@ Mission::update_offboard_mission()\n void\n Mission::advance_mission()\n {\n-\tif (_takeoff) {\n-\t\t_takeoff = false;\n-\t\t_takeoff_finished = true;\n+\t/* do not advance mission item if we're processing sub mission work items */\n+\tif (_work_item_type != WORK_ITEM_TYPE_DEFAULT) {\n+\t\treturn;\n+\t}\n \n-\t} else {\n-\t\tswitch (_mission_type) {\n-\t\tcase MISSION_TYPE_ONBOARD:\n-\t\t\t_current_onboard_mission_index++;\n-\t\t\tbreak;\n-\n-\t\tcase MISSION_TYPE_OFFBOARD:\n-\t\t\t_current_offboard_mission_index++;\n-\t\t\tbreak;\n-\n-\t\tcase MISSION_TYPE_NONE:\n-\t\tdefault:\n-\t\t\tbreak;\n-\t\t}\n+\tswitch (_mission_type) {\n+\tcase MISSION_TYPE_ONBOARD:\n+\t\t_current_onboard_mission_index++;\n+\t\tbreak;\n+\n+\tcase MISSION_TYPE_OFFBOARD:\n+\t\t_current_offboard_mission_index++;\n+\t\tbreak;\n+\n+\tcase MISSION_TYPE_NONE:\n+\tdefault:\n+\t\tbreak;\n \t}\n }\n \n@@ -327,19 +326,23 @@ Mission::set_mission_items()\n \n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t/* set previous position setpoint to current */\n-\tset_previous_pos_setpoint();\n+\t/* the home dist check provides user feedback, so we initialize it to this */\n+\tbool user_feedback_done = false;\n+\n+\t/* mission item that comes after current if available */\n+\tstruct mission_item_s mission_item_next_position;\n+\tbool has_next_position_item = false;\n+\n+\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \n-\t/* Copy previous mission item altitude (can be extended to a copy of the full mission item if needed) */\n-\tif (pos_sp_triplet->previous.valid) {\n+\t/* copy information about the previous mission item */\n+\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n+\t\t/* Copy previous mission item altitude */\n \t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n \t}\n \n-\t/* the home dist check provides user feedback, so we initialize it to this */\n-\tbool user_feedback_done = false;\n-\n \t/* try setting onboard mission item */\n-\tif (_param_onboard_enabled.get() && read_mission_item(true, true, &_mission_item)) {\n+\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n@@ -348,7 +351,7 @@ Mission::set_mission_items()\n \t\t_mission_type = MISSION_TYPE_ONBOARD;\n \n \t/* try setting offboard mission item */\n-\t} else if (read_mission_item(false, true, &_mission_item)) {\n+\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n \t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n@@ -404,82 +407,152 @@ Mission::set_mission_items()\n \t\treturn;\n \t}\n \n-\tif (pos_sp_triplet->current.valid) {\n-\t\t_on_arrival_yaw = _mission_item.yaw;\n-\t}\n+\t/*********************************** handle mission item *********************************************/\n \n-\t/* do takeoff on first waypoint for rotary wing vehicles */\n-\tif (_navigator->get_vstatus()->is_rotary_wing) {\n-\t\t/* force takeoff if landed (additional protection) */\n-\t\tif (!_takeoff && _navigator->get_vstatus()->condition_landed) {\n-\t\t\t_need_takeoff = true;\n+\t/* handle position mission items */\n+\tif (item_contains_position(&_mission_item)) {\n+\n+\t\t/* we have a new position item so set previous position setpoint to current */\n+\t\tset_previous_pos_setpoint();\n+\n+\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n+\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n+\n+\t\t\t/* use current mission item as next position item */\n+\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n+\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\thas_next_position_item = true;\n+\n+\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n+\n+\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n+\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n+\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n+\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n+\t\t\t/* ignore yaw for takeoff items */\n+\t\t\t_mission_item.yaw = NAN;\n+\t\t\t_mission_item.altitude = takeoff_alt;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n \t\t}\n \n-\t\t/* new current mission item set, check if we need takeoff */\n-\t\tif (_need_takeoff && (\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n-\t\t\t_takeoff = true;\n-\t\t\t_need_takeoff = false;\n+\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t}\n-\t}\n \n-\tif (_takeoff) {\n-\t\t/* do takeoff before going to setpoint */\n-\t\t/* set mission item as next position setpoint */\n-\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n-\t\t/* next SP is not takeoff anymore */\n-\t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t\t/* move to landing waypoint before descent if necessary */\n+\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n \n-\t\t/* calculate takeoff altitude */\n-\t\tfloat takeoff_alt = get_absolute_altitude_for_item(_mission_item);\n+\t\t\t/* use current mission item as next position item */\n+\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n+\t\t\thas_next_position_item = true;\n \n-\t\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n-\t\tif (_navigator->get_vstatus()->condition_landed) {\n-\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n+\t\t\t/*\n+\t\t\t * Ignoring waypoint altitude:\n+\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n+\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n+\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n+\t\t\t * what the altitude means on this waypoint type.\n+\t\t\t */\n+\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n+\t\t\tif (pos_sp_triplet->current.valid) {\n+\t\t\t\taltitude = pos_sp_triplet->current.alt;\n+\t\t\t}\n \n-\t\t} else {\n-\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n+\t\t\t_mission_item.altitude = altitude;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n+\t\t}\n+\n+\t\t/* we just moved to the landing waypoint, now descend */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \t\t}\n \n-\t\t/* check if we already above takeoff altitude */\n-\t\tif (_navigator->get_global_position()->alt < takeoff_alt) {\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n+\t\t/* ignore yaw for landing items */\n+\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n+\t\t * that aligns the vehicle first */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n+\t\t\t_mission_item.yaw = NAN;\n+\t\t}\n \n-\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n+\t/* handle non-position mission items such as commands */\n+\t} else {\n+\n+\t\t/* turn towards next waypoint before MC to FW transition */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n+\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n+\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t&& has_next_position_item) {\n+\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n+\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n \t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n-\t\t\t_mission_item.yaw = NAN;\n-\t\t\t_mission_item.altitude = takeoff_alt;\n+\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.time_inside = 0;\n+\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n+\t\t\t\t_navigator->get_global_position()->lat,\n+\t\t\t\t_navigator->get_global_position()->lon,\n+\t\t\t\tmission_item_next_position.lat,\n+\t\t\t\tmission_item_next_position.lon);\n+\t\t}\n \n-\t\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\t/* yaw is aligned now */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t}\n \n-\t\t\t_navigator->set_position_setpoint_triplet_updated();\n-\t\t\treturn;\n+\t\t/* don't advance mission after FW to MC command */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n+\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n+\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t&& pos_sp_triplet->current.valid) {\n \n-\t\t} else {\n-\t\t\t/* skip takeoff */\n-\t\t\t_takeoff = false;\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n+\t\t}\n+\n+\t\t/* after FW to MC transition finish moving to the waypoint */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n+\t\t\t\t&& pos_sp_triplet->current.valid) {\n+\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n+\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n+\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n \t\t}\n-\t}\n \n-\tif (_takeoff_finished) {\n-\t\t/* we just finished takeoff */\n-\t\t/* in case we still have to move to the takeoff waypoint we need a waypoint mission item */\n-\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t_takeoff_finished = false;\n \t}\n \n-\t/* set current position setpoint from mission item */\n+\t/*********************************** set setpoints and check next *********************************************/\n+\n+\t/* set current position setpoint from mission item (is protected agains non-position items) */\n \tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \n+\t/* issue command if ready (will do nothing for position mission items) */\n+\tissue_command(&_mission_item);\n+\n+\t/* set current work item type */\n+\t_work_item_type = new_work_item_type;\n+\n \t/* require takeoff after landing or idle */\n \tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n \t\t_need_takeoff = true;\n@@ -494,12 +567,11 @@ Mission::set_mission_items()\n \t// TODO: report onboard mission item somehow\n \n \tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n-\t\t/* try to read next mission item */\n-\t\tstruct mission_item_s mission_item_next;\n+\t\t/* try to process next mission item */\n \n-\t\tif (read_mission_item(_mission_type == MISSION_TYPE_ONBOARD, false, &mission_item_next)) {\n+\t\tif (has_next_position_item) {\n \t\t\t/* got next mission item, update setpoint triplet */\n-\t\t\tmission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n+\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n \t\t} else {\n \t\t\t/* next mission item is not available */\n \t\t\tpos_sp_triplet->next.valid = false;\n@@ -512,7 +584,8 @@ Mission::set_mission_items()\n \n \t/* Save the distance between the current sp and the previous one */\n \tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n-\t\t_distance_current_previous = get_distance_to_next_waypoint(pos_sp_triplet->current.lat,\n+\t\t_distance_current_previous = get_distance_to_next_waypoint(\n+\t\t\t\tpos_sp_triplet->current.lat,\n \t\t\t\tpos_sp_triplet->current.lon,\n \t\t\t\tpos_sp_triplet->previous.lat,\n \t\t\t\tpos_sp_triplet->previous.lon);\n@@ -521,72 +594,143 @@ Mission::set_mission_items()\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n+bool\n+Mission::do_need_takeoff()\n+{\n+\tif (_navigator->get_vstatus()->is_rotary_wing) {\n+\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n+\n+\t\t/* force takeoff if landed (additional protection) */\n+\t\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\t\t_need_takeoff = true;\n+\n+\t\t/* if in-air and already above takeoff height, don't do takeoff */\n+\t\t} else if (_navigator->get_global_position()->alt > takeoff_alt) {\n+\t\t\t_need_takeoff = false;\n+\t\t}\n+\n+\t\t/* check if current mission item is one that requires takeoff before */\n+\t\tif (_need_takeoff && (\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n+\n+\t\t\t_need_takeoff = false;\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool\n+Mission::do_need_move_to_land()\n+{\n+\tif (_navigator->get_vstatus()->is_rotary_wing && _mission_item.nav_cmd == NAV_CMD_LAND) {\n+\n+\t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\n+\t\treturn d_current > _navigator->get_acceptance_radius();\n+\t}\n+\n+\treturn false;\n+}\n+\n+float\n+Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n+{\n+\t/* calculate takeoff altitude */\n+\tfloat takeoff_alt = get_absolute_altitude_for_item(*mission_item);\n+\n+\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n+\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n+\n+\t} else {\n+\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n+\t}\n+\n+\treturn takeoff_alt;\n+}\n+\n void\n Mission::heading_sp_update()\n {\n-\tif (_takeoff) {\n-\t\t/* we don't want to be yawing during takeoff */\n+\t/* we don't want to be yawing during takeoff, landing or aligning for a transition */\n+\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_LAND\n+\t\t\t|| _work_item_type == WORK_ITEM_TYPE_ALIGN) {\n \t\treturn;\n \t}\n \n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t/* Don't change setpoint if last and current waypoint are not valid */\n-\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n-\t\t\t!PX4_ISFINITE(_on_arrival_yaw)) {\n-\t\treturn;\n-\t}\n-\n-\t/* Don't change heading for takeoff waypoints, the ground may be near */\n-\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n+\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid) {\n \t\treturn;\n \t}\n \n-\t/* set yaw angle for the waypoint iff a loiter time has been specified */\n+\t/* set yaw angle for the waypoint if a loiter time has been specified */\n \tif (_waypoint_position_reached && _mission_item.time_inside > 0.0f) {\n-\t\t_mission_item.yaw = _on_arrival_yaw;\n-\t} else {\n+\t\t// XXX: should actually be param4 from mission item\n+\t\t// at the moment it will just keep the heading it has\n+\t\t//_mission_item.yaw = _on_arrival_yaw;\n+\t\t//pos_sp_triplet->current.yaw = _mission_item.yaw;\n \n-\t\t/* calculate direction the vehicle should point to:\n-\t\t * normal waypoint: current position to {waypoint or home or home + 180deg}\n-\t\t * landing waypoint: last waypoint to {waypoint or home or home + 180deg}\n-\t\t * For landing the last waypoint (= constant) is used to avoid excessive yawing near the ground\n-\t\t */\n+\t} else {\n+\t\t/* Calculate direction the vehicle should point to. */\n \t\tdouble point_from_latlon[2];\n-\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n-\t\t\tpoint_from_latlon[0] = pos_sp_triplet->previous.lat;\n-\t\t\tpoint_from_latlon[1] = pos_sp_triplet->previous.lon;\n+\t\tdouble point_to_latlon[2];\n+\n+\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n+\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n+\n+\t\t/* target location is home */\n+\t\tif ((_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME\n+\t\t\t\t|| _param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME)\n+\t\t\t\t// need to be rotary wing for this but not in a transition\n+\t\t\t\t// in VTOL mode this will prevent updating yaw during FW flight\n+\t\t\t\t// (which would result in a wrong yaw setpoint spike during back transition)\n+\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !(_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION || _navigator->get_vstatus()->in_transition_mode)) {\n+\t\t\tpoint_to_latlon[0] = _navigator->get_home_position()->lat;\n+\t\t\tpoint_to_latlon[1] = _navigator->get_home_position()->lon;\n+\n+\t\t/* target location is next (current) waypoint */\n \t\t} else {\n-\t\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n-\t\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n+\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n+\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n \t\t}\n \n-\t\t/* always keep the front of the rotary wing pointing to the next waypoint */\n-\t\tif (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT\n-\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n-\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\tpoint_from_latlon[0],\n-\t\t\t\tpoint_from_latlon[1],\n-\t\t\t\t_mission_item.lat,\n-\t\t\t\t_mission_item.lon);\n-\t\t/* always keep the back of the rotary wing pointing towards home */\n-\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME) {\n-\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\tpoint_from_latlon[0],\n-\t\t\t\tpoint_from_latlon[1],\n-\t\t\t\t_navigator->get_home_position()->lat,\n-\t\t\t\t_navigator->get_home_position()->lon);\n-\t\t/* always keep the back of the rotary wing pointing towards home */\n-\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n-\t\t\t_mission_item.yaw = _wrap_pi(get_bearing_to_next_waypoint(\n+\t\tfloat d_current = get_distance_to_next_waypoint(\n+\t\t\tpoint_from_latlon[0], point_from_latlon[1],\n+\t\t\tpoint_to_latlon[0], point_to_latlon[1]);\n+\n+\t\t/* stop if positions are close together to prevent excessive yawing */\n+\t\tif (d_current > _navigator->get_acceptance_radius()) {\n+\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n \t\t\t\tpoint_from_latlon[0],\n \t\t\t\tpoint_from_latlon[1],\n-\t\t\t\t_navigator->get_home_position()->lat,\n-\t\t\t\t_navigator->get_home_position()->lon) + M_PI_F);\n+\t\t\t\tpoint_to_latlon[0],\n+\t\t\t\tpoint_to_latlon[1]);\n+\n+\t\t\t/* always keep the back of the rotary wing pointing towards home */\n+\t\t\tif (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n+\t\t\t\t_mission_item.yaw = _wrap_pi(yaw + M_PI_F);\n+\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n+\n+\t\t\t} else {\n+\t\t\t\t_mission_item.yaw = yaw;\n+\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n+\t\t\t}\n \t\t}\n \t}\n \n-\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t// we set yaw directly so we can run this in parallel to the FOH update\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n@@ -613,7 +757,6 @@ Mission::altitude_sp_foh_update()\n \t\treturn;\n \t}\n \n-\n \t/* Calculate distance to current waypoint */\n \tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n \t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n@@ -627,6 +770,7 @@ Mission::altitude_sp_foh_update()\n \t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n \tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n \t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n+\n \t} else {\n \t\t/* update the altitude sp of the 'current' item in the sp triplet, but do not update the altitude sp\n \t\t* of the mission item as it is used to check if the mission item is reached\n@@ -637,9 +781,9 @@ Mission::altitude_sp_foh_update()\n \t\tfloat grad = -delta_alt/(_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius));\n \t\tfloat a = _mission_item_previous_alt - grad * _distance_current_previous;\n \t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n-\n \t}\n \n+\t// we set altitude directly so we can run this in parallel to the heading update\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n@@ -650,33 +794,55 @@ Mission::altitude_sp_foh_reset()\n }\n \n bool\n-Mission::read_mission_item(bool onboard, bool is_current, struct mission_item_s *mission_item)\n+Mission::prepare_mission_items(bool onboard, struct mission_item_s *mission_item,\n+\tstruct mission_item_s *next_position_mission_item, bool *has_next_position_item)\n+{\n+\tbool first_res = false;\n+\tint offset = 1;\n+\n+\tif (read_mission_item(onboard, 0, mission_item)) {\n+\t\t\n+\t\tfirst_res = true;\n+\n+\t\t/* trying to find next position mission item */\n+\t\twhile(read_mission_item(onboard, offset, next_position_mission_item)) {\n+\n+\t\t\tif (item_contains_position(next_position_mission_item)) {\n+\t\t\t\t*has_next_position_item = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\toffset++;\n+\t\t}\n+\t}\n+\n+\treturn first_res;\n+}\n+\n+bool\n+Mission::read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item)\n {\n \t/* select onboard/offboard mission */\n \tint *mission_index_ptr;\n \tdm_item_t dm_item;\n \n \tstruct mission_s *mission = (onboard) ? &_onboard_mission : &_offboard_mission;\n-\tint mission_index_next = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n+\tint current_index = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n+\tint index_to_read = current_index + offset;\n \n \t/* do not work on empty missions */\n \tif (mission->count == 0) {\n \t\treturn false;\n \t}\n \n-\t/* move to next item if there is one */\n-\tif (mission_index_next < ((int)mission->count - 1)) {\n-\t\tmission_index_next++;\n-\t}\n-\n \tif (onboard) {\n \t\t/* onboard mission */\n-\t\tmission_index_ptr = is_current ? &_current_onboard_mission_index : &mission_index_next;\n+\t\tmission_index_ptr = (offset == 0) ? &_current_onboard_mission_index : &index_to_read;\n \t\tdm_item = DM_KEY_WAYPOINTS_ONBOARD;\n \n \t} else {\n \t\t/* offboard mission */\n-\t\tmission_index_ptr = is_current ? &_current_offboard_mission_index : &mission_index_next;\n+\t\tmission_index_ptr = (offset == 0) ? &_current_offboard_mission_index : &index_to_read;\n \t\tdm_item = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n \t}\n \n@@ -712,8 +878,8 @@ Mission::read_mission_item(bool onboard, bool is_current, struct mission_item_s\n \t\t\tif (mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) {\n \n \t\t\t\t/* only raise the repeat count if this is for the current mission item\n-\t\t\t\t* but not for the next mission item */\n-\t\t\t\tif (is_current) {\n+\t\t\t\t* but not for the read ahead mission item */\n+\t\t\t\tif (offset == 0) {\n \t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n \t\t\t\t\t/* save repeat count */\n \t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, DM_PERSIST_POWER_ON_RESET,\n@@ -732,8 +898,8 @@ Mission::read_mission_item(bool onboard, bool is_current, struct mission_item_s\n \t\t\t\t*mission_index_ptr = mission_item_tmp.do_jump_mission_index;\n \n \t\t\t} else {\n-\t\t\t\tif (is_current) {\n-\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(),\n+\t\t\t\tif (offset == 0) {\n+\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(),\n \t\t\t\t\t\t\t     \"DO JUMP repetitions completed\");\n \t\t\t\t}\n \t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb16e2fa49c1dce43c120e4274edd16dfcd83f16/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 37,
        "deletions": 4,
        "changes": 41,
        "patch": "@@ -119,6 +119,21 @@ class Mission : public MissionBlock\n \t */\n \tvoid set_mission_items();\n \n+\t/**\n+\t * Returns true if we need to do a takeoff at the current state\n+\t */\n+\tbool do_need_takeoff();\n+\n+\t/**\n+\t * Returns true if we need to move to waypoint location before starting descent\n+\t */\n+\tbool do_need_move_to_land();\n+\n+\t/**\n+\t * Calculate takeoff height for mission item considering ground clearance\n+\t */\n+\tfloat calculate_takeoff_altitude(struct mission_item_s *mission_item);\n+\n \t/**\n \t * Updates the heading of the vehicle. Rotary wings only.\n \t */\n@@ -137,10 +152,21 @@ class Mission : public MissionBlock\n \tfloat get_absolute_altitude_for_item(struct mission_item_s &mission_item);\n \n \t/**\n-\t * Read current or next mission item from the dataman and watch out for DO_JUMPS\n+\t * Read the current and the next mission item. The next mission item read is the\n+\t * next mission item that contains a position.\n+\t *\n+\t * @return true if current mission item available\n+\t */\n+\tbool prepare_mission_items(bool onboard, struct mission_item_s *mission_item,\n+\t\tstruct mission_item_s *next_position_mission_item, bool *has_next_position_item);\n+\n+\t/**\n+\t * Read current (offset == 0) or a specific (offset > 0) mission item\n+\t * from the dataman and watch out for DO_JUMPS\n+\t *\n \t * @return true if successful\n \t */\n-\tbool read_mission_item(bool onboard, bool is_current, struct mission_item_s *mission_item);\n+\tbool read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item);\n \n \t/**\n \t * Save current offboard mission state to dataman\n@@ -184,8 +210,6 @@ class Mission : public MissionBlock\n \tint _current_onboard_mission_index;\n \tint _current_offboard_mission_index;\n \tbool _need_takeoff;\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n-\tbool _takeoff;\t\t\t\t\t\t/**< takeoff state flag */\n-\tbool _takeoff_finished;\t\t\t\t\t/**< set if takeoff was requested before and is now done */\n \n \tenum {\n \t\tMISSION_TYPE_NONE,\n@@ -204,6 +228,15 @@ class Mission : public MissionBlock\n \tfloat _on_arrival_yaw; /**< holds the yaw value that should be applied when the current waypoint is reached */\n \tfloat _distance_current_previous; /**< distance from previous to current sp in pos_sp_triplet,\n \t\t\t\t\t    only use if current and previous are valid */\n+\n+\tenum work_item_type {\n+\t\tWORK_ITEM_TYPE_DEFAULT,\t\t/**< default mission item */\n+\t\tWORK_ITEM_TYPE_TAKEOFF,\t\t/**< takeoff before moving to waypoint */\n+\t\tWORK_ITEM_TYPE_MOVE_TO_LAND,\t/**< move to land waypoint before descent */\n+\t\tWORK_ITEM_TYPE_ALIGN,\t\t/**< align for next waypoint */\n+\t\tWORK_ITEM_TYPE_CMD_BEFORE_MOVE\t/**<  */\n+\t} _work_item_type;\t/**< current type of work to do (sub mission item) */\n+\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb16e2fa49c1dce43c120e4274edd16dfcd83f16/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 96,
        "deletions": 31,
        "changes": 127,
        "patch": "@@ -36,6 +36,7 @@\n  * Helper class to use mission items\n  *\n  * @author Julian Oes <julian@oes.ch>\n+ * @author Sander Smeets <sander@droneslab.com>\n  */\n \n #include <sys/types.h>\n@@ -66,9 +67,11 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_waypoint_position_reached(false),\n \t_waypoint_yaw_reached(false),\n \t_time_first_inside_orbit(0),\n+\t_action_start(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n-\t_cmd_pub(nullptr)\n+\t_cmd_pub(nullptr),\n+\t_param_vtol_wv_land(this, \"VT_OPT_WV_LND\", false)\n {\n }\n \n@@ -81,17 +84,8 @@ MissionBlock::is_mission_item_reached()\n {\n \t/* handle non-navigation or indefinite waypoints */\n \tswitch (_mission_item.nav_cmd) {\n-\t\tcase NAV_CMD_DO_SET_SERVO: {\n-\t\t\tmemset(&actuators, 0, sizeof(actuators));\n-\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n-\t\t\tactuators.timestamp = hrt_absolute_time();\n-\t\t\tif (_actuator_pub != nullptr) {\n-\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n-\t\t\t} else {\n-\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n-\t\t\t}\n+\t\tcase NAV_CMD_DO_SET_SERVO:\n \t\t\treturn true;\n-\t\t\t}\n \n \t\tcase NAV_CMD_LAND:\n \t\t\treturn _navigator->get_vstatus()->condition_landed;\n@@ -102,20 +96,22 @@ MissionBlock::is_mission_item_reached()\n \t\tcase NAV_CMD_LOITER_UNLIMITED:\n \t\t\treturn false;\n \n-\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n-\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n-\t\t\t{\n-\t\t\t/* forward the command to other processes */\n-\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n-\t\t\tstruct vehicle_command_s cmd = {};\n-\t\t\tcmd.command = _mission_item.nav_cmd;\n-\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n-\t\t\tif (_cmd_pub != nullptr) {\n-\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n-\t\t\t} else {\n-\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n-\t\t\t}\n+\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n \t\t\treturn true;\n+\n+\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n+\t\t\t/*\n+\t\t\t * We wait half a second to give the transition command time to propagate.\n+\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n+\t\t\t */\n+\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n+\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n+\t\t\t\t_action_start = 0;\n+\n+\t\t\t\treturn true;\n+\n+\t\t\t} else {\n+\t\t\t\treturn false;\n \t\t\t}\n \n \t\tdefault:\n@@ -180,6 +176,7 @@ MissionBlock::is_mission_item_reached()\n \t}\n \n \t/* Check if the waypoint and the requested yaw setpoint. */\n+\n \tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n \n \t\t/* TODO: removed takeoff, why? */\n@@ -237,6 +234,7 @@ MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item,\n \tcmd->param5 = item->params[4];\n \tcmd->param6 = item->params[5];\n \tcmd->param7 = item->params[6];\n+\tcmd->command = item->nav_cmd;\n \n \tcmd->target_system = _navigator->get_vstatus()->system_id;\n \tcmd->target_component = _navigator->get_vstatus()->component_id;\n@@ -245,9 +243,65 @@ MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item,\n \tcmd->confirmation = false;\n }\n \n+void\n+MissionBlock::issue_command(const struct mission_item_s *item)\n+{\n+\tif (item_contains_position(item)) {\n+\t\treturn;\n+\t}\n+\n+\tif (item->nav_cmd == NAV_CMD_DO_SET_SERVO) {\n+\t\tPX4_WARN(\"do_set_servo command\");\n+\t\t// XXX: we should issue a vehicle command and handle this somewhere else\n+\t\tmemset(&actuators, 0, sizeof(actuators));\n+\t\t// params[0] actuator number to be set 0..5 ( corresponds to AUX outputs 1..6\n+\t\t// params[1] new value for selected actuator in ms 900...2000\n+\t\tactuators.control[(int)item->params[0]] = 1.0f / 2000 * -item->params[1];\n+\t\tactuators.timestamp = hrt_absolute_time();\n+\n+\t\tif (_actuator_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n+\n+\t\t} else {\n+\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n+\t\t}\n+\n+\t} else {\n+\t\tPX4_WARN(\"forwarding command %d\\n\", item->nav_cmd);\n+\t\tstruct vehicle_command_s cmd = {};\n+\t\tmission_item_to_vehicle_command(item, &cmd);\n+\t\t_action_start = hrt_absolute_time();\n+\n+\t\tif (_cmd_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\n+\t\t} else {\n+\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t}\n+\t}\n+}\n+\n+bool\n+MissionBlock::item_contains_position(const struct mission_item_s *item)\n+{\n+\t// XXX: maybe extend that check onto item properties\n+\tif (item->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n+\t\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION ||\n+\t\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO) {\n+\t\treturn false;\n+\t}\n+\n+\treturn true;\n+}\n+\n void\n MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n {\n+\t/* don't change the setpoint for non-position items */\n+\tif (!item_contains_position(item)) {\n+\t\treturn;\n+\t}\n+\n \tsp->valid = true;\n \tsp->lat = item->lat;\n \tsp->lon = item->lon;\n@@ -258,15 +312,9 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->loiter_direction = item->loiter_direction;\n \tsp->pitch_min = item->pitch_min;\n \tsp->acceptance_radius = item->acceptance_radius;\n+\tsp->disable_mc_yaw_control = false;\n \n \tswitch (item->nav_cmd) {\n-\tcase NAV_CMD_DO_SET_SERVO:\n-\t\t\t/* Set current position for loitering set point*/\n-\t\t\tsp->lat = _navigator->get_global_position()->lat;\n-\t\t\tsp->lon = _navigator->get_global_position()->lon;\n-\t\t\tsp->alt = _navigator->get_global_position()->alt;\n-\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\tbreak;\n \tcase NAV_CMD_IDLE:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n \t\tbreak;\n@@ -277,6 +325,9 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \n \tcase NAV_CMD_LAND:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n+\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n+\t\t\tsp->disable_mc_yaw_control = true;\n+\t\t}\n \t\tbreak;\n \n \tcase NAV_CMD_LOITER_TIME_LIMIT:\n@@ -374,6 +425,20 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance,\n void\n MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_location)\n {\n+\n+\t/* VTOL transition to RW before landing */\n+\tif(_navigator->get_vstatus()->is_vtol){\n+\t\tstruct vehicle_command_s cmd = {};\n+\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\tif (_cmd_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t} else {\n+\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t}\n+\t}\n+\n+\t/* set the land item */\n \titem->nav_cmd = NAV_CMD_LAND;\n \n \t/* use current position */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb16e2fa49c1dce43c120e4274edd16dfcd83f16/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "patch": "@@ -45,6 +45,9 @@\n \n #include <navigator/navigation.h>\n \n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+\n #include <uORB/topics/mission.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n@@ -78,6 +81,8 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid reset_mission_item_reached();\n \n+\tbool item_contains_position(const struct mission_item_s *item);\n+\n \t/**\n \t * Convert a mission item to a position setpoint\n \t *\n@@ -116,14 +121,18 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n \n+\tvoid issue_command(const struct mission_item_s *item);\n+\n \tmission_item_s _mission_item;\n \tbool _waypoint_position_reached;\n \tbool _waypoint_yaw_reached;\n \thrt_abstime _time_first_inside_orbit;\n+\thrt_abstime _action_start;\n \n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n \torb_advert_t\t_cmd_pub;\n+\tcontrol::BlockParamInt _param_vtol_wv_land;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb16e2fa49c1dce43c120e4274edd16dfcd83f16/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "patch": "@@ -51,7 +51,6 @@\n #include <fcntl.h>\n #include <errno.h>\n #include <uORB/topics/fence.h>\n-#include <uORB/topics/vehicle_command.h>\n \n MissionFeasibilityChecker::MissionFeasibilityChecker() :\n \t_mavlink_fd(-1),\n@@ -335,10 +334,6 @@ bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size\n bool\n MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued)\n {\n-\tif (_dist_1wp_ok) {\n-\t\t/* always return true after at least one successful check */\n-\t\treturn true;\n-\t}\n \n \t/* check if first waypoint is not too far from home */\n \tif (dist_first_wp > 0.0f) {\n@@ -352,14 +347,14 @@ MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionI\n \t\t\t\tif (mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO){\n \n \t\t\t\t\t/* check actuator number */\n-\t\t\t\t\tif (mission_item.actuator_num < 0 || mission_item.actuator_num > 5) {\n-\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.actuator_num);\n+\t\t\t\t\tif (mission_item.params[0] < 0 || mission_item.params[0] > 5) {\n+\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.params[0]);\n \t\t\t\t\t\twarning_issued = true;\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t\t/* check actuator value */\n-\t\t\t\t\tif (mission_item.actuator_value < -2000 || mission_item.actuator_value > 2000) {\n-\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.actuator_value);\n+\t\t\t\t\tif (mission_item.params[1] < -2000 || mission_item.params[1] > 2000) {\n+\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.params[1]);\n \t\t\t\t\t\twarning_issued = true;\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb16e2fa49c1dce43c120e4274edd16dfcd83f16/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -103,9 +103,8 @@ struct mission_item_s {\n \tint do_jump_mission_index;\t/**< index where the do jump will go to                 */\n \tunsigned do_jump_repeat_count;\t/**< how many times do jump needs to be done            */\n \tunsigned do_jump_current_count;\t/**< count how many times the jump has been done\t*/\n-\tint actuator_num;               /**< actuator number to be set 0..5 ( corresponds to AUX outputs 1..6    */\n-\tint actuator_value;             /**< new value for selected actuator in ms 900...2000         */\n \tfloat params[7];\t\t/**< array to store mission command values for MAV_FRAME_MISSION ***/\n+\tint8_t frame;\t\t\t/**< mission frame ***/\n };\n #pragma pack(pop)\n #include <uORB/topics/mission.h>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb16e2fa49c1dce43c120e4274edd16dfcd83f16/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::altitude_sp_foh_reset",
        "Mission::altitude_sp_foh_update",
        "read_mission_item",
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "Mission::on_active",
        "Mission::read_mission_item",
        "waypoint",
        "MissionBlock::is_mission_item_reached",
        "MissionBlock::set_takeoff_item",
        "Mission::update_offboard_mission",
        "MissionBlock::mission_item_to_vehicle_command",
        "MissionFeasibilityChecker::check_dist_1wp",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::MissionBlock",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::altitude_sp_foh_reset",
          "Mission::altitude_sp_foh_update",
          "Mission::on_active",
          "Mission::read_mission_item",
          "waypoint",
          "Mission::update_offboard_mission",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission.h": [
          "read_mission_item"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::set_takeoff_item",
          "MissionBlock::mission_item_to_vehicle_command",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::MissionBlock"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding",
          "MissionFeasibilityChecker::check_dist_1wp"
        ]
      }
    }
  },
  {
    "title": "Remove run-once procedure on check_dist_1wp",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3690",
    "number": 3690,
    "created_at": "2016-02-07T00:40:51Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes: https://github.com/PX4/Firmware/issues/3688\n\nThe stored mission is checked at system startup. When no mission is loaded the check returns OK and sets a param that it does not need to check again. When a new mission is uploaded this bool is not reset.\n\nIn light of future adjustments to the feasibility checker (soft check on load, hard check on execute) i have chosen to remove the run-once procedure. I will soon add the ability to load a mission on a location far from the first waypoint, it will warn the user but still accept the mission. Upon execution it will run the check again and fail to execute if still too far away.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T16:56:24Z",
          "body": "Thanks! Cherry-picked to master.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes an improper state-management logic bug: a run-once flag allowed the stored mission check to return OK at startup and never re-run when a new mission was uploaded, so new missions could bypass feasibility checks. Removing the run-once behavior corrects the incorrect conditional/state transition that caused unintended behavior.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -335,10 +335,6 @@ bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size\n bool\n MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued)\n {\n-\tif (_dist_1wp_ok) {\n-\t\t/* always return true after at least one successful check */\n-\t\treturn true;\n-\t}\n \n \t/* check if first waypoint is not too far from home */\n \tif (dist_first_wp > 0.0f) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/754b7c53c257091bf8d13a6466ac0ec612bebc4a/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkFixedWingLanding"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding"
        ]
      }
    }
  },
  {
    "title": "Vtol RTL transition before landing when in fixed wing",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3687",
    "number": 3687,
    "created_at": "2016-02-06T22:30:54Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes: https://github.com/PX4/Firmware/issues/3617\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T16:39:01Z",
          "body": "Is this SITL tested?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-07T17:16:07Z",
          "body": "Yes works well in sitl. You can switch a mission during fw flight to rtl, it will transition before landing\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T17:20:01Z",
          "body": "Applied to master as its nicely self-contained.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect VTOL state transition behavior: when switching to RTL during fixed-wing flight the vehicle should transition to multicopter mode prior to landing. This is a state-transition/behavior bug (logic error) where the system previously handled the RTL command incorrectly, and the change corrects that unintended behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "patch": "@@ -36,6 +36,7 @@\n  * Helper class to use mission items\n  *\n  * @author Julian Oes <julian@oes.ch>\n+ * @author Sander Smeets <sander@droneslab.com>\n  */\n \n #include <sys/types.h>\n@@ -379,6 +380,20 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance,\n void\n MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_location)\n {\n+\n+\t/* VTOL transition to RW before landing */\n+\tif(_navigator->get_vstatus()->is_vtol){\n+\t\tstruct vehicle_command_s cmd = {};\n+\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\tif (_cmd_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t} else {\n+\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t}\n+\t}\n+\n+\t/* set the land item */\n \titem->nav_cmd = NAV_CMD_LAND;\n \n \t/* use current position */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9aa96b27fb0c9bded45980f36890bc8b8c9f5db0/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_takeoff_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_takeoff_item"
        ]
      }
    }
  },
  {
    "title": "use system specific acceptance radius for multirotor takeoff",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3686",
    "number": 3686,
    "created_at": "2016-02-06T20:40:25Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "Fixes #3684 \n\nThe condition for reaching takeoff waypoint is the same as on my mission update. Also had to update the isolated takeoff item altitude because the acceptance radius won't be used anymore. Tested in sitl/hil\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T00:48:40Z",
          "body": "The root cause of the issue for me seems to be that all acceptance radii are zero. So this PR fixes takeoff, but not the other waypoints.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-07T09:24:02Z",
          "body": "In SITL they are/were NAN for some reason. If they were zero it would work as it is.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-07T09:32:30Z",
          "body": "This fix does only use the system acceptance radius for takeoff like we want it anyway, and by chance is also a workaround for sitl issue.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-07T11:33:34Z",
          "body": "Applied on master\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects the logic used to determine when a multirotor has reached the takeoff waypoint by switching to the system-specific acceptance radius. The previous behavior (using the wrong/invalid acceptance radius or NaN/zero) caused incorrect waypoint-reached decisions, which is a classic logic error in the conditional/state handling.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "patch": "@@ -141,17 +141,9 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t&dist_xy, &dist_z);\n \n \t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n-\t\t\t/* require only altitude for takeoff for multicopter */\n-\n-\t\t\t/* _mission_item.acceptance_radius is not always set */\n-\t\t\tfloat mission_acceptance_radius = _mission_item.acceptance_radius;\n-\t\t\t/* if set to zero use the default instead */\n-\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n-\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n-\t\t\t}\n-\n+\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n \t\t\tif (_navigator->get_global_position()->alt >\n-\t\t\t\taltitude_amsl - mission_acceptance_radius) {\n+\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n@@ -362,14 +354,17 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance,\n \n \tif (min_clearance > 0.0f) {\n \t\titem->altitude += min_clearance;\n+\n+\t\t/* we must takeoff to a point further above ground than the acceptance radius */\n+\t\tif (_navigator->get_acceptance_radius() > min_clearance) {\n+\t\t\titem->altitude += _navigator->get_acceptance_radius();\n+\t\t}\n \t}\n \n \titem->altitude_is_relative = false;\n \titem->yaw = NAN;\n \titem->loiter_radius = _navigator->get_loiter_radius();\n \titem->loiter_direction = 1;\n-\titem->acceptance_radius = (_navigator->get_acceptance_radius() > min_clearance / 2.0f) ?\n-\t\t\t\t\t(min_clearance / 2) : _navigator->get_acceptance_radius();\n \titem->time_inside = 0.0f;\n \titem->pitch_min = min_pitch;\n \titem->autocontinue = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/57b6b0acf0ce102999e38556684a4aea989dafbf/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_takeoff_item",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_takeoff_item",
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "WIP: Vtol TECS fix",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3678",
    "number": 3678,
    "created_at": "2016-02-05T18:29:34Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "@tumbili new tecs fix branch off master\n",
      "issue_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-11T12:26:41Z",
          "body": "With this branch, the desired airspeed is nicely ramped up after the transition. I did 2 flights in altitude control (which is btw awesome to fly the standard VTOL in):\n\n![tecs init flight 1](https://cloud.githubusercontent.com/assets/5750020/12976174/774bc7dc-d0c2-11e5-960b-883c1389e2d1.png)\nhttp://logs.uaventure.com/view/ArZvMEN93W9uMHHU4igTed\n\n![tecs init flight 2](https://cloud.githubusercontent.com/assets/5750020/12976178/79492282-d0c2-11e5-8479-0058136969e1.png)\nhttp://logs.uaventure.com/view/zrRkhmi35oGRRZiq9fTcPm\n\nIn flight 1 you still see that TECS has a huge pitch integrator to start with. There must be something wrong there when TECS starts. In the following transitions and in flight 2 you never see any integrator when it starts, so I'm assuming it's correctly reset.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T08:17:45Z",
          "body": "Another log from yesterday afternoon where the init was ok: http://logs.uaventure.com/view/Gi8kX8ho4oaye8gcjjS5sd\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-12T08:21:19Z",
          "body": "Are you saying we should merge?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T08:28:06Z",
          "body": "No :) This should be flight tested a bit more, also I need to fix AUX logging so I see FW thrust during the transition which is also one of the reasons for this fix.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-12T08:28:44Z",
          "body": "Aux logging is fixed on master (as far as implemented).\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T15:01:10Z",
          "body": "Two more flights:\nmission http://logs.uaventure.com/view/gVUinykcLifN6tCpvTTrW6\naltctl http://logs.uaventure.com/view/943VqsD7bbhZq5hX9vzCUf\nnot analyzed yet\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T17:12:36Z",
          "body": "Looked good in both flights:\n![screen shot 2016-02-12 at 18 04 01](https://cloud.githubusercontent.com/assets/5750020/13014311/731ff268-d1b3-11e5-8b07-9094368b3d05.png)\n\nVTOL att contorller is holding thrust until tecs/fw pos is publishing, TECS is reinitialized and airspeed setpoint ramps up. The only thing I don't like now is the thrust dip after the transition, could also still be smoothed out.\n\n@tumbili I implemented the thrust holding for standard vtol, how does it look for tailsitter and tiltrotor?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-12T22:25:13Z",
          "body": "TODOs\n- implement wait_on_fw for tailsitter and tiltrotor\n- copy MC state until finished waiting so the attitude setpoint doesn't jump to an undefined value\n\nFlight test\n- try setting a higher transition speed, e.g. min speed + 1\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-15T00:22:43Z",
          "body": "@tumbili I made the FW position controller aware of when TECS is running and using a 0 pitch and thrust setpoint if not. The irregularity we had before was due to stale TECS data published before it started to run (and reset) again.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-15T07:45:30Z",
          "body": "@AndreasAntener I had a look and it looks good to me. Looking forward to some flight results.\nEspecially, for the planes of Marco and Sanders I hope to see some difference. They were always diving quite a bit.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-15T13:18:14Z",
          "body": "I think i can fly this tomorrow\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-16T15:16:36Z",
          "body": "2 logs of successful missions and one with induced rc loss failsafe RTL;\nRTL mission 1: http://logs.uaventure.com/view/3msrKYiSjKrDvKKckveA4e\nFull mission 2: http://logs.uaventure.com/view/7y4hdAoz4Bsog8K24qE67c\nFull mission 3: http://logs.uaventure.com/view/x7RvfZX3MVfCrnVgocbUoG\nMission 3 video: https://drive.google.com/file/d/0B27AvDmVit4KQzNNZGRxZ0RaU2M/view?usp=sharing\n\nFor reference here a manual hover log with one yaw turn:\nhttp://logs.uaventure.com/view/YXLzTNbzjasnmqnaQfjMBY \n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-16T15:39:20Z",
          "body": "Wobbly back transition, see missions 2 and 3. and video at 4:27\nThe wobble wasnt there in the transition that happened when switching to manual mode in mission 1\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-16T15:51:00Z",
          "body": "Mission flight on master (without this branch): http://logs.uaventure.com/view/57bJPThtDayp6ZXCQ2guTQ\nmission: http://logs.uaventure.com/view/GanJap84VKsX4scBe7Zk5C\naltctl: http://logs.uaventure.com/view/vY8d5Hdufkwip8gCobdqEL\nabort after transition because it got blown away by wind: http://logs.uaventure.com/view/zQ5WKTyQcqPMJdhLHBD6Zg\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-16T20:01:41Z",
          "body": "After changing some parameters MUCH better performance:\nnew mission 1: http://logs.uaventure.com/view/zCiXVJtTPNoPNZ7e2cn4h\nnew mission 2: http://logs.uaventure.com/view/SGutTXNPo92waZE5UBkGSK\n\nAnd a video of mission 1: https://drive.google.com/file/d/0B27AvDmVit4KT1BpNTRnNzVrZEE/view?usp=sharing\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-16T21:03:36Z",
          "body": "The 2 missions with new params were identical.\nI do see strange altitude behavior when comparing both:\n\nThe whole mission was set on 25m altitude waypoints\n(Alt \\* 100)\n\nMission 1:\n![alt 1](https://cloud.githubusercontent.com/assets/14801663/13090946/1157dbba-d4f9-11e5-8dcc-23900b049b1b.png)\n\nMission 2:\n![alt 2](https://cloud.githubusercontent.com/assets/14801663/13090951/16fe7146-d4f9-11e5-864d-8eaacc407911.png)\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-17T15:39:32Z",
          "body": "New test flights, in 0 wind, higher transition speed, and 0 speed weight:\nhttp://logs.uaventure.com/view/2AZKfJ5DHxbAmbbmsg4dr8\nhttp://logs.uaventure.com/view/qjFVbGSC4ACEzeCN3UcMRB\nvery nice\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-18T10:35:29Z",
          "body": "@AndreasAntener This is tested with tailsitter in SITL.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-18T17:54:24Z",
          "body": "@AndreasAntener Can we merge this?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-18T17:56:58Z",
          "body": "Awesome work! Rebased and applied (and I checked that I had Roman's rebased branch and the diff is clean).\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect runtime behavior caused by stale TECS data and improper state transitions during VTOLâ†’FW transitions (e.g. huge pitch integrator at startup, thrust dips). The changes reinitialize TECS, hold thrust until FW/TECS are ready and make the FW controller aware of TECS state, addressing improper state/data flow and synchronization â€” classic logic errors.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -37,6 +37,7 @@\n  *\n  * @author Julian Oes <julian@oes.ch>\n  * @author Sander Smeets <sander@droneslab.com>\n+ * @author Andreas Antener <andreas@uaventure.com>\n  */\n \n #include <sys/types.h>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/aa90c0686b766102b3bd1efb2a4f7ecd28adbe61/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Simulation lockstep",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3675",
    "number": 3675,
    "created_at": "2016-02-04T23:56:36Z",
    "merged": true,
    "merged_at": "2016-02-05T15:52:05Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "This PR implements the Simulator -> SITL direction and blocks the execution of SITL if the simulator is lagging. It also does time bookkeeping and ensures the blocked execution does not lead to jumping timestamps. \"Flight tested\" in Sim, leads to a lot more stability.\n\n@liamstask @tumbili You probably will enjoy this.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-04T23:58:03Z",
          "body": "@vbuskirk @darknight-007 This should fix your cloud environment.\n",
          "type": "issue_comment"
        },
        {
          "author": "liamstask",
          "created_at": "2016-02-05T00:01:03Z",
          "body": "nice, checking this out now\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-05T08:26:27Z",
          "body": "@LorenzMeier Great, this is fantastic!\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-05T08:44:01Z",
          "body": "@tumbili could you help with the code review so we can get it in?\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-05T09:00:23Z",
          "body": "@LorenzMeier Yes, will do!\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-02-05T09:46:50Z",
          "body": "@LorenzMeier Works perfectly fine for me! Will do a review now.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-05T15:52:18Z",
          "body": "Merged after more testing and review.\n",
          "type": "issue_comment"
        },
        {
          "author": "i-sheremet",
          "created_at": "2016-02-06T12:25:48Z",
          "body": "@LorenzMeier Thank you for working on it!\nI have already made a [post](https://groups.google.com/forum/#!topic/px4users/O3r9kFyVT4Y) regarding the issue and my PC setup (_Asus ux32vd : Intel i7 3517U Processor x4_cores, 10 Gb RAM, SSD memory, discrete video card - Nvidia GT 620M_), but unfortunately I didn't notice any significant difference in performance with this corrections. Here are the results I got:\n\nFlight with default setup, gzclient on, shuttling between waypoints 2-3-4. [Flight log](https://drive.google.com/file/d/0B9wE0Um8rdPgc0duUTd0aW1mWE0/view?usp=sharing)\n![1](https://cloud.githubusercontent.com/assets/7020958/12866583/7363e1e4-ccdb-11e5-9415-f1780acf04af.png)\n![2](https://cloud.githubusercontent.com/assets/7020958/12866595/f77c5e84-ccdb-11e5-9f23-1afaac3c6c97.png)\nnutshell constantly prints messages as these:\n\n```\nINFO  simulator is slow. Delay added: 17398 us\nINFO  simulator is slow. Delay added: 13763 us\nINFO  simulator is slow. Delay added: 13225 us\nINFO  simulator is slow. Delay added: 10039 us\nINFO  simulator is slow. Delay added: 11732 us\nINFO  simulator is slow. Delay added: 23303 us\nINFO  simulator is slow. Delay added: 12116 us\nINFO  simulator is slow. Delay added: 11689 us\nINFO  simulator is slow. Delay added: 20377 us\n```\n\nThe exact flight with gzclient off. It made several circles, path is overlapped. [Flight log](https://drive.google.com/file/d/0B9wE0Um8rdPgbXFnREplSHVlLXM/view?usp=sharing)\n![3](https://cloud.githubusercontent.com/assets/7020958/12866610/aa20a662-ccdc-11e5-9a05-d24a9086d4b0.png)\n![4](https://cloud.githubusercontent.com/assets/7020958/12866617/1a1cdcb0-ccdd-11e5-984b-b8f2f4456bc9.png)\nonly 3 messages in nutshell:\n\n```\nINFO  simulator is slow. Delay added: 17390 us\nINFO  simulator is slow. Delay added: 13690 us\nINFO  simulator is slow. Delay added: 14090 us\n```\n\nSo the problem remains. Maybe it has something to do with my gazebo or pc setup? I have gazebo version 6.5.1\nThanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes simulator-SITL synchronization and time bookkeeping to block SITL when the simulator is lagging, preventing timestamp jumps and desynchronization. This addresses a timing/synchronization logic bug (improper state/timing transitions) rather than a syntax or style issue.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -331,7 +331,7 @@ Navigator::task_main()\n \n \t\t} else if (pret < 0) {\n \t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n-\t\t\tPX4_WARN(\"poll error %d, %d\", pret, errno);\n+\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n \t\t\tcontinue;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/15e7b1999128ce9fdee119024b60df055d6e2004/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "Mission feasibility fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3673",
    "number": 3673,
    "created_at": "2016-02-04T19:48:57Z",
    "merged": true,
    "merged_at": "2016-02-04T20:36:52Z",
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "- Fixes https://github.com/PX4/Firmware/issues/3656\n- Fixes https://github.com/PX4/Firmware/issues/3648\n- Corrected spelling on method\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-04T19:58:19Z",
          "body": "Looking good! Will merge once they pass.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-04T20:37:02Z",
          "body": "Merged, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR is titled 'Mission feasibility fixes' and explicitly states it 'Fixes' two issue reports, which implies correcting incorrect behavior in mission feasibility logic rather than syntax or style. The nature of the changes (feasibility checks) and the issue references indicate the PR addresses logic errors causing wrong/undesired program behavior.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -80,7 +80,7 @@ Mission::Mission(Navigator *navigator, const char *name) :\n \t_mission_type(MISSION_TYPE_NONE),\n \t_inited(false),\n \t_home_inited(false),\n-\t_missionFeasiblityChecker(),\n+\t_missionFeasibilityChecker(),\n \t_min_current_sp_distance_xy(FLT_MAX),\n \t_mission_item_previous_alt(NAN),\n   \t_on_arrival_yaw(NAN),\n@@ -255,7 +255,7 @@ Mission::update_offboard_mission()\n \t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n \t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n \n-\t\tfailed = !_missionFeasiblityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n+\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n@@ -841,7 +841,7 @@ Mission::check_mission_valid()\n \n \t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n \n-\t\t_navigator->get_mission_result()->valid = _missionFeasiblityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n+\t\t_navigator->get_mission_result()->valid = _missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fdcfb7c7c6c85a5bfb747b60871ff8166d02c103/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -196,7 +196,7 @@ class Mission : public MissionBlock\n \tbool _inited;\n \tbool _home_inited;\n \n-\tMissionFeasibilityChecker _missionFeasiblityChecker; /**< class that checks if a mission is feasible */\n+\tMissionFeasibilityChecker _missionFeasibilityChecker; /**< class that checks if a mission is feasible */\n \n \tfloat _min_current_sp_distance_xy; /**< minimum distance which was achieved to the current waypoint  */\n \tfloat _mission_item_previous_alt; /**< holds the altitude of the previous mission item,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fdcfb7c7c6c85a5bfb747b60871ff8166d02c103/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 15,
        "changes": 49,
        "patch": "@@ -36,6 +36,7 @@\n  *\n  * @author Lorenz Meier <lm@inf.ethz.ch>\n  * @author Thomas Gubler <thomasgubler@student.ethz.ch>\n+ * @author Sander Smeets <sander@droneslab.com>\n  */\n \n #include \"mission_feasibility_checker.h\"\n@@ -185,25 +186,32 @@ bool MissionFeasibilityChecker::checkHomePositionAltitude(dm_item_t dm_current,\n \t\t\treturn false;\n \t\t}\n \n-\t\t/* always reject relative alt without home set */\n-\t\tif (missionitem.altitude_is_relative && !home_valid) {\n-\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: No home pos, WP %d uses rel alt\", i);\n+\t\t/* reject relative alt without home set */\n+\t\tif (missionitem.altitude_is_relative && !home_valid && isPositionCommand(missionitem.nav_cmd)) {\n+\n \t\t\twarning_issued = true;\n-\t\t\treturn false;\n+\n+\t\t\tif (throw_error) {\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission: No home pos, WP %d uses rel alt\", i+1);\n+\t\t\t\treturn false;\n+\t\t\t} else\t{\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: No home pos, WP %d uses rel alt\", i+1);\n+\t\t\t\treturn true;\n+\t\t\t}\n \t\t}\n \n \t\t/* calculate the global waypoint altitude */\n \t\tfloat wp_alt = (missionitem.altitude_is_relative) ? missionitem.altitude + home_alt : missionitem.altitude;\n \n-\t\tif (home_alt > wp_alt) {\n+\t\tif (home_alt > wp_alt && isPositionCommand(missionitem.nav_cmd)) {\n \n \t\t\twarning_issued = true;\n \n \t\t\tif (throw_error) {\n-\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Waypoint %d below home\", i);\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission: Waypoint %d below home\", i+1);\n \t\t\t\treturn false;\n \t\t\t} else\t{\n-\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Waypoint %d below home\", i);\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Waypoint %d below home\", i+1);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n@@ -235,8 +243,8 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n-\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL &&\n-\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION) {\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n \n \t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n \t\t\treturn false;\n@@ -357,12 +365,7 @@ MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionI\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t/* check only items with valid lat/lon */\n-\t\t\t\telse if ( mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n-\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n-\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n-\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n-\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n-\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_PATHPLANNING) {\n+\t\t\t\telse if (isPositionCommand(mission_item.nav_cmd)) {\n \n \t\t\t\t\t/* check distance from current position to item */\n \t\t\t\t\tfloat dist_to_1wp = get_distance_to_next_waypoint(\n@@ -401,6 +404,22 @@ MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionI\n \t}\n }\n \n+bool\n+MissionFeasibilityChecker::isPositionCommand(unsigned cmd){\n+\tif( cmd == NAV_CMD_WAYPOINT ||\n+\t\tcmd == NAV_CMD_LOITER_TIME_LIMIT ||\n+\t\tcmd == NAV_CMD_LOITER_TURN_COUNT ||\n+\t\tcmd == NAV_CMD_LOITER_UNLIMITED ||\n+\t\tcmd == NAV_CMD_TAKEOFF ||\n+\t\tcmd == NAV_CMD_LAND ||\n+\t\tcmd == NAV_CMD_PATHPLANNING) {\n+\t\treturn true;\n+\t} else {\n+\t\treturn false;\n+\n+\t}\n+}\n+\n void MissionFeasibilityChecker::updateNavigationCapabilities()\n {\n \t(void)orb_copy(ORB_ID(navigation_capabilities), _capabilities_sub, &_nav_caps);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fdcfb7c7c6c85a5bfb747b60871ff8166d02c103/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -36,6 +36,7 @@\n  *\n  * @author Lorenz Meier <lm@inf.ethz.ch>\n  * @author Thomas Gubler <thomasgubler@student.ethz.ch>\n+ * @author Sander Smeets <sander@droneslab.com>\n  */\n \n #ifndef MISSION_FEASIBILITY_CHECKER_H_\n@@ -65,6 +66,7 @@ class MissionFeasibilityChecker\n \tbool checkHomePositionAltitude(dm_item_t dm_current, size_t nMissionItems, float home_alt, bool home_valid, bool &warning_issued, bool throw_error = false);\n \tbool checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed);\n \tbool check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued);\n+\tbool isPositionCommand(unsigned cmd);\n \n \t/* Checks specific to fixedwing airframes */\n \tbool checkMissionFeasibleFixedwing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fdcfb7c7c6c85a5bfb747b60871ff8166d02c103/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -64,6 +64,7 @@ enum NAV_CMD {\n \tNAV_CMD_DO_JUMP = 177,\n \tNAV_CMD_DO_SET_SERVO=183,\n \tNAV_CMD_DO_REPEAT_SERVO=184,\n+\tNAV_CMD_DO_DIGICAM_CONTROL=203,\n \tNAV_CMD_DO_VTOL_TRANSITION=3000,\n \tNAV_CMD_INVALID=UINT16_MAX /* ensure that casting a large number results in a specific error */\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fdcfb7c7c6c85a5bfb747b60871ff8166d02c103/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::update_offboard_mission",
        "Mission::check_mission_valid",
        "MissionFeasibilityChecker::checkHomePositionAltitude",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "MissionFeasibilityChecker::check_dist_1wp"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::update_offboard_mission",
          "Mission::check_mission_valid"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkHomePositionAltitude",
          "MissionFeasibilityChecker::checkMissionItemValidity",
          "MissionFeasibilityChecker::check_dist_1wp"
        ]
      }
    }
  },
  {
    "title": "VTOL: check mission feasibility as rotary wing",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3664",
    "number": 3664,
    "created_at": "2016-02-03T21:15:16Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "VTOL mission feasibility can be validated on rotary wing basis so no fixed wing landing feasibility will fail the mission\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-02-06T09:28:36Z",
          "body": "@sanderux Did you test this! If yes I will rebase and merge, looks good.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-06T09:43:21Z",
          "body": "Yes, tested and works. I should note that it does now allow a mission where fw flight flies at very low altitudes when vtol\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-18T17:56:48Z",
          "body": "@tumbili Roman I think we can pull this in. Need to think about further mission check strategies for vtol\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-18T20:42:49Z",
          "body": "Cherry-picked.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes mission-feasibility validation so VTOL missions are evaluated using rotary-wing constraints instead of fixed-wing landing checks. The previous logic could incorrectly reject valid VTOL missions (false negatives) by applying fixed-wing landing feasibility, so this is a correction of incorrect decision/validation logic. The author tested it and reviewers approved, though it introduces a noted side-effect (allowing very low-altitude fixed-wing legs when flown as VTOL).",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -257,7 +257,7 @@ Mission::update_offboard_mission()\n \t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n \t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n \n-\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n+\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), (_navigator->get_vstatus()->is_rotary_wing || _navigator->get_vstatus()->is_vtol),\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n@@ -1027,7 +1027,7 @@ Mission::check_mission_valid()\n \n \t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n \n-\t\t_navigator->get_mission_result()->valid = _missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n+\t\t_navigator->get_mission_result()->valid = _missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), (_navigator->get_vstatus()->is_rotary_wing || _navigator->get_vstatus()->is_vtol),\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/035fe6cddce5682657d8fd7105a890056afb4ee5/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_offboard_mission",
        "Mission::check_mission_valid"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::update_offboard_mission",
          "Mission::check_mission_valid"
        ]
      }
    }
  },
  {
    "title": "Mavlink read back frame fix",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3660",
    "number": 3660,
    "created_at": "2016-02-03T10:56:08Z",
    "merged": true,
    "merged_at": "2016-02-03T12:09:06Z",
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes https://github.com/PX4/Firmware/issues/3658\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-03T11:24:18Z",
          "body": "Nice! Will merge once it passes.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and description explicitly state it fixes a Mavlink 'read back frame' bug and references an issue, indicating incorrect runtime behavior rather than a syntax/style change. The reviewer comment approving merge further supports that this is a behavioral bug fix, i.e. a logic error being corrected.",
    "patches": {
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -64,6 +64,7 @@ enum NAV_CMD {\n \tNAV_CMD_DO_JUMP = 177,\n \tNAV_CMD_DO_SET_SERVO=183,\n \tNAV_CMD_DO_REPEAT_SERVO=184,\n+\tNAV_CMD_DO_VTOL_TRANSITION=3000,\n \tNAV_CMD_INVALID=UINT16_MAX /* ensure that casting a large number results in a specific error */\n };\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/f0bad06bfdd9b8e9a4d9977c8d4c4f3d5a2ae183/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "RTL was broken by a recent change, revert",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3604",
    "number": 3604,
    "created_at": "2016-01-26T14:56:37Z",
    "merged": true,
    "merged_at": "2016-01-27T11:05:59Z",
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "@tumbili can you quickly verify the revert and pull this?\n\nI'm going to reimplement this in https://github.com/PX4/Firmware/pull/3598\n",
      "issue_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-26T14:59:02Z",
          "body": "log with mission and RTL: http://logs.uaventure.com/view/zKUEwNhZM4Sep6gkDyLZUd\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and comments state that RTL (Return-To-Launch) behavior was broken by a recent change and the PR reverts that change. This indicates it corrects incorrect runtime behavior/regression (not a syntax/style issue), so it is fixing a logic error in the code.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "patch": "@@ -150,6 +150,7 @@ void\n Mission::on_active()\n {\n \tcheck_mission_valid();\n+\n \t/* check if anything has changed */\n \tbool onboard_updated = false;\n \torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n@@ -180,12 +181,6 @@ Mission::on_active()\n \n \t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n \t\taltitude_sp_foh_update();\n-\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _waypoint_position_reached && _navigator->get_vstatus()->is_rotary_wing) {\n-\t\t// the copter has reached the landing spot location\n-\t\t// set the same landing item again but this time the vehicle will actually\n-\t\t// descend and land\n-\t\tset_mission_item_reached();\n-\t\tset_mission_items();\n \t} else {\n \t\t/* if waypoint position reached allow loiter on the setpoint */\n \t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3928924c4332083d5d282c1df387aa29c61256a8/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 28,
        "changes": 31,
        "patch": "@@ -92,17 +92,9 @@ MissionBlock::is_mission_item_reached()\n \t\t\t}\n \t\t\treturn true;\n \t\t\t}\n+\n \t\tcase NAV_CMD_LAND:\n-\t\t\tif (!_navigator->get_vstatus()->is_rotary_wing) {\n-\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n-\t\t\t} else {\n-\t\t\t\tif (_waypoint_position_reached) {\n-\t\t\t\t\t// the copter has reached the position of the landing spot\n-\t\t\t\t\t// it can can start to descend\n-\t\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n+\t\t\treturn _navigator->get_vstatus()->condition_landed;\n \n \t\t/* TODO: count turns */\n \t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n@@ -167,12 +159,6 @@ MissionBlock::is_mission_item_reached()\n \t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n-\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND) {\n-\t\t\t// check if we have reached our landing spot\n-\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n-\t\t\t\t_waypoint_position_reached = true;\n-\t\t\t\treturn false;\n-\t\t\t}\n \t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n \t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n \t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n@@ -236,7 +222,6 @@ MissionBlock::is_mission_item_reached()\n \t\t\treturn true;\n \t\t}\n \t}\n-\n \treturn false;\n }\n \n@@ -299,17 +284,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \t\tbreak;\n \n \tcase NAV_CMD_LAND:\n-\n-\t\tif (!_waypoint_position_reached) {\n-\t\t\t// we first need to move to the landing waypoint\n-\t\t\t// use the altitude specified in the mission item\n-\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n-\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n-\t\t} else {\n-\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n-\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n-\t\t}\n-\n+\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n \t\tbreak;\n \n \tcase NAV_CMD_LOITER_TIME_LIMIT:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3928924c4332083d5d282c1df387aa29c61256a8/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint",
        "Mission::on_active",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_active"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "VTOL mission item handling",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3598",
    "number": 3598,
    "created_at": "2016-01-26T02:10:05Z",
    "merged": true,
    "merged_at": "2016-02-08T23:11:44Z",
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "In general this will fix handling for 2 part mission items (takeoff, landing, transitions)\nFixes #3583\nFixes #3581\nFixes #3501\nFixes #3414\n\nShould handle the following cases consistently:\n- [x] transition: yaw into direction of next wp then transition\n- [x] back transition: transition then move to wp\n- [x] back transition yaw issue\n- [x] takeoff: climb then move to wp\n- [x] land: move to wp then descend (fixes #3388)\n- [x] back transition: yaw north when flying south\n",
      "issue_comments": [
        {
          "author": "julianoes",
          "created_at": "2016-01-26T07:05:20Z",
          "body": "@AndreasAntener ready for review?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-26T07:19:39Z",
          "body": "Only conceptual, see the comment here: https://github.com/PX4/Firmware/issues/3583#issuecomment-174783402\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-28T08:09:40Z",
          "body": "@sanderux This is now working in STIL. Please take extra care when testing, I haven't thoroughly tested it yet, so please to a SITL test first. Forward transition now aligns towards next waypoint:\n\n<img width=\"819\" alt=\"screen shot 2016-01-28 at 08 57 03\" src=\"https://cloud.githubusercontent.com/assets/5750020/12638564/7e9d981e-c59e-11e5-9974-1bca814a5505.png\">\n\nhttp://logs.uaventure.com/view/iMh8rPQvEyiCWGfNUTtq2C\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-28T08:35:13Z",
          "body": "@AndreasAntener mission_block.cpp:195 \nPX4_WARN(\"yaw err: %.3f\", (float)yaw_err);\n\ngives me a compilation error (double to float). disabled it\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-28T23:57:44Z",
          "body": "@AndreasAntener I have a commit ready that fixes an IO hog because the mission feasibility checker was constantly running. Now only running before entering a mission. If you give me access i can attach to your PR to save a lot of merging.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-29T06:41:56Z",
          "body": "Nice! Is it independent from this functionality and my changes? If yes we should treat it as such, so it's traceable and documented on a PR.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-29T08:50:00Z",
          "body": "On further inspection it seems although it loops it's only executed when a new home position is set. There does seem to be an issue of accepting invalid missions. see https://github.com/PX4/Firmware/issues/3627\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-29T16:30:13Z",
          "body": "Quick update, here is the log from our last flight: http://logs.uaventure.com/view/4G7pGXVjfMSttAmqPTCDkP\n\nWe had some issues with loading the mission back from QGC, which messed up the transition waypoints (lost the \"frame\"). So this flight http://logs.uaventure.com/view/BCMa7QKdCMgakcGdKFUSSg is actually also good but there was probably something wrong with the forward transition waypoint.\n\nOne or two more checks with latest QGC would be good and I need to go through the rest of the command handling to make sure nothing got lost during the refactoring.\n\nAnd the fix on the position controller is still to be verified further.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-01-29T17:51:05Z",
          "body": "I think the mission feasablity checker needs to run when a mission is uploaded, not just before it gets executed. Otherwise the user doesn't get the feedback in time.\nOr, is this already the case?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-29T18:04:21Z",
          "body": "@julianoes I think both should happen in a different way. I could be loading a mission from home, 10km away from my intended takeoff point. The FC could warn about the location but it should accept the mission. When switching to mission mode it should fail 10km away from the takeoff point. So i think both answers are correct but the feasibility checker should consider it's frame of reference (store or execute)\n\n@AndreasAntener I have a flight window saturday and/or sunday, I will update to the latest QGC. is there anything specific i could test for you?\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-30T09:10:44Z",
          "body": "@sanderux Nothing specific. Would be cool to see this branch working for you as well. Still need to find some setpoint irregularities, curious if they show up in one of your logs as well.\n\nOn the feasibility checker, I think it already works like that. Or somewhat at leas. I was able to load a mission indoors (no position lock) and then go out and fly it. Maybe if you already have a lock it doesn't accept it then. Could you check these cases and open an issue for it? And describe how it should work.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-31T16:25:55Z",
          "body": "Full autonomous mission flown.\nLog: http://logs.uaventure.com/view/5e9jP3aSS7Y4UaUyfqaYR9\nVideo: https://drive.google.com/open?id=0B27AvDmVit4KRVlpYkFMNVpTLWM\n\nSaturation occurred at back transition, likely because the next waypoint commanded decent and the angle placed the vehicle sideways on fair wind. I don't know why the rotations before land occurred.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-01-31T19:37:02Z",
          "body": "I had a quick look through the changes, mostly looking at comments and trying to spot stupid mistakes (without success which is good :smile:)\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-01T07:52:35Z",
          "body": "@AndreasAntener Could you give this another pass? When is the next opportunity to test-fly the final state for you and / or @sanderux? If not today I would prefer to merge as-is to avoid branch drift.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-01T09:16:07Z",
          "body": "Wind conditions will make further testing hard for me this week. I have noticed several irregularities that i can reproduce in sitl. I will create mission files for this and share them with analysis and confirmation of such behavior in actual flight\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-01T10:50:55Z",
          "body": "@julianoes thanks!\n\n@LorenzMeier I cannot test today, but let me correct a few things, also pushing default VTOL acceptance radius to 3m here as it seems that's what hits people currently the most.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-01T19:13:43Z",
          "body": "@AndreasAntener \nWith reference to https://github.com/mavlink/qgroundcontrol/issues/3390 perhaps we could add the info log of the current waypoint as shown here: https://github.com/sanderux/Firmware/commit/c0f0d883eb9f20202708c9ba82ed90cdedcff1ee#diff-9b5a77642a641b107c8f8a966de34acdR821\n\nOr shall i put this in a separate PR after merging this to master? \n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-02T01:25:22Z",
          "body": "@AndreasAntener please review https://github.com/UAVenture/Firmware/pull/2\nthis implements a general failsafe for most corner cases i encountered.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-02T13:15:36Z",
          "body": "Corner case in which the plane continues flight forever.\n\nSITL waypoint file:\n[land-and-then-backtransition.txt](https://github.com/PX4/Firmware/files/113944/land-and-then-backtransition.txt)\n\nThe sequence of mission items may seem unlikely but i will try to motivate my concern.\nA user will experience that the transition command is executed at the start of the next waypoint (it might even seem as if it is executed before this point). The user could therefor attempt what might seem like a shortcut (set land and then transition) to have the plane land in VTOL.\n\nThe current result of this is a plane that continues forward on it's heading until it runs out of power or in to something. \n\nMy suggestion is to have the feasibility checker validate that there will always be a waypoint before a transition command.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-02T20:18:29Z",
          "body": "I'm just tracking down the yawing issues on takeoff/landing and @sanderux FW fly-away, should have an update soon.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-02T23:03:08Z",
          "body": "@sanderux didn't yet find the cause of your landing/transition issue. The fixed wing landing already kicks in there.\n\nFixed a bunch of yawing issues, should be good to merge after another flight test.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-03T06:27:24Z",
          "body": "@AndreasAntener I have created a new PR for the front transition timeout (https://github.com/UAVenture/Firmware/pull/3) where i have integrated your and @LorenzMeier 's comments. \n\nThe weather is very unstable but i will try to get some test flights done soon.\n\nAs soon as things have been tested and merged with master i will start work on mission failsafe (RTH) on failed transitions, improved mission navigation feedback and  i could have a look at MAV_CMD_NAV_VTOL_TAKEOFF / LAND support.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-03T09:07:13Z",
          "body": "I updated the task list for 2 more issues. test can be done by flying this mission in sitl: \n[mission south.txt](https://github.com/PX4/Firmware/files/115354/mission.south.txt)\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-03T17:47:27Z",
          "body": "I added the back transition fix. For corner cases regarding missions \"invalid\" missions we should open new issues.\n\n@sanderux could you give this another SITL test with valid missions?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-03T18:09:28Z",
          "body": "Tested. SITL normal mission looks great, no more unneeded yawing\n",
          "type": "issue_comment"
        },
        {
          "author": "CornerOfSkyline",
          "created_at": "2016-02-05T15:32:47Z",
          "body": "@AndreasAntener \n![2016-02-05 23 34 13](https://cloud.githubusercontent.com/assets/12220448/12850697/077b8ce0-cc61-11e5-96c8-dd385c39d2ea.png)\nI think we should make the velocity commander smooth. When the vtol translate back to the mc, the velocity can not decelerate smaller than the mc max velocity in the several translate back seconds, there will be a huge velocity commander to control the vtol in the mc mode. It cause a big pitch commander and the vtol respond the pitch commander , it looks danger when the vtol translate back.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-05T15:48:43Z",
          "body": "The question is what velocity you commanded - if you command position hold (pitch stick zero) and trigger the velocity you get what you ask for - deceleration with the maximum braking moment. I haven't seen so far anything in real flight or in videos that I would consider extreme.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-02-05T18:20:06Z",
          "body": "Two flights with the current state:\nhttp://logs.uaventure.com/view/VxcqqMHj6cNiuqXDjcA9C7\nhttp://logs.uaventure.com/view/GiVxcx93DbU3W5jFgXZ6Qc\n\nApart from the last bit they went great, there was a waypoint missing on the mission at the end, the climbing I cannot reproduce in SITL\n\n@CornerOfSkyline yes I see pitching as well. Maybe something changed on master, I have a feeling this was better a while back.\n",
          "type": "issue_comment"
        },
        {
          "author": "CornerOfSkyline",
          "created_at": "2016-02-06T02:14:12Z",
          "body": "@LorenzMeier  I test the VTOL auto mission in the gazebo_sitl , the whole fly is in mission mode. There is no manual control.\n\nHere is the log file.\n\nhttp://logs.uaventure.com/view/YNQ9bgD4XmUwt2srbo6whQ\n\n![2016-02-06 10 21 20](https://cloud.githubusercontent.com/assets/12220448/12864038/73d7e73a-ccbb-11e5-8b7e-8102c3d3933b.png)\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-02-06T09:37:24Z",
          "body": "@andreasantener does your last commit fully replace\nhttps://github.com/PX4/Firmware/pull/3660 ?\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "julianoes",
          "created_at": "2016-01-31T19:21:30Z",
          "body": "Please add a comment for why this condition is how it is. A reader has no clue what's going on here.\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-01-31T19:22:10Z",
          "body": "Also, this comment is out of sync because it seems it's not just about AUTO.\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-01T07:50:39Z",
          "body": "This is not a critical message.\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-01T07:50:57Z",
          "body": "This is not a critical message.\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes the sequencing and handling of 2-part VTOL mission items (takeoff, land, forward/back transitions) and fixes incorrect state transitions, yaw behavior and waypoint ordering that previously produced unintended flight behavior (e.g. wrong yawing, incorrect move/descend order, and a corner-case that could let the plane fly away). The discussion and tests show it addresses behavioral bugs rather than syntax/style issues, so this is a logic error fix.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 311,
        "deletions": 145,
        "changes": 456,
        "patch": "@@ -40,6 +40,7 @@\n  * @author Anton Babushkin <anton.babushkin@me.com>\n  * @author Ban Siesta <bansiesta@gmail.com>\n  * @author Simon Wilks <simon@uaventure.com>\n+ * @author Andreas Antener <andreas@uaventure.com>\n  */\n \n #include <sys/types.h>\n@@ -76,15 +77,14 @@ Mission::Mission(Navigator *navigator, const char *name) :\n \t_current_onboard_mission_index(-1),\n \t_current_offboard_mission_index(-1),\n \t_need_takeoff(true),\n-\t_takeoff(false),\n \t_mission_type(MISSION_TYPE_NONE),\n \t_inited(false),\n \t_home_inited(false),\n \t_missionFeasibilityChecker(),\n \t_min_current_sp_distance_xy(FLT_MAX),\n \t_mission_item_previous_alt(NAN),\n-  \t_on_arrival_yaw(NAN),\n-\t_distance_current_previous(0.0f)\n+\t_distance_current_previous(0.0f),\n+\t_work_item_type(WORK_ITEM_TYPE_DEFAULT)\n {\n \t/* load initial params */\n \tupdateParams();\n@@ -176,11 +176,11 @@ Mission::on_active()\n \t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n \t\t\tadvance_mission();\n \t\t\tset_mission_items();\n-\n \t\t}\n \n-\t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n+\t} else if (_mission_type != MISSION_TYPE_NONE && _param_altmode.get() == MISSION_ALTMODE_FOH) {\n \t\taltitude_sp_foh_update();\n+\n \t} else {\n \t\t/* if waypoint position reached allow loiter on the setpoint */\n \t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n@@ -285,24 +285,23 @@ Mission::update_offboard_mission()\n void\n Mission::advance_mission()\n {\n-\tif (_takeoff) {\n-\t\t_takeoff = false;\n-\t\t_takeoff_finished = true;\n+\t/* do not advance mission item if we're processing sub mission work items */\n+\tif (_work_item_type != WORK_ITEM_TYPE_DEFAULT) {\n+\t\treturn;\n+\t}\n \n-\t} else {\n-\t\tswitch (_mission_type) {\n-\t\tcase MISSION_TYPE_ONBOARD:\n-\t\t\t_current_onboard_mission_index++;\n-\t\t\tbreak;\n-\n-\t\tcase MISSION_TYPE_OFFBOARD:\n-\t\t\t_current_offboard_mission_index++;\n-\t\t\tbreak;\n-\n-\t\tcase MISSION_TYPE_NONE:\n-\t\tdefault:\n-\t\t\tbreak;\n-\t\t}\n+\tswitch (_mission_type) {\n+\tcase MISSION_TYPE_ONBOARD:\n+\t\t_current_onboard_mission_index++;\n+\t\tbreak;\n+\n+\tcase MISSION_TYPE_OFFBOARD:\n+\t\t_current_offboard_mission_index++;\n+\t\tbreak;\n+\n+\tcase MISSION_TYPE_NONE:\n+\tdefault:\n+\t\tbreak;\n \t}\n }\n \n@@ -327,19 +326,23 @@ Mission::set_mission_items()\n \n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t/* set previous position setpoint to current */\n-\tset_previous_pos_setpoint();\n+\t/* the home dist check provides user feedback, so we initialize it to this */\n+\tbool user_feedback_done = false;\n+\n+\t/* mission item that comes after current if available */\n+\tstruct mission_item_s mission_item_next_position;\n+\tbool has_next_position_item = false;\n+\n+\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \n-\t/* Copy previous mission item altitude (can be extended to a copy of the full mission item if needed) */\n-\tif (pos_sp_triplet->previous.valid) {\n+\t/* copy information about the previous mission item */\n+\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n+\t\t/* Copy previous mission item altitude */\n \t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n \t}\n \n-\t/* the home dist check provides user feedback, so we initialize it to this */\n-\tbool user_feedback_done = false;\n-\n \t/* try setting onboard mission item */\n-\tif (_param_onboard_enabled.get() && read_mission_item(true, true, &_mission_item)) {\n+\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n@@ -348,7 +351,7 @@ Mission::set_mission_items()\n \t\t_mission_type = MISSION_TYPE_ONBOARD;\n \n \t/* try setting offboard mission item */\n-\t} else if (read_mission_item(false, true, &_mission_item)) {\n+\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n \t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n@@ -404,82 +407,152 @@ Mission::set_mission_items()\n \t\treturn;\n \t}\n \n-\tif (pos_sp_triplet->current.valid) {\n-\t\t_on_arrival_yaw = _mission_item.yaw;\n-\t}\n+\t/*********************************** handle mission item *********************************************/\n \n-\t/* do takeoff on first waypoint for rotary wing vehicles */\n-\tif (_navigator->get_vstatus()->is_rotary_wing) {\n-\t\t/* force takeoff if landed (additional protection) */\n-\t\tif (!_takeoff && _navigator->get_vstatus()->condition_landed) {\n-\t\t\t_need_takeoff = true;\n+\t/* handle position mission items */\n+\tif (item_contains_position(&_mission_item)) {\n+\n+\t\t/* we have a new position item so set previous position setpoint to current */\n+\t\tset_previous_pos_setpoint();\n+\n+\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n+\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n+\n+\t\t\t/* use current mission item as next position item */\n+\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n+\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\thas_next_position_item = true;\n+\n+\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n+\n+\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n+\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n+\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n+\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n+\t\t\t/* ignore yaw for takeoff items */\n+\t\t\t_mission_item.yaw = NAN;\n+\t\t\t_mission_item.altitude = takeoff_alt;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n \t\t}\n \n-\t\t/* new current mission item set, check if we need takeoff */\n-\t\tif (_need_takeoff && (\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n-\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n-\t\t\t_takeoff = true;\n-\t\t\t_need_takeoff = false;\n+\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t}\n-\t}\n \n-\tif (_takeoff) {\n-\t\t/* do takeoff before going to setpoint */\n-\t\t/* set mission item as next position setpoint */\n-\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n-\t\t/* next SP is not takeoff anymore */\n-\t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t\t/* move to landing waypoint before descent if necessary */\n+\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n \n-\t\t/* calculate takeoff altitude */\n-\t\tfloat takeoff_alt = get_absolute_altitude_for_item(_mission_item);\n+\t\t\t/* use current mission item as next position item */\n+\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n+\t\t\thas_next_position_item = true;\n \n-\t\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n-\t\tif (_navigator->get_vstatus()->condition_landed) {\n-\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n+\t\t\t/*\n+\t\t\t * Ignoring waypoint altitude:\n+\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n+\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n+\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n+\t\t\t * what the altitude means on this waypoint type.\n+\t\t\t */\n+\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n+\t\t\tif (pos_sp_triplet->current.valid) {\n+\t\t\t\taltitude = pos_sp_triplet->current.alt;\n+\t\t\t}\n \n-\t\t} else {\n-\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n+\t\t\t_mission_item.altitude = altitude;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n+\t\t}\n+\n+\t\t/* we just moved to the landing waypoint, now descend */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \t\t}\n \n-\t\t/* check if we already above takeoff altitude */\n-\t\tif (_navigator->get_global_position()->alt < takeoff_alt) {\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n+\t\t/* ignore yaw for landing items */\n+\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n+\t\t * that aligns the vehicle first */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n+\t\t\t_mission_item.yaw = NAN;\n+\t\t}\n \n-\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n+\t/* handle non-position mission items such as commands */\n+\t} else {\n+\n+\t\t/* turn towards next waypoint before MC to FW transition */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n+\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n+\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t&& has_next_position_item) {\n+\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n+\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n \t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n-\t\t\t_mission_item.yaw = NAN;\n-\t\t\t_mission_item.altitude = takeoff_alt;\n+\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.time_inside = 0;\n+\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n+\t\t\t\t_navigator->get_global_position()->lat,\n+\t\t\t\t_navigator->get_global_position()->lon,\n+\t\t\t\tmission_item_next_position.lat,\n+\t\t\t\tmission_item_next_position.lon);\n+\t\t}\n \n-\t\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\t/* yaw is aligned now */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t}\n \n-\t\t\t_navigator->set_position_setpoint_triplet_updated();\n-\t\t\treturn;\n+\t\t/* don't advance mission after FW to MC command */\n+\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n+\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n+\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n+\t\t\t\t&& pos_sp_triplet->current.valid) {\n \n-\t\t} else {\n-\t\t\t/* skip takeoff */\n-\t\t\t_takeoff = false;\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n+\t\t}\n+\n+\t\t/* after FW to MC transition finish moving to the waypoint */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n+\t\t\t\t&& pos_sp_triplet->current.valid) {\n+\n+\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n+\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n+\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.time_inside = 0;\n \t\t}\n-\t}\n \n-\tif (_takeoff_finished) {\n-\t\t/* we just finished takeoff */\n-\t\t/* in case we still have to move to the takeoff waypoint we need a waypoint mission item */\n-\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t_takeoff_finished = false;\n \t}\n \n-\t/* set current position setpoint from mission item */\n+\t/*********************************** set setpoints and check next *********************************************/\n+\n+\t/* set current position setpoint from mission item (is protected agains non-position items) */\n \tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \n+\t/* issue command if ready (will do nothing for position mission items) */\n+\tissue_command(&_mission_item);\n+\n+\t/* set current work item type */\n+\t_work_item_type = new_work_item_type;\n+\n \t/* require takeoff after landing or idle */\n \tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n \t\t_need_takeoff = true;\n@@ -494,12 +567,11 @@ Mission::set_mission_items()\n \t// TODO: report onboard mission item somehow\n \n \tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n-\t\t/* try to read next mission item */\n-\t\tstruct mission_item_s mission_item_next;\n+\t\t/* try to process next mission item */\n \n-\t\tif (read_mission_item(_mission_type == MISSION_TYPE_ONBOARD, false, &mission_item_next)) {\n+\t\tif (has_next_position_item) {\n \t\t\t/* got next mission item, update setpoint triplet */\n-\t\t\tmission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n+\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n \t\t} else {\n \t\t\t/* next mission item is not available */\n \t\t\tpos_sp_triplet->next.valid = false;\n@@ -512,7 +584,8 @@ Mission::set_mission_items()\n \n \t/* Save the distance between the current sp and the previous one */\n \tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n-\t\t_distance_current_previous = get_distance_to_next_waypoint(pos_sp_triplet->current.lat,\n+\t\t_distance_current_previous = get_distance_to_next_waypoint(\n+\t\t\t\tpos_sp_triplet->current.lat,\n \t\t\t\tpos_sp_triplet->current.lon,\n \t\t\t\tpos_sp_triplet->previous.lat,\n \t\t\t\tpos_sp_triplet->previous.lon);\n@@ -521,72 +594,143 @@ Mission::set_mission_items()\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n+bool\n+Mission::do_need_takeoff()\n+{\n+\tif (_navigator->get_vstatus()->is_rotary_wing) {\n+\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n+\n+\t\t/* force takeoff if landed (additional protection) */\n+\t\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\t\t_need_takeoff = true;\n+\n+\t\t/* if in-air and already above takeoff height, don't do takeoff */\n+\t\t} else if (_navigator->get_global_position()->alt > takeoff_alt) {\n+\t\t\t_need_takeoff = false;\n+\t\t}\n+\n+\t\t/* check if current mission item is one that requires takeoff before */\n+\t\tif (_need_takeoff && (\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n+\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n+\n+\t\t\t_need_takeoff = false;\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool\n+Mission::do_need_move_to_land()\n+{\n+\tif (_navigator->get_vstatus()->is_rotary_wing && _mission_item.nav_cmd == NAV_CMD_LAND) {\n+\n+\t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\n+\t\treturn d_current > _navigator->get_acceptance_radius();\n+\t}\n+\n+\treturn false;\n+}\n+\n+float\n+Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n+{\n+\t/* calculate takeoff altitude */\n+\tfloat takeoff_alt = get_absolute_altitude_for_item(*mission_item);\n+\n+\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n+\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n+\n+\t} else {\n+\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n+\t}\n+\n+\treturn takeoff_alt;\n+}\n+\n void\n Mission::heading_sp_update()\n {\n-\tif (_takeoff) {\n-\t\t/* we don't want to be yawing during takeoff */\n+\t/* we don't want to be yawing during takeoff, landing or aligning for a transition */\n+\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_LAND\n+\t\t\t|| _work_item_type == WORK_ITEM_TYPE_ALIGN) {\n \t\treturn;\n \t}\n \n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t/* Don't change setpoint if last and current waypoint are not valid */\n-\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n-\t\t\t!PX4_ISFINITE(_on_arrival_yaw)) {\n-\t\treturn;\n-\t}\n-\n-\t/* Don't change heading for takeoff waypoints, the ground may be near */\n-\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n+\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid) {\n \t\treturn;\n \t}\n \n-\t/* set yaw angle for the waypoint iff a loiter time has been specified */\n+\t/* set yaw angle for the waypoint if a loiter time has been specified */\n \tif (_waypoint_position_reached && _mission_item.time_inside > 0.0f) {\n-\t\t_mission_item.yaw = _on_arrival_yaw;\n-\t} else {\n+\t\t// XXX: should actually be param4 from mission item\n+\t\t// at the moment it will just keep the heading it has\n+\t\t//_mission_item.yaw = _on_arrival_yaw;\n+\t\t//pos_sp_triplet->current.yaw = _mission_item.yaw;\n \n-\t\t/* calculate direction the vehicle should point to:\n-\t\t * normal waypoint: current position to {waypoint or home or home + 180deg}\n-\t\t * landing waypoint: last waypoint to {waypoint or home or home + 180deg}\n-\t\t * For landing the last waypoint (= constant) is used to avoid excessive yawing near the ground\n-\t\t */\n+\t} else {\n+\t\t/* Calculate direction the vehicle should point to. */\n \t\tdouble point_from_latlon[2];\n-\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n-\t\t\tpoint_from_latlon[0] = pos_sp_triplet->previous.lat;\n-\t\t\tpoint_from_latlon[1] = pos_sp_triplet->previous.lon;\n+\t\tdouble point_to_latlon[2];\n+\n+\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n+\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n+\n+\t\t/* target location is home */\n+\t\tif ((_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME\n+\t\t\t\t|| _param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME)\n+\t\t\t\t// need to be rotary wing for this but not in a transition\n+\t\t\t\t// in VTOL mode this will prevent updating yaw during FW flight\n+\t\t\t\t// (which would result in a wrong yaw setpoint spike during back transition)\n+\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n+\t\t\t\t&& !(_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION || _navigator->get_vstatus()->in_transition_mode)) {\n+\t\t\tpoint_to_latlon[0] = _navigator->get_home_position()->lat;\n+\t\t\tpoint_to_latlon[1] = _navigator->get_home_position()->lon;\n+\n+\t\t/* target location is next (current) waypoint */\n \t\t} else {\n-\t\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n-\t\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n+\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n+\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n \t\t}\n \n-\t\t/* always keep the front of the rotary wing pointing to the next waypoint */\n-\t\tif (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT\n-\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n-\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\tpoint_from_latlon[0],\n-\t\t\t\tpoint_from_latlon[1],\n-\t\t\t\t_mission_item.lat,\n-\t\t\t\t_mission_item.lon);\n-\t\t/* always keep the back of the rotary wing pointing towards home */\n-\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME) {\n-\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\tpoint_from_latlon[0],\n-\t\t\t\tpoint_from_latlon[1],\n-\t\t\t\t_navigator->get_home_position()->lat,\n-\t\t\t\t_navigator->get_home_position()->lon);\n-\t\t/* always keep the back of the rotary wing pointing towards home */\n-\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n-\t\t\t_mission_item.yaw = _wrap_pi(get_bearing_to_next_waypoint(\n+\t\tfloat d_current = get_distance_to_next_waypoint(\n+\t\t\tpoint_from_latlon[0], point_from_latlon[1],\n+\t\t\tpoint_to_latlon[0], point_to_latlon[1]);\n+\n+\t\t/* stop if positions are close together to prevent excessive yawing */\n+\t\tif (d_current > _navigator->get_acceptance_radius()) {\n+\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n \t\t\t\tpoint_from_latlon[0],\n \t\t\t\tpoint_from_latlon[1],\n-\t\t\t\t_navigator->get_home_position()->lat,\n-\t\t\t\t_navigator->get_home_position()->lon) + M_PI_F);\n+\t\t\t\tpoint_to_latlon[0],\n+\t\t\t\tpoint_to_latlon[1]);\n+\n+\t\t\t/* always keep the back of the rotary wing pointing towards home */\n+\t\t\tif (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n+\t\t\t\t_mission_item.yaw = _wrap_pi(yaw + M_PI_F);\n+\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n+\n+\t\t\t} else {\n+\t\t\t\t_mission_item.yaw = yaw;\n+\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n+\t\t\t}\n \t\t}\n \t}\n \n-\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t// we set yaw directly so we can run this in parallel to the FOH update\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n@@ -613,7 +757,6 @@ Mission::altitude_sp_foh_update()\n \t\treturn;\n \t}\n \n-\n \t/* Calculate distance to current waypoint */\n \tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n \t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n@@ -627,6 +770,7 @@ Mission::altitude_sp_foh_update()\n \t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n \tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n \t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n+\n \t} else {\n \t\t/* update the altitude sp of the 'current' item in the sp triplet, but do not update the altitude sp\n \t\t* of the mission item as it is used to check if the mission item is reached\n@@ -637,9 +781,9 @@ Mission::altitude_sp_foh_update()\n \t\tfloat grad = -delta_alt/(_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius));\n \t\tfloat a = _mission_item_previous_alt - grad * _distance_current_previous;\n \t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n-\n \t}\n \n+\t// we set altitude directly so we can run this in parallel to the heading update\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n@@ -650,33 +794,55 @@ Mission::altitude_sp_foh_reset()\n }\n \n bool\n-Mission::read_mission_item(bool onboard, bool is_current, struct mission_item_s *mission_item)\n+Mission::prepare_mission_items(bool onboard, struct mission_item_s *mission_item,\n+\tstruct mission_item_s *next_position_mission_item, bool *has_next_position_item)\n+{\n+\tbool first_res = false;\n+\tint offset = 1;\n+\n+\tif (read_mission_item(onboard, 0, mission_item)) {\n+\t\t\n+\t\tfirst_res = true;\n+\n+\t\t/* trying to find next position mission item */\n+\t\twhile(read_mission_item(onboard, offset, next_position_mission_item)) {\n+\n+\t\t\tif (item_contains_position(next_position_mission_item)) {\n+\t\t\t\t*has_next_position_item = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\toffset++;\n+\t\t}\n+\t}\n+\n+\treturn first_res;\n+}\n+\n+bool\n+Mission::read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item)\n {\n \t/* select onboard/offboard mission */\n \tint *mission_index_ptr;\n \tdm_item_t dm_item;\n \n \tstruct mission_s *mission = (onboard) ? &_onboard_mission : &_offboard_mission;\n-\tint mission_index_next = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n+\tint current_index = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n+\tint index_to_read = current_index + offset;\n \n \t/* do not work on empty missions */\n \tif (mission->count == 0) {\n \t\treturn false;\n \t}\n \n-\t/* move to next item if there is one */\n-\tif (mission_index_next < ((int)mission->count - 1)) {\n-\t\tmission_index_next++;\n-\t}\n-\n \tif (onboard) {\n \t\t/* onboard mission */\n-\t\tmission_index_ptr = is_current ? &_current_onboard_mission_index : &mission_index_next;\n+\t\tmission_index_ptr = (offset == 0) ? &_current_onboard_mission_index : &index_to_read;\n \t\tdm_item = DM_KEY_WAYPOINTS_ONBOARD;\n \n \t} else {\n \t\t/* offboard mission */\n-\t\tmission_index_ptr = is_current ? &_current_offboard_mission_index : &mission_index_next;\n+\t\tmission_index_ptr = (offset == 0) ? &_current_offboard_mission_index : &index_to_read;\n \t\tdm_item = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n \t}\n \n@@ -712,8 +878,8 @@ Mission::read_mission_item(bool onboard, bool is_current, struct mission_item_s\n \t\t\tif (mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) {\n \n \t\t\t\t/* only raise the repeat count if this is for the current mission item\n-\t\t\t\t* but not for the next mission item */\n-\t\t\t\tif (is_current) {\n+\t\t\t\t* but not for the read ahead mission item */\n+\t\t\t\tif (offset == 0) {\n \t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n \t\t\t\t\t/* save repeat count */\n \t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, DM_PERSIST_POWER_ON_RESET,\n@@ -732,8 +898,8 @@ Mission::read_mission_item(bool onboard, bool is_current, struct mission_item_s\n \t\t\t\t*mission_index_ptr = mission_item_tmp.do_jump_mission_index;\n \n \t\t\t} else {\n-\t\t\t\tif (is_current) {\n-\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(),\n+\t\t\t\tif (offset == 0) {\n+\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(),\n \t\t\t\t\t\t\t     \"DO JUMP repetitions completed\");\n \t\t\t\t}\n \t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb8b98101505f525979329b82eede536b0a80a7f/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 37,
        "deletions": 4,
        "changes": 41,
        "patch": "@@ -119,6 +119,21 @@ class Mission : public MissionBlock\n \t */\n \tvoid set_mission_items();\n \n+\t/**\n+\t * Returns true if we need to do a takeoff at the current state\n+\t */\n+\tbool do_need_takeoff();\n+\n+\t/**\n+\t * Returns true if we need to move to waypoint location before starting descent\n+\t */\n+\tbool do_need_move_to_land();\n+\n+\t/**\n+\t * Calculate takeoff height for mission item considering ground clearance\n+\t */\n+\tfloat calculate_takeoff_altitude(struct mission_item_s *mission_item);\n+\n \t/**\n \t * Updates the heading of the vehicle. Rotary wings only.\n \t */\n@@ -137,10 +152,21 @@ class Mission : public MissionBlock\n \tfloat get_absolute_altitude_for_item(struct mission_item_s &mission_item);\n \n \t/**\n-\t * Read current or next mission item from the dataman and watch out for DO_JUMPS\n+\t * Read the current and the next mission item. The next mission item read is the\n+\t * next mission item that contains a position.\n+\t *\n+\t * @return true if current mission item available\n+\t */\n+\tbool prepare_mission_items(bool onboard, struct mission_item_s *mission_item,\n+\t\tstruct mission_item_s *next_position_mission_item, bool *has_next_position_item);\n+\n+\t/**\n+\t * Read current (offset == 0) or a specific (offset > 0) mission item\n+\t * from the dataman and watch out for DO_JUMPS\n+\t *\n \t * @return true if successful\n \t */\n-\tbool read_mission_item(bool onboard, bool is_current, struct mission_item_s *mission_item);\n+\tbool read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item);\n \n \t/**\n \t * Save current offboard mission state to dataman\n@@ -184,8 +210,6 @@ class Mission : public MissionBlock\n \tint _current_onboard_mission_index;\n \tint _current_offboard_mission_index;\n \tbool _need_takeoff;\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n-\tbool _takeoff;\t\t\t\t\t\t/**< takeoff state flag */\n-\tbool _takeoff_finished;\t\t\t\t\t/**< set if takeoff was requested before and is now done */\n \n \tenum {\n \t\tMISSION_TYPE_NONE,\n@@ -204,6 +228,15 @@ class Mission : public MissionBlock\n \tfloat _on_arrival_yaw; /**< holds the yaw value that should be applied when the current waypoint is reached */\n \tfloat _distance_current_previous; /**< distance from previous to current sp in pos_sp_triplet,\n \t\t\t\t\t    only use if current and previous are valid */\n+\n+\tenum work_item_type {\n+\t\tWORK_ITEM_TYPE_DEFAULT,\t\t/**< default mission item */\n+\t\tWORK_ITEM_TYPE_TAKEOFF,\t\t/**< takeoff before moving to waypoint */\n+\t\tWORK_ITEM_TYPE_MOVE_TO_LAND,\t/**< move to land waypoint before descent */\n+\t\tWORK_ITEM_TYPE_ALIGN,\t\t/**< align for next waypoint */\n+\t\tWORK_ITEM_TYPE_CMD_BEFORE_MOVE\t/**<  */\n+\t} _work_item_type;\t/**< current type of work to do (sub mission item) */\n+\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb8b98101505f525979329b82eede536b0a80a7f/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 30,
        "changes": 104,
        "patch": "@@ -67,6 +67,7 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_waypoint_position_reached(false),\n \t_waypoint_yaw_reached(false),\n \t_time_first_inside_orbit(0),\n+\t_action_start(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n \t_cmd_pub(nullptr)\n@@ -82,17 +83,8 @@ MissionBlock::is_mission_item_reached()\n {\n \t/* handle non-navigation or indefinite waypoints */\n \tswitch (_mission_item.nav_cmd) {\n-\t\tcase NAV_CMD_DO_SET_SERVO: {\n-\t\t\tmemset(&actuators, 0, sizeof(actuators));\n-\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n-\t\t\tactuators.timestamp = hrt_absolute_time();\n-\t\t\tif (_actuator_pub != nullptr) {\n-\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n-\t\t\t} else {\n-\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n-\t\t\t}\n+\t\tcase NAV_CMD_DO_SET_SERVO:\n \t\t\treturn true;\n-\t\t\t}\n \n \t\tcase NAV_CMD_LAND:\n \t\t\treturn _navigator->get_vstatus()->condition_landed;\n@@ -103,20 +95,22 @@ MissionBlock::is_mission_item_reached()\n \t\tcase NAV_CMD_LOITER_UNLIMITED:\n \t\t\treturn false;\n \n-\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n-\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n-\t\t\t{\n-\t\t\t/* forward the command to other processes */\n-\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n-\t\t\tstruct vehicle_command_s cmd = {};\n-\t\t\tcmd.command = _mission_item.nav_cmd;\n-\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n-\t\t\tif (_cmd_pub != nullptr) {\n-\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n-\t\t\t} else {\n-\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n-\t\t\t}\n+\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n \t\t\treturn true;\n+\n+\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n+\t\t\t/*\n+\t\t\t * We wait half a second to give the transition command time to propagate.\n+\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n+\t\t\t */\n+\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n+\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n+\t\t\t\t_action_start = 0;\n+\n+\t\t\t\treturn true;\n+\n+\t\t\t} else {\n+\t\t\t\treturn false;\n \t\t\t}\n \n \t\tdefault:\n@@ -238,6 +232,7 @@ MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item,\n \tcmd->param5 = item->params[4];\n \tcmd->param6 = item->params[5];\n \tcmd->param7 = item->params[6];\n+\tcmd->command = item->nav_cmd;\n \n \tcmd->target_system = _navigator->get_vstatus()->system_id;\n \tcmd->target_component = _navigator->get_vstatus()->component_id;\n@@ -246,9 +241,65 @@ MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item,\n \tcmd->confirmation = false;\n }\n \n+void\n+MissionBlock::issue_command(const struct mission_item_s *item)\n+{\n+\tif (item_contains_position(item)) {\n+\t\treturn;\n+\t}\n+\n+\tif (item->nav_cmd == NAV_CMD_DO_SET_SERVO) {\n+\t\tPX4_WARN(\"do_set_servo command\");\n+\t\t// XXX: we should issue a vehicle command and handle this somewhere else\n+\t\tmemset(&actuators, 0, sizeof(actuators));\n+\t\t// params[0] actuator number to be set 0..5 ( corresponds to AUX outputs 1..6\n+\t\t// params[1] new value for selected actuator in ms 900...2000\n+\t\tactuators.control[(int)item->params[0]] = 1.0f / 2000 * -item->params[1];\n+\t\tactuators.timestamp = hrt_absolute_time();\n+\n+\t\tif (_actuator_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n+\n+\t\t} else {\n+\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n+\t\t}\n+\n+\t} else {\n+\t\tPX4_WARN(\"forwarding command %d\\n\", item->nav_cmd);\n+\t\tstruct vehicle_command_s cmd = {};\n+\t\tmission_item_to_vehicle_command(item, &cmd);\n+\t\t_action_start = hrt_absolute_time();\n+\n+\t\tif (_cmd_pub != nullptr) {\n+\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\n+\t\t} else {\n+\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t}\n+\t}\n+}\n+\n+bool\n+MissionBlock::item_contains_position(const struct mission_item_s *item)\n+{\n+\t// XXX: maybe extend that check onto item properties\n+\tif (item->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n+\t\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION ||\n+\t\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO) {\n+\t\treturn false;\n+\t}\n+\n+\treturn true;\n+}\n+\n void\n MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n {\n+\t/* don't change the setpoint for non-position items */\n+\tif (!item_contains_position(item)) {\n+\t\treturn;\n+\t}\n+\n \tsp->valid = true;\n \tsp->lat = item->lat;\n \tsp->lon = item->lon;\n@@ -261,13 +312,6 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->acceptance_radius = item->acceptance_radius;\n \n \tswitch (item->nav_cmd) {\n-\tcase NAV_CMD_DO_SET_SERVO:\n-\t\t\t/* Set current position for loitering set point*/\n-\t\t\tsp->lat = _navigator->get_global_position()->lat;\n-\t\t\tsp->lon = _navigator->get_global_position()->lon;\n-\t\t\tsp->alt = _navigator->get_global_position()->alt;\n-\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\tbreak;\n \tcase NAV_CMD_IDLE:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n \t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb8b98101505f525979329b82eede536b0a80a7f/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -78,6 +78,8 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid reset_mission_item_reached();\n \n+\tbool item_contains_position(const struct mission_item_s *item);\n+\n \t/**\n \t * Convert a mission item to a position setpoint\n \t *\n@@ -116,10 +118,13 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n \n+\tvoid issue_command(const struct mission_item_s *item);\n+\n \tmission_item_s _mission_item;\n \tbool _waypoint_position_reached;\n \tbool _waypoint_yaw_reached;\n \thrt_abstime _time_first_inside_orbit;\n+\thrt_abstime _action_start;\n \n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb8b98101505f525979329b82eede536b0a80a7f/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "patch": "@@ -51,7 +51,6 @@\n #include <fcntl.h>\n #include <errno.h>\n #include <uORB/topics/fence.h>\n-#include <uORB/topics/vehicle_command.h>\n \n MissionFeasibilityChecker::MissionFeasibilityChecker() :\n \t_mavlink_fd(-1),\n@@ -348,14 +347,14 @@ MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionI\n \t\t\t\tif (mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO){\n \n \t\t\t\t\t/* check actuator number */\n-\t\t\t\t\tif (mission_item.actuator_num < 0 || mission_item.actuator_num > 5) {\n-\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.actuator_num);\n+\t\t\t\t\tif (mission_item.params[0] < 0 || mission_item.params[0] > 5) {\n+\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.params[0]);\n \t\t\t\t\t\twarning_issued = true;\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t\t/* check actuator value */\n-\t\t\t\t\tif (mission_item.actuator_value < -2000 || mission_item.actuator_value > 2000) {\n-\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.actuator_value);\n+\t\t\t\t\tif (mission_item.params[1] < -2000 || mission_item.params[1] > 2000) {\n+\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.params[1]);\n \t\t\t\t\t\twarning_issued = true;\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb8b98101505f525979329b82eede536b0a80a7f/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -103,9 +103,8 @@ struct mission_item_s {\n \tint do_jump_mission_index;\t/**< index where the do jump will go to                 */\n \tunsigned do_jump_repeat_count;\t/**< how many times do jump needs to be done            */\n \tunsigned do_jump_current_count;\t/**< count how many times the jump has been done\t*/\n-\tint actuator_num;               /**< actuator number to be set 0..5 ( corresponds to AUX outputs 1..6    */\n-\tint actuator_value;             /**< new value for selected actuator in ms 900...2000         */\n \tfloat params[7];\t\t/**< array to store mission command values for MAV_FRAME_MISSION ***/\n+\tint8_t frame;\t\t\t/**< mission frame ***/\n };\n #pragma pack(pop)\n #include <uORB/topics/mission.h>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fb8b98101505f525979329b82eede536b0a80a7f/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::altitude_sp_foh_reset",
        "Mission::altitude_sp_foh_update",
        "read_mission_item",
        "Mission::on_active",
        "Mission::read_mission_item",
        "waypoint",
        "MissionBlock::is_mission_item_reached",
        "Mission::update_offboard_mission",
        "MissionBlock::mission_item_to_vehicle_command",
        "MissionFeasibilityChecker::check_dist_1wp",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::MissionBlock",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::altitude_sp_foh_reset",
          "Mission::altitude_sp_foh_update",
          "Mission::on_active",
          "Mission::read_mission_item",
          "waypoint",
          "Mission::update_offboard_mission",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission.h": [
          "read_mission_item"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::MissionBlock",
          "MissionBlock::mission_item_to_vehicle_command"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::check_dist_1wp"
        ]
      }
    }
  },
  {
    "title": "Navigator: Do not update a position setpoint for mission items not enâ€¦",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3582",
    "number": 3582,
    "created_at": "2016-01-24T16:03:27Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "â€¦coding positions. Fix for #3581 - or at least a step towards it.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-24T16:04:11Z",
          "body": "@AndreasAntener @tumbili I think you need to do this or more to fix the zero altitude you got. It should at least point you into the right direction.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-24T16:27:43Z",
          "body": "@julianoes Please don't comment on commits, but on the diff here. Its non-consumable. This patch set is not complete. Its just a first step.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-24T16:28:28Z",
          "body": "What I fixed is the lower-level routine not having any boundary checks. The _real_ fix is to ensure it never gets called on a non-position setpoint!\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-24T16:33:25Z",
          "body": "@tumbili @AndreasAntener @julianoes The real fix needs to be applied here: Instead of returning a mission item, this routine needs to return the next action and the next 3D position:\nhttps://github.com/PX4/Firmware/blob/6eac78d67529e20c3170092fd271c11c57c70f2f/src/modules/navigator/mission.cpp#L658-L759\n\nThen the action needs to be handled and the next 3D position is fed into the right mission logic. With that change we always have a next 3D position, no changes to the main waypoint code are required and we just need to slightly change the way commands are published.\n\nThe two PRs I submitted could potentially be left out as well. Please make sure you understand the implications before you continue on this.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-31T14:06:08Z",
          "body": "replaced by #3598\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect behavior where the navigator was updating position setpoints for mission items that do not encode 3D positions, causing wrong outputs (e.g. zero altitude). The change adds boundary checks and prevents inappropriate updates to the position setpoint, which is a logic/state-handling bug rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "patch": "@@ -379,7 +379,7 @@ Mission::set_mission_items()\n \n \t\t/* update position setpoint triplet  */\n \t\tpos_sp_triplet->previous.valid = false;\n-\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\t(void)mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \t\tpos_sp_triplet->next.valid = false;\n \n \t\t/* reuse setpoint for LOITER only if it's not IDLE */\n@@ -436,7 +436,7 @@ Mission::set_mission_items()\n \tif (_takeoff) {\n \t\t/* do takeoff before going to setpoint */\n \t\t/* set mission item as next position setpoint */\n-\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n+\t\t(void)mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n \t\t/* next SP is not takeoff anymore */\n \t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n \n@@ -464,7 +464,7 @@ Mission::set_mission_items()\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.time_inside = 0;\n \n-\t\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\t\t(void)mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \n \t\t\t_navigator->set_position_setpoint_triplet_updated();\n \t\t\treturn;\n@@ -483,7 +483,7 @@ Mission::set_mission_items()\n \t}\n \n \t/* set current position setpoint from mission item */\n-\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t(void)mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n \n \t/* require takeoff after landing or idle */\n \tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n@@ -504,7 +504,8 @@ Mission::set_mission_items()\n \n \t\tif (read_mission_item(_mission_type == MISSION_TYPE_ONBOARD, false, &mission_item_next)) {\n \t\t\t/* got next mission item, update setpoint triplet */\n-\t\t\tmission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n+\t\t\t// XXX the updated call below might need to check against the rvalue of this\n+\t\t\t(void)mission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n \t\t} else {\n \t\t\t/* next mission item is not available */\n \t\t\tpos_sp_triplet->next.valid = false;\n@@ -591,8 +592,10 @@ Mission::heading_sp_update()\n \t\t}\n \t}\n \n-\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n-\t_navigator->set_position_setpoint_triplet_updated();\n+\tbool updated = mission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\tif (updated) {\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t}\n }\n \n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0a72db3cfa622d5c1635380f474fbffa32d3362a/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 18,
        "changes": 53,
        "patch": "@@ -268,28 +268,19 @@ MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item,\n \tcmd->confirmation = false;\n }\n \n-void\n+bool\n MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n {\n-\tsp->valid = true;\n-\tsp->lat = item->lat;\n-\tsp->lon = item->lon;\n-\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n-\tsp->yaw = item->yaw;\n-\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n-\t\t\t\t_navigator->get_loiter_radius();\n-\tsp->loiter_direction = item->loiter_direction;\n-\tsp->pitch_min = item->pitch_min;\n-\tsp->acceptance_radius = item->acceptance_radius;\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_DO_SET_SERVO:\n-\t\t\t/* Set current position for loitering set point*/\n-\t\t\tsp->lat = _navigator->get_global_position()->lat;\n-\t\t\tsp->lon = _navigator->get_global_position()->lon;\n-\t\t\tsp->alt = _navigator->get_global_position()->alt;\n-\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\tbreak;\n+\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t/* Set current position for loitering set point*/\n+\t\tsp->lat = _navigator->get_global_position()->lat;\n+\t\tsp->lon = _navigator->get_global_position()->lon;\n+\t\tsp->alt = _navigator->get_global_position()->alt;\n+\t\tbreak;\n+\n \tcase NAV_CMD_IDLE:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n \t\tbreak;\n@@ -318,10 +309,36 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\tbreak;\n \n-\tdefault:\n+\tcase NAV_CMD_WAYPOINT:\n+\tcase NAV_CMD_PATHPLANNING:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n \t\tbreak;\n+\n+\tdefault:\n+\t\t/* we do not know this setpoint type, we need to abort */\n+\t\treturn false;\n \t}\n+\n+\t/* if we get here this is a valid position setpoint, set the remaining fields */\n+\tsp->valid = true;\n+\n+\tif (item->nav_cmd != NAV_CMD_DO_SET_SERVO) {\n+\t\tsp->lat = item->lat;\n+\t\tsp->lon = item->lon;\n+\n+\t\tif (item->nav_cmd != NAV_CMD_LAND) {\n+\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n+\t\t}\n+\t}\n+\n+\tsp->yaw = item->yaw;\n+\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n+\t\t\t\t_navigator->get_loiter_radius();\n+\tsp->loiter_direction = item->loiter_direction;\n+\tsp->pitch_min = item->pitch_min;\n+\tsp->acceptance_radius = item->acceptance_radius;\n+\n+\treturn true;\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0a72db3cfa622d5c1635380f474fbffa32d3362a/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -83,8 +83,10 @@ class MissionBlock : public NavigatorMode\n \t *\n \t * @param the mission item to convert\n \t * @param the position setpoint that needs to be set\n+\t *\n+\t * @return true on success, false on failure\n \t */\n-\tvoid mission_item_to_position_setpoint(const mission_item_s *item, position_setpoint_s *sp);\n+\tbool mission_item_to_position_setpoint(const mission_item_s *item, position_setpoint_s *sp);\n \n \t/**\n \t * Set previous position setpoint to current setpoint",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0a72db3cfa622d5c1635380f474fbffa32d3362a/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_vehicle_command",
        "mission_item_to_position_setpoint",
        "Mission::heading_sp_update",
        "MissionBlock::mission_item_to_position_setpoint",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::heading_sp_update",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::mission_item_to_vehicle_command"
        ],
        "src/modules/navigator/mission_block.h": [
          "mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "VTOL transition command: Wait for transition to complete before switcâ€¦",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3579",
    "number": 3579,
    "created_at": "2016-01-24T13:43:12Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "â€¦hing state. This ensures there cannot be a race condition with acceptance radius handling.\n\n@AndreasAntener This is the last needed bit to secure the acceptance radius handling.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-24T16:34:54Z",
          "body": "I think we should rather fix it here:\nhttps://github.com/PX4/Firmware/pull/3582#issuecomment-174314142\n\nAnd remove all command handling from inline mission code.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-31T14:05:54Z",
          "body": "replaced by #3598\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the VTOL transition handling to wait for the transition to complete before switching state, which addresses a race condition/timing issue with acceptance-radius handling. This is an improper state transition/synchronization bug (logic error) rather than a syntax or style fix.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 3,
        "changes": 32,
        "patch": "@@ -66,6 +66,7 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_waypoint_position_reached(false),\n \t_waypoint_yaw_reached(false),\n \t_time_first_inside_orbit(0),\n+\t_action_start(0),\n \t_actuators{},\n \t_actuator_pub(nullptr),\n \t_cmd_pub(nullptr)\n@@ -114,16 +115,41 @@ MissionBlock::is_mission_item_reached()\n \t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n \t\t\t{\n \t\t\t/* forward the command to other processes */\n-\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n \t\t\tstruct vehicle_command_s cmd = {};\n \t\t\tcmd.command = _mission_item.nav_cmd;\n \t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n \t\t\tif (_cmd_pub != nullptr) {\n-\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t\t\tif (_action_start == 0) {\n+\t\t\t\t\t_action_start = hrt_absolute_time();\n+\t\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t\t\t}\n \t\t\t} else {\n+\t\t\t\t_action_start = hrt_absolute_time();\n \t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n \t\t\t}\n-\t\t\treturn true;\n+\n+\t\t\tif (vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION) {\n+\n+\t\t\t\t/* we want to wait half a second so the system state can propagate */\n+\t\t\t\t// XXX this is acceptable to get started, but in general should be\n+\t\t\t\t// based on state switching, not on min holdoff times.\n+\t\t\t\tif (hrt_absolute_time() - _action_start > 500000 &&\n+\t\t\t\t\t!_navigator->get_vstatus()->in_transition_mode) {\n+\t\t\t\t\t/*\n+\t\t\t\t\t * if half a second has passed and we're not in transition\n+\t\t\t\t\t * return - we are now in the other flight mode.\n+\t\t\t\t\t */\n+\t\t\t\t\t_action_start = 0;\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t} else {\n+\n+\t\t\t\t/* not an action one needs to wait for */\n+\t\t\t\t_action_start = 0;\n+\t\t\t\treturn true;\n+\t\t\t}\n \t\t\t}\n \n \t\tdefault:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fba044cd1d1639a0f9e5fd9270d502144283b18b/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -120,6 +120,7 @@ class MissionBlock : public NavigatorMode\n \tbool _waypoint_position_reached;\n \tbool _waypoint_yaw_reached;\n \thrt_abstime _time_first_inside_orbit;\n+\thrt_abstime _action_start;\n \n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fba044cd1d1639a0f9e5fd9270d502144283b18b/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached",
        "MissionBlock::MissionBlock"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "MissionBlock::MissionBlock"
        ]
      }
    }
  },
  {
    "title": "Reject mission when starting with LAND and vehicle is landed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3571",
    "number": 3571,
    "created_at": "2016-01-23T16:01:21Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "This will reject a mission that starts with a LAND command if the vehicle is not airborn\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-23T16:06:08Z",
          "body": "Nice!\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-24T10:19:29Z",
          "body": "Applied on master, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes mission validation to reject a mission that starts with a LAND command when the vehicle is already landed, correcting improper state handling. This fixes a logic bug where the system would accept/execute a mission that is semantically invalid given the vehicle's current state, preventing unintended behavior.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -264,7 +264,8 @@ Mission::update_offboard_mission()\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius());\n+\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n+\t\t\t\t_navigator->get_vstatus()->condition_landed);\n \n \t\t_navigator->get_mission_result()->valid = !failed;\n \t\t_navigator->increment_mission_instance_count();\n@@ -848,7 +849,8 @@ Mission::check_mission_valid()\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius());\n+\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n+\t\t\t\t_navigator->get_vstatus()->condition_landed);\n \n \t\t_navigator->increment_mission_instance_count();\n \t\t_navigator->set_mission_result_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0165ef0085fccf16bf1940f4bb42e7285044f31/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "patch": "@@ -65,7 +65,8 @@ MissionFeasibilityChecker::MissionFeasibilityChecker() :\n bool MissionFeasibilityChecker::checkMissionFeasible(int mavlink_fd, bool isRotarywing,\n \tdm_item_t dm_current, size_t nMissionItems, Geofence &geofence,\n \tfloat home_alt, bool home_valid, double curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued,\n-\tfloat default_acceptance_rad)\n+\tfloat default_acceptance_rad,\n+\tbool condition_landed)\n {\n \tbool failed = false;\n \tbool warned = false;\n@@ -84,7 +85,7 @@ bool MissionFeasibilityChecker::checkMissionFeasible(int mavlink_fd, bool isRota\n \t}\n \n \t// check if all mission item commands are supported\n-\tfailed = failed || !checkMissionItemValidity(dm_current, nMissionItems);\n+\tfailed = failed || !checkMissionItemValidity(dm_current, nMissionItems, condition_landed);\n \tfailed = failed || !checkGeofence(dm_current, nMissionItems, geofence);\n \tfailed = failed || !checkHomePositionAltitude(dm_current, nMissionItems, home_alt, home_valid, warned);\n \n@@ -211,7 +212,7 @@ bool MissionFeasibilityChecker::checkHomePositionAltitude(dm_item_t dm_current,\n \treturn true;\n }\n \n-bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems) {\n+bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed) {\n \t// do not allow mission if we find unsupported item\n \tfor (size_t i = 0; i < nMissionItems; i++) {\n \t\tstruct mission_item_s missionitem;\n@@ -223,7 +224,7 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\treturn false;\n \t\t}\n \n-\t\t// check if we find unsupported item and reject mission if so\n+\t\t// check if we find unsupported items and reject mission if so\n \t\tif (missionitem.nav_cmd != NAV_CMD_IDLE &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_WAYPOINT &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n@@ -240,6 +241,17 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n \t\t\treturn false;\n \t\t}\n+\n+\t\t// check if the mission starts with a land command while the vehicle is landed\n+\t\tif (missionitem.nav_cmd == NAV_CMD_LAND &&\n+\t\t\ti == 0 &&\n+\t\t\tcondition_landed) {\n+\n+\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission that starts with LAND command while vehicle is landed.\");\n+\t\t\treturn false;\n+\t\t}\n+\n+\n \t}\n \treturn true;\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0165ef0085fccf16bf1940f4bb42e7285044f31/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -63,7 +63,7 @@ class MissionFeasibilityChecker\n \t/* Checks for all airframes */\n \tbool checkGeofence(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence);\n \tbool checkHomePositionAltitude(dm_item_t dm_current, size_t nMissionItems, float home_alt, bool home_valid, bool &warning_issued, bool throw_error = false);\n-\tbool checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems);\n+\tbool checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed);\n \tbool check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued);\n \n \t/* Checks specific to fixedwing airframes */\n@@ -83,7 +83,8 @@ class MissionFeasibilityChecker\n \t */\n \tbool checkMissionFeasible(int mavlink_fd, bool isRotarywing, dm_item_t dm_current,\n \t\tsize_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid,\n-\t\tdouble curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued, float default_acceptance_rad);\n+\t\tdouble curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued, float default_acceptance_rad,\n+\t\tbool condition_landed);\n \n };\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c0165ef0085fccf16bf1940f4bb42e7285044f31/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_offboard_mission",
        "Mission::check_mission_valid",
        "MissionFeasibilityChecker::MissionFeasibilityChecker",
        "MissionFeasibilityChecker::checkHomePositionAltitude",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "checkMissionItemValidity",
        "MissionFeasibilityChecker::checkMissionFeasible"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::update_offboard_mission",
          "Mission::check_mission_valid"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkHomePositionAltitude",
          "MissionFeasibilityChecker::checkMissionItemValidity",
          "MissionFeasibilityChecker::MissionFeasibilityChecker",
          "MissionFeasibilityChecker::checkMissionFeasible"
        ],
        "src/modules/navigator/mission_feasibility_checker.h": [
          "checkMissionItemValidity"
        ]
      }
    }
  },
  {
    "title": "Do change speed support",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3567",
    "number": 3567,
    "created_at": "2016-01-22T12:31:43Z",
    "merged": true,
    "merged_at": "2016-03-13T17:12:39Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-22T12:32:28Z",
          "body": "@MikaelFerland  @tubeme This is now implemented, but UNTESTED. Simulation testing would be appreciated. I will get to test it later this weekend.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-07T17:13:43Z",
          "body": "Support is in for QGC. Just needs to be validated here.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-11T10:50:39Z",
          "body": "Doesn't seem to work yet. Not sure why.\n",
          "type": "issue_comment"
        },
        {
          "author": "MikaelFerland",
          "created_at": "2016-02-11T12:51:13Z",
          "body": "Does it take the speed from an average of GPS data or it uses the ground\nspeed sensor as reference? I have tested over HITL with jMAVSim, but I was\nunsuccesful for me also.\n\nDoesn't seem to work yet. Not sure why.\n\nâ€”\nReply to this email directly or view it on GitHub\nhttps://github.com/PX4/Firmware/pull/3567#issuecomment-182807771.\n",
          "type": "issue_comment"
        },
        {
          "author": "tubeme",
          "created_at": "2016-02-16T13:44:10Z",
          "body": "Does not work in mission. Could not load the mission QGC gave error. I'm using the Latest master with the Intel angle patch from couple of days. PX4 master is 5 days old. \n\n![setspeed](https://cloud.githubusercontent.com/assets/12617619/13077856/145353c4-d4c4-11e5-897b-019862457e6f.png)\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-17T15:52:32Z",
          "body": "@tubeme I've tested it after a few additional fixes successfully in SITL. @dagar Could you test with Gazebo / VTOL sim in fixed wing mode? Then it would be ready for flight tests.\n\n<img width=\"1392\" alt=\"screen shot 2016-02-17 at 16 49 19\" src=\"https://cloud.githubusercontent.com/assets/1208119/13115122/d2b8e4f0-d596-11e5-93b9-ed8fee75b986.png\">\n",
          "type": "issue_comment"
        },
        {
          "author": "MikaelFerland",
          "created_at": "2016-02-17T18:06:30Z",
          "body": "@LorenzMeier Did you see my comments? Addionally, do I will be able to test it with jMAVSim or you guys usually tested it with Gazebo? Because it will fix my setup to get better results. Thank you for your time.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-17T18:09:23Z",
          "body": "@MikaelFerland You would need to re-test with the current state I pushed. Its ground speed based for multicopters, currently airspeed based for planes. We'll clean this up for planes later.\n",
          "type": "issue_comment"
        },
        {
          "author": "MikaelFerland",
          "created_at": "2016-02-17T18:14:05Z",
          "body": "Perfect, to simulate it jMAVSim or Gazebo is prefered?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-17T18:21:24Z",
          "body": "Both works.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-18T05:36:10Z",
          "body": "It seems my old thinkpad is nowhere near fast enough to run the gazebo simulation, so you may have finally given me a reason to upgrade. I'll try it again on a faster machine tomorrow.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-02-18T17:58:25Z",
          "body": "Rebased on master. Needs flight testing. Tested successfully in SITL in multicopter mode.\n",
          "type": "issue_comment"
        },
        {
          "author": "tubeme",
          "created_at": "2016-02-18T21:59:13Z",
          "body": "Do I need the latest master of QGC for this mission or can go with the current version I use from the screenshot?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-19T01:11:21Z",
          "body": "![screenshot from 2016-02-18 20 09 31](https://cloud.githubusercontent.com/assets/84712/13163508/b579da6c-d67b-11e5-9093-381c8c94dcf2.png)\n\nI'm getting airspeed errors in the gazebo simulation now.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-02-19T01:34:06Z",
          "body": "Rebased on master to get airspeed fix.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-13T17:12:54Z",
          "body": "Merged to master.\n",
          "type": "issue_comment"
        },
        {
          "author": "MikaelFerland",
          "created_at": "2016-03-15T02:29:59Z",
          "body": "@LorenzMeier Thank you, we tested it last weekend, and it works very well. We land unsuccessfully, but I think we broke the power plug before the mission start. We will test it again this sunday of the weather permit us.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-07T20:00:19Z",
          "body": "Really? ;) I'd say 10 would be the max acceptable default.\n",
          "path": "src/modules/mc_pos_control/mc_pos_control_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-07T20:00:38Z",
          "body": "I guess that should be MPC_XY_CRUISE\n",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-03-07T21:59:06Z",
          "body": "Yes indeed.\n",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR implements and corrects the mission \"change speed\" behavior â€” previously the feature either did not work or used the wrong speed reference (ground speed vs airspeed) and caused mission/load failures. Comments show it was untested, then several logic fixes were applied and SITL/flight tests confirmed the corrected behavior, indicating this was a logic bug rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "patch": "@@ -121,6 +121,15 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\treturn false;\n \t\t\t}\n \n+\t\tcase vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED:\n+\t\t\t// XXX not differentiating ground and airspeed yet\n+\t\t\tif (_mission_item.params[1] > 0.0f) {\n+\t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n+\t\t\t} else {\n+\t\t\t\t_navigator->set_cruising_speed();\n+\t\t\t}\n+\t\t\treturn true;\n+\n \t\tdefault:\n \t\t\t/* do nothing, this is a 3D waypoint */\n \t\t\tbreak;\n@@ -312,7 +321,8 @@ MissionBlock::item_contains_position(const struct mission_item_s *item)\n \tif (item->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n \t\t\titem->nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST ||\n \t\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION ||\n-\t\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO) {\n+\t\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO ||\n+\t\t\titem->nav_cmd == NAV_CMD_DO_CHANGE_SPEED) {\n \t\treturn false;\n \t}\n \n@@ -338,6 +348,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->pitch_min = item->pitch_min;\n \tsp->acceptance_radius = item->acceptance_radius;\n \tsp->disable_mc_yaw_control = false;\n+\tsp->cruising_speed = _navigator->get_cruising_speed();\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_IDLE:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b323908fc508c400549a8feaae7085c99818b21f/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -242,11 +242,12 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_CHANGE_SPEED &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_DIST &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n \n-\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n+\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported cmd: %d\", (int)(i+1), (int)missionitem.nav_cmd);\n \t\t\treturn false;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b323908fc508c400549a8feaae7085c99818b21f/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -62,6 +62,7 @@ enum NAV_CMD {\n \tNAV_CMD_ROI = 80,\n \tNAV_CMD_PATHPLANNING = 81,\n \tNAV_CMD_DO_JUMP = 177,\n+\tNAV_CMD_DO_CHANGE_SPEED = 178,\n \tNAV_CMD_DO_SET_SERVO=183,\n \tNAV_CMD_DO_REPEAT_SERVO=184,\n \tNAV_CMD_DO_DIGICAM_CONTROL=203,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b323908fc508c400549a8feaae7085c99818b21f/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "patch": "@@ -156,6 +156,18 @@ class Navigator : public control::SuperBlock\n \t */\n \tfloat\t\tget_acceptance_radius();\n \n+\t/**\n+\t * Get the cruising speed\n+\t *\n+\t * @return the desired cruising speed for this mission\n+\t */\n+\tfloat\t\tget_cruising_speed();\n+\n+\t/**\n+\t * Set the cruising speed\n+\t */\n+\tvoid\t\tset_cruising_speed(float speed=-1.0f) { _mission_cruising_speed = speed; }\n+\n \t/**\n \t * Get the acceptance radius given the mission item preset radius\n \t *\n@@ -244,6 +256,12 @@ class Navigator : public control::SuperBlock\n \tcontrol::BlockParamFloat _param_acceptance_radius;\t/**< acceptance for takeoff */\n \tcontrol::BlockParamInt _param_datalinkloss_obc;\t/**< if true: obc mode on data link loss enabled */\n \tcontrol::BlockParamInt _param_rcloss_obc;\t/**< if true: obc mode on rc loss enabled */\n+\t\n+\tcontrol::BlockParamFloat _param_cruising_speed_hover;\n+\tcontrol::BlockParamFloat _param_cruising_speed_plane;\n+\n+\tfloat _mission_cruising_speed;\n+\n \t/**\n \t * Retrieve global position\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b323908fc508c400549a8feaae7085c99818b21f/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "patch": "@@ -151,7 +151,10 @@ Navigator::Navigator() :\n \t_param_loiter_radius(this, \"LOITER_RAD\"),\n \t_param_acceptance_radius(this, \"ACC_RAD\"),\n \t_param_datalinkloss_obc(this, \"DLL_OBC\"),\n-\t_param_rcloss_obc(this, \"RCL_OBC\")\n+\t_param_rcloss_obc(this, \"RCL_OBC\"),\n+\t_param_cruising_speed_hover(this, \"MPC_XY_CRUISE\", false),\n+\t_param_cruising_speed_plane(this, \"FW_AIRSPD_TRIM\", false),\n+\t_mission_cruising_speed(-1.0f)\n {\n \t/* Create a list of our possible navigation types */\n \t_navigation_mode_array[0] = &_mission;\n@@ -615,6 +618,19 @@ Navigator::get_acceptance_radius()\n \treturn get_acceptance_radius(_param_acceptance_radius.get());\n }\n \n+float\n+Navigator::get_cruising_speed()\n+{\n+\t/* there are three options: The mission-requested cruise speed, or the current hover / plane speed */\n+\tif (_mission_cruising_speed > 0.0f) {\n+\t\treturn _mission_cruising_speed;\n+\t} else if (_vstatus.is_rotary_wing) {\n+\t\treturn _param_cruising_speed_hover.get();\n+\t} else {\n+\t\treturn _param_cruising_speed_plane.get();\n+\t}\n+}\n+\n float\n Navigator::get_acceptance_radius(float mission_item_radius)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b323908fc508c400549a8feaae7085c99818b21f/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::item_contains_position",
        "MissionBlock::is_mission_item_reached",
        "Navigator::Navigator",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "MissionBlock::mission_item_to_position_setpoint",
        "Navigator::get_acceptance_radius"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::item_contains_position",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionItemValidity"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_acceptance_radius",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "for multicopter landings make sure that the copter moves",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3523",
    "number": 3523,
    "created_at": "2016-01-16T16:29:32Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "to the landing waypoint first before the descending phase starts\n\nFixes https://github.com/PX4/Firmware/issues/3388\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-01-16T16:31:28Z",
          "body": "@LorenzMeier @AndreasAntener This makes sure that the copter first moves to the landing waypoint before it starts to descend. For the approach it will use the altitude specified in the landing waypoint.\nI'm not very sure if this is the correct altitude. What is the meaning of the landing waypoint altitude?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-16T16:49:32Z",
          "body": "From a user standpoint i would agree that the altitude in a land command would mean 'go here at this altitude and then land'. 0 altitude could be interpreted as 'keep current altitude'\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-01-16T17:08:13Z",
          "body": "@sanderux Thanks for your feedback! Makes sense, I can add the logic for the zero case.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-17T09:56:50Z",
          "body": "@sanderux @tumbili We should be careful with special cases that are not clearly documented/specified. It could as well be that 0 is a valid relative landing WP altitude if the target landing point is below home. Because the user always specifies the altitude for a normal WP I would just keep that behaviour consistent as Roman described.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-01-17T10:10:15Z",
          "body": "@AndreasAntener Yes, good argument.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-17T10:34:06Z",
          "body": "Yes, true. QGC (and most GCS i think) maintain the altitude of the last WP when planning a mission so it should not be needed.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-21T17:36:07Z",
          "body": "Tested and working. But before the yaw setpoint changed back to what it had at home for the landing. We can probably take this because we need to have a look at yawing during missions anyway.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the landing sequence so the multicopter first moves to the landing waypoint before beginning descent, correcting an incorrect state/sequence (approach vs descend) that produced unintended behavior. The discussion about waypoint altitude semantics and special-case handling (altitude==0) further indicates it addresses inconsistent or ambiguous behavior rather than a style/syntax issue.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "patch": "@@ -150,7 +150,6 @@ void\n Mission::on_active()\n {\n \tcheck_mission_valid();\n-\n \t/* check if anything has changed */\n \tbool onboard_updated = false;\n \torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n@@ -181,6 +180,12 @@ Mission::on_active()\n \n \t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n \t\taltitude_sp_foh_update();\n+\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _waypoint_position_reached && _navigator->get_vstatus()->is_rotary_wing) {\n+\t\t// the copter has reached the landing spot location\n+\t\t// set the same landing item again but this time the vehicle will actually\n+\t\t// descend and land\n+\t\tset_mission_item_reached();\n+\t\tset_mission_items();\n \t} else {\n \t\t/* if waypoint position reached allow loiter on the setpoint */\n \t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ad1058d3742bbfa9cbd16648aa2925fa1e618a55/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 3,
        "changes": 31,
        "patch": "@@ -92,9 +92,17 @@ MissionBlock::is_mission_item_reached()\n \t\t\t}\n \t\t\treturn true;\n \t\t\t}\n-\n \t\tcase NAV_CMD_LAND:\n-\t\t\treturn _navigator->get_vstatus()->condition_landed;\n+\t\t\tif (!_navigator->get_vstatus()->is_rotary_wing) {\n+\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n+\t\t\t} else {\n+\t\t\t\tif (_waypoint_position_reached) {\n+\t\t\t\t\t// the copter has reached the position of the landing spot\n+\t\t\t\t\t// it can can start to descend\n+\t\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n \n \t\t/* TODO: count turns */\n \t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n@@ -159,6 +167,12 @@ MissionBlock::is_mission_item_reached()\n \t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n+\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND) {\n+\t\t\t// check if we have reached our landing spot\n+\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n+\t\t\t\t_waypoint_position_reached = true;\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n \t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n \t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n@@ -222,6 +236,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\treturn true;\n \t\t}\n \t}\n+\n \treturn false;\n }\n \n@@ -284,7 +299,17 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \t\tbreak;\n \n \tcase NAV_CMD_LAND:\n-\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n+\n+\t\tif (!_waypoint_position_reached) {\n+\t\t\t// we first need to move to the landing waypoint\n+\t\t\t// use the altitude specified in the mission item\n+\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n+\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t\t} else {\n+\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n+\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n+\t\t}\n+\n \t\tbreak;\n \n \tcase NAV_CMD_LOITER_TIME_LIMIT:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ad1058d3742bbfa9cbd16648aa2925fa1e618a55/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint",
        "Mission::on_active",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_active"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "multirotor mission feasibility checks:",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3518",
    "number": 3518,
    "created_at": "2016-01-15T11:48:39Z",
    "merged": true,
    "merged_at": "2016-01-17T14:43:53Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "make sure that the relative altitude of the takeoff waypoint is\nat least one meter higher than the acceptance radius of the waypoint.\nThis makes sure that the takeoff waypoint is not reached before the vehicle\nis at least one meter in the air.\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-01-17T12:10:49Z",
          "body": "@LorenzMeier Fixed\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-17T12:12:42Z",
          "body": "Is this tested in SITL? If it passes there I would like to merge it. This is something where SITL provides 100% coverage and I can't see why it would be worse than outdoor tests.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-01-17T12:13:37Z",
          "body": "@LorenzMeier Tested in SITL but needs one more test after checks.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-17T14:38:41Z",
          "body": "So can we test and merge (locally, not via github) now?\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-01-17T14:43:48Z",
          "body": "@LorenzMeier Tested it in SITL, works as expected.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-17T11:30:25Z",
          "body": "There is a call to get the default acceptance radius from the navigator. Never use hardcoded numbers.\n",
          "path": "src/modules/navigator/mission_feasibility_checker.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-17T11:31:57Z",
          "body": "`get_acceptance_radius();` in class Navigator.\n",
          "path": "src/modules/navigator/mission_feasibility_checker.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-17T11:32:35Z",
          "body": "Should say \"Mission rejected: Takeoff altitude too low!\"\n",
          "path": "src/modules/navigator/mission_feasibility_checker.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The change addresses incorrect mission-feasibility logic: previously a takeoff waypoint could be considered reached while the vehicle was still on the ground if the waypoint acceptance radius exceeded its relative altitude. Ensuring the takeoff waypoint altitude is at least 1 m above the acceptance radius corrects an improper state/condition check so the vehicle must be airborne before the waypoint is marked reached.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -259,7 +259,7 @@ Mission::update_offboard_mission()\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning);\n+\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius());\n \n \t\t_navigator->get_mission_result()->valid = !failed;\n \t\t_navigator->increment_mission_instance_count();\n@@ -843,7 +843,7 @@ Mission::check_mission_valid()\n \t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n \t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n \t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning);\n+\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius());\n \n \t\t_navigator->increment_mission_instance_count();\n \t\t_navigator->set_mission_result_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/07fafc491347e858ef90c5602e33a23b3bb5ede3/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 4,
        "changes": 41,
        "patch": "@@ -64,7 +64,8 @@ MissionFeasibilityChecker::MissionFeasibilityChecker() :\n \n bool MissionFeasibilityChecker::checkMissionFeasible(int mavlink_fd, bool isRotarywing,\n \tdm_item_t dm_current, size_t nMissionItems, Geofence &geofence,\n-\tfloat home_alt, bool home_valid, double curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued)\n+\tfloat home_alt, bool home_valid, double curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued,\n+\tfloat default_acceptance_rad)\n {\n \tbool failed = false;\n \tbool warned = false;\n@@ -88,17 +89,49 @@ bool MissionFeasibilityChecker::checkMissionFeasible(int mavlink_fd, bool isRota\n \tfailed = failed || !checkHomePositionAltitude(dm_current, nMissionItems, home_alt, home_valid, warned);\n \n \tif (isRotarywing) {\n-\t\tfailed = failed || !checkMissionFeasibleRotarywing(dm_current, nMissionItems, geofence, home_alt, home_valid);\n+\t\tfailed = failed || !checkMissionFeasibleRotarywing(dm_current, nMissionItems, geofence, home_alt, home_valid, default_acceptance_rad);\n \t} else {\n \t\tfailed = failed || !checkMissionFeasibleFixedwing(dm_current, nMissionItems, geofence, home_alt, home_valid);\n \t}\n \n \treturn !failed;\n }\n \n-bool MissionFeasibilityChecker::checkMissionFeasibleRotarywing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid)\n+bool MissionFeasibilityChecker::checkMissionFeasibleRotarywing(dm_item_t dm_current, size_t nMissionItems,\n+\tGeofence &geofence, float home_alt, bool home_valid, float default_acceptance_rad)\n {\n-\t/* no custom rotary wing checks yet */\n+\t/* Check if all all waypoints are above the home altitude, only return false if bool throw_error = true */\n+\tfor (size_t i = 0; i < nMissionItems; i++) {\n+\t\tstruct mission_item_s missionitem;\n+\t\tconst ssize_t len = sizeof(struct mission_item_s);\n+\n+\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n+\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t// look for a takeoff waypoint\n+\t\tif (missionitem.nav_cmd == NAV_CMD_TAKEOFF) {\n+\t\t\t// make sure that the altitude of the waypoint is at least one meter larger than the acceptance radius\n+\t\t\t// this makes sure that the takeoff waypoint is not reached before we are at least one meter in the air\n+\t\t\tfloat takeoff_alt = missionitem.altitude_is_relative\n+\t\t\t\t      ? missionitem.altitude\n+\t\t\t              : missionitem.altitude - home_alt;\n+\t\t\t// check if we should use default acceptance radius\n+\t\t\tfloat acceptance_radius = default_acceptance_rad;\n+\n+\t\t\tif (missionitem.acceptance_radius > NAV_EPSILON_POSITION) {\n+\t\t\t\tacceptance_radius = missionitem.acceptance_radius;\n+\t\t\t}\n+\n+\t\t\tif (takeoff_alt - 1.0f < acceptance_radius) {\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Mission rejected: Takeoff altitude too low!\");\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// all checks have passed\n \treturn true;\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/07fafc491347e858ef90c5602e33a23b3bb5ede3/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -72,7 +72,7 @@ class MissionFeasibilityChecker\n \tvoid updateNavigationCapabilities();\n \n \t/* Checks specific to rotarywing airframes */\n-\tbool checkMissionFeasibleRotarywing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid);\n+\tbool checkMissionFeasibleRotarywing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid, float default_acceptance_rad);\n public:\n \n \tMissionFeasibilityChecker();\n@@ -83,7 +83,7 @@ class MissionFeasibilityChecker\n \t */\n \tbool checkMissionFeasible(int mavlink_fd, bool isRotarywing, dm_item_t dm_current,\n \t\tsize_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid,\n-\t\tdouble curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued);\n+\t\tdouble curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued, float default_acceptance_rad);\n \n };\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/07fafc491347e858ef90c5602e33a23b3bb5ede3/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      }
    },
    "modified_functions": {
      "all": [
        "checkMissionFeasibleRotarywing",
        "Mission::update_offboard_mission",
        "Mission::check_mission_valid",
        "MissionFeasibilityChecker::MissionFeasibilityChecker",
        "MissionFeasibilityChecker::checkMissionFeasibleRotarywing",
        "MissionFeasibilityChecker::checkMissionFeasible"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::update_offboard_mission",
          "Mission::check_mission_valid"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionFeasibleRotarywing",
          "MissionFeasibilityChecker::MissionFeasibilityChecker",
          "MissionFeasibilityChecker::checkMissionFeasible"
        ],
        "src/modules/navigator/mission_feasibility_checker.h": [
          "checkMissionFeasibleRotarywing"
        ]
      }
    }
  },
  {
    "title": "Properly handle takeoff waypoint when not currently at takeoff location",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3459",
    "number": 3459,
    "created_at": "2016-01-07T16:01:09Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "Fixes #3387 \n\nInstead of taking off like this:\n![screen shot 2016-01-07 at 15 01 38](https://cloud.githubusercontent.com/assets/5750020/12174890/8cb62cd0-b55f-11e5-94e1-05624b7419d4.png)\n\nIt will now do this:\n![screen shot 2016-01-07 at 15 08 12](https://cloud.githubusercontent.com/assets/5750020/12174892/8e6dc330-b55f-11e5-8b6e-1bcc4df9e956.png)\n\nThis should also fix a bug where the \"next\" setpoint kept the type takeoff and just never stopped climbing. Although that one occurred randomly for me and I could never really pin it down.\n\nTested with takeoff WP at current location and away from current location. Fixed-wing should not be affected because the already existing takeoff flag is only set for MC\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-07T21:25:34Z",
          "body": "Applied, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect handling of a takeoff waypoint when the vehicle is not at the takeoff location, which led to wrong setpoint/state behavior (e.g. the next setpoint remaining of type 'takeoff' and causing perpetual climb). This is a logic bug involving improper state/condition handling and setpoint transitions rather than a syntax or style issue.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "patch": "@@ -286,6 +286,7 @@ Mission::advance_mission()\n {\n \tif (_takeoff) {\n \t\t_takeoff = false;\n+\t\t_takeoff_finished = true;\n \n \t} else {\n \t\tswitch (_mission_type) {\n@@ -430,6 +431,8 @@ Mission::set_mission_items()\n \t\t/* do takeoff before going to setpoint */\n \t\t/* set mission item as next position setpoint */\n \t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n+\t\t/* next SP is not takeoff anymore */\n+\t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n \n \t\t/* calculate takeoff altitude */\n \t\tfloat takeoff_alt = get_absolute_altitude_for_item(_mission_item);\n@@ -466,6 +469,13 @@ Mission::set_mission_items()\n \t\t}\n \t}\n \n+\tif (_takeoff_finished) {\n+\t\t/* we just finished takeoff */\n+\t\t/* in case we still have to move to the takeoff waypoint we need a waypoint mission item */\n+\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t_takeoff_finished = false;\n+\t}\n+\n \t/* set current position setpoint from mission item */\n \tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e66f0285cf67b0ee1f21905f473feb59ff4747ca/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -185,6 +185,7 @@ class Mission : public MissionBlock\n \tint _current_offboard_mission_index;\n \tbool _need_takeoff;\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n \tbool _takeoff;\t\t\t\t\t\t/**< takeoff state flag */\n+\tbool _takeoff_finished;\t\t\t\t\t/**< set if takeoff was requested before and is now done */\n \n \tenum {\n \t\tMISSION_TYPE_NONE,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e66f0285cf67b0ee1f21905f473feb59ff4747ca/src%2Fmodules%2Fnavigator%2Fmission.h"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::advance_mission",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::advance_mission",
          "Mission::set_mission_items"
        ]
      }
    }
  },
  {
    "title": "VTOL transition helper class",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3426",
    "number": 3426,
    "created_at": "2016-01-03T20:22:51Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "A helper class for VTOL transitions.\nNavigator modified to wait until transition has finished before proceding to next waypoint.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-03T23:26:06Z",
          "body": "Nice! @sjwilks @AndreasAntener FYI\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the change addresses improper state/timing behavior: the Navigator previously proceeded to the next waypoint before a VTOL transition completed. Making the navigator wait for the transition fixes an incorrect state/sequence (timing) bug that would produce wrong runtime behavior.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -46,6 +46,7 @@ px4_add_module(\n \t\trtl.cpp\n \t\ttakeoff.cpp\n \t\tland.cpp\n+\t\ttransition.cpp\n \t\tmission_feasibility_checker.cpp\n \t\tgeofence.cpp\n \t\tdatalinkloss.cpp",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 91,
        "deletions": 20,
        "changes": 111,
        "patch": "@@ -51,6 +51,7 @@\n \n #include <uORB/uORB.h>\n #include <uORB/topics/actuator_controls.h>\n+#include <uORB/topics/vehicle_command.h>\n \n #include \"navigator.h\"\n #include \"mission_block.h\"\n@@ -64,9 +65,11 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_mission_item({0}),\n \t_waypoint_position_reached(false),\n \t_waypoint_yaw_reached(false),\n+    _transition_started(false),\n \t_time_first_inside_orbit(0),\n \t_actuators{},\n-\t_actuator_pub(nullptr)\n+\t_actuator_pub(nullptr),\n+\t_cmd_pub(nullptr)\n {\n }\n \n@@ -77,27 +80,74 @@ MissionBlock::~MissionBlock()\n bool\n MissionBlock::is_mission_item_reached()\n {\n-\tif (_mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO) {\n-\t\tactuator_pub_fd = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n-\t\tmemset(&actuators, 0, sizeof(actuators));\n-\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n-\t\tactuators.timestamp = hrt_absolute_time();\n-\t\torb_publish(ORB_ID(actuator_controls_2), actuator_pub_fd, &actuators);\n-\t\treturn true;\n-\t}\n-\n-\tif (_mission_item.nav_cmd == NAV_CMD_IDLE) {\n-\t\treturn false;\n-\t}\n+\t/* handle non-navigation or indefinite waypoints */\n+\tswitch (_mission_item.nav_cmd) {\n+\t\tcase NAV_CMD_DO_SET_SERVO: {\n+\t\t\tmemset(&actuators, 0, sizeof(actuators));\n+\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n+\t\t\tactuators.timestamp = hrt_absolute_time();\n+\t\t\tif (_actuator_pub != nullptr) {\n+\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n+\t\t\t} else {\n+\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t\t}\n \n-\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n-\t\treturn _navigator->get_vstatus()->condition_landed;\n-\t}\n+\t\tcase NAV_CMD_LAND:\n+\t\t\treturn _navigator->get_vstatus()->condition_landed;\n+\n+\t\t/* TODO: count turns */\n+\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n+\t\tcase NAV_CMD_IDLE: /* fall through */\n+\t\tcase NAV_CMD_LOITER_UNLIMITED:\n+\t\t\treturn false;\n+\n+\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL:\n+\t\t\t{\n+\t\t\t/* forward the command to other processes */\n+\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n+\t\t\tstruct vehicle_command_s cmd = {};\n+\t\t\tcmd.command = _mission_item.nav_cmd;\n+\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n+\t\t\tif (_cmd_pub != nullptr) {\n+\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t\t} else {\n+\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t\t}\n \n-\t/* TODO: count turns */\n-\tif (/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n-\t     _mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED) {\n-\t\treturn false;\n+        case vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n+            {\n+            if(_navigator->get_vtol_status()->vtol_in_trans_mode){\n+                _transition_started = true;\n+                return false;\n+            } else {\n+                if(_transition_started){\n+                    PX4_INFO(\"VTOL transition finished\");\n+                    _transition_started = false;\n+                    return true;\n+                } else {\n+                    PX4_INFO(\"VTOL transition requested\");\n+                    /* forward the command to other processes */\n+                    struct vehicle_command_s cmd = {};\n+                    cmd.command = _mission_item.nav_cmd;\n+                    mission_item_to_vehicle_command(&_mission_item, &cmd);\n+                    if (_cmd_pub != nullptr) {\n+                        orb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+                    } else {\n+                        _cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+                    }\n+\n+                    return false;\n+                }\n+            }\n+            }\n+\n+\t\tdefault:\n+\t\t\t/* do nothing, this is a 3D waypoint */\n+\t\t\tbreak;\n \t}\n \n \thrt_abstime now = hrt_absolute_time();\n@@ -210,6 +260,26 @@ MissionBlock::reset_mission_item_reached()\n \t_time_first_inside_orbit = 0;\n }\n \n+void\n+MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd)\n+{\n+\t// Assignment based on MAVLink spec for param enumeration:\n+\t// http://mavlink.org/messages/common#MAV_CMD_NAV_WAYPOINT\n+\tcmd->param1 = item->time_inside;\n+\tcmd->param2 = item->acceptance_radius;\n+\tcmd->param3 = item->loiter_radius;\n+\tcmd->param4 = item->yaw;\n+\tcmd->param5 = item->lat;\n+\tcmd->param6 = item->lon;\n+\tcmd->param7 = item->altitude;\n+\n+\tcmd->target_system = _navigator->get_vstatus()->system_id;\n+\tcmd->target_component = _navigator->get_vstatus()->component_id;\n+\tcmd->source_system = _navigator->get_vstatus()->system_id;\n+\tcmd->source_component = _navigator->get_vstatus()->component_id;\n+\tcmd->confirmation = false;\n+}\n+\n void\n MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n {\n@@ -361,6 +431,7 @@ MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_locatio\n \titem->origin = ORIGIN_ONBOARD;\n }\n \n+\n void\n MissionBlock::set_idle_item(struct mission_item_s *item)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "patch": "@@ -50,6 +50,7 @@\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/actuator_controls.h>\n \n+\n #include \"navigator_mode.h\"\n \n class Navigator;\n@@ -111,14 +112,20 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_idle_item(struct mission_item_s *item);\n \n+\t/**\n+\t * Convert a mission item to a command\n+\t */\n+\tvoid mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n+\n \tmission_item_s _mission_item;\n \tbool _waypoint_position_reached;\n \tbool _waypoint_yaw_reached;\n+    bool _transition_started;\n \thrt_abstime _time_first_inside_orbit;\n \n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n-\n+\torb_advert_t\t_cmd_pub;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -50,6 +50,7 @@\n #include <fcntl.h>\n #include <errno.h>\n #include <uORB/topics/fence.h>\n+#include <uORB/topics/vehicle_command.h>\n \n MissionFeasibilityChecker::MissionFeasibilityChecker() :\n \t_mavlink_fd(-1),\n@@ -199,7 +200,9 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n-\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO) {\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n+\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL &&\n+\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION) {\n \n \t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n \t\t\treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 19,
        "deletions": 6,
        "changes": 25,
        "patch": "@@ -57,12 +57,14 @@\n #include <uORB/topics/mission_result.h>\n #include <uORB/topics/geofence_result.h>\n #include <uORB/topics/vehicle_attitude_setpoint.h>\n+#include <uORB/topics/vtol_vehicle_status.h>\n \n #include \"navigator_mode.h\"\n #include \"mission.h\"\n #include \"loiter.h\"\n #include \"takeoff.h\"\n #include \"land.h\"\n+#include \"transition.h\"\n #include \"rtl.h\"\n #include \"datalinkloss.h\"\n #include \"enginefailure.h\"\n@@ -73,7 +75,7 @@\n /**\n  * Number of navigation modes that need on_active/on_inactive calls\n  */\n-#define NAVIGATOR_MODE_ARRAY_SIZE 9\n+#define NAVIGATOR_MODE_ARRAY_SIZE 10\n \n class Navigator : public control::SuperBlock\n {\n@@ -132,7 +134,8 @@ class Navigator : public control::SuperBlock\n \t * Getters\n \t */\n \tstruct vehicle_status_s*\t    get_vstatus() { return &_vstatus; }\n-\tstruct vehicle_control_mode_s*\t    get_control_mode() { return &_control_mode; }\n+    struct vtol_vehicle_status_s*\t    get_vtol_status() { return &_vtol_vehicle_status; }\n+    struct vehicle_control_mode_s*\t    get_control_mode() { return &_control_mode; }\n \tstruct vehicle_global_position_s*   get_global_position() { return &_global_pos; }\n \tstruct vehicle_gps_position_s*\t    get_gps_position() { return &_gps_pos; }\n \tstruct sensor_combined_s*\t    get_sensor_combined() { return &_sensor_combined; }\n@@ -181,12 +184,14 @@ class Navigator : public control::SuperBlock\n \tint\t\t_home_pos_sub;\t\t\t/**< home position subscription */\n \tint\t\t_vstatus_sub;\t\t\t/**< vehicle status subscription */\n \tint\t\t_capabilities_sub;\t\t/**< notification of vehicle capabilities updates */\n-\tint\t\t_control_mode_sub;\t\t/**< vehicle control mode subscription */\n+    int     _vtol_vehicle_status_sub;    /**< notification of vtol status updates */\n+    int\t\t_control_mode_sub;\t\t/**< vehicle control mode subscription */\n \tint\t\t_onboard_mission_sub;\t\t/**< onboard mission subscription */\n \tint\t\t_offboard_mission_sub;\t\t/**< offboard mission subscription */\n \tint\t\t_param_update_sub;\t\t/**< param update subscription */\n \tint\t\t_vehicle_command_sub;\t\t/**< vehicle commands (onboard and offboard) */\n \n+\n \torb_advert_t\t_pos_sp_triplet_pub;\t\t/**< publish position setpoint triplet */\n \torb_advert_t\t_mission_result_pub;\n \torb_advert_t\t_geofence_result_pub;\n@@ -202,7 +207,8 @@ class Navigator : public control::SuperBlock\n \thome_position_s\t\t\t\t\t_home_pos;\t\t/**< home position for RTL */\n \tmission_item_s \t\t\t\t\t_mission_item;\t\t/**< current mission item */\n \tnavigation_capabilities_s\t\t\t_nav_caps;\t\t/**< navigation capabilities */\n-\tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet;\t/**< triplet of position setpoints */\n+    position_setpoint_triplet_s\t\t\t_pos_sp_triplet;\t/**< triplet of position setpoints */\n+    vtol_vehicle_status_s\t\t\t_vtol_vehicle_status;\t\t/**< vtol status */\n \n \tmission_result_s\t\t\t\t_mission_result;\n \tgeofence_result_s\t\t\t\t_geofence_result;\n@@ -228,7 +234,8 @@ class Navigator : public control::SuperBlock\n \tLoiter\t\t_loiter;\t\t\t/**< class that handles loiter */\n \tTakeoff\t\t_takeoff;\t\t\t/**< class for handling takeoff commands */\n \tLand\t\t_land;\t\t\t/**< class for handling land commands */\n-\tRTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */\n+    Transition\t_transition;\t\t/**< class that handles vtol transitions */\n+    RTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */\n \tRCLoss \t\t_rcLoss;\t\t\t\t/**< class that handles RTL according to\n \t\t\t\t\t\t\t  OBC rules (rc loss mode) */\n \tDataLinkLoss\t_dataLinkLoss;\t\t\t/**< class that handles the OBC datalink loss mode */\n@@ -267,7 +274,13 @@ class Navigator : public control::SuperBlock\n \t */\n \tvoid\t\tnavigation_capabilities_update();\n \n-\t/**\n+    /**\n+     * Retreive vtol values\n+     */\n+    void\t\tvtol_vehicle_status_update();\n+\n+\n+    /**\n \t * Retrieve vehicle status\n \t */\n \tvoid\t\tvehicle_status_update();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "patch": "@@ -72,6 +72,7 @@\n #include <uORB/topics/fence.h>\n #include <uORB/topics/navigation_capabilities.h>\n #include <uORB/topics/vehicle_command.h>\n+#include <uORB/topics/vtol_vehicle_status.h>\n #include <drivers/drv_baro.h>\n \n #include <systemlib/err.h>\n@@ -108,7 +109,8 @@ Navigator::Navigator() :\n \t_home_pos_sub(-1),\n \t_vstatus_sub(-1),\n \t_capabilities_sub(-1),\n-\t_control_mode_sub(-1),\n+    _vtol_vehicle_status_sub(-1),\n+    _control_mode_sub(-1),\n \t_onboard_mission_sub(-1),\n \t_offboard_mission_sub(-1),\n \t_param_update_sub(-1),\n@@ -126,7 +128,8 @@ Navigator::Navigator() :\n \t_mission_item{},\n \t_nav_caps{},\n \t_pos_sp_triplet{},\n-\t_mission_result{},\n+    _vtol_vehicle_status{},\n+    _mission_result{},\n \t_att_sp{},\n \t_mission_item_valid(false),\n \t_mission_instance_count(0),\n@@ -143,6 +146,7 @@ Navigator::Navigator() :\n \t_loiter(this, \"LOI\"),\n \t_takeoff(this, \"TKF\"),\n \t_land(this, \"LND\"),\n+    _transition(this, \"TRN\"),\n \t_rtl(this, \"RTL\"),\n \t_rcLoss(this, \"RCL\"),\n \t_dataLinkLoss(this, \"DLL\"),\n@@ -163,6 +167,7 @@ Navigator::Navigator() :\n \t_navigation_mode_array[6] = &_rcLoss;\n \t_navigation_mode_array[7] = &_takeoff;\n \t_navigation_mode_array[8] = &_land;\n+    _navigation_mode_array[9] = &_transition;\n \n \tupdateParams();\n }\n@@ -227,6 +232,13 @@ Navigator::navigation_capabilities_update()\n \torb_copy(ORB_ID(navigation_capabilities), _capabilities_sub, &_nav_caps);\n }\n \n+void\n+Navigator::vtol_vehicle_status_update()\n+{\n+    orb_copy(ORB_ID(vtol_vehicle_status), _vtol_vehicle_status_sub, &_vtol_vehicle_status);\n+}\n+\n+\n void\n Navigator::vehicle_status_update()\n {\n@@ -239,7 +251,7 @@ Navigator::vehicle_status_update()\n void\n Navigator::vehicle_control_mode_update()\n {\n-\tif (orb_copy(ORB_ID(vehicle_control_mode), _control_mode_sub, &_control_mode) != OK) {\n+    if (orb_copy(ORB_ID(vehicle_control_mode), _control_mode_sub, &_control_mode) != OK) {\n \t\t/* in case the commander is not be running */\n \t\t_control_mode.flag_control_auto_enabled = false;\n \t\t_control_mode.flag_armed = false;\n@@ -287,6 +299,7 @@ Navigator::task_main()\n \t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n \t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n \t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n+\t_vtol_vehicle_status_sub = orb_subscribe(ORB_ID(vtol_vehicle_status));\n \t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n \t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n \t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n@@ -387,6 +400,13 @@ Navigator::task_main()\n \t\t\tnavigation_capabilities_update();\n \t\t}\n \n+        /* navigation capabilities updated */\n+        orb_check(_vtol_vehicle_status_sub, &updated);\n+        if (updated) {\n+            vtol_vehicle_status_update();\n+        }\n+\n+\n \t\t/* home position updated */\n \t\torb_check(_home_pos_sub, &updated);\n \t\tif (updated) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/transition.cpp": {
        "filename": "src/modules/navigator/transition.cpp",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "patch": "@@ -0,0 +1,106 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2013-2014 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file Transition.cpp\n+ *\n+ * Helper class to Perform Transition\n+ *\n+ * @author Sander Smeets <sander@droneslab.com>\n+ */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <math.h>\n+#include <fcntl.h>\n+\n+#include <mavlink/mavlink_log.h>\n+#include <systemlib/err.h>\n+\n+#include <uORB/uORB.h>\n+#include <uORB/topics/position_setpoint_triplet.h>\n+#include <uORB/topics/vehicle_command.h>\n+\n+#include \"transition.h\"\n+#include \"navigator.h\"\n+\n+Transition::Transition(Navigator *navigator, const char *name) :\n+    MissionBlock(navigator, name)\n+{\n+\t/* load initial params */\n+\tupdateParams();\n+}\n+\n+Transition::~Transition()\n+{\n+}\n+\n+void\n+Transition::on_inactive()\n+{\n+}\n+\n+void\n+Transition::on_activation()\n+{\n+    /* forward the command to other processes */\n+    warnx(\"got transition command, forwarding.\\n\");\n+    struct vehicle_command_s cmd = {};\n+    cmd.command = _mission_item.nav_cmd;\n+    mission_item_to_vehicle_command(&_mission_item, &cmd);\n+    if (_cmd_pub != nullptr) {\n+        orb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+    } else {\n+        _cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+    }\n+\n+\t_navigator->get_mission_result()->reached = false;\n+\t_navigator->get_mission_result()->finished = false;\n+\t_navigator->set_mission_result_updated();\n+\treset_mission_item_reached();\n+}\n+\n+void\n+Transition::on_active()\n+{\n+\tif (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n+\t\t_navigator->get_mission_result()->finished = true;\n+\t\t_navigator->set_mission_result_updated();\n+\n+        /* set loiter item so position controllers stop doing transition logic */\n+\t\tset_loiter_item(&_mission_item);\n+\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Ftransition.cpp"
      },
      "src/modules/navigator/transition.h": {
        "filename": "src/modules/navigator/transition.h",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "patch": "@@ -0,0 +1,64 @@\n+/***************************************************************************\n+ *\n+ *   Copyright (c) 2014 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file Transition.h\n+ *\n+ * Helper class to perform VTOL transitions\n+ *\n+ * @author Sander Smeets <sander@droneslab.com>\n+ */\n+\n+#ifndef NAVIGATOR_TRANSITION_H\n+#define NAVIGATOR_TRANSITION_H\n+\n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+\n+#include \"navigator_mode.h\"\n+#include \"mission_block.h\"\n+\n+class Transition : public MissionBlock\n+{\n+public:\n+    Transition(Navigator *navigator, const char *name);\n+\n+    ~Transition();\n+\n+\tvirtual void on_inactive();\n+\n+\tvirtual void on_activation();\n+\n+\tvirtual void on_active();\n+};\n+\n+#endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4c6751093aa76c20f3d2585404c4b513346804f3/src%2Fmodules%2Fnavigator%2Ftransition.h"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::navigation_capabilities_update",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "Navigator::task_main",
        "MissionBlock::set_land_item",
        "Navigator::Navigator",
        "Navigator::vehicle_status_update",
        "get_control_mode",
        "MissionBlock::MissionBlock",
        "MissionBlock::reset_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_land_item",
          "MissionBlock::MissionBlock",
          "MissionBlock::reset_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionItemValidity"
        ],
        "src/modules/navigator/navigator.h": [
          "get_control_mode"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::vehicle_status_update",
          "Navigator::navigation_capabilities_update",
          "Navigator::task_main",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Cmd forwarding",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3419",
    "number": 3419,
    "created_at": "2016-01-02T20:21:57Z",
    "merged": true,
    "merged_at": "2016-01-11T07:35:45Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "@AndreasAntener @sanderux This should be enough to forward the transition command and allow to embed it into missions. It also prepares everything for camera triggers. QGC should get support for all this also today.\n\nNone of this is tested, so bring up carefully. But it shows at least where to put the plumbing.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-02T20:22:20Z",
          "body": "@SimonWilks This goes pretty far in enabling what we discussed.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-02T20:35:14Z",
          "body": "You can use this QGC branch: https://github.com/mavlink/qgroundcontrol/pull/2510\n\n<img width=\"1144\" alt=\"screen shot 2016-01-02 at 21 32 28\" src=\"https://cloud.githubusercontent.com/assets/1208119/12076012/b25644d6-b198-11e5-910c-c49f5b46fddd.png\">\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-03T13:50:52Z",
          "body": "This is in QGC master and has made it into the daily build.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-03T20:26:12Z",
          "body": "PR https://github.com/PX4/Firmware/pull/3426\nUntested but a basis to expand on.\n\nI will field test this asap. If succesful i will add some more logic like failsafe.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-05T20:16:58Z",
          "body": "@sanderux Before re-working the whole mission / transition logic, should we maybe test this and try to get this in? It should enable transitions already.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-01-05T23:54:05Z",
          "body": "@LorenzMeier The commands where not picked up by the VTOL controller. The current setup doesn't use the helper classes to perform these tasks in missions. (same with takeoff / land).they are only used for navigation modes.\n\nI have added publishing the command and checking transition completion in the current style for missions. I would be an advocate of rewriting this so that the helper classes are used in missions as well. Currently that would mean changing transition, takeoff and land procedures in the mission_block.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-06T07:54:30Z",
          "body": "@sanderux With helper classes I assume you are referring to the independent nav state handlers (takeoff.cpp, land.cpp etc). I agree that we should try to reuse the handling code, like mission item creation which I already refactored for takeoff/land and RTL (common code in the super class mission_block.cpp). That should go into the direction you mean right?\n\nBut generally these navigation states can be executed standalone and therefore have different entry/exit state handling which we cannot merge. Otherwise we need to think about the general approach there.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-01-11T07:33:48Z",
          "body": "I think this can be merged. Just did another test with the rebased version.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-01-11T07:35:47Z",
          "body": "Nice!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect runtime behavior: transition commands embedded in missions were not being forwarded/picked up by the VTOL controller, so missions did not trigger transitions as intended. The changes add plumbing to publish the command and verify transition completion (and prepare for camera triggers), which corrects the program's logic/state handling without being a syntax or style fix.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 20,
        "changes": 83,
        "patch": "@@ -51,6 +51,7 @@\n \n #include <uORB/uORB.h>\n #include <uORB/topics/actuator_controls.h>\n+#include <uORB/topics/vehicle_command.h>\n \n #include \"navigator.h\"\n #include \"mission_block.h\"\n@@ -66,7 +67,8 @@ MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n \t_waypoint_yaw_reached(false),\n \t_time_first_inside_orbit(0),\n \t_actuators{},\n-\t_actuator_pub(nullptr)\n+\t_actuator_pub(nullptr),\n+\t_cmd_pub(nullptr)\n {\n }\n \n@@ -77,27 +79,48 @@ MissionBlock::~MissionBlock()\n bool\n MissionBlock::is_mission_item_reached()\n {\n-\tif (_mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO) {\n-\t\tactuator_pub_fd = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n-\t\tmemset(&actuators, 0, sizeof(actuators));\n-\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n-\t\tactuators.timestamp = hrt_absolute_time();\n-\t\torb_publish(ORB_ID(actuator_controls_2), actuator_pub_fd, &actuators);\n-\t\treturn true;\n-\t}\n-\n-\tif (_mission_item.nav_cmd == NAV_CMD_IDLE) {\n-\t\treturn false;\n-\t}\n+\t/* handle non-navigation or indefinite waypoints */\n+\tswitch (_mission_item.nav_cmd) {\n+\t\tcase NAV_CMD_DO_SET_SERVO: {\n+\t\t\tmemset(&actuators, 0, sizeof(actuators));\n+\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n+\t\t\tactuators.timestamp = hrt_absolute_time();\n+\t\t\tif (_actuator_pub != nullptr) {\n+\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n+\t\t\t} else {\n+\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t\t}\n \n-\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n-\t\treturn _navigator->get_vstatus()->condition_landed;\n-\t}\n+\t\tcase NAV_CMD_LAND:\n+\t\t\treturn _navigator->get_vstatus()->condition_landed;\n+\n+\t\t/* TODO: count turns */\n+\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n+\t\tcase NAV_CMD_IDLE: /* fall through */\n+\t\tcase NAV_CMD_LOITER_UNLIMITED:\n+\t\t\treturn false;\n+\n+\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n+\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n+\t\t\t{\n+\t\t\t/* forward the command to other processes */\n+\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n+\t\t\tstruct vehicle_command_s cmd = {};\n+\t\t\tcmd.command = _mission_item.nav_cmd;\n+\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n+\t\t\tif (_cmd_pub != nullptr) {\n+\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n+\t\t\t} else {\n+\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t\t}\n \n-\t/* TODO: count turns */\n-\tif (/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n-\t     _mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED) {\n-\t\treturn false;\n+\t\tdefault:\n+\t\t\t/* do nothing, this is a 3D waypoint */\n+\t\t\tbreak;\n \t}\n \n \thrt_abstime now = hrt_absolute_time();\n@@ -210,6 +233,26 @@ MissionBlock::reset_mission_item_reached()\n \t_time_first_inside_orbit = 0;\n }\n \n+void\n+MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd)\n+{\n+\t// we're expecting a mission command item here so assign the \"raw\" inputs to the command\n+\t// (MAV_FRAME_MISSION mission item)\n+\tcmd->param1 = item->params[0];\n+\tcmd->param2 = item->params[1];\n+\tcmd->param3 = item->params[2];\n+\tcmd->param4 = item->params[3];\n+\tcmd->param5 = item->params[4];\n+\tcmd->param6 = item->params[5];\n+\tcmd->param7 = item->params[6];\n+\n+\tcmd->target_system = _navigator->get_vstatus()->system_id;\n+\tcmd->target_component = _navigator->get_vstatus()->component_id;\n+\tcmd->source_system = _navigator->get_vstatus()->system_id;\n+\tcmd->source_component = _navigator->get_vstatus()->component_id;\n+\tcmd->confirmation = false;\n+}\n+\n void\n MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e7b21cbdc678e3ac006162275edc1a79021123f/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "patch": "@@ -111,14 +111,19 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_idle_item(struct mission_item_s *item);\n \n+\t/**\n+\t * Convert a mission item to a command\n+\t */\n+\tvoid mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd);\n+\n \tmission_item_s _mission_item;\n \tbool _waypoint_position_reached;\n \tbool _waypoint_yaw_reached;\n \thrt_abstime _time_first_inside_orbit;\n \n \tactuator_controls_s _actuators;\n \torb_advert_t    _actuator_pub;\n-\n+\torb_advert_t\t_cmd_pub;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e7b21cbdc678e3ac006162275edc1a79021123f/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -50,6 +50,7 @@\n #include <fcntl.h>\n #include <errno.h>\n #include <uORB/topics/fence.h>\n+#include <uORB/topics/vehicle_command.h>\n \n MissionFeasibilityChecker::MissionFeasibilityChecker() :\n \t_mavlink_fd(-1),\n@@ -199,7 +200,9 @@ bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, s\n \t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n \t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n-\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO) {\n+\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n+\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL &&\n+\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION) {\n \n \t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n \t\t\treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e7b21cbdc678e3ac006162275edc1a79021123f/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -103,6 +103,7 @@ struct mission_item_s {\n \tunsigned do_jump_current_count;\t/**< count how many times the jump has been done\t*/\n \tint actuator_num;               /**< actuator number to be set 0..5 ( corresponds to AUX outputs 1..6    */\n \tint actuator_value;             /**< new value for selected actuator in ms 900...2000         */\n+\tfloat params[7];\t\t/**< array to store mission command values for MAV_FRAME_MISSION ***/\n };\n #pragma pack(pop)\n #include <uORB/topics/mission.h>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e7b21cbdc678e3ac006162275edc1a79021123f/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "MissionBlock::MissionBlock",
        "MissionBlock::reset_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::MissionBlock",
          "MissionBlock::reset_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionItemValidity"
        ]
      }
    }
  },
  {
    "title": "Break down sensor combined",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4917",
    "number": 4917,
    "created_at": "2016-06-27T06:30:10Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "As discussed in https://github.com/PX4/Firmware/issues/4861\n- This reduces the size of `sensor_combined` by a factor of 10 (!) from 790 to 72 bytes.\n- move voting into sensors module. This means that now everyone using `sensor_combined` gets voted data, including ekf2. It also adds voting for the baro.\n- use relative timestamps, necessary for the new logger. Logging `sensor_combined` at full rate now only needs 18KB/s.\n- Memory savings: when using the `q` estimator, we get almost 2kB of additional RAM, with ekf2 it's roughly 0.6kB. This is because ekf2 did not do voting, and voting itself is quite heavy, it requires 1.5kB.\n\nThis introduces a lot of changes at central places, affecting all estimators. Nothing complex, but still, it needs careful review and testing all of the estimators.\n\nI still plan to break up the sensors class into several smaller classes to make things easier to maintain.\n",
      "issue_comments": [
        {
          "author": "bkueng",
          "created_at": "2016-06-28T18:31:59Z",
          "body": "This was flight tested with inav and q estimators.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-06T07:31:55Z",
          "body": "@bkueng What is the value of renaming sensor_accel to sensor_accel_raw? Unless there is clear value on top of just naming I would like to avoid that change.\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-06T07:39:50Z",
          "body": "It makes it more clear that it's the raw sensor data from the driver. Initially I planned to split up sensor_combined into several topics which would have gotten the name `sensor_accel` etc. However as sensor_combined is now really small, it's not necessary to split it, so the topic rename is not strictly necessary either.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-06T08:01:52Z",
          "body": "I don't think that the rename at this point adds significant clarity and I know that a lot of people are using the topics directly. So I think that's a change we shouldn't make at this point.\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-06T08:18:49Z",
          "body": "Fine with me. I'll drop it when rebasing. Do you plan to merge it now?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-06T08:38:18Z",
          "body": "Yes, I think it makes sense to get these in.\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-06T09:16:23Z",
          "body": "rebased & dropped sensor topics renaming\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-06T13:51:18Z",
          "body": "@julianoes I agree in both cases. I discussed this with @tumbili and he prefered the integral because the estimators use it. But when looking at the overall usage, most places need the value, not the integral. Personally I also prefer the values.\nPlus when thinking about the new logger, the value can be plotted directly.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-07-06T14:11:57Z",
          "body": "I like the changes overall but I would vote to change the sensor_combined struct and make the API as simple as possible for devs.\n\nTherefore, I'd publish the accel/gyro/mag values without integral plus timestamp. If an estimator really wants integrals, it should just multiply the values with delta_t. I think this would make it cleaner and also better performance-wise because it would lead to less divisions.\nI'm just not sold on the idea of integrals instead of intuitive values.\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-06T14:18:24Z",
          "body": "just to be clear, you mean like this? sensor_combined.msg:\n\n```\nfloat32[3] gyro_rad\nfloat gyro_integral_dt # in seconds\n\nint32 accelerometer_timestamp_relative\nfloat32[3] accelerometer_m_s\nfloat accelerometer_integral_dt \n\nint32 magnetometer_timestamp_relative\nfloat32[3] magnetometer_ga  \n\nint32 baro_timestamp_relative\nfloat32 baro_alt_meter      \nfloat32 baro_temp_celcius\n```\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-07-06T14:32:39Z",
          "body": "@bkueng yes that's what I would suggest.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-06T14:56:35Z",
          "body": "Looks sensible to me.\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-06T17:04:41Z",
          "body": "ok if no one objects, I'll change this.\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2016-07-07T08:54:19Z",
          "body": "refactored to the above format\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-07T09:36:17Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "julianoes",
          "created_at": "2016-07-06T13:18:08Z",
          "body": "Having to add the division through dt everywhere seems painful. Of course, you've done it already, I'm just thinking of devs that will get confused. Are we sure we want to do this?\n",
          "path": "src/drivers/frsky_telemetry/frsky_data.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-07-06T13:23:46Z",
          "body": "I would argue this should be a `float32` in seconds. I'm not completely happy that you need to do `/ 1.e6f;` everywhere below.\n",
          "path": "msg/sensor_combined.msg",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR is primarily a refactor/performance and API change (reducing message size, moving voting into the sensors module, switching to relative timestamps) rather than a fix for incorrect program logic. While it changes behavior (e.g. making voted data available to all consumers), there is no indication in the description or reviews that it corrects an existing erroneous output or behavior â€” it's an intentional redesign/optimization, not a bugfix.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -500,7 +500,7 @@ Navigator::task_main()\n \t\tif (have_geofence_position_data &&\n \t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n \t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n-\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n+\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter, _home_pos, home_position_valid());\n \t\t\tlast_geofence_check = hrt_absolute_time();\n \t\t\thave_geofence_position_data = false;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9a954af24d9053ac70f2e315fa4239d4b6d9f81f/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "Stable",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4895",
    "number": 4895,
    "created_at": "2016-06-24T07:13:11Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "idandan0924",
      "body": "",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "There is no PR description, code diffs, comments, or review context to indicate what the change does. Without details indicating corrected incorrect behavior, state transitions, or algorithmic fixes, I cannot determine this addresses a logic error.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -684,6 +684,11 @@ Navigator::publish_position_setpoint_triplet()\n \t/* update navigation state */\n \t_pos_sp_triplet.nav_state = _vstatus.nav_state;\n \n+\t/* do not publish an empty triplet */\n+\tif (!_pos_sp_triplet.current.valid) {\n+\t\treturn;\n+\t}\n+\n \t/* lazily publish the position setpoint triplet only once available */\n \tif (_pos_sp_triplet_pub != nullptr) {\n \t\torb_publish(ORB_ID(position_setpoint_triplet), _pos_sp_triplet_pub, &_pos_sp_triplet);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/403d76c7a7ff7d6a1413f23ee15bd7f07c6d3254/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::publish_position_setpoint_triplet"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_position_setpoint_triplet"
        ]
      }
    }
  },
  {
    "title": "Fw vtol no airspeed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4813",
    "number": 4813,
    "created_at": "2016-06-14T08:51:44Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-06-14T08:52:49Z",
          "body": "@sanderux I was looking at it and noticed that with this implementation we will not be blending controls during the transition. Might make sense to blend the controls based on time just like it's done for the backtransition.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-15T22:12:04Z",
          "body": "i'll get that in, do you think it's ok to base it on min trans time, or should i add a seperate param?\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T08:35:36Z",
          "body": "@sanderux I think min trans time is ok.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The discussion indicates the change affects VTOL transition behavior when no airspeed is available and that the current implementation omitted blending controls during transition. Missing control blending during a state transition is an improper state transition/logic error; the comments propose adding time-based blending (using min transition time) to correct the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -127,7 +127,14 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n \t\t\t} else {\n \t\t\t\t_navigator->set_cruising_speed();\n+\t\t\t\t/* if no speed target was given try to set throttle */\n+\t\t\t\tif (_mission_item.params[2] > 0.0f) {\n+\t\t\t\t\t_navigator->set_cruising_throttle(_mission_item.params[2] / 100);\n+\t\t\t\t} else {\n+\t\t\t\t\t_navigator->set_cruising_throttle();\n+\t\t\t\t}\n \t\t\t}\n+\n \t\t\treturn true;\n \n \t\tdefault:\n@@ -367,6 +374,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->acceptance_radius = item->acceptance_radius;\n \tsp->disable_mc_yaw_control = false;\n \tsp->cruising_speed = _navigator->get_cruising_speed();\n+\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_IDLE:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/199239e780c19f4fccc3cbc9bdf3f0f2a4070e96/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "patch": "@@ -178,6 +178,19 @@ class Navigator : public control::SuperBlock\n \t */\n \tvoid\t\tset_cruising_speed(float speed=-1.0f) { _mission_cruising_speed = speed; }\n \n+\n+\t/**\n+\t * Get the target throttle\n+\t *\n+\t * @return the desired throttle for this mission\n+\t */\n+\tfloat\t\tget_cruising_throttle();\n+\n+\t/**\n+\t * Set the target throttle\n+\t */\n+\tvoid\t\tset_cruising_throttle(float throttle=-1.0f) { _mission_throttle = throttle; }\n+\n \t/**\n \t * Get the acceptance radius given the mission item preset radius\n \t *\n@@ -277,8 +290,10 @@ class Navigator : public control::SuperBlock\n \t\n \tcontrol::BlockParamFloat _param_cruising_speed_hover;\n \tcontrol::BlockParamFloat _param_cruising_speed_plane;\n+\tcontrol::BlockParamFloat _param_cruising_throttle_plane;\n \n \tfloat _mission_cruising_speed;\n+\tfloat _mission_throttle;\n \n \t/**\n \t * Retrieve global position",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/199239e780c19f4fccc3cbc9bdf3f0f2a4070e96/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "patch": "@@ -159,6 +159,7 @@ Navigator::Navigator() :\n \t_param_rcloss_act(this, \"RCL_ACT\"),\n \t_param_cruising_speed_hover(this, \"MPC_XY_CRUISE\", false),\n \t_param_cruising_speed_plane(this, \"FW_AIRSPD_TRIM\", false),\n+\t_param_cruising_throttle_plane(this, \"FW_THR_CRUISE\", false),\n \t_mission_cruising_speed(-1.0f)\n {\n \t/* Create a list of our possible navigation types */\n@@ -724,6 +725,17 @@ Navigator::get_cruising_speed()\n \t}\n }\n \n+float\n+Navigator::get_cruising_throttle()\n+{\n+\t/* Return the mission-requested cruise speed, or default FW_THR_CRUISE value */\n+\tif (_mission_throttle > 0.0f) {\n+\t\treturn _mission_throttle;\n+\t} else {\n+\t\treturn _param_cruising_throttle_plane.get();\n+\t}\n+}\n+\n float\n Navigator::get_acceptance_radius(float mission_item_radius)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/199239e780c19f4fccc3cbc9bdf3f0f2a4070e96/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint",
        "Navigator::get_cruising_speed",
        "MissionBlock::is_mission_item_reached",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_cruising_speed",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Implement throttle setting for MAV_CMD_DO_CHANGE_SPEED",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4790",
    "number": 4790,
    "created_at": "2016-06-09T23:19:56Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes https://github.com/PX4/Firmware/issues/4786\n\nThis implements the throttle value of the mission command \"Change speed\"\nAttaching this to the no-airspeed PR as it only has (serious) effect when disabling airspeed sensor\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-06-10T07:03:14Z",
          "body": "@tumbili Can you review? Looks good for me.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-06-10T15:58:39Z",
          "body": "Have you flown this outside @sanderux? I'm just curious how consistently you actually keep the desired throttle? If the commanded throttle isn't sufficient for the altitude setpoint it's going to be ignored anyway.\nhttps://github.com/PX4/Firmware/blob/master/src/lib/external_lgpl/tecs/tecs.cpp#L312\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-10T21:56:51Z",
          "body": "@dagar i havent flown it outside yet. it's true that tecs will balance the throttle with the altitude but there does seem to be a limit to that.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-06-21T08:23:43Z",
          "body": "@sanderux Will merge once flown\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T13:10:53Z",
          "body": "@LorenzMeier @sanderux @dagar Did a review and it looks good (did a minor comment on variable naming). So next thing here is a log from a flight test.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T14:04:36Z",
          "body": "@sanderux Personally I think this change will not change much. TECS will adjust its throttle integrator until it's back at the old desired value. You can verify this in SITL by the way.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-06-21T14:55:29Z",
          "body": "Right, it's the same as just changing FW_THR_CRUISE.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-21T19:24:23Z",
          "body": "@tumbili ready to go\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-21T19:31:00Z",
          "body": "@dagar applying this will only make sense when airspeed sensor is disabled. at that point tecs will disregard airspeed and only change throttle if required for altitude. This will enable vtol's with no airspeed sensor to decrease speed before backtransition or increase speed when climbing significantly. a typical mission would be:\n- vtol takeoff 20m\n- throttle to 80%\n- climb to 150m\n- throttle to 40%\n- cruise towards destination\n- descend to 20m\n- throttle to 20%\n- vtol_land \n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T20:59:58Z",
          "body": "Closing in favour of #4770\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T12:49:13Z",
          "body": "@sanderux Why is the argument called 'percent'? Aren't you passing a throttle value?\n",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-21T12:57:27Z",
          "body": "@tumbili no, QGC asks for a percentage. mavlink also specs this: https://pixhawk.ethz.ch/mavlink/#MAV_CMD_DO_CHANGE_SPEED\n\nFW_THR_CRUISE is also a percentage and tecs expects a percentage here\n",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T13:09:42Z",
          "body": "@sanderux Yeah, the mission item holds a throttle percentage but the function 'set_cruising_throttle' takes as argument a throttle value between 0 and 1.\n",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-21T13:11:31Z",
          "body": "Ok, shall i just call it throttle, or value then?\n",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-21T13:12:57Z",
          "body": "@sanderux throttle is good.\n",
          "path": "src/modules/navigator/navigator.h",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR implements handling of the throttle parameter for MAV_CMD_DO_CHANGE_SPEED which was previously ignored, causing the mission throttle request to have no effect â€” an incorrect program behavior. Although TECS and other flight logic may limit or override throttle (so effect can be constrained), the omission of applying the command parameter is a logic bug (unexpected/undesired behavior) that this PR fixes.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -127,7 +127,14 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n \t\t\t} else {\n \t\t\t\t_navigator->set_cruising_speed();\n+\t\t\t\t/* if no speed target was given try to set throttle */\n+\t\t\t\tif (_mission_item.params[2] > 0.0f) {\n+\t\t\t\t\t_navigator->set_cruising_throttle(_mission_item.params[2] / 100);\n+\t\t\t\t} else {\n+\t\t\t\t\t_navigator->set_cruising_throttle();\n+\t\t\t\t}\n \t\t\t}\n+\n \t\t\treturn true;\n \n \t\tdefault:\n@@ -367,6 +374,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->acceptance_radius = item->acceptance_radius;\n \tsp->disable_mc_yaw_control = false;\n \tsp->cruising_speed = _navigator->get_cruising_speed();\n+\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_IDLE:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/199239e780c19f4fccc3cbc9bdf3f0f2a4070e96/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "patch": "@@ -178,6 +178,19 @@ class Navigator : public control::SuperBlock\n \t */\n \tvoid\t\tset_cruising_speed(float speed=-1.0f) { _mission_cruising_speed = speed; }\n \n+\n+\t/**\n+\t * Get the target throttle\n+\t *\n+\t * @return the desired throttle for this mission\n+\t */\n+\tfloat\t\tget_cruising_throttle();\n+\n+\t/**\n+\t * Set the target throttle\n+\t */\n+\tvoid\t\tset_cruising_throttle(float throttle=-1.0f) { _mission_throttle = throttle; }\n+\n \t/**\n \t * Get the acceptance radius given the mission item preset radius\n \t *\n@@ -277,8 +290,10 @@ class Navigator : public control::SuperBlock\n \t\n \tcontrol::BlockParamFloat _param_cruising_speed_hover;\n \tcontrol::BlockParamFloat _param_cruising_speed_plane;\n+\tcontrol::BlockParamFloat _param_cruising_throttle_plane;\n \n \tfloat _mission_cruising_speed;\n+\tfloat _mission_throttle;\n \n \t/**\n \t * Retrieve global position",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/199239e780c19f4fccc3cbc9bdf3f0f2a4070e96/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "patch": "@@ -159,6 +159,7 @@ Navigator::Navigator() :\n \t_param_rcloss_act(this, \"RCL_ACT\"),\n \t_param_cruising_speed_hover(this, \"MPC_XY_CRUISE\", false),\n \t_param_cruising_speed_plane(this, \"FW_AIRSPD_TRIM\", false),\n+\t_param_cruising_throttle_plane(this, \"FW_THR_CRUISE\", false),\n \t_mission_cruising_speed(-1.0f)\n {\n \t/* Create a list of our possible navigation types */\n@@ -724,6 +725,17 @@ Navigator::get_cruising_speed()\n \t}\n }\n \n+float\n+Navigator::get_cruising_throttle()\n+{\n+\t/* Return the mission-requested cruise speed, or default FW_THR_CRUISE value */\n+\tif (_mission_throttle > 0.0f) {\n+\t\treturn _mission_throttle;\n+\t} else {\n+\t\treturn _param_cruising_throttle_plane.get();\n+\t}\n+}\n+\n float\n Navigator::get_acceptance_radius(float mission_item_radius)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/199239e780c19f4fccc3cbc9bdf3f0f2a4070e96/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint",
        "Navigator::get_cruising_speed",
        "MissionBlock::is_mission_item_reached",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_cruising_speed",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Comply with altitude for VTOL_LAND mission item",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4785",
    "number": 4785,
    "created_at": "2016-06-09T09:26:19Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "fixes https://github.com/PX4/Firmware/issues/4784\n",
      "issue_comments": [
        {
          "author": "sanderux",
          "created_at": "2016-06-30T20:59:16Z",
          "body": "@LorenzMeier AFAIK ready to merge\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-10T10:52:13Z",
          "body": "Doesn't look ready. It changes the logic entirely and it makes assumptions about magic values.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-07-10T10:55:15Z",
          "body": "The magic value is in QGC, it defaults the mission_item altitude to 0.\nBut you're right, it should check if it is different from 0, not just below zero.\nor do you think we should ignore the mission_item's altitude all together?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-07-23T23:18:53Z",
          "body": "@LorenzMeier i addressed your comment, can you review bearing in mind that QGC defaults the altitude parameter to 0 on a VTOL_LAND command?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-08-01T06:56:48Z",
          "body": "@LorenzMeier is this ready to merge?\n",
          "type": "issue_comment"
        },
        {
          "author": "PX4BuildBot",
          "created_at": "2016-10-19T19:53:03Z",
          "body": "Can one of the admins verify this patch?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-10-27T00:10:48Z",
          "body": "It seems like MAV_CMD_NAV_VTOL_LAND needs a separate transition altitude and landing altitude.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-10-27T09:04:00Z",
          "body": "@LorenzMeier can you review this again? (note that stable QGC sets altitude to 0 by default for VTOL_LAND)\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-11-08T03:46:52Z",
          "body": "@sanderux does it make sense now that VTOL_LAND specifies the landing coordinates (lat, lon, alt) just like regular LAND? The QGC default is 0 relative to home. Could we add an additional optional param to VTOL_LAND that also specifics the back transition altitude?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-11-08T08:27:57Z",
          "body": "I think we need a different discussion on the meaning of altitude in a land command as it does not seem to perform what i would expect.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-12-20T00:53:13Z",
          "body": "closing in favor of changes pending from https://github.com/PX4/Firmware/issues/5824",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-07-10T10:51:46Z",
          "body": "So if I fly at sea level an altitude request of 0 meters will be rejected? This doesn't look completely thought out.\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The discussion centers on incorrect handling of the VTOL_LAND mission item's altitude (misinterpreting a QGC default/magic value and when to apply or ignore the altitude), which is a behavioural/logic problem. The PR attempts to change that logic but reviewers flagged incorrect assumptions about magic values and the PR was ultimately closed in favor of a different approach.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "patch": "@@ -523,13 +523,17 @@ Mission::set_mission_items()\n \t\t\t/* use current mission item as next position item */\n \t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n \t\t\thas_next_position_item = true;\n-\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n-\t\t\tif (pos_sp_triplet->current.valid) {\n-\t\t\t\taltitude = pos_sp_triplet->current.alt;\n+\n+\t\t\t/* hold current altitude when no altitude is given, QGC defaults this to 0 */\n+\t\t\tif (_mission_item.altitude < 0.01f && _mission_item.altitude > -0.01f ) {\n+\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n+\t\t\t\tif (pos_sp_triplet->current.valid) {\n+\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n+\t\t\t\t}\n+\t\t\t\t_mission_item.altitude = altitude;\n+\t\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t}\n \n-\t\t\t_mission_item.altitude = altitude;\n-\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.time_inside = 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc9be3830da6b32658a17838aa3ec5a7fbe8a517/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ]
      }
    }
  },
  {
    "title": "Enable FW without airspeed sensor",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4770",
    "number": 4770,
    "created_at": "2016-06-08T09:33:06Z",
    "merged": true,
    "merged_at": "2016-06-23T07:28:06Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "Enables flying a fw / vtol without an airspeed sensor.\nThe new mode parameter enables 3 different modes:\n\n1) Use values from airspeed sensor\n2) Approximate airspeed with ground velocity (good if wind-still, e.g indoors with VICON )\n3) Declare airspeed invalid, controllers will assume trim speed (e.g. TECS or fw attitude controller)\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-06-08T11:14:33Z",
          "body": "Jenkins test this please!\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-08T12:51:35Z",
          "body": "Very nice. To enable VTOL transitions without ASPS we need to change the transition logic to consider this param. A new (or existing param) should be used to add a time constant (front transition time).\nAt the moment we have a VT_F_TRANS_DUR (front transition duration) param which in effect is the ramp-up time for the pusher motor. To avoid confusion i propose to rename this to VT_F_TRANS_RAMP and use VT_F_TRANS_TIME as the new constant.\n\nAlternatively we could rely on VT_TRANS_MIN_TM but this will have defaulted to low values by now.\n@tumbili ?\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-08T12:54:12Z",
          "body": "SITL flies very well on mode 2 (disable airspeed) (transition still looks at airspeed) but the FW flights holds well even at very low airspeeds. TECS does respond too slow to compensate for stalls when the throttle trim is too low but it nicely balances banking etc.\n",
          "type": "issue_comment"
        },
        {
          "author": "melisab",
          "created_at": "2016-06-08T16:21:26Z",
          "body": "So, in VTOL we need to use ground speed estimation to replace indicated_airspeed_m_s ? \n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-08T19:24:46Z",
          "body": "@melisab You certainly don't need to do this and if you have an airspeed sensor available I certainly don't recommend you to do this.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-08T21:09:22Z",
          "body": "@tumbili i added initial support for vtol transition based on minimum transition time. Works very nice in sitl. tested a few scenarios, no regression.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-08T21:41:50Z",
          "body": "![image](https://cloud.githubusercontent.com/assets/14801663/15911879/ed479cba-2dd1-11e6-871d-36c8bf01022c.png)\n\nNotes on flying VTOL without airspeed sensor:\n- Make sure your FW_THR_CRUISE is set to a sensible level.\n- Set the airspeed sensor circuit braker\n- Set VT_TRANS_MIN_TM higher (this is the time it will take to transition)\n- Set VT_F_TRANS_DUR lower (this is the time the pusher takes to ramp up, 1 second should be good)\n",
          "type": "issue_comment"
        },
        {
          "author": "melisab",
          "created_at": "2016-06-18T01:38:01Z",
          "body": "The problem with relying on ground speed is that when there is tailwind then there won't be enough lift to transition from MC to FW.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-18T01:43:06Z",
          "body": "@melisab relying on fixed throttle settings is not the same as relying on ground speed. this would however only work when the fixed throttle is significantly above stall speed.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-21T20:03:49Z",
          "body": "@tumbili time based blending is in\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-22T09:16:09Z",
          "body": "@sanderux This needs testing now. I'll do some basic tests in SITL.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-06-22T11:27:10Z",
          "body": "@sanderux Tested all three modes in SITL, works as expected.\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2016-06-22T11:46:16Z",
          "body": "@tumbili considering all these changes only have impact on disabled airspeed sensor i see no possibility for regression. I think it's safe to merge this but i'll leave that up to you. I will test fly but that might be a while.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-06-22T13:43:55Z",
          "body": "@tumbili The publish logic for EKF1 is missing, which is what planes are using still today.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes control logic to handle cases where the airspeed sensor is unavailable or unreliable by adding three modes (use sensor, approximate from ground speed, declare invalid and assume trim). This corrects incorrect/undesired behavior (e.g., VTOL transition and FW controllers relying on invalid airspeed) and updates transition/blending logic to avoid unsafe state transitions, which fits the definition of a logic error fix.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -127,7 +127,14 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n \t\t\t} else {\n \t\t\t\t_navigator->set_cruising_speed();\n+\t\t\t\t/* if no speed target was given try to set throttle */\n+\t\t\t\tif (_mission_item.params[2] > 0.0f) {\n+\t\t\t\t\t_navigator->set_cruising_throttle(_mission_item.params[2] / 100);\n+\t\t\t\t} else {\n+\t\t\t\t\t_navigator->set_cruising_throttle();\n+\t\t\t\t}\n \t\t\t}\n+\n \t\t\treturn true;\n \n \t\tdefault:\n@@ -367,6 +374,7 @@ MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *ite\n \tsp->acceptance_radius = item->acceptance_radius;\n \tsp->disable_mc_yaw_control = false;\n \tsp->cruising_speed = _navigator->get_cruising_speed();\n+\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n \n \tswitch (item->nav_cmd) {\n \tcase NAV_CMD_IDLE:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/27e61127a814830139c35d430df921dfb1c088b8/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "patch": "@@ -178,6 +178,19 @@ class Navigator : public control::SuperBlock\n \t */\n \tvoid\t\tset_cruising_speed(float speed=-1.0f) { _mission_cruising_speed = speed; }\n \n+\n+\t/**\n+\t * Get the target throttle\n+\t *\n+\t * @return the desired throttle for this mission\n+\t */\n+\tfloat\t\tget_cruising_throttle();\n+\n+\t/**\n+\t * Set the target throttle\n+\t */\n+\tvoid\t\tset_cruising_throttle(float throttle=-1.0f) { _mission_throttle = throttle; }\n+\n \t/**\n \t * Get the acceptance radius given the mission item preset radius\n \t *\n@@ -277,8 +290,10 @@ class Navigator : public control::SuperBlock\n \t\n \tcontrol::BlockParamFloat _param_cruising_speed_hover;\n \tcontrol::BlockParamFloat _param_cruising_speed_plane;\n+\tcontrol::BlockParamFloat _param_cruising_throttle_plane;\n \n \tfloat _mission_cruising_speed;\n+\tfloat _mission_throttle;\n \n \t/**\n \t * Retrieve global position",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/27e61127a814830139c35d430df921dfb1c088b8/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "patch": "@@ -159,6 +159,7 @@ Navigator::Navigator() :\n \t_param_rcloss_act(this, \"RCL_ACT\"),\n \t_param_cruising_speed_hover(this, \"MPC_XY_CRUISE\", false),\n \t_param_cruising_speed_plane(this, \"FW_AIRSPD_TRIM\", false),\n+\t_param_cruising_throttle_plane(this, \"FW_THR_CRUISE\", false),\n \t_mission_cruising_speed(-1.0f)\n {\n \t/* Create a list of our possible navigation types */\n@@ -725,6 +726,17 @@ Navigator::get_cruising_speed()\n \t}\n }\n \n+float\n+Navigator::get_cruising_throttle()\n+{\n+\t/* Return the mission-requested cruise speed, or default FW_THR_CRUISE value */\n+\tif (_mission_throttle > 0.0f) {\n+\t\treturn _mission_throttle;\n+\t} else {\n+\t\treturn _param_cruising_throttle_plane.get();\n+\t}\n+}\n+\n float\n Navigator::get_acceptance_radius(float mission_item_radius)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/27e61127a814830139c35d430df921dfb1c088b8/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint",
        "Navigator::get_cruising_speed",
        "MissionBlock::is_mission_item_reached",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_cruising_speed",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Added tracker to navigator to record the recent path.",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4726",
    "number": 4726,
    "created_at": "2016-06-03T12:23:06Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "samuelsadok",
      "body": "A tracker module for the navigator records the recently flown path. A new flight mode is introduced to enable flying back along this path (though it doesn't look smooth yet).\n",
      "issue_comments": [
        {
          "author": "PX4BuildBot",
          "created_at": "2016-10-19T19:53:06Z",
          "body": "Can one of the admins verify this patch?\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-10-19T23:04:13Z",
          "body": "@samuelsadok can you rebase?\n",
          "type": "issue_comment"
        },
        {
          "author": "samuelsadok",
          "created_at": "2016-10-23T13:57:25Z",
          "body": "This pull request is now superseded by #5735. I therefore recommend to focus on that new request and suggest we close this one.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR adds a new tracker module and a flight mode to replay a recent path â€” this is a new feature, not a fix to incorrect behavior. There is no mention of correcting wrong logic, state transitions, or unexpected outputs; the author also notes the change is superseded by another PR, indicating this was not presented as a logic bug fix.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -42,15 +42,17 @@ px4_add_module(\n \t\tmission.cpp\n \t\tloiter.cpp\n \t\trtl.cpp\n+\t\trcrecover.cpp\n+\t\trcloss.cpp\n+\t\tdatalinkloss.cpp\n \t\ttakeoff.cpp\n \t\tland.cpp\n \t\tmission_feasibility_checker.cpp\n \t\tgeofence.cpp\n-\t\tdatalinkloss.cpp\n-\t\trcloss.cpp\n \t\tenginefailure.cpp\n \t\tgpsfailure.cpp\n \t\tfollow_target.cpp\n+\t\ttracker.cpp\n \tDEPENDS\n \t\tplatforms__common\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -113,7 +113,7 @@ struct mission_item_s {\n \tfloat time_inside;\t\t/**< time that the MAV should stay inside the radius before advancing in seconds */\n \tfloat pitch_min;\t\t/**< minimal pitch angle for fixed wing takeoff waypoints */\n \tbool autocontinue;\t\t/**< true if next waypoint should follow after this one */\n-\tunsigned origin;\t\t/**< where the waypoint has been generated\t\t*/\n+\tenum ORIGIN origin;\t\t/**< where the waypoint has been generated\t\t*/\n \tint do_jump_mission_index;\t/**< index where the do jump will go to                 */\n \tunsigned do_jump_repeat_count;\t/**< how many times do jump needs to be done            */\n \tunsigned do_jump_current_count;\t/**< count how many times the jump has been done\t*/",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 33,
        "deletions": 19,
        "changes": 52,
        "patch": "@@ -52,6 +52,7 @@\n #include <uORB/topics/vehicle_control_mode.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/vehicle_global_position.h>\n+#include <uORB/topics/vehicle_local_position.h>\n #include <uORB/topics/vehicle_gps_position.h>\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/mission_result.h>\n@@ -65,17 +66,19 @@\n #include \"takeoff.h\"\n #include \"land.h\"\n #include \"rtl.h\"\n+#include \"rcrecover.h\"\n+#include \"rcloss.h\"\n #include \"datalinkloss.h\"\n #include \"enginefailure.h\"\n #include \"follow_target.h\"\n #include \"gpsfailure.h\"\n-#include \"rcloss.h\"\n #include \"geofence.h\"\n+#include \"tracker.h\"\n \n /**\n  * Number of navigation modes that need on_active/on_inactive calls\n  */\n-#define NAVIGATOR_MODE_ARRAY_SIZE 10\n+#define NAVIGATOR_MODE_ARRAY_SIZE 11\n \n class Navigator : public control::SuperBlock\n {\n@@ -137,6 +140,7 @@ class Navigator : public control::SuperBlock\n \tstruct vehicle_land_detected_s*\t    get_land_detected() { return &_land_detected; }\n \tstruct vehicle_control_mode_s*\t    get_control_mode() { return &_control_mode; }\n \tstruct vehicle_global_position_s*   get_global_position() { return &_global_pos; }\n+\tstruct vehicle_local_position_s*    get_local_position() { return &_local_pos; }\n \tstruct vehicle_gps_position_s*\t    get_gps_position() { return &_gps_pos; }\n \tstruct sensor_combined_s*\t    get_sensor_combined() { return &_sensor_combined; }\n \tstruct home_position_s*\t\t    get_home_position() { return &_home_pos; }\n@@ -153,6 +157,8 @@ class Navigator : public control::SuperBlock\n \tGeofence&\tget_geofence() { return _geofence; }\n \tbool\t\tget_can_loiter_at_sp() { return _can_loiter_at_sp; }\n \tfloat\t\tget_loiter_radius() { return _param_loiter_radius.get(); }\n+\t\n+\tTracker&\tget_tracker() { return _tracker; }\n \n \t/**\n \t * Returns the default acceptance radius defined by the parameter\n@@ -223,17 +229,18 @@ class Navigator : public control::SuperBlock\n \torb_advert_t\t_mavlink_log_pub;\t\t/**< the uORB advert to send messages over mavlink */\n \n \tint\t\t_global_pos_sub;\t\t/**< global position subscription */\n-\tint\t\t_gps_pos_sub;\t\t/**< gps position subscription */\n-\tint\t\t_sensor_combined_sub;\t\t/**< sensor combined subscription */\n+\tint\t\t_local_pos_sub;\t\t\t/**< local position subscription */\n+\tint\t\t_gps_pos_sub;\t\t\t/**< gps position subscription */\n+\tint\t\t_sensor_combined_sub;\t/**< sensor combined subscription */\n \tint\t\t_home_pos_sub;\t\t\t/**< home position subscription */\n \tint\t\t_vstatus_sub;\t\t\t/**< vehicle status subscription */\n \tint\t\t_land_detected_sub;\t\t/**< vehicle land detected subscription */\n \tint\t\t_fw_pos_ctrl_status_sub;\t\t/**< notification of vehicle capabilities updates */\n \tint\t\t_control_mode_sub;\t\t/**< vehicle control mode subscription */\n-\tint\t\t_onboard_mission_sub;\t\t/**< onboard mission subscription */\n-\tint\t\t_offboard_mission_sub;\t\t/**< offboard mission subscription */\n+\tint\t\t_onboard_mission_sub;\t/**< onboard mission subscription */\n+\tint\t\t_offboard_mission_sub;\t/**< offboard mission subscription */\n \tint\t\t_param_update_sub;\t\t/**< param update subscription */\n-\tint\t\t_vehicle_command_sub;\t\t/**< vehicle commands (onboard and offboard) */\n+\tint\t\t_vehicle_command_sub;\t/**< vehicle commands (onboard and offboard) */\n \n \torb_advert_t\t_pos_sp_triplet_pub;\t\t/**< publish position setpoint triplet */\n \torb_advert_t\t_mission_result_pub;\n@@ -246,6 +253,7 @@ class Navigator : public control::SuperBlock\n \tvehicle_land_detected_s\t\t\t\t_land_detected;\t\t/**< vehicle land_detected */\n \tvehicle_control_mode_s\t\t\t\t_control_mode;\t\t/**< vehicle control mode */\n \tvehicle_global_position_s\t\t\t_global_pos;\t\t/**< global vehicle position */\n+\tvehicle_local_position_s\t\t\t_local_pos;\t\t\t/**< local vehicle position */\n \tvehicle_gps_position_s\t\t\t\t_gps_pos;\t\t/**< gps position */\n \tsensor_combined_s\t\t\t\t_sensor_combined;\t/**< sensor values */\n \thome_position_s\t\t\t\t\t_home_pos;\t\t/**< home position for RTL */\n@@ -268,24 +276,25 @@ class Navigator : public control::SuperBlock\n \tbool\t\t_geofence_violation_warning_sent; /**< prevents spaming to mavlink */\n \n \tbool\t\t_inside_fence;\t\t\t/**< vehicle is inside fence */\n+\t\n+\tTracker\t\t_tracker;\t\t\t\t/**< tracks the vehicle path **/\n \n \tbool\t\t_can_loiter_at_sp;\t\t\t/**< flags if current position SP can be used to loiter */\n \tbool\t\t_pos_sp_triplet_updated;\t\t/**< flags if position SP triplet needs to be published */\n \tbool \t\t_pos_sp_triplet_published_invalid_once;\t/**< flags if position SP triplet has been published once to UORB */\n \tbool\t\t_mission_result_updated;\t\t/**< flags if mission result has seen an update */\n \n \tNavigatorMode\t*_navigation_mode;\t\t/**< abstract pointer to current navigation mode class */\n-\tMission\t\t_mission;\t\t\t/**< class that handles the missions */\n-\tLoiter\t\t_loiter;\t\t\t/**< class that handles loiter */\n-\tTakeoff\t\t_takeoff;\t\t\t/**< class for handling takeoff commands */\n-\tLand\t\t_land;\t\t\t/**< class for handling land commands */\n-\tRTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */\n-\tRCLoss \t\t_rcLoss;\t\t\t\t/**< class that handles RTL according to\n-\t\t\t\t\t\t\t  OBC rules (rc loss mode) */\n-\tDataLinkLoss\t_dataLinkLoss;\t\t\t/**< class that handles the OBC datalink loss mode */\n-\tEngineFailure\t_engineFailure;\t\t\t/**< class that handles the engine failure mode\n-\t\t\t\t\t\t\t  (FW only!) */\n-\tGpsFailure\t_gpsFailure;\t\t\t/**< class that handles the OBC gpsfailure loss mode */\n+\tMission\t\t_mission;\t\t\t\t\t/**< class that handles the missions */\n+\tLoiter\t\t_loiter;\t\t\t\t\t/**< class that handles loiter */\n+\tTakeoff\t\t_takeoff;\t\t\t\t\t/**< class for handling takeoff commands */\n+\tLand\t\t_land;\t\t\t\t\t\t/**< class for handling land commands */\n+\tRTL \t\t_rtl;\t\t\t\t\t\t/**< class that handles return-to-land */\n+\tRCRecover\t_rcRecover;\t\t\t\t\t/**< class that handles RC recovery */\n+\tRCLoss \t\t_rcLoss;\t\t\t\t\t/**< class that handles RC loss according to OBC rules (rc loss mode) */\n+\tDataLinkLoss\t_dataLinkLoss;\t\t\t/**< class that handles datalink loss according OBC rules */\n+\tEngineFailure\t_engineFailure;\t\t\t/**< class that handles the engine failure mode (FW only!) */\n+\tGpsFailure\t_gpsFailure;\t\t\t\t/**< class that handles the OBC gpsfailure loss mode */\n \n \tFollowTarget _follow_target;\n \n@@ -296,7 +305,7 @@ class Navigator : public control::SuperBlock\n \tcontrol::BlockParamFloat _param_fw_alt_acceptance_radius;\t/**< acceptance radius for fixedwing altitude */\n \tcontrol::BlockParamFloat _param_mc_alt_acceptance_radius;\t/**< acceptance radius for multicopter altitude */\n \tcontrol::BlockParamInt _param_datalinkloss_act;\t/**< select data link loss action */\n-\tcontrol::BlockParamInt _param_rcloss_act;\t/**< select data link loss action */\n+\tcontrol::BlockParamInt _param_rcloss_act;\t/**< select RC loss action */\n \t\n \tcontrol::BlockParamFloat _param_cruising_speed_hover;\n \tcontrol::BlockParamFloat _param_cruising_speed_plane;\n@@ -310,6 +319,11 @@ class Navigator : public control::SuperBlock\n \t */\n \tvoid\t\tglobal_position_update();\n \n+\t/**\n+\t * Retrieve local position\n+\t */\n+\tvoid\t\tlocal_position_update();\n+\n \t/**\n \t * Retrieve gps position\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 9,
        "changes": 48,
        "patch": "@@ -104,6 +104,7 @@ Navigator::Navigator() :\n \t_navigator_task(-1),\n \t_mavlink_log_pub(nullptr),\n \t_global_pos_sub(-1),\n+\t_local_pos_sub(-1),\n \t_gps_pos_sub(-1),\n \t_sensor_combined_sub(-1),\n \t_home_pos_sub(-1),\n@@ -123,6 +124,7 @@ Navigator::Navigator() :\n \t_land_detected{},\n \t_control_mode{},\n \t_global_pos{},\n+\t_local_pos{},\n \t_gps_pos{},\n \t_sensor_combined{},\n \t_home_pos{},\n@@ -139,6 +141,7 @@ Navigator::Navigator() :\n \t_geofence(this),\n \t_geofence_violation_warning_sent(false),\n \t_inside_fence(true),\n+\t_tracker(),\n \t_can_loiter_at_sp(false),\n \t_pos_sp_triplet_updated(false),\n \t_pos_sp_triplet_published_invalid_once(false),\n@@ -149,6 +152,7 @@ Navigator::Navigator() :\n \t_takeoff(this, \"TKF\"),\n \t_land(this, \"LND\"),\n \t_rtl(this, \"RTL\"),\n+\t_rcRecover(this, \"RCRECOVER\"),\n \t_rcLoss(this, \"RCL\"),\n \t_dataLinkLoss(this, \"DLL\"),\n \t_engineFailure(this, \"EF\"),\n@@ -170,13 +174,14 @@ Navigator::Navigator() :\n \t_navigation_mode_array[0] = &_mission;\n \t_navigation_mode_array[1] = &_loiter;\n \t_navigation_mode_array[2] = &_rtl;\n-\t_navigation_mode_array[3] = &_dataLinkLoss;\n-\t_navigation_mode_array[4] = &_engineFailure;\n-\t_navigation_mode_array[5] = &_gpsFailure;\n-\t_navigation_mode_array[6] = &_rcLoss;\n-\t_navigation_mode_array[7] = &_takeoff;\n-\t_navigation_mode_array[8] = &_land;\n-\t_navigation_mode_array[9] = &_follow_target;\n+\t_navigation_mode_array[3] = &_rcRecover;\n+\t_navigation_mode_array[4] = &_rcLoss;\n+\t_navigation_mode_array[5] = &_dataLinkLoss;\n+\t_navigation_mode_array[6] = &_engineFailure;\n+\t_navigation_mode_array[7] = &_gpsFailure;\n+\t_navigation_mode_array[8] = &_takeoff;\n+\t_navigation_mode_array[9] = &_land;\n+\t_navigation_mode_array[10] = &_follow_target;\n \n \tupdateParams();\n }\n@@ -212,6 +217,14 @@ Navigator::global_position_update()\n \torb_copy(ORB_ID(vehicle_global_position), _global_pos_sub, &_global_pos);\n }\n \n+void\n+Navigator::local_position_update()\n+{\n+\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n+\tif (!_land_detected.landed)\n+\t\t_tracker.update(&_local_pos);\n+}\n+\n void\n Navigator::gps_position_update()\n {\n@@ -232,6 +245,7 @@ Navigator::home_position_update(bool force)\n \n \tif (updated || force) {\n \t\torb_copy(ORB_ID(home_position), _home_pos_sub, &_home_pos);\n+\t\t_tracker.reset(&_home_pos);\n \t}\n }\n \n@@ -254,6 +268,8 @@ void\n Navigator::vehicle_land_detected_update()\n {\n \torb_copy(ORB_ID(vehicle_land_detected), _land_detected_sub, &_land_detected);\n+\tif (!_land_detected.landed)\n+\t\t_tracker.update(&_local_pos);\n }\n \n void\n@@ -301,6 +317,7 @@ Navigator::task_main()\n \n \t/* do subscriptions */\n \t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n+\t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n \t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n \t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n \t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n@@ -318,6 +335,7 @@ Navigator::task_main()\n \tvehicle_land_detected_update();\n \tvehicle_control_mode_update();\n \tglobal_position_update();\n+\tlocal_position_update();\n \tgps_position_update();\n \tsensor_combined_update();\n \thome_position_update(true);\n@@ -367,6 +385,12 @@ Navigator::task_main()\n \n \t\tbool updated;\n \n+\t\t/* local position updated */\n+\t\torb_check(_local_pos_sub, &updated);\n+\t\tif (updated) {\n+\t\t\tlocal_position_update();\n+\t\t}\n+\n \t\t/* gps updated */\n \t\torb_check(_gps_pos_sub, &updated);\n \t\tif (updated) {\n@@ -543,6 +567,8 @@ Navigator::task_main()\n \t\t\t\t} else if (_param_rcloss_act.get() == 3) {\n \t\t\t\t\t_navigation_mode = &_land;\n \t\t\t\t} else if (_param_rcloss_act.get() == 4) {\n+\t\t\t\t\t_navigation_mode = &_rcRecover;\n+\t\t\t\t} else if (_param_rcloss_act.get() == 5) {\n \t\t\t\t\t_navigation_mode = &_rcLoss;\n \t\t\t\t} else { /* if == 2 or unknown, RTL */\n \t\t\t\t\t_navigation_mode = &_rtl;\n@@ -551,6 +577,7 @@ Navigator::task_main()\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\t_navigation_mode = &_rtl;\n+\t\t\t\t//_navigation_mode = &_rcRecover; // for development only\n \t\t\t\tbreak;\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n@@ -565,14 +592,14 @@ Navigator::task_main()\n \t\t\t\t_navigation_mode = &_land;\n \t\t\t\tbreak;\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n-\t\t\t\t/* Use complex data link loss mode only when enabled via param\n-\t\t\t\t* otherwise use rtl */\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t\tif (_param_datalinkloss_act.get() == 1) {\n \t\t\t\t\t_navigation_mode = &_loiter;\n \t\t\t\t} else if (_param_datalinkloss_act.get() == 3) {\n \t\t\t\t\t_navigation_mode = &_land;\n \t\t\t\t} else if (_param_datalinkloss_act.get() == 4) {\n+\t\t\t\t\t_navigation_mode = &_rcRecover;\n+\t\t\t\t} else if (_param_datalinkloss_act.get() == 5) {\n \t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n \t\t\t\t} else { /* if == 2 or unknown, RTL */\n \t\t\t\t\t_navigation_mode = &_rtl;\n@@ -683,6 +710,9 @@ Navigator::status()\n \t} else {\n \t\tPX4_INFO(\"Geofence not set (no /etc/geofence.txt on microsd) or not valid\");\n \t}\n+\t\n+\t_tracker.dump_recent_path();\n+\t_tracker.dump_full_path();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -102,14 +102,15 @@ PARAM_DEFINE_FLOAT(NAV_MC_ALT_RAD, 3.0f);\n  *\n  * The data link loss failsafe will only be entered after a timeout,\n  * set by COM_DL_LOSS_T in seconds. Once the timeout occurs the selected\n- * action will be executed. Setting this parameter to 4 will enable CASA\n+ * action will be executed. Setting this parameter to 5 will enable CASA\n  * Outback Challenge rules, which are only recommended to participants\n  * of that competition.\n  *\n  * @value 0 Disabled\n  * @value 1 Loiter\n  * @value 2 Return to Land\n  * @value 3 Land at current position\n+ * @value 4 Return along recent path\n  *\n  * @group Mission\n  */\n@@ -121,13 +122,14 @@ PARAM_DEFINE_INT32(NAV_DLL_ACT, 0);\n  * The RC loss failsafe will only be entered after a timeout,\n  * set by COM_RC_LOSS_T in seconds. If RC input checks have been disabled\n  * by setting the COM_RC_IN_MODE param it will not be triggered.\n- * Setting this parameter to 4 will enable CASA Outback Challenge rules,\n+ * Setting this parameter to 5 will enable CASA Outback Challenge rules,\n  * which are only recommended to participants of that competition.\n  *\n  * @value 0 Disabled\n  * @value 1 Loiter\n  * @value 2 Return to Land\n  * @value 3 Land at current position\n+ * @value 4 Return along recent path\n  *\n  * @group Mission\n  */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rcrecover.cpp": {
        "filename": "src/modules/navigator/rcrecover.cpp",
        "status": "added",
        "additions": 168,
        "deletions": 0,
        "changes": 168,
        "patch": "@@ -0,0 +1,168 @@\n+/**\n+ * @file rcrecover.cpp\n+ * RC recovery navigation mode\n+ */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <math.h>\n+#include <fcntl.h>\n+\n+#include <systemlib/mavlink_log.h>\n+#include <systemlib/err.h>\n+#include <geo/geo.h>\n+\n+#include <uORB/uORB.h>\n+#include <uORB/topics/home_position.h>\n+\n+#include \"navigator.h\"\n+#include \"rcrecover.h\"\n+\n+#define DELAY_SIGMA\t0.01f\n+\n+RCRecover::RCRecover(Navigator *navigator, const char *name) :\n+\tMissionBlock(navigator, name),\n+\t_state(RCRECOVER_STATE_NONE),\n+\t_start_lock(false),\n+\t_param_rtl_delay(this, \"RCRCVR_RTL_DELAY\", false)\n+{\n+\t// load initial params\n+\tupdateParams();\n+\t\n+\t// initial reset\n+\ton_inactive();\n+}\n+\n+RCRecover::~RCRecover()\n+{\n+}\n+\n+void RCRecover::on_inactive()\n+{\n+\t_navigator->get_tracker().set_recent_path_tracking_enabled(true);\n+\t\n+\t// reset RCRecover state only if setpoint moved (why?)\n+\tif (!_navigator->get_can_loiter_at_sp())\n+\t\t_state = RCRECOVER_STATE_NONE;\n+}\n+\n+void RCRecover::on_activation()\n+{\n+\t_navigator->get_tracker().set_recent_path_tracking_enabled(false);\n+\t\n+\t/* reset starting point so we override what the triplet contained from the previous navigation state */\n+\t_start_lock = false;\n+\tset_current_position_item(&_mission_item);\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\n+\tif (_state == RCRECOVER_STATE_NONE) {\n+\t\t// for safety reasons don't go into RCRecover if landed\n+\t\tif (_navigator->get_land_detected()->landed) {\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RC Recover: not available when landed\");\n+\n+\t\t// otherwise, return along recent path\n+\t\t} else {\n+\t\t\t_state = RCRECOVER_STATE_RETURN;\n+\t\t\t\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RC Recover: return along recent path\");\n+\t\t\t\n+\t\t\t// in case there is no recent path, loiter at the current position\n+\t\t\tloiter_lat = _navigator->get_global_position()->lat;\n+\t\t\tloiter_lon = _navigator->get_global_position()->lon;\n+\t\t\tloiter_alt = _navigator->get_global_position()->alt;\n+\t\t}\n+\n+\t}\n+\n+\tupdate_mission_item();\n+}\n+\n+void RCRecover::on_active()\n+{\n+\tif (is_mission_item_reached())\n+\t\tupdate_mission_item();\n+}\n+\n+void RCRecover::update_mission_item()\n+{\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t// make sure we have the latest params\n+\tupdateParams();\n+\n+\tif (!_start_lock)\n+\t\tset_previous_pos_setpoint();\n+\n+\t_navigator->set_can_loiter_at_sp(false);\n+\t\n+\t//if (_state == RCRECOVER_STATE_LOITER)\n+\t\t// todo: switch to RTL mode\n+\n+\tswitch (_state) {\n+\tcase RCRECOVER_STATE_RETURN: {\n+\t\t\n+\t\tif (_navigator->get_tracker().pop_recent_path(_mission_item.lat, _mission_item.lon, _mission_item.altitude)) {\n+\t\t\tloiter_lat = _mission_item.lat;\n+\t\t\tloiter_lon = _mission_item.lon;\n+\t\t\tloiter_alt = _mission_item.altitude;\n+\t\t\t\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.yaw = NAN;\n+\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t_mission_item.loiter_direction = 1;\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\t\t\t_mission_item.time_inside = 0.0f;\n+\t\t\t_mission_item.pitch_min = 0.0f;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n+\t\t\t\n+\t\t\t_start_lock = true;\n+\t\t\tbreak;\n+\t\t}\n+\t\t\n+\t\t// Recent path is empty: fall through to loiter\n+\t\t_state = RCRECOVER_STATE_LOITER;\n+\t}\n+\n+\tcase RCRECOVER_STATE_LOITER: {\n+\t\tbool autortl = _param_rtl_delay.get() > -DELAY_SIGMA;\n+\n+\t\t_mission_item.lat = loiter_lat;\n+\t\t_mission_item.lon = loiter_lon;\n+\t\t_mission_item.altitude = loiter_alt;\n+\t\t_mission_item.altitude_is_relative = false;\n+\t\t_mission_item.yaw = _navigator->get_global_position()->yaw;\n+\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t_mission_item.loiter_direction = 1;\n+\t\t_mission_item.nav_cmd = autortl ? NAV_CMD_LOITER_TIME_LIMIT : NAV_CMD_LOITER_UNLIMITED;\n+\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\t\t_mission_item.time_inside = _param_rtl_delay.get() < 0.0f ? 0.0f : _param_rtl_delay.get();\n+\t\t_mission_item.pitch_min = 0.0f;\n+\t\t_mission_item.autocontinue = autortl;\n+\t\t_mission_item.origin = ORIGIN_ONBOARD;\n+\n+\t\t_navigator->set_can_loiter_at_sp(true);\n+\n+\t\tif (autortl) {\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RC Recover: loiter %.1fs\", (double)_mission_item.time_inside);\n+\t\t} else {\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RC Recover: completed, loiter\");\n+\t\t}\n+\t\t\t\n+\t\tbreak;\n+\t}\n+\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\treset_mission_item_reached();\n+\n+\t/* convert mission item to current position setpoint and make it valid */\n+\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\tpos_sp_triplet->next.valid = false;\n+\n+\t_navigator->set_position_setpoint_triplet_updated();\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Frcrecover.cpp"
      },
      "src/modules/navigator/rcrecover.h": {
        "filename": "src/modules/navigator/rcrecover.h",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "patch": "@@ -0,0 +1,47 @@\n+/**\n+ * @file rcrecover.h\n+ * RC recovery navigation mode\n+ */\n+\n+#ifndef NAVIGATOR_RTGS_H\n+#define NAVIGATOR_RTGS_H\n+\n+#include <controllib/blocks.hpp>\n+#include <controllib/block/BlockParam.hpp>\n+\n+#include \"navigator_mode.h\"\n+#include \"mission_block.h\"\n+\n+class Navigator;\n+\n+class RCRecover : public MissionBlock\n+{\n+public:\n+\tRCRecover(Navigator *navigator, const char *name);\n+\n+\t~RCRecover();\n+\n+\tvoid on_inactive();\n+\tvoid on_activation();\n+\tvoid on_active();\n+\n+private:\n+\t// Set the mission item\n+\tvoid update_mission_item();\n+\n+\tenum RCRecoverState {\n+\t\tRCRECOVER_STATE_NONE = 0,\n+\t\tRCRECOVER_STATE_RETURN,\n+\t\tRCRECOVER_STATE_LOITER\n+\t} _state;\n+\n+\tbool _start_lock;\n+\t\n+\tdouble loiter_lat;\n+\tdouble loiter_lon;\n+\tfloat loiter_alt;\n+\t\n+\tcontrol::BlockParamFloat _param_rtl_delay;\n+};\n+\n+#endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Frcrecover.h"
      },
      "src/modules/navigator/rcrecover_params.c": {
        "filename": "src/modules/navigator/rcrecover_params.c",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "patch": "@@ -0,0 +1,24 @@\n+/**\n+ * @file rcrecover_params.c\n+ *\n+ * Parameters for RC Recover mode\n+ */\n+\n+/*\n+ * RC Recover parameters, accessible via MAVLink\n+ */\n+\n+/**\n+ * RTL delay\n+ *\n+ * Delay after returning along recent path before switching to RTL mode.\n+ * If set to -1 the system will not switch to RTL but loiter at the earliest known position.\n+ *\n+ * @unit s\n+ * @min -1\n+ * @max 300\n+ * @decimal 1\n+ * @increment 0.5\n+ * @group RC Recover\n+ */\n+PARAM_DEFINE_FLOAT(RCRCVR_RTL_DELAY, -1.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Frcrecover_params.c"
      },
      "src/modules/navigator/tracker.cpp": {
        "filename": "src/modules/navigator/tracker.cpp",
        "status": "added",
        "additions": 283,
        "deletions": 0,
        "changes": 283,
        "patch": "@@ -0,0 +1,283 @@\n+\n+#include <limits.h>\n+#include <geo/geo.h>\n+#include \"tracker.h\"\n+\n+\n+inline bool Tracker::is_close(fpos_t pos1, fpos_t pos2) {\n+    float delta_x = pos1.x - pos2.x;\n+    float delta_y = pos1.y - pos2.y;\n+    float delta_z = pos1.z - pos2.z;\n+    return delta_x * delta_x + delta_y * delta_y + delta_z * delta_z < (ACCURACY * ACCURACY);\n+}\n+\n+inline bool Tracker::is_close(ipos_t pos1, fpos_t pos2) {\n+    return is_close(to_fpos(pos1), pos2);\n+}\n+\n+inline Tracker::graph_item_t Tracker::make_delta_item(ipos_t &from_pos, ipos_t &to_pos) {\n+    int delta_x = to_pos.x - from_pos.x;\n+    int delta_y = to_pos.y - from_pos.y;\n+    int delta_z = to_pos.z - from_pos.z;\n+    return ((delta_x & 0x1F) << 10) | ((delta_y & 0x1F) << 5) | ((delta_z & 0x1F) << 0);\n+}\n+\n+inline void Tracker::subtract_delta_item(ipos_t &position, graph_item_t &delta) {\n+    const int SHIFT_COUNT = CHAR_BIT * sizeof(int) - 5; \n+    position.x -= ((int)(delta << (SHIFT_COUNT - 10))) >> SHIFT_COUNT;\n+    position.y -= ((int)(delta << (SHIFT_COUNT - 5))) >> SHIFT_COUNT;\n+    position.z -= ((int)(delta << (SHIFT_COUNT - 0))) >> SHIFT_COUNT;\n+}\n+\n+void Tracker::reset(home_position_s *position) {\n+    home_position.x = position->x;\n+    home_position.y = position->y;\n+    home_position.z = position->z;\n+}\n+\n+\n+void Tracker::update(vehicle_local_position_s *position) {\n+    if (position->xy_global) {\n+        ref_lat = position->ref_lat;\n+        ref_lon = position->ref_lon;\n+    }\n+    \n+    if (position->z_global)\n+        ref_alt = position->ref_alt;\n+    \n+    if (!position->xy_valid || !position->z_valid)\n+        return;\n+        \n+    fpos_t local_position = {\n+        .x = position->x,\n+        .y = position->y,\n+        .z = position->z\n+    };\n+    \n+    if (recent_path_tracking_enabled)\n+        push_recent_path(local_position);\n+\n+    if (graph_tracking_enabled)\n+        push_graph(local_position);\n+}\n+\n+\n+void Tracker::push_recent_path(fpos_t &position) {\n+    \n+    bool rollback = false;\n+    size_t index = recent_path_next_write;\n+    ipos_t head = to_ipos(recent_path_head);\n+    \n+    if (recent_path_next_read != RECENT_PATH_LENGTH) {\n+        \n+        // If we're still close to the most recent position, don't update\n+        if (is_close(head, position))\n+            return;\n+        \n+        // Scan the buffer for a close position, starting at the latest one\n+        do {\n+            index = (index ? index : RECENT_PATH_LENGTH) - 1;\n+        \n+            if (index == recent_path_next_write)\n+                break; // Note that the initial position is always invalid, so we musn't use that\n+                    \n+            subtract_delta_item(head, recent_path[index]);\n+            \n+            rollback = is_close(head, position);\n+        } while ((index != recent_path_next_read) && !rollback);\n+    }\n+    \n+    \n+    if (rollback) {\n+        \n+        // If there was a close position in the path, roll the path back to that position\n+        recent_path_head = to_fpos(head);\n+        recent_path_next_write = index;\n+        PX4_INFO(\"recent path rollback to %zu\", index);\n+        \n+    } else {\n+        \n+        // If there was no close position in the path, add the current position to the buffer\n+        // todo: handle large distances\n+        \n+        ipos_t old_head = to_ipos(recent_path_head);\n+        ipos_t new_head = to_ipos(position);\n+        \n+        graph_item_t item = make_delta_item(old_head, new_head);\n+        \n+        recent_path_head = position;\n+        recent_path[recent_path_next_write] = item;\n+        \n+        if (recent_path_next_write++ == recent_path_next_read)\n+            recent_path_next_read = recent_path_next_write;\n+            \n+        if (recent_path_next_write == RECENT_PATH_LENGTH)\n+            recent_path_next_write = 0;\n+            \n+        if (recent_path_next_read == RECENT_PATH_LENGTH)\n+            recent_path_next_read = 0;\n+    }\n+}\n+\n+\n+bool Tracker::pop_recent_path(fpos_t &position) {\n+    position = recent_path_head;\n+    \n+    if (recent_path_next_read == RECENT_PATH_LENGTH)\n+        return false;\n+    \n+    int last_index = (recent_path_next_write ? recent_path_next_write : RECENT_PATH_LENGTH) - 1;\n+    \n+    // Roll back most recent position\n+    ipos_t head = to_ipos(recent_path_head);\n+    subtract_delta_item(head, recent_path[last_index]);\n+    recent_path_head = to_fpos(head);\n+    \n+    if ((recent_path_next_write = last_index) == recent_path_next_read) {\n+        recent_path_next_write = 0;\n+        recent_path_next_read = RECENT_PATH_LENGTH;\n+    }\n+    return true;\n+}\n+\n+\n+bool Tracker::pop_recent_path(double &lat, double &lon, float &alt) {\n+    fpos_t position;\n+    \n+    if (!pop_recent_path(position))\n+        return false;\n+    \n+    return !globallocalconverter_toglobal(position.x, position.y, position.z, &lat, &lon, &alt);\n+}\n+\n+\n+Tracker::graph_item_t Tracker::get_delta_item(size_t &index) {\n+    graph_item_t item = full_path[index--];\n+\n+    if (is_delta_item(item))\n+        return item;\n+\n+    if (is_data_item(item)) {\n+        index -= 2;\n+    } else {\n+        size_t link = get_link_item(item);\n+        if (is_data_item(full_path[link + 2]))\n+            return full_path[link + 1];\n+    }\n+\n+    return full_path[index--];\n+}\n+\n+\n+void Tracker::push_graph(fpos_t &position) {\n+    ipos_t old_head = to_ipos(full_path_head);\n+\n+    // Don't update if we're still close to the last position\n+    if (is_close(old_head, position))\n+        return;\n+\n+    // Don't update if the path is almost full (we might append up to 4 elements)\n+    if (full_path_next_write > FULL_PATH_LENGTH - 4)\n+        return; // todo: consider a clean-up pass\n+    \n+    \n+    // Add the current position to the graph\n+    // todo: handle large distances\n+        \n+    ipos_t new_head = to_ipos(position);\n+    \n+    full_path_head = position;\n+    full_path[full_path_next_write++] = make_delta_item(old_head, new_head);\n+    \n+\n+    // Scan through the existing path to see if we've been here already\n+\n+    ipos_t head = new_head;\n+\n+    int search_bound = FULL_PATH_SEARCH_RANGE < full_path_next_write ? full_path_next_write - FULL_PATH_SEARCH_RANGE : 0;\n+\n+    for (size_t index = full_path_next_write - 1; index > search_bound;) {\n+        graph_item_t item = get_delta_item(index);\n+        subtract_delta_item(head, item);\n+\n+        // Check for intersection\n+        if (head == new_head) {\n+            if (is_data_item(full_path[index]))\n+                index -= 2;\n+\n+            // Evict existing item by inserting a link to the current position (which is where the back-link will be placed)\n+            item = full_path[index];\n+            full_path[index] = make_link_item(full_path_next_write);\n+\n+            // If the evicted item was not already a link, we need to initialize the link cycle\n+            if (is_delta_item(item))\n+                full_path[full_path_next_write++] = make_link_item(index);\n+            \n+            // Insert the evicted item (which may be a link)\n+            full_path[full_path_next_write++] = item;\n+            \n+            // If we just created a new cycle, we need to attach a reserved field\n+            if (is_delta_item(item))\n+                full_path[full_path_next_write++] = make_data_item(0);\n+\n+            break;\n+        }\n+    }\n+}\n+\n+\n+void Tracker::dump_recent_path() {\n+    if (recent_path_next_read == RECENT_PATH_LENGTH) {\n+        PX4_INFO(\"recent path empty\");\n+        PX4_INFO(\"element size is %lu bytes\", sizeof(graph_item_t));\n+        return;\n+    }\n+    \n+    PX4_INFO(\"recent path:\");\n+    size_t recent_path_length = (recent_path_next_write + RECENT_PATH_LENGTH - recent_path_next_read - 1) % RECENT_PATH_LENGTH + 1;\n+    PX4_INFO(\"  length: %zu (read-ptr: %zu, write-ptr: %zu)\", recent_path_length, recent_path_next_read, recent_path_next_write);\n+    \n+    size_t index = recent_path_next_write;\n+    ipos_t head = to_ipos(recent_path_head);\n+    \n+    do {\n+        PX4_INFO(\"  (%d, %d, %d)\", head.x, head.y, head.z);\n+        \n+        index = (index ? index : RECENT_PATH_LENGTH) - 1;\n+        subtract_delta_item(head, recent_path[index]);\n+    } while (index != recent_path_next_read);\n+}\n+\n+\n+void Tracker::dump_full_path() {\n+    if (!full_path_next_write) {\n+        PX4_INFO(\"full path empty\");\n+        return;\n+    }\n+    \n+    PX4_INFO(\"full path (%zu elements):\", full_path_next_write);\n+\n+    ipos_t head = to_ipos(full_path_head);\n+\n+    for (size_t index = full_path_next_write - 1; index > 0;) {\n+        if (is_data_item(full_path[index]))\n+            index -= 2;\n+\n+        PX4_INFO(\"  %zu: (%d, %d, %d)\", index, head.x, head.y, head.z);\n+\n+        graph_item_t item = get_delta_item(index);\n+        subtract_delta_item(head, item);\n+    }\n+\n+    PX4_INFO(\"full path nodes:\");\n+    for (size_t index = 2; index < full_path_next_write; index++) {\n+        graph_item_t item = full_path[index];\n+        if (is_data_item(item)) {\n+            PX4_INFO(\"  node with data %d:\", get_data_item(item));\n+            size_t link = index - 2;\n+            do {\n+                PX4_INFO(\"  pos %zu\", link);\n+            } while ((link = get_link_item(full_path[link])) != index - 2);\n+        }\n+    }\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Ftracker.cpp"
      },
      "src/modules/navigator/tracker.h": {
        "filename": "src/modules/navigator/tracker.h",
        "status": "added",
        "additions": 141,
        "deletions": 0,
        "changes": 141,
        "patch": "@@ -0,0 +1,141 @@\n+\n+#ifndef NAVIGATOR_TRACKER_H\n+#define NAVIGATOR_TRACKER_H\n+\n+\n+#include <uORB/topics/home_position.h>\n+#include <uORB/topics/vehicle_local_position.h>\n+\n+\n+class Tracker\n+{\n+    \n+public:\n+    // Resets the home position used by the tracker.\n+    void reset(home_position_s *position);\n+    \n+    // Informs the tracker about a new current position.\n+    void update(vehicle_local_position_s *position);\n+    \n+    // Pops the last position from the recent path. Returns false if the path is empty.\n+    bool pop_recent_path(double &lat, double &lon, float &alt);\n+    \n+    // Enables or disables tracking of the recent path.\n+    void set_recent_path_tracking_enabled(bool enabled) { recent_path_tracking_enabled = enabled; }\n+    \n+    // Enables or disables tracking of the flight path as a graph.\n+    void set_graph_tracking_enabled(bool enabled) { graph_tracking_enabled = enabled; }\n+    \n+    // Dumps the points in the recent path to the log output\n+    void dump_recent_path(void);\n+    \n+    // Dumps the content of the full flight graph to the log output\n+    void dump_full_path(void);\n+    \n+private:\n+    \n+    // Tracking accuracy in meters\n+\tstatic constexpr float ACCURACY = 2;\n+    \n+    // Number of positions that are retained in the recent path buffer.\n+    // This must be a multiple of 16 (?)\n+    static constexpr int RECENT_PATH_LENGTH = 64;\n+    \n+    // Number of positions that can be stored in the full flight path.\n+    // The actual number of position depends on how many intersections are recorded.\n+    static constexpr int FULL_PATH_LENGTH = 256;\n+\n+    // Number of position to scan at each update to find intersections.\n+    // If the entire buffer is scanned, CPU usage may be too high.\n+    static constexpr int FULL_PATH_SEARCH_RANGE = FULL_PATH_LENGTH;\n+    \n+\n+    struct fpos_t {\n+        float x, y, z;\n+    };\n+    \n+    struct ipos_t {\n+        int x, y, z;\n+        \n+        inline bool operator==(const ipos_t &pos2) const {\n+            return this->x == pos2.x && this->y == pos2.y && this->z == pos2.z;\n+        }\n+    };\n+    \n+    static inline bool is_close(fpos_t pos1, fpos_t pos2);\n+    static inline bool is_close(ipos_t pos1, fpos_t pos2);\n+    static inline fpos_t to_fpos(ipos_t &pos) { return { .x = (float)pos.x, .y = (float)pos.y, .z = (float)pos.z }; }\n+    static inline ipos_t to_ipos(fpos_t &pos) { return { .x = (int)pos.x, .y = (int)pos.y, .z = (int)pos.z }; }\n+\n+\n+    typedef uint16_t graph_item_t;\n+\n+    static inline graph_item_t make_delta_item(ipos_t &from_pos, ipos_t &to_pos);\n+    static inline graph_item_t make_link_item(uint16_t index) { return (1 << 15) | (index & 0x3FFF); }\n+    static inline graph_item_t make_data_item(uint16_t data) { return (3 << 14) | (data & 0x3FFF); }\n+    static inline bool is_delta_item(graph_item_t &item) { return !(item >> 15); }\n+    static inline bool is_data_item(graph_item_t &item) { return (item >> 14) == 3; }\n+\n+    // Subtracts the delta from the provided position. The caller must ensure that the item is really a delta item.\n+    static inline void subtract_delta_item(ipos_t &position, graph_item_t &delta);\n+\n+    // Returns the index contained by a link item. The caller must ensure that the item is really a link item.\n+    static inline uint16_t get_link_item(graph_item_t &item) { return item & 0x3FFF; }\n+\n+    // Returns the payload contained by a data item. The caller must ensure that the item is really a data item.\n+    static inline uint16_t get_data_item(graph_item_t &item) { return item & 0x3FFF; }\n+\n+    \n+    // Pushes a new current position to the recent path. This works even while the recent path is disabled.\n+    void push_recent_path(fpos_t &position);\n+    \n+    // Pops the last position from the recent path. Returns false if the path is empty.\n+    bool pop_recent_path(fpos_t &position);\n+\n+    // Pushes a new current position to the flight graph.\n+    void push_graph(fpos_t &position);\n+\n+    // Fetches the delta item at the specified index from the graph.\n+    // If the index points to a special item, this is handled appropriately.\n+    // The index is decremented to point to the next item that should be consumed.\n+    // The index must be larger than 0.\n+    graph_item_t get_delta_item(size_t &index);\n+\n+    \n+    double ref_lat;\n+    double ref_lon;\n+    float ref_alt;\n+    \n+    fpos_t home_position;\n+\n+\n+    bool recent_path_tracking_enabled = true;\n+    bool graph_tracking_enabled = true;\n+\n+    \n+    // The most recent position in the recent path. The absolute positions in the path can be calculated based on this. \n+    // If tracking has not yet started (that is, if the path is empty), this is invalid.\n+    fpos_t recent_path_head = { .x = 0, .y = 0, .z = 0 };\n+    \n+    // Stores the (potentially shortened) recent flight path as a ring buffer.\n+    // The recent path respects the following invariant: No two points are closer than ACCURACY.\n+    // This buffer contains only delta items. Each item stores a position relative to the previous position in the path.\n+    // Note that the first item carries no valid information other than that the path is non-empty.\n+    graph_item_t recent_path[RECENT_PATH_LENGTH];\n+    \n+    size_t recent_path_next_write = 0; // always valid, 0 if empty, equal to next_read if full\n+    size_t recent_path_next_read = RECENT_PATH_LENGTH; // LENGTH if empty, valid if non-empty\n+\n+\n+    // The most recent position in the full path.\n+    fpos_t full_path_head = { .x = 0, .y = 0, .z = 0 };\n+\n+    // Stores the entire flight path (until the buffer is full).\n+    // Each delta item stores a position relative to the previous position in the path.\n+    // If an intersection is detected, a node is created by linking the intersecting positions and attaching some payload data to the node.\n+    // Note that the first item carries no valid information other than that the path is non-empty.\n+    graph_item_t full_path[FULL_PATH_LENGTH];\n+    size_t full_path_next_write = 0;\n+};\n+\n+#endif // NAVIGATOR_TRACKER_H",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/713fb187a51c6035cf59971516897983a94f5ced/src%2Fmodules%2Fnavigator%2Ftracker.h"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::Navigator",
        "Navigator::task_main",
        "Navigator::home_position_update",
        "Navigator::global_position_update",
        "Navigator::status",
        "rules",
        "Navigator::vehicle_land_detected_update"
      ],
      "by_file": {
        "src/modules/navigator/navigator.h": [
          "rules"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::home_position_update",
          "Navigator::status",
          "Navigator::vehicle_land_detected_update",
          "Navigator::task_main",
          "Navigator::global_position_update",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "more follow target updates",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4649",
    "number": 4649,
    "created_at": "2016-05-26T18:47:23Z",
    "merged": true,
    "merged_at": "2016-05-27T20:28:31Z",
    "state": "closed",
    "conversation": {
      "author": "catch-twenty-two",
      "body": "Testing completed ready to merge.  Refactor of follow target module for readability and complexity.  Fixed yaw smoothing.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-27T20:28:35Z",
          "body": "Rebased and applied, thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR notes a refactor of the follow-target module and explicitly states 'Fixed yaw smoothing', which implies previous incorrect behavior in the yaw control logic. Yaw smoothing affects control output/state transitions and producing wrong/undesired vehicle orientation is a classic logic error. ",
    "patches": {
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 70,
        "changes": 113,
        "patch": "@@ -73,9 +73,6 @@ FollowTarget::FollowTarget(Navigator *navigator, const char *name) :\n \t_last_update_time(0),\n \t_current_target_motion({}),\n \t_previous_target_motion({}),\n-\t_avg_cos_ratio(0.0F),\n-\t_filtered_target_lat(0.0F),\n-\t_filtered_target_lon(0.0F),\n \t_yaw_rate(0.0F),\n \t_responsiveness(0.0F),\n \t_yaw_auto_max(0.0F),\n@@ -126,7 +123,7 @@ void FollowTarget::on_active()\n {\n \tstruct map_projection_reference_s target_ref;\n \tmath::Vector<3> target_reported_velocity(0, 0, 0);\n-\tfollow_target_s target_motion = {};\n+\tfollow_target_s target_motion_with_offset = {};\n \tuint64_t current_time = hrt_absolute_time();\n \tbool _radius_entered = false;\n \tbool _radius_exited = false;\n@@ -136,14 +133,23 @@ void FollowTarget::on_active()\n \torb_check(_follow_target_sub, &updated);\n \n \tif (updated) {\n+\t\tfollow_target_s target_motion;\n \n \t\t_target_updates++;\n \n \t\t// save last known motion topic\n \n \t\t_previous_target_motion = _current_target_motion;\n \n-\t\torb_copy(ORB_ID(follow_target), _follow_target_sub, &_current_target_motion);\n+\t\torb_copy(ORB_ID(follow_target), _follow_target_sub, &target_motion);\n+\n+\t\tif(_current_target_motion.timestamp == 0) {\n+\t\t\t_current_target_motion = target_motion;\n+\t\t}\n+\n+\t\t_current_target_motion.timestamp = target_motion.timestamp;\n+\t\t_current_target_motion.lat = (_current_target_motion.lat*(double)_responsiveness) + target_motion.lat*(double)(1 - _responsiveness);\n+\t\t_current_target_motion.lon = (_current_target_motion.lon*(double)_responsiveness) + target_motion.lon*(double)(1 - _responsiveness);\n \n \t\ttarget_reported_velocity(0) = _current_target_motion.vx;\n \t\ttarget_reported_velocity(1) = _current_target_motion.vy;\n@@ -159,14 +165,7 @@ void FollowTarget::on_active()\n \t\t// get distance to target\n \n \t\tmap_projection_init(&target_ref, _navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n-\t\tmap_projection_project(&target_ref, _filtered_target_lat, _filtered_target_lon, &_target_distance(0), &_target_distance(1));\n-\n-\t\ttarget_motion = _current_target_motion;\n-\n-\t\t// use target offset\n-\n-\t\tmap_projection_init(&target_ref,  _filtered_target_lat, _filtered_target_lon);\n-\t\tmap_projection_reproject(&target_ref, _target_position_offset(0), _target_position_offset(1), &target_motion.lat, &target_motion.lon);\n+\t\tmap_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &_target_distance(0), &_target_distance(1));\n \n \t}\n \n@@ -190,40 +189,16 @@ void FollowTarget::on_active()\n \n \t\t\tmap_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &(_target_position_delta(0)), &(_target_position_delta(1)));\n \n-\t\t\t// filter out gps noise to figure out if we are actually moving\n-\n-\t\t\tif (_target_position_delta.length() > 0.1F && prev_position_delta.length() > 0.1F) {\n-\n-\t\t\t\tfloat cos_ratio = (_target_position_delta * prev_position_delta)/(_target_position_delta.length() * prev_position_delta.length());\n-\n-\t\t\t\t_avg_cos_ratio = _responsiveness*_avg_cos_ratio + (1 - _responsiveness) * cos_ratio;\n-\n-\t\t\t\tif(_avg_cos_ratio < 0) {\n-\t\t\t\t\t_avg_cos_ratio = 0.0F;\n-\t\t\t\t}\n-\n-\t\t\t\tif (_avg_cos_ratio > 0.0F) {\n-\t\t\t\t\t_filtered_target_position_delta = _target_position_delta*_avg_cos_ratio + _filtered_target_position_delta*(1.0F - _avg_cos_ratio);\n-\t\t\t\t}\n+\t\t\t// update the average velocity of the target based on the position\n \n-\t\t\t\t// if ratio is high enough, track target from a side\n+\t\t\t_est_target_vel = _target_position_delta / (dt_ms / 1000.0f);\n \n-\t\t\t\tif(_avg_cos_ratio  > .70F) {\n-\t\t\t\t\t_target_position_offset = _rot_matrix * (_filtered_target_position_delta.normalized() * _follow_offset);\n-\t\t\t\t}\n+\t\t\t// if the target is moving add an offset and rotation\n \n-\t\t\t} else  {\n-\t\t\t\t_filtered_target_position_delta.zero();\n-\t\t\t\t_avg_cos_ratio = 0.0F;\n+\t\t\tif(_est_target_vel.length() > .5F) {\n+\t\t\t\t_target_position_offset = _rot_matrix*_est_target_vel.normalized()*_follow_offset;\n \t\t\t}\n \n-\t\t\t// update the average velocity of the target based on the position\n-\n-\t\t\t_est_target_vel = _filtered_target_position_delta / (dt_ms / 1000.0f);\n-\n-\t\t\t_filtered_target_lat = (_current_target_motion.lat*(double)_avg_cos_ratio) + _filtered_target_lat*(double)(1 - _avg_cos_ratio);\n-\t\t\t_filtered_target_lon = (_current_target_motion.lon*(double)_avg_cos_ratio) + _filtered_target_lon*(double)(1 - _avg_cos_ratio);\n-\n \t\t\t// are we within the target acceptance radius?\n \t\t\t// give a buffer to exit/enter the radius to give the velocity controller\n \t\t\t// a chance to catch up\n@@ -243,27 +218,26 @@ void FollowTarget::on_active()\n \t\t\t_step_vel /= (dt_ms / 1000.0F * (float) INTERPOLATION_PNTS);\n \t\t\t_step_time_in_ms = (dt_ms / (float) INTERPOLATION_PNTS);\n \n-\t\t\t// if we are less than 3 meters from the target don't worry about trying to yaw\n-\t\t\t// lock the yaw until we are a distance that makes sense\n+\t\t\t// if we are less than 1 meter from the target don't worry about trying to yaw\n+\t\t\t// lock the yaw until we are at a distance that makes sense\n \n-\t\t\tif((_target_distance).length() > 3.0F) {\n+\t\t\tif((_target_distance).length() > 1.0F) {\n \n-\t\t\t\t// yaw smoothing\n+\t\t\t\t// yaw rate smoothing\n \n \t\t\t\t// this really needs to control the yaw rate directly in the attitude pid controller\n-\t\t\t\t// but seems to work ok for now since that cannot be controlled directly in auto mode\n-\t\t\t\t// right now\n+\t\t\t\t// but seems to work ok for now since the yaw rate cannot be controlled directly in auto mode\n \n \t\t\t\t_yaw_angle = get_bearing_to_next_waypoint(_navigator->get_global_position()->lat,\n-\t\t\t\t\t\t_navigator->get_global_position()->lon,\n-\t\t\t\t\t\t_current_target_motion.lat,\n-\t\t\t\t\t\t_current_target_motion.lon);\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t _current_target_motion.lat,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t _current_target_motion.lon);\n \n \t\t\t\t_yaw_rate = (_yaw_angle - _navigator->get_global_position()->yaw) / (dt_ms / 1000.0F);\n \n \t\t\t\t_yaw_rate = _wrap_pi(_yaw_rate);\n \n-\t\t\t\t_yaw_rate = math::constrain(_yaw_rate, -1.0F*_yaw_auto_max, _yaw_auto_max);//*.80F;\n+\t\t\t\t_yaw_rate = math::constrain(_yaw_rate, -1.0F*_yaw_auto_max, _yaw_auto_max);\n \n \t\t\t} else {\n \t\t\t\t_yaw_angle = _yaw_rate = NAN;\n@@ -283,15 +257,21 @@ void FollowTarget::on_active()\n //\t\t\t\t(double)_avg_cos_ratio, (double) _yaw_rate);\n \t}\n \n-\t// prevent yaw rate smoothing from over shooting target\n-\t// uses modulus of two pi to get diff\n-\t// by converting float to int\n+\tif(target_position_valid()) {\n \n-\tint angle_diff = (int) ((fabsf(_yaw_angle) - fabsf(_navigator->get_global_position()->yaw)) * 1e4F);\n-\tfloat mod_diff = ((float)(angle_diff % ((int) (M_PI_F * 2.0F * 1e4F))))/1e4F;\n+\t\t// get the target position using the calculated offset\n \n-\tif (fabsf(mod_diff) < math::radians(5.0F)) {\n-\t\t_yaw_angle = _yaw_rate = NAN;\n+\t\tmap_projection_init(&target_ref,  _current_target_motion.lat, _current_target_motion.lon);\n+\t\tmap_projection_reproject(&target_ref, _target_position_offset(0), _target_position_offset(1), &target_motion_with_offset.lat, &target_motion_with_offset.lon);\n+\t}\n+\n+\t// clamp yaw rate smoothing if we are with in\n+\t// 3 degrees of facing target\n+\n+\tif (PX4_ISFINITE(_yaw_rate)) {\n+\t\tif (fabsf(fabsf(_yaw_angle) - fabsf(_navigator->get_global_position()->yaw)) < math::radians(3.0F)) {\n+\t\t\t_yaw_rate = NAN;\n+\t\t}\n \t}\n \n \t// update state machine\n@@ -303,12 +283,11 @@ void FollowTarget::on_active()\n \t\t\tif (_radius_entered == true) {\n \t\t\t\t_follow_target_state = TRACK_VELOCITY;\n \t\t\t} else if (target_velocity_valid()) {\n-\t\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), target_motion, _yaw_angle);\n+\t\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), target_motion_with_offset, _yaw_angle);\n \t\t\t\t// keep the current velocity updated with the target velocity for when it's needed\n \t\t\t\t_current_vel = _est_target_vel;\n-\t\t\t\t_filtered_target_lat = _current_target_motion.lat;\n-\t\t\t\t_filtered_target_lon = _current_target_motion.lon;\n-\t\t\t\tupdate_position_sp(true, true, NAN);\n+\n+\t\t\t\tupdate_position_sp(true, true, _yaw_rate);\n \t\t\t} else {\n \t\t\t\t_follow_target_state = SET_WAIT_FOR_TARGET_POSITION;\n \t\t\t}\n@@ -327,7 +306,7 @@ void FollowTarget::on_active()\n \t\t\t\t\t_last_update_time = current_time;\n \t\t\t\t}\n \n-\t\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), target_motion, _yaw_angle);\n+\t\t\t\tset_follow_target_item(&_mission_item, _param_min_alt.get(), target_motion_with_offset, _yaw_angle);\n \n \t\t\t\tupdate_position_sp(true, false, _yaw_rate);\n \t\t\t} else {\n@@ -357,11 +336,6 @@ void FollowTarget::on_active()\n \t}\n \tcase WAIT_FOR_TARGET_POSITION: {\n \n-\t\tif(target_position_valid()) {\n-\t\t\t_filtered_target_lat = _current_target_motion.lat;\n-\t\t\t_filtered_target_lon = _current_target_motion.lon;\n-\t\t}\n-\n \t\tif (is_mission_item_reached() && target_velocity_valid()) {\n \t\t\t_target_position_offset(0) = _follow_offset;\n \t\t\t_follow_target_state = TRACK_POSITION;\n@@ -397,7 +371,6 @@ void FollowTarget::update_position_sp(bool use_velocity, bool use_position, floa\n void FollowTarget::reset_target_validity()\n {\n \t_yaw_rate = NAN;\n-\t_avg_cos_ratio = 0.0F;\n \t_previous_target_motion = {};\n \t_current_target_motion = {};\n \t_target_updates = 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/38acd15ec6d34dc5a39d1ae87efa45cd6e296d8f/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/follow_target.h": {
        "filename": "src/modules/navigator/follow_target.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "patch": "@@ -126,9 +126,6 @@ class FollowTarget : public MissionBlock\n \n \tfollow_target_s _current_target_motion;\n \tfollow_target_s _previous_target_motion;\n-\tfloat _avg_cos_ratio;\n-\tdouble _filtered_target_lat;\n-\tdouble _filtered_target_lon;\n \tfloat _yaw_rate;\n \tfloat _responsiveness;\n \tfloat _yaw_auto_max;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/38acd15ec6d34dc5a39d1ae87efa45cd6e296d8f/src%2Fmodules%2Fnavigator%2Ffollow_target.h"
      }
    },
    "modified_functions": {
      "all": [
        "math::constrain",
        "FollowTarget::update_position_sp",
        "FollowTarget::on_active",
        "FollowTarget::FollowTarget",
        "math::radians"
      ],
      "by_file": {
        "src/modules/navigator/follow_target.cpp": [
          "FollowTarget::on_active",
          "FollowTarget::FollowTarget",
          "math::constrain",
          "FollowTarget::update_position_sp",
          "math::radians"
        ]
      }
    }
  },
  {
    "title": "stop spamming console with navigator timeout warnings",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4583",
    "number": 4583,
    "created_at": "2016-05-19T20:02:10Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "kd0aij",
      "body": "report timeout only once per gps loss (added missing line to clear global_pos_available_once, which isn't referenced anywhere else)\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T20:10:43Z",
          "body": "neat!\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T20:18:19Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect behavior where navigator timeout warnings were repeatedly printed because a state flag (global_pos_available_once) was never cleared. Adding the missing clear corrects an improper state transition so the timeout is reported only once per GPS loss, which is a logic error (unexpected/undesired output) rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -339,6 +339,7 @@ Navigator::task_main()\n \t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n \t\t\tif (global_pos_available_once) {\n \t\t\t\tPX4_WARN(\"navigator timed out\");\n+\t\t\t\tglobal_pos_available_once = false;\n \t\t\t}\n \t\t\tcontinue;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d38ddc7915a1a22bef1a4fc0e0ec22bd8e7be8b5/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "adjust stack sizes and cleanup ignored warnings",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4581",
    "number": 4581,
    "created_at": "2016-05-19T19:09:46Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "I enabled   CONFIG_ARMV7M_STACKCHECK and adjusted some of the insufficient stack sizes I saw. There are still more modules to check and I still did get the system fully running. Once we have a hardware test harness I think we should have a build with stackcheck enabled. Alternatively if the overhead is acceptable we could keep it enabled on px4fmu-v4.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T19:43:19Z",
          "body": "Thanks, this is awesome!\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T19:45:20Z",
          "body": "The main reason to not have it on by default is that it draws a ton of CPU power. But we should indeed have proper test runs. The fact that you adjusted so much clearly shows that we have an unresolved process issue here.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T19:49:58Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-19T19:56:16Z",
          "body": "The NuttX wiki claims 30% to 35% additional CPU utilization which is huge, but maybe better than the alternative?\n\nI should emphasize this was only with a pixhawk configured for fixed wing and I didn't even get the system fully booted. I'm guessing there's going to be a lot more.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T20:09:06Z",
          "body": "@dagar The other thing to keep in mind is that the instrumentation itself draws memory. So this could be all a false alarm. The reported usage of the high watermarks in top is pretty accurate.\n",
          "type": "issue_comment"
        },
        {
          "author": "davids5",
          "created_at": "2016-05-19T20:34:42Z",
          "body": "@LorenzMeier and @dagar \nI may need revisit the headroom on master....\nThe water mark is large. If we have plenty or RAM then the \"larger than needed headroom\" is moot. If not, the values gleaned from `top` will be a good indicator of penetration just not large chunk overflow.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-19T23:10:44Z",
          "body": "Alright we won't panic over these potential stack issues, but for peace of mind let's work towards a build that runs cleanly with stack check enabled. I've added the idea to the testing wishlist #4532.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T19:42:14Z",
          "body": "That's a steep increase - does the start handler really need more stack? Or did you intent to increase the main app stack? Which would be in task_spawn, NOT here.\n",
          "path": "src/modules/sensors/CMakeLists.txt",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T19:47:27Z",
          "body": "Disregard that - I'm pretty sure its valid and intended.\n",
          "path": "src/modules/sensors/CMakeLists.txt",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-19T19:50:28Z",
          "body": "This shouldn't have made it in. When stackcheck is enabled sensors is somehow causing a hard fault when the main exits. I tried throwing a ton of stack at it.\n",
          "path": "src/modules/sensors/CMakeLists.txt",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T19:58:50Z",
          "body": "Are you sure its causing a hard fault or rather entering the stack check trap?\n",
          "path": "src/modules/sensors/CMakeLists.txt",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-19T20:01:37Z",
          "body": "I've reset it for now to 1200. But I would appreciate your feedback.\n",
          "path": "src/modules/sensors/CMakeLists.txt",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-19T23:15:02Z",
          "body": "It was a hard fault in up_switchcontext.S according to the PC.\n",
          "path": "src/modules/sensors/CMakeLists.txt",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR enables stack checking and adjusts insufficient stack sizes, which addresses boundary-condition/runtime errors (stack overflows/high-water marks) that cause incorrect or unstable behavior. While this is largely a configuration/resource fix rather than an algorithm rewrite, it corrects improper state (insufficient stack headroom) and thus fixes a logic-related issue; confidence is medium because the instrumentation may produce false positives and the author notes not all modules were fully checked yet.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -33,9 +33,8 @@\n px4_add_module(\n \tMODULE modules__navigator\n \tMAIN navigator\n-\tSTACK_MAIN 1200\n+\tSTACK_MAIN 1300\n \tCOMPILE_FLAGS\n-\t\t-Wno-sign-compare\n \t\t-Os\n \tSRCS\n \t\tnavigator_main.cpp",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/918114973d601635cecedd086759f3ac3029bbeb/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -131,7 +131,7 @@ class Geofence : public control::SuperBlock\n \tcontrol::BlockParamInt _param_max_hor_distance;\n \tcontrol::BlockParamInt _param_max_ver_distance;\n \n-\tunsigned _outside_counter;\n+\tint _outside_counter;\n \n \tbool inside(double lat, double lon, float altitude);\n \tbool inside(const struct vehicle_global_position_s &global_position);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/918114973d601635cecedd086759f3ac3029bbeb/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -1149,7 +1149,7 @@ Mission::reset_offboard_mission(struct mission_s &mission)\n \t\t\tif (mission.count > 0) {\n \t\t\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(mission.dataman_id);\n \n-\t\t\t\tfor (int index = 0; index < mission.count; index++) {\n+\t\t\t\tfor (unsigned index = 0; index < mission.count; index++) {\n \t\t\t\t\tstruct mission_item_s item;\n \t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/918114973d601635cecedd086759f3ac3029bbeb/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::reset_offboard_mission"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::reset_offboard_mission"
        ]
      }
    }
  },
  {
    "title": "orb macros: cleanup some unused code",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4576",
    "number": 4576,
    "created_at": "2016-05-19T08:17:18Z",
    "merged": true,
    "merged_at": "2016-05-19T09:08:37Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR title only indicates cleanup of unused code (orb macros) and there is no description, comments, or review text showing a behavioral bug or incorrect program logic being fixed. Without evidence of changed conditional/state/algorithmic behavior, this appears to be refactoring rather than a logic error fix.",
    "patches": {
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "patch": "@@ -119,8 +119,5 @@ struct mission_item_s {\n  * @}\n  */\n \n-/* register this as object request broker structure */\n-ORB_DECLARE(offboard_mission);\n-ORB_DECLARE(onboard_mission);\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/91b4249b50e5535bb9558d2f5076927d7892b9bd/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Param metadata",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4540",
    "number": 4540,
    "created_at": "2016-05-14T00:32:29Z",
    "merged": true,
    "merged_at": "2016-05-14T09:20:28Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "Param metadata cleanup as discussed here. https://github.com/mavlink/qgroundcontrol/issues/3012#issuecomment-219168089\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-14T09:14:53Z",
          "body": "Thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR description only mentions a 'Param metadata cleanup' and links to a discussion, with no explicit mention of fixing incorrect behavior, bugs, or logic. The comments/reviews do not indicate a behavioral problem was resolved; this appears to be a cleanup/refactor of metadata rather than a targeted logic fix. Given the minimal information, there is insufficient evidence that this addresses a logic error.",
    "patches": {
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -72,7 +72,7 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 10.0f);\n PARAM_DEFINE_FLOAT(MIS_LTRMIN_ALT, 1.2f);\n \n /**\n- * Enable persistent onboard mission storage\n+ * Persistent onboard mission storage\n  *\n  * When enabled, missions that have been uploaded by the GCS are stored\n  * and reloaded after reboot persistently.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e1868216927ee3a33a98b3b9d309dfc13a506703/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Bring SITL back to life",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4533",
    "number": 4533,
    "created_at": "2016-05-13T16:38:30Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "julianoes",
      "body": "Reverted the evil commit, works again.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T18:46:13Z",
          "body": "I'll try to fix it proper. I have flown dozens of times in jMAVSim without any regression - can you explain the steps to repro?\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-05-13T18:48:44Z",
          "body": "```\ngit checkout master\ngit submodule update\nmake clean\nmake posix gazebo\n```\n\nThen wait for home, and do `commander takeoff` and it slides along, flips and the estimator goes towards Rapperswil. :smiley: \n\nAnd for jMAVSim, the same, it just doesn't crash as bad but it kinda slides along.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T18:50:08Z",
          "body": "Can you get me a screenshot of the Accel Z measurements of your fixed state? I'd like to see how they look when its idle on the ground.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-05-13T18:54:37Z",
          "body": "![terrible_accel](https://cloud.githubusercontent.com/assets/1419688/15258621/e2477eb4-194c-11e6-9ed2-05ac0de5641e.png)\nYer that looks pretty terrible.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-05-13T18:56:30Z",
          "body": "That would explain the bad flight performance with lots of slow oscillations in gazebo but that's another issue.\n\nThis is a general takeoff issue that affects definitely both jMAVSim and gazebo.\n\nSome setpoint is not set correctly, because it does the takeoff jump but then just slides along without proper setpoints.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T19:38:58Z",
          "body": "What are the steps with jMAVsim to repro?\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-05-13T19:47:21Z",
          "body": "Same thing.\n\n```\ngit checkout master\ngit submodule update\nmake clean\nmake posix jmavsim\n```\n\n```\ncommander takeoff\n```\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T19:51:23Z",
          "body": "Got it. This must actually be much more recent than the commit you bisected. Because I tested that commit that way.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-05-13T20:01:58Z",
          "body": "Well I did a bisect and that's what I got.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T20:03:58Z",
          "body": "I was inaccurate. I did fire the takeoff command via QGC, not shell. And it turns out the shell version did not stick to the API. I just fixed that and now things behave.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T20:06:26Z",
          "body": "I also replaced EKF2 with LPE in SITL. You should find your workflow to be back to bearable. Still looking into speeding up boot time.\n",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-05-13T20:09:43Z",
          "body": "Aha, nice catch!\n\nThanks.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR reverts a commit that caused incorrect runtime behavior (takeoff setpoints not applied, sliding/flipping and bad estimator readings) without crashing. Discussion pins the root cause to an API mismatch / improper state handling for the takeoff command and sensor/setpoint handling in SITL, which are classic logic errors (incorrect state transitions / data flow).",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 43,
        "changes": 58,
        "patch": "@@ -58,8 +58,7 @@\n \n Loiter::Loiter(Navigator *navigator, const char *name) :\n \tMissionBlock(navigator, name),\n-\t_param_min_alt(this, \"MIS_LTRMIN_ALT\", false),\n-\t_loiter_pos_set(false)\n+\t_param_min_alt(this, \"MIS_LTRMIN_ALT\", false)\n {\n \t// load initial params\n \tupdateParams();\n@@ -72,7 +71,6 @@ Loiter::~Loiter()\n void\n Loiter::on_inactive()\n {\n-\t_loiter_pos_set = false;\n }\n \n void\n@@ -81,7 +79,19 @@ Loiter::on_activation()\n \tif (_navigator->get_reposition_triplet()->current.valid) {\n \t\treposition();\n \t} else {\n-\t\tset_loiter_position();\n+\t\t// set current mission item to loiter\n+\t\tset_loiter_item(&_mission_item, _param_min_alt.get());\n+\n+\t\t// convert mission item to current setpoint\n+\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tpos_sp_triplet->current.velocity_valid = false;\n+\t\tpos_sp_triplet->previous.valid = false;\n+\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\tpos_sp_triplet->next.valid = false;\n+\n+\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n }\n \n@@ -91,46 +101,11 @@ Loiter::on_active()\n \tif (_navigator->get_reposition_triplet()->current.valid) {\n \t\treposition();\n \t}\n-\n-\t// reset the loiter position if we get disarmed\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n-\t\t_loiter_pos_set = false;\n-\t}\n-}\n-\n-void\n-Loiter::set_loiter_position()\n-{\n-\t// not setting loiter position until armed\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED ||\n-\t\t_loiter_pos_set) {\n-\t\treturn;\n-\t} else {\n-\t\t_loiter_pos_set = true;\n-\t}\n-\n-\t// set current mission item to loiter\n-\tset_loiter_item(&_mission_item, _param_min_alt.get());\n-\n-\t// convert mission item to current setpoint\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tpos_sp_triplet->current.velocity_valid = false;\n-\tpos_sp_triplet->previous.valid = false;\n-\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n-\tpos_sp_triplet->next.valid = false;\n-\n-\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n-\n-\t_navigator->set_position_setpoint_triplet_updated();\n }\n \n void\n Loiter::reposition()\n {\n-\t// we can't reposition if we are not armed yet\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n-\t\treturn;\n-\t}\n \n \tstruct position_setpoint_triplet_s *rep = _navigator->get_reposition_triplet();\n \n@@ -140,10 +115,7 @@ Loiter::reposition()\n \t\t// convert mission item to current setpoint\n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \t\tpos_sp_triplet->current.velocity_valid = false;\n-\t\tpos_sp_triplet->previous.yaw = _navigator->get_global_position()->yaw;\n-\t\tpos_sp_triplet->previous.lat = _navigator->get_global_position()->lat;\n-\t\tpos_sp_triplet->previous.lon = _navigator->get_global_position()->lon;\n-\t\tpos_sp_triplet->previous.alt = _navigator->get_global_position()->alt;\n+\t\tmemcpy(&pos_sp_triplet->previous, &rep->previous, sizeof(rep->previous));\n \t\tmemcpy(&pos_sp_triplet->current, &rep->current, sizeof(rep->current));\n \t\tpos_sp_triplet->next.valid = false;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b10201372a83fad53f19894190e233fface7ac0/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "patch": "@@ -67,13 +67,7 @@ class Loiter : public MissionBlock\n \t */\n \tvoid reposition();\n \n-\t/**\n-\t * Set the position to hold based on the current local position\n-\t */\n-\tvoid set_loiter_position();\n-\n \tcontrol::BlockParamFloat _param_min_alt;\n-\tbool _loiter_pos_set;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b10201372a83fad53f19894190e233fface7ac0/src%2Fmodules%2Fnavigator%2Floiter.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -143,7 +143,6 @@ class Navigator : public control::SuperBlock\n \tbool\t\t\t\t    home_position_valid() { return (_home_pos.timestamp > 0); }\n \tstruct position_setpoint_triplet_s* get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n \tstruct position_setpoint_triplet_s* get_reposition_triplet() { return &_reposition_triplet; }\n-\tstruct position_setpoint_triplet_s* get_takeoff_triplet() { return &_takeoff_triplet; }\n \tstruct mission_result_s*\t    get_mission_result() { return &_mission_result; }\n \tstruct geofence_result_s*\t\t    get_geofence_result() { return &_geofence_result; }\n \tstruct vehicle_attitude_setpoint_s* get_att_sp() { return &_att_sp; }\n@@ -232,7 +231,6 @@ class Navigator : public control::SuperBlock\n \tfw_pos_ctrl_status_s\t\t\t_fw_pos_ctrl_status;\t\t/**< fixed wing navigation capabilities */\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet;\t/**< triplet of position setpoints */\n \tposition_setpoint_triplet_s\t\t\t_reposition_triplet;\t/**< triplet for non-mission direct position command */\n-\tposition_setpoint_triplet_s\t\t\t_takeoff_triplet;\t/**< triplet for non-mission direct takeoff command */\n \n \tmission_result_s\t\t\t\t_mission_result;\n \tgeofence_result_s\t\t\t\t_geofence_result;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b10201372a83fad53f19894190e233fface7ac0/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 23,
        "changes": 26,
        "patch": "@@ -129,7 +129,6 @@ Navigator::Navigator() :\n \t_fw_pos_ctrl_status{},\n \t_pos_sp_triplet{},\n \t_reposition_triplet{},\n-\t_takeoff_triplet{},\n \t_mission_result{},\n \t_att_sp{},\n \t_mission_item_valid(false),\n@@ -416,7 +415,7 @@ Navigator::task_main()\n \t\t\t\tstruct position_setpoint_triplet_s *rep = get_reposition_triplet();\n \n \t\t\t\t// store current position as previous position and goal as next\n-\t\t\t\trep->previous.yaw = get_global_position()->yaw;\n+\t\t\t\trep->previous.yaw = NAN;\n \t\t\t\trep->previous.lat = get_global_position()->lat;\n \t\t\t\trep->previous.lon = get_global_position()->lon;\n \t\t\t\trep->previous.alt = get_global_position()->alt;\n@@ -449,28 +448,9 @@ Navigator::task_main()\n \t\t\t\trep->previous.valid = true;\n \t\t\t\trep->current.valid = true;\n \t\t\t\trep->next.valid = false;\n-\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n-\t\t\t\tstruct position_setpoint_triplet_s *rep = get_takeoff_triplet();\n-\n-\t\t\t\t// store current position as previous position and goal as next\n-\t\t\t\trep->previous.yaw = get_global_position()->yaw;\n-\t\t\t\trep->previous.lat = get_global_position()->lat;\n-\t\t\t\trep->previous.lon = get_global_position()->lon;\n-\t\t\t\trep->previous.alt = get_global_position()->alt;\n-\n-\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\trep->current.loiter_direction = 1;\n-\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n-\t\t\t\trep->current.yaw = cmd.param4;\n-\t\t\t\trep->current.lat = cmd.param5 / (double)1e7;\n-\t\t\t\trep->current.lon = cmd.param6 / (double)1e7;\n-\t\t\t\trep->current.alt = cmd.param7;\n-\n-\t\t\t\trep->previous.valid = true;\n-\t\t\t\trep->current.valid = true;\n-\t\t\t\trep->next.valid = false;\n+\t\t\t}\n \n-\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n+\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n \t\t\t\twarnx(\"navigator: got pause/continue command\");\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b10201372a83fad53f19894190e233fface7ac0/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 43,
        "changes": 62,
        "patch": "@@ -57,7 +57,7 @@ Takeoff::Takeoff(Navigator *navigator, const char *name) :\n \tMissionBlock(navigator, name),\n \t_param_min_alt(this, \"MIS_TAKEOFF_ALT\", false)\n {\n-\t// load initial params\n+\t/* load initial params */\n \tupdateParams();\n }\n \n@@ -72,32 +72,6 @@ Takeoff::on_inactive()\n \n void\n Takeoff::on_activation()\n-{\n-\tset_takeoff_position();\n-}\n-\n-void\n-Takeoff::on_active()\n-{\n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n-\tif (rep->current.valid) {\n-\t\t// reset the position\n-\t\tset_takeoff_position();\n-\n-\t} else if (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n-\n-\t\t// set loiter item so position controllers stop doing takeoff logic\n-\t\tset_loiter_item(&_mission_item);\n-\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n-\t\t_navigator->set_position_setpoint_triplet_updated();\n-\t}\n-}\n-\n-void\n-Takeoff::set_takeoff_position()\n {\n \t// set current mission item to takeoff\n \tset_takeoff_item(&_mission_item, _param_min_alt.get());\n@@ -115,22 +89,9 @@ Takeoff::set_takeoff_position()\n \tpos_sp_triplet->next.valid = false;\n \n \t// check if a specific target altitude has been set\n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n-\tif (rep->current.valid) {\n-\t\tif (PX4_ISFINITE(rep->current.alt)) {\n-\t\t\tpos_sp_triplet->current.alt = rep->current.alt;\n-\t\t}\n-\n-\t\t// Go on and check which changes had been requested\n-\t\tif (PX4_ISFINITE(rep->current.yaw)) {\n-\t\t\tpos_sp_triplet->current.yaw = rep->current.yaw;\n-\t\t}\n-\n-\t\tif (PX4_ISFINITE(rep->current.lat) && PX4_ISFINITE(rep->current.lon)) {\n-\t\t\tpos_sp_triplet->current.lat = rep->current.lat;\n-\t\t\tpos_sp_triplet->current.lon = rep->current.lon;\n-\t\t}\n-\n+\tstruct position_setpoint_triplet_s *rep = _navigator->get_reposition_triplet();\n+\tif (rep->current.valid && PX4_ISFINITE(rep->current.alt)) {\n+\t\tpos_sp_triplet->current.alt = rep->current.alt;\n \t\t// mark this as done\n \t\tmemset(rep, 0, sizeof(*rep));\n \t}\n@@ -139,3 +100,18 @@ Takeoff::set_takeoff_position()\n \n \t_navigator->set_position_setpoint_triplet_updated();\n }\n+\n+void\n+Takeoff::on_active()\n+{\n+\tif (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n+\t\t_navigator->get_mission_result()->finished = true;\n+\t\t_navigator->set_mission_result_updated();\n+\n+\t\t/* set loiter item so position controllers stop doing takeoff logic */\n+\t\tset_loiter_item(&_mission_item);\n+\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b10201372a83fad53f19894190e233fface7ac0/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/takeoff.h": {
        "filename": "src/modules/navigator/takeoff.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -62,8 +62,6 @@ class Takeoff : public MissionBlock\n \n private:\n \tcontrol::BlockParamFloat _param_min_alt;\n-\n-\tvoid set_takeoff_position();\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b10201372a83fad53f19894190e233fface7ac0/src%2Fmodules%2Fnavigator%2Ftakeoff.h"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::Loiter",
        "set_loiter_position",
        "Takeoff::Takeoff",
        "Loiter::reposition",
        "Navigator::task_main",
        "Loiter::on_activation",
        "Loiter::on_active",
        "Takeoff::set_takeoff_position",
        "get_takeoff_triplet",
        "Takeoff::on_inactive",
        "Navigator::Navigator",
        "set_takeoff_position"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::Loiter",
          "Loiter::reposition",
          "Loiter::on_active",
          "Loiter::on_activation"
        ],
        "src/modules/navigator/loiter.h": [
          "set_loiter_position"
        ],
        "src/modules/navigator/navigator.h": [
          "get_takeoff_triplet"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main",
          "Navigator::Navigator"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::set_takeoff_position",
          "Takeoff::on_inactive",
          "Takeoff::Takeoff"
        ],
        "src/modules/navigator/takeoff.h": [
          "set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "Navigator: Only run FOH logic when in mission mode",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4494",
    "number": 4494,
    "created_at": "2016-05-10T08:14:16Z",
    "merged": true,
    "merged_at": "2016-05-10T11:59:25Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "@tumbili This should fix #4491. Please test in SITL and real flights.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-10T09:18:58Z",
          "body": "Jenkins test this please\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes when FOH logic is executed to only run in mission mode, which addresses an incorrect conditional/state check. That indicates it fixes a logic bug where FOH code could run in inappropriate modes and produce unintended behavior (as referenced by the linked issue).",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2013-2014 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2013-2016 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -864,11 +864,12 @@ Mission::altitude_sp_foh_update()\n \t\treturn;\n \t}\n \n-\t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n+\t/* Don't do FOH for non-missions, landing and takeoff waypoints, the ground may be near\n \t * and the FW controller has a custom landing logic */\n \tif (_mission_item.nav_cmd == NAV_CMD_LAND\n \t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n-\t\t\t|| _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n+\t\t\t|| _mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t\t|| !_navigator->is_planned_mission()) {\n \t\treturn;\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/65f9a86c1965942d388613d10974e34f10ac3444/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::altitude_sp_foh_update",
        "Copyright"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::altitude_sp_foh_update",
          "Copyright"
        ]
      }
    }
  },
  {
    "title": "WIP: Pr topic att sp cleanup",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4478",
    "number": 4478,
    "created_at": "2016-05-07T12:02:56Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2016-05-07T12:04:35Z",
          "body": "@birchera This is the vehicle attitude setpoint cleanup WIP. For now it compiles but I will go through it and implement functions in the matrix lib which can be used all over the code.\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2016-07-20T13:23:36Z",
          "body": "Replaced by #5105 \n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR is a WIP refactor/cleanup of vehicle attitude setpoint code and mentions implementing matrix helper functions; there is no description or comments indicating it fixes incorrect behavior or addresses a specific bug. It was later replaced by another PR (#5105), further suggesting this PR itself did not resolve a concrete logic error.",
    "patches": {
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -102,8 +102,10 @@ GpsFailure::on_active()\n \tcase GPSF_STATE_LOITER: {\n \t\t/* Position controller does not run in this mode:\n \t\t * navigator has to publish an attitude setpoint */\n-\t\t_navigator->get_att_sp()->roll_body = M_DEG_TO_RAD_F * _param_openlooploiter_roll.get();\n-\t\t_navigator->get_att_sp()->pitch_body = M_DEG_TO_RAD_F * _param_openlooploiter_pitch.get();\n+\t\tmatrix::Quaternion<float> q_sp(&_navigator->get_att_sp()->q_d[0]);\n+\t\tmatrix::Euler<float> euler_sp(q_sp);\n+\t\teuler_sp(0) = M_DEG_TO_RAD_F * _param_openlooploiter_roll.get();\n+\t\teuler_sp(1) = M_DEG_TO_RAD_F * _param_openlooploiter_pitch.get();\n \t\t_navigator->get_att_sp()->thrust = _param_openlooploiter_thrust.get();\n \t\t_navigator->publish_att_sp();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e5846f830d34814df8a197bfaaab33e010945d3/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "GpsFailure::on_active"
      ],
      "by_file": {
        "src/modules/navigator/gpsfailure.cpp": [
          "GpsFailure::on_active"
        ]
      }
    }
  },
  {
    "title": "Param metadata",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4472",
    "number": 4472,
    "created_at": "2016-05-06T22:23:51Z",
    "merged": true,
    "merged_at": "2016-05-11T16:47:26Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This mainly adds increment and decimal to fixed wing params.\n\nOne thing to note is that increment and decimal for `@unit norm` (0-1.0) is somewhat confusing. Those actually apply to the QGC formatted percent (0-100).\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-07T09:06:14Z",
          "body": "Can you fix the decimal and increment to relate to the norm field, not to the percentage? The improper scaling should be fixed on the QGC side instead.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-08T00:49:56Z",
          "body": "Yes that sounds like the better solution. I'll take a look.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-08T09:30:06Z",
          "body": "@dagar Here is the QGC support for that (screenshot included against meta data from master):\nhttps://github.com/mavlink/qgroundcontrol/pull/3346\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-11T07:46:51Z",
          "body": "@dagar Did you get a chance to rework the patch here to have the proper units? The QGC change is in and released, so all that's missing is really getting this PR in.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2016-05-11T16:36:44Z",
          "body": "I fixed the @norm usage. QGC params already looked much better with just your change.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-11T16:49:07Z",
          "body": "Thanks merged!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect scaling/semantics: increment and decimal were being applied to a percent (0â€“100) representation rather than the @unit norm (0â€“1) values, causing improper parameter behavior/representation. The change makes the metadata relate to the norm field (and QGC was adjusted accordingly), correcting the logical mismatch rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/datalinkloss_params.c": {
        "filename": "src/modules/navigator/datalinkloss_params.c",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "patch": "@@ -50,6 +50,9 @@\n  *\n  * @unit s\n  * @min 0.0\n+ * @max 3600.0\n+ * @decimal 0\n+ * @increment 1\n  * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_DLL_CH_T, 120.0f);\n@@ -86,17 +89,22 @@ PARAM_DEFINE_INT32(NAV_DLL_CH_LON, 1518453890);\n  * @unit m\n  * @min -50\n  * @max 30000\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_DLL_CH_ALT, 600.0f);\n \n /**\n- * Airfield hole wait time\n+ * Airfield home wait time\n  *\n  * The amount of time in seconds the system should wait at the airfield home waypoint\n  *\n  * @unit s\n  * @min 0.0\n+ * @max 3600.0\n+ * @decimal 0\n+ * @increment 1\n  * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_DLL_AH_T, 120.0f);\n@@ -106,9 +114,9 @@ PARAM_DEFINE_FLOAT(NAV_DLL_AH_T, 120.0f);\n  *\n  * After more than this number of data link timeouts the aircraft returns home directly\n  *\n- * @group Data Link Loss\n  * @min 0\n  * @max 1000\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_INT32(NAV_DLL_N, 2);\n \n@@ -118,7 +126,7 @@ PARAM_DEFINE_INT32(NAV_DLL_N, 2);\n  * If set to 1 the system will skip the comms hold wp on data link loss and will directly fly to\n  * airfield home\n  *\n- * @group Data Link Loss\n  * @boolean\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CHSK, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8e130c878c4f871cdd79309a392a54b66d29c2ee/src%2Fmodules%2Fnavigator%2Fdatalinkloss_params.c"
      },
      "src/modules/navigator/gpsfailure_params.c": {
        "filename": "src/modules/navigator/gpsfailure_params.c",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "patch": "@@ -51,6 +51,9 @@\n  *\n  * @unit s\n  * @min 0.0\n+ * @max 3600.0\n+ * @decimal 0\n+ * @increment 1\n  * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_LT, 30.0f);\n@@ -63,6 +66,8 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_LT, 30.0f);\n  * @unit deg\n  * @min 0.0\n  * @max 30.0\n+ * @decimal 1\n+ * @increment 0.5\n  * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_R, 15.0f);\n@@ -75,6 +80,8 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_R, 15.0f);\n  * @unit deg\n  * @min -30.0\n  * @max 30.0\n+ * @decimal 1\n+ * @increment 0.5\n  * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_P, 0.0f);\n@@ -84,8 +91,11 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_P, 0.0f);\n  *\n  * Thrust value which is set during the open loop loiter\n  *\n+ * @unit norm\n  * @min 0.0\n  * @max 1.0\n+ * @decimal 2\n+ * @increment 0.05\n  * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_TR, 0.7f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8e130c878c4f871cdd79309a392a54b66d29c2ee/src%2Fmodules%2Fnavigator%2Fgpsfailure_params.c"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "patch": "@@ -51,6 +51,8 @@\n  * @unit m\n  * @min 0\n  * @max 80\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 10.0f);\n@@ -63,6 +65,8 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 10.0f);\n  * @unit m\n  * @min 0\n  * @max 80\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_LTRMIN_ALT, 1.2f);\n@@ -88,6 +92,8 @@ PARAM_DEFINE_INT32(MIS_ONBOARD_EN, 1);\n  * @unit m\n  * @min 0\n  * @max 1000\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_DIST_1WP, 900);\n@@ -133,17 +139,19 @@ PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n  * @unit s\n  * @min -1\n  * @max 20\n+ * @decimal 1\n  * @increment 1\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n \n /**\n- * Max yaw error in degree needed for waypoint heading acceptance.\n+ * Max yaw error in degrees needed for waypoint heading acceptance.\n  *\n  * @unit deg\n  * @min 0\n  * @max 90\n+ * @decimal 1\n  * @increment 1\n  * @group Mission\n  */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8e130c878c4f871cdd79309a392a54b66d29c2ee/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -48,6 +48,8 @@\n  * @unit m\n  * @min 25\n  * @max 1000\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(NAV_LOITER_RAD, 50.0f);\n@@ -60,6 +62,8 @@ PARAM_DEFINE_FLOAT(NAV_LOITER_RAD, 50.0f);\n  * @unit m\n  * @min 0.05\n  * @max 200.0\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(NAV_ACC_RAD, 10.0f);\n@@ -131,6 +135,8 @@ PARAM_DEFINE_INT32(NAV_AH_LON, 1518423250);\n  *\n  * @unit m\n  * @min -50\n+ * @decimal 1\n+ * @increment 0.5\n  * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_AH_ALT, 600.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8e130c878c4f871cdd79309a392a54b66d29c2ee/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Auto take-off corner case: Reset work item type when landed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4420",
    "number": 4420,
    "created_at": "2016-05-03T12:10:25Z",
    "merged": true,
    "merged_at": "2016-05-03T12:13:17Z",
    "state": "closed",
    "conversation": {
      "author": "mswingtra",
      "body": "If the auto mission is paused/aborted during take-off and we land in manual mode, then work_item_type needs to be reset unless we re-power. Otherwise, it is set to WORK_ITEM_TYPE_TAKEOFF, and take-off waypoint is treated as normal position waypoint next time mission is launched. Thus, controller does not use take-off logic but position control logic. \n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-03T12:13:30Z",
          "body": "Thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes improper state handling: when a take-off is aborted/paused and the vehicle lands in manual mode, the work_item_type was not being reset, causing the next mission to misinterpret the take-off waypoint as a normal position waypoint. This is a logic bug (incorrect state transition/boundary condition) that leads to incorrect controller behavior rather than a crash.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -146,6 +146,11 @@ Mission::on_inactive()\n \t/* require takeoff after non-loiter or landing */\n \tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n \t\t_need_takeoff = true;\n+\t\t/* Reset work item type to default if auto take-off has been paused or aborted,\n+\t\t   and we landed in manual mode. */\n+\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n+\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\t\t\n+\t\t}\n \t}\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9db80b75f4603787b96ce324f6a827fd29406cb0/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::on_inactive"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_inactive"
        ]
      }
    }
  },
  {
    "title": "FW add mavlink NAV_CONTROLLER_OUTPUT",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4363",
    "number": 4363,
    "created_at": "2016-04-25T18:15:08Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This implements mavlink NAV_CONTROLLER_OUTPUT to show altitude and airspeed error for fixed wing.\nhttp://mavlink.org/messages/common#NAV_CONTROLLER_OUTPUT\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2016-04-26T07:48:12Z",
          "body": "Looking good. Will merge once we have 1.3.0 out.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-13T10:56:26Z",
          "body": "Rebased and applied.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR adds support for the MAVLink NAV_CONTROLLER_OUTPUT message to report altitude and airspeed error for fixed-wing â€” it's a feature/telemetry addition. The description and comments indicate implementation and merge, with no mention of correcting incorrect behavior, state transitions, or faulty logic, so this is not a logic error fix.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "patch": "@@ -55,11 +55,11 @@\n \n MissionFeasibilityChecker::MissionFeasibilityChecker() :\n \t_mavlink_log_pub(nullptr),\n-\t_capabilities_sub(-1),\n+\t_fw_pos_ctrl_status_sub(-1),\n \t_initDone(false),\n \t_dist_1wp_ok(false)\n {\n-\t_nav_caps = {0};\n+\t_fw_pos_ctrl_status = {};\n }\n \n \n@@ -275,7 +275,6 @@ bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size\n \t/* Go through all mission items and search for a landing waypoint\n \t * if landing waypoint is found: the previous waypoint is checked to be at a feasible distance and altitude given the landing slope */\n \n-\n \tfor (size_t i = 0; i < nMissionItems; i++) {\n \t\tstruct mission_item_s missionitem;\n \t\tconst ssize_t len = sizeof(missionitem);\n@@ -293,15 +292,15 @@ bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size\n \t\t\t\t}\n \n \t\t\t\tfloat wp_distance = get_distance_to_next_waypoint(missionitem_previous.lat , missionitem_previous.lon, missionitem.lat, missionitem.lon);\n-\t\t\t\tfloat slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude, _nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad);\n-\t\t\t\tfloat wp_distance_req = Landingslope::getLandingSlopeWPDistance(missionitem_previous.altitude, missionitem.altitude, _nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad);\n+\t\t\t\tfloat slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude, _fw_pos_ctrl_status.landing_horizontal_slope_displacement, _fw_pos_ctrl_status.landing_slope_angle_rad);\n+\t\t\t\tfloat wp_distance_req = Landingslope::getLandingSlopeWPDistance(missionitem_previous.altitude, missionitem.altitude, _fw_pos_ctrl_status.landing_horizontal_slope_displacement, _fw_pos_ctrl_status.landing_slope_angle_rad);\n \t\t\t\tfloat delta_altitude = missionitem.altitude - missionitem_previous.altitude;\n //\t\t\t\twarnx(\"wp_distance %.2f, delta_altitude %.2f, missionitem_previous.altitude %.2f, missionitem.altitude %.2f, slope_alt_req %.2f, wp_distance_req %.2f\",\n //\t\t\t\t\t\twp_distance, delta_altitude, missionitem_previous.altitude, missionitem.altitude, slope_alt_req, wp_distance_req);\n //\t\t\t\twarnx(\"_nav_caps.landing_horizontal_slope_displacement %.4f, _nav_caps.landing_slope_angle_rad %.4f, _nav_caps.landing_flare_length %.4f\",\n //\t\t\t\t\t\t_nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad, _nav_caps.landing_flare_length);\n \n-\t\t\t\tif (wp_distance > _nav_caps.landing_flare_length) {\n+\t\t\t\tif (wp_distance > _fw_pos_ctrl_status.landing_flare_length) {\n \t\t\t\t\t/* Last wp is before flare region */\n \n \t\t\t\t\tif (delta_altitude < 0) {\n@@ -424,14 +423,14 @@ MissionFeasibilityChecker::isPositionCommand(unsigned cmd){\n \n void MissionFeasibilityChecker::updateNavigationCapabilities()\n {\n-\t(void)orb_copy(ORB_ID(navigation_capabilities), _capabilities_sub, &_nav_caps);\n+\t(void)orb_copy(ORB_ID(fw_pos_ctrl_status), _fw_pos_ctrl_status_sub, &_fw_pos_ctrl_status);\n }\n \n void MissionFeasibilityChecker::init()\n {\n \tif (!_initDone) {\n \n-\t\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n+\t\t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n \n \t\t_initDone = true;\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee9b404fea24e0e3e5542b8fce4a980facf6de72/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -44,7 +44,7 @@\n \n #include <unistd.h>\n #include <uORB/topics/mission.h>\n-#include <uORB/topics/navigation_capabilities.h>\n+#include <uORB/topics/fw_pos_ctrl_status.h>\n #include <dataman/dataman.h>\n #include \"geofence.h\"\n \n@@ -54,8 +54,8 @@ class MissionFeasibilityChecker\n private:\n \torb_advert_t\t\t*_mavlink_log_pub;\n \n-\tint _capabilities_sub;\n-\tstruct navigation_capabilities_s _nav_caps;\n+\tint _fw_pos_ctrl_status_sub;\n+\tstruct fw_pos_ctrl_status_s _fw_pos_ctrl_status;\n \n \tbool _initDone;\n \tbool _dist_1wp_ok;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee9b404fea24e0e3e5542b8fce4a980facf6de72/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -207,7 +207,7 @@ class Navigator : public control::SuperBlock\n \tint\t\t_home_pos_sub;\t\t\t/**< home position subscription */\n \tint\t\t_vstatus_sub;\t\t\t/**< vehicle status subscription */\n \tint\t\t_land_detected_sub;\t\t/**< vehicle land detected subscription */\n-\tint\t\t_capabilities_sub;\t\t/**< notification of vehicle capabilities updates */\n+\tint\t\t_fw_pos_ctrl_status_sub;\t\t/**< notification of vehicle capabilities updates */\n \tint\t\t_control_mode_sub;\t\t/**< vehicle control mode subscription */\n \tint\t\t_onboard_mission_sub;\t\t/**< onboard mission subscription */\n \tint\t\t_offboard_mission_sub;\t\t/**< offboard mission subscription */\n@@ -229,7 +229,7 @@ class Navigator : public control::SuperBlock\n \tsensor_combined_s\t\t\t\t_sensor_combined;\t/**< sensor values */\n \thome_position_s\t\t\t\t\t_home_pos;\t\t/**< home position for RTL */\n \tmission_item_s \t\t\t\t\t_mission_item;\t\t/**< current mission item */\n-\tnavigation_capabilities_s\t\t\t_nav_caps;\t\t/**< navigation capabilities */\n+\tfw_pos_ctrl_status_s\t\t\t_fw_pos_ctrl_status;\t\t/**< fixed wing navigation capabilities */\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet;\t/**< triplet of position setpoints */\n \tposition_setpoint_triplet_s\t\t\t_reposition_triplet;\t/**< triplet for non-mission direct position command */\n \tposition_setpoint_triplet_s\t\t\t_takeoff_triplet;\t/**< triplet for non-mission direct takeoff command */\n@@ -301,9 +301,9 @@ class Navigator : public control::SuperBlock\n \tvoid\t\thome_position_update(bool force=false);\n \n \t/**\n-\t * Retreive navigation capabilities\n+\t * Retrieve fixed wing navigation capabilities\n \t */\n-\tvoid\t\tnavigation_capabilities_update();\n+\tvoid\t\tfw_pos_ctrl_status_update();\n \n \t/**\n \t * Retrieve vehicle status",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee9b404fea24e0e3e5542b8fce4a980facf6de72/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "patch": "@@ -70,7 +70,7 @@\n #include <uORB/topics/vehicle_status.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/fence.h>\n-#include <uORB/topics/navigation_capabilities.h>\n+#include <uORB/topics/fw_pos_ctrl_status.h>\n #include <uORB/topics/vehicle_command.h>\n #include <drivers/drv_baro.h>\n \n@@ -108,7 +108,7 @@ Navigator::Navigator() :\n \t_home_pos_sub(-1),\n \t_vstatus_sub(-1),\n \t_land_detected_sub(-1),\n-\t_capabilities_sub(-1),\n+\t_fw_pos_ctrl_status_sub(-1),\n \t_control_mode_sub(-1),\n \t_onboard_mission_sub(-1),\n \t_offboard_mission_sub(-1),\n@@ -126,7 +126,7 @@ Navigator::Navigator() :\n \t_sensor_combined{},\n \t_home_pos{},\n \t_mission_item{},\n-\t_nav_caps{},\n+\t_fw_pos_ctrl_status{},\n \t_pos_sp_triplet{},\n \t_reposition_triplet{},\n \t_takeoff_triplet{},\n@@ -231,9 +231,9 @@ Navigator::home_position_update(bool force)\n }\n \n void\n-Navigator::navigation_capabilities_update()\n+Navigator::fw_pos_ctrl_status_update()\n {\n-\torb_copy(ORB_ID(navigation_capabilities), _capabilities_sub, &_nav_caps);\n+\torb_copy(ORB_ID(fw_pos_ctrl_status), _fw_pos_ctrl_status_sub, &_fw_pos_ctrl_status);\n }\n \n void\n@@ -298,7 +298,7 @@ Navigator::task_main()\n \t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n \t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n \t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n-\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n+\t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n \t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n \t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n \t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n@@ -316,7 +316,7 @@ Navigator::task_main()\n \tgps_position_update();\n \tsensor_combined_update();\n \thome_position_update(true);\n-\tnavigation_capabilities_update();\n+\tfw_pos_ctrl_status_update();\n \tparams_update();\n \n \t/* wakeup source(s) */\n@@ -395,9 +395,9 @@ Navigator::task_main()\n \t\t}\n \n \t\t/* navigation capabilities updated */\n-\t\torb_check(_capabilities_sub, &updated);\n+\t\torb_check(_fw_pos_ctrl_status_sub, &updated);\n \t\tif (updated) {\n-\t\t\tnavigation_capabilities_update();\n+\t\t\tfw_pos_ctrl_status_update();\n \t\t}\n \n \t\t/* home position updated */\n@@ -524,7 +524,7 @@ Navigator::task_main()\n \t\t\t\t_can_loiter_at_sp = false;\n \t\t\t\tbreak;\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n-\t\t\t\tif (_nav_caps.abort_landing) {\n+\t\t\t\tif (_fw_pos_ctrl_status.abort_landing) {\n \t\t\t\t\t// pos controller aborted landing, requests loiter\n \t\t\t\t\t// above landing waypoint\n \t\t\t\t\t_navigation_mode = &_loiter;\n@@ -727,9 +727,9 @@ Navigator::get_acceptance_radius(float mission_item_radius)\n \t// when in fixed wing mode\n \t// this might need locking against a commanded transition\n \t// so that a stale _vstatus doesn't trigger an accepted mission item.\n-\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode && hrt_elapsed_time(&_nav_caps.timestamp) < 5000000) {\n-\t\tif (_nav_caps.turn_distance > radius) {\n-\t\t\tradius = _nav_caps.turn_distance;\n+\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n+\t\tif ((hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 5000000) && (_fw_pos_ctrl_status.turn_distance > radius)) {\n+\t\t\tradius = _fw_pos_ctrl_status.turn_distance;\n \t\t}\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee9b404fea24e0e3e5542b8fce4a980facf6de72/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "Navigator::home_position_update",
        "MissionFeasibilityChecker::isPositionCommand",
        "MissionFeasibilityChecker::MissionFeasibilityChecker",
        "Navigator::task_main",
        "navigation_capabilities_update",
        "Landingslope::getLandingSlopeAbsoluteAltitude",
        "Navigator::Navigator",
        "Landingslope::getLandingSlopeWPDistance",
        "Navigator::get_acceptance_radius"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding",
          "MissionFeasibilityChecker::isPositionCommand",
          "MissionFeasibilityChecker::MissionFeasibilityChecker",
          "Landingslope::getLandingSlopeAbsoluteAltitude",
          "Landingslope::getLandingSlopeWPDistance"
        ],
        "src/modules/navigator/navigator.h": [
          "navigation_capabilities_update"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::home_position_update",
          "Navigator::task_main",
          "Navigator::get_acceptance_radius",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Support for reposition MAVLink command",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4347",
    "number": 4347,
    "created_at": "2016-04-23T18:13:57Z",
    "merged": true,
    "merged_at": "2016-04-24T14:54:11Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "@dagar @DonLakeFlyer This implements the reposition command. Now I need QGC support / implementing it in order to finish the testing. Pretty close though and will go into 1.3.0.\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR message indicates adding support/implementation for a new 'reposition' MAVLink command rather than correcting incorrect behavior. There is no mention of fixing an incorrect algorithm, state transition, or unintended output, so this appears to be feature implementation, not a logic bug fix.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 11,
        "changes": 54,
        "patch": "@@ -58,7 +58,7 @@ Loiter::Loiter(Navigator *navigator, const char *name) :\n \tMissionBlock(navigator, name),\n \t_param_min_alt(this, \"MIS_LTRMIN_ALT\", false)\n {\n-\t/* load initial params */\n+\t// load initial params\n \tupdateParams();\n }\n \n@@ -74,22 +74,54 @@ Loiter::on_inactive()\n void\n Loiter::on_activation()\n {\n-\t/* set current mission item to loiter */\n-\tset_loiter_item(&_mission_item, _param_min_alt.get());\n+\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\t\treposition();\n+\t} else {\n+\t\t// set current mission item to loiter\n+\t\tset_loiter_item(&_mission_item, _param_min_alt.get());\n \n-\t/* convert mission item to current setpoint */\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tpos_sp_triplet->current.velocity_valid = false;\n-\tpos_sp_triplet->previous.valid = false;\n-\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n-\tpos_sp_triplet->next.valid = false;\n+\t\t// convert mission item to current setpoint\n+\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tpos_sp_triplet->current.velocity_valid = false;\n+\t\tpos_sp_triplet->previous.valid = false;\n+\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n+\t\tpos_sp_triplet->next.valid = false;\n \n-\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n+\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n \n-\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t}\n }\n \n void\n Loiter::on_active()\n {\n+\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\t\treposition();\n+\t}\n+}\n+\n+void\n+Loiter::reposition()\n+{\n+\n+\tstruct position_setpoint_triplet_s *rep = _navigator->get_reposition_triplet();\n+\n+\tif (rep->current.valid) {\n+\t\t// set loiter position based on reposition command\n+\n+\t\t// convert mission item to current setpoint\n+\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tpos_sp_triplet->current.velocity_valid = false;\n+\t\tmemcpy(&pos_sp_triplet->previous, &rep->previous, sizeof(rep->previous));\n+\t\tmemcpy(&pos_sp_triplet->current, &rep->current, sizeof(rep->current));\n+\t\tpos_sp_triplet->next.valid = false;\n+\n+\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t\t// mark this as done\n+\t\tmemset(rep, 0, sizeof(*rep));\n+\t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/588133e85d80907f97bc3fe8fd7f97ec5c010bf6/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -61,6 +61,12 @@ class Loiter : public MissionBlock\n \tvirtual void on_active();\n \n private:\n+\t/**\n+\t * Use the stored reposition location of the navigator\n+\t * to move to a new location.\n+\t */\n+\tvoid reposition();\n+\n \tcontrol::BlockParamFloat _param_min_alt;\n };\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/588133e85d80907f97bc3fe8fd7f97ec5c010bf6/src%2Fmodules%2Fnavigator%2Floiter.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -142,6 +142,7 @@ class Navigator : public control::SuperBlock\n \tstruct home_position_s*\t\t    get_home_position() { return &_home_pos; }\n \tbool\t\t\t\t    home_position_valid() { return (_home_pos.timestamp > 0); }\n \tstruct position_setpoint_triplet_s* get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n+\tstruct position_setpoint_triplet_s* get_reposition_triplet() { return &_reposition_triplet; }\n \tstruct mission_result_s*\t    get_mission_result() { return &_mission_result; }\n \tstruct geofence_result_s*\t\t    get_geofence_result() { return &_geofence_result; }\n \tstruct vehicle_attitude_setpoint_s* get_att_sp() { return &_att_sp; }\n@@ -227,6 +228,7 @@ class Navigator : public control::SuperBlock\n \tmission_item_s \t\t\t\t\t_mission_item;\t\t/**< current mission item */\n \tnavigation_capabilities_s\t\t\t_nav_caps;\t\t/**< navigation capabilities */\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet;\t/**< triplet of position setpoints */\n+\tposition_setpoint_triplet_s\t\t\t_reposition_triplet;\t/**< triplet for non-mission direct position command */\n \n \tmission_result_s\t\t\t\t_mission_result;\n \tgeofence_result_s\t\t\t\t_geofence_result;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/588133e85d80907f97bc3fe8fd7f97ec5c010bf6/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "patch": "@@ -128,6 +128,7 @@ Navigator::Navigator() :\n \t_mission_item{},\n \t_nav_caps{},\n \t_pos_sp_triplet{},\n+\t_reposition_triplet{},\n \t_mission_result{},\n \t_att_sp{},\n \t_mission_item_valid(false),\n@@ -408,7 +409,43 @@ Navigator::task_main()\n \t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n \n \t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n-\t\t\t\twarnx(\"navigator: got reposition command\");\n+\n+\t\t\t\tstruct position_setpoint_triplet_s *rep = get_reposition_triplet();\n+\n+\t\t\t\t// store current position as previous position and goal as next\n+\t\t\t\trep->previous.yaw = NAN;\n+\t\t\t\trep->previous.lat = get_global_position()->lat;\n+\t\t\t\trep->previous.lon = get_global_position()->lon;\n+\t\t\t\trep->previous.alt = get_global_position()->alt;\n+\n+\t\t\t\t// Go on and check which changes had been requested\n+\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n+\t\t\t\t\trep->current.yaw = cmd.param4;\n+\t\t\t\t} else {\n+\t\t\t\t\trep->current.yaw = NAN;\n+\t\t\t\t}\n+\n+\t\t\t\tif (PX4_ISFINITE(cmd.param5)) {\n+\t\t\t\t\trep->current.lat = cmd.param5 / (double)1e7;\n+\t\t\t\t} else {\n+\t\t\t\t\trep->current.lat = get_global_position()->lat;\n+\t\t\t\t}\n+\n+\t\t\t\tif (PX4_ISFINITE(cmd.param6)) {\n+\t\t\t\t\trep->current.lon = cmd.param6 / (double)1e7;\n+\t\t\t\t} else {\n+\t\t\t\t\trep->current.lon = get_global_position()->lon;\n+\t\t\t\t}\n+\n+\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n+\t\t\t\t\trep->current.alt = cmd.param7;\n+\t\t\t\t} else {\n+\t\t\t\t\trep->current.alt = get_global_position()->alt;\n+\t\t\t\t}\n+\n+\t\t\t\trep->previous.valid = true;\n+\t\t\t\trep->current.valid = true;\n+\t\t\t\trep->next.valid = false;\n \t\t\t}\n \n \t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/588133e85d80907f97bc3fe8fd7f97ec5c010bf6/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::Loiter",
        "Loiter::on_inactive",
        "Navigator::task_main",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::Loiter",
          "Loiter::on_inactive"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Better granularity for flight failsafe modes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/4344",
    "number": 4344,
    "created_at": "2016-04-23T14:54:59Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "@kd0aij Testing this with props off would be great. Main documentation:\n\n``` C++\n/**\n * Set data link loss failsafe mode\n *\n * The data link loss failsafe will only be entered after a timeout,\n * set by COM_RC_LOSS_T in seconds.\n *\n * @value 0 Disabled\n * @value 1 Loiter\n * @value 2 Return to Land\n * @value 3 Land at current position\n * @value 4 Outback Challenge (OBC) rules\n *\n * @group Mission\n */\nPARAM_DEFINE_INT32(NAV_DLL_ACT, 0);\n\n/**\n * Set RC loss failsafe mode\n *\n * The RC loss failsafe will only be entered after a timeout,\n * set by COM_RC_LOSS_T in seconds. If the timeout value is smaller than\n * zero it will never be entered. If RC input checks have been disabled\n * by setting the COM_RC_IN_MODE param it will also not be triggered.\n *\n * @value 0 Disabled\n * @value 1 Loiter\n * @value 2 Return to Land\n * @value 3 Land at current position\n * @value 4 Outback Challenge (OBC) rules\n *\n * @group Mission\n */\nPARAM_DEFINE_INT32(NAV_RCL_ACT, 0);\n```\n\n@DonLakeFlyer The comments above should also be enough to re-do the safety screen. I've broken the param system with this change, I need to think how we address that.\n",
      "issue_comments": [
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T15:09:51Z",
          "body": "For testing this, can \"datalink\" be wifi connection of QGC to pixracer? \n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-04-23T15:10:30Z",
          "body": "Yes, that should trigger it.\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T15:56:22Z",
          "body": "first test of RC loss with option 3 gave no feedback on console or QGC and motor speed did not change\n\nalso getting this on the console:\n\n```\nWARN  Failed to open MAVLink log: /fs/microsd/msgs_2016_04_23_15_53_43.txt@ï¿½ errno=22\nWARN  Failed to open MAVLink log: /fs/microsd/msgs_2016_04_23_15_53_48.txt@ï¿½ errno=22\nWARN  Failed to open MAVLink log: /fs/microsd/msgs_2016_04_23_15_53_48.txt@ï¿½ errno=22\n```\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-04-23T16:15:03Z",
          "body": "@kd0aij If you get these you need to wipe your SD card. File system fail.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-04-23T16:15:58Z",
          "body": "Its possible that the motor speed is not changing if the system believes it already is landed. But I need to check.\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T16:20:20Z",
          "body": "is there a console or mavlink message indicating failsafe is engaged?\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T16:27:51Z",
          "body": "refetched, cleaned and reflashed. RC loss results in QGC \"Landing\" mode and much later \"failsafe mode on\". No messages on console. Motors sped up and stayed at that speed for several minutes. What is supposed to happen?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-04-23T16:28:59Z",
          "body": "That sounds about right. It would have landed on-spot.\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T16:29:47Z",
          "body": "motors never stop?\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T16:31:31Z",
          "body": "battery voltage reading in QGC is erratic... critical battery warning with FrSky telemetry showing 11.1V\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T16:32:35Z",
          "body": "I have an ACSP5 on this PixRacer\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T16:37:33Z",
          "body": "Why isn't there an RC failsafe option to kill the motors? Is that the OBC mode?\n@LorenzMeier Does the copter disarm after \"land at current position\" when RC is lost?\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-04-23T17:53:07Z",
          "body": "Killing the wifi link while armed in manual mode didn't appear to do anything, but I guess there's intentionally no feedback on the console?\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-05-02T23:05:08Z",
          "body": "@LorenzMeier I see you merged this with open questions from me... Were there other test results which were more definitive? I tried this again today with the copter tied down, but the \"land at current position\" motor behavior seemed wrong, and it went to high throttle when I turned the TX back on, so I don't trust that option. So as far as I can tell, there's no safe option available to prevent a fly-away on RC loss.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-03T07:44:18Z",
          "body": "You will need to try this on a tether, rather than tied down. If its close to home it will land straight, if it is not close to home it will RTL.\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-05-03T13:23:06Z",
          "body": "is a GPS lock required?\n\nOn Tue, May 3, 2016 at 1:44 AM Lorenz Meier notifications@github.com\nwrote:\n\n> You will need to try this on a tether, rather than tied down. If its close\n> to home it will land straight, if it is not close to home it will RTL.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/PX4/Firmware/pull/4344#issuecomment-216460164\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2016-05-30T14:37:58Z",
          "body": "apparently this needs more testing, but I would need more explanation of expected results to be able to test it safely: https://github.com/PX4/Firmware/issues/4674\n",
          "type": "issue_comment"
        },
        {
          "author": "xn365",
          "created_at": "2016-05-31T13:47:01Z",
          "body": "https://github.com/PX4/Firmware/blob/master/src/modules/navigator/navigator_main.cpp#L344\nI think navigator will not working When we don't have gps.\nCould AUTOLAND or LANDGPSFAIL mode run in this case?\nhttps://github.com/PX4/Firmware/blob/master/src/modules/commander/state_machine_helper.cpp#L615\nWe will chang to DESCEND mode in the case of  RC lost and have no GPS.\nBut this line will never be reached when we have no GPS :https://github.com/PX4/Firmware/blob/master/src/modules/navigator/navigator_main.cpp#L566\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR introduces finer-grained failsafe modes (a feature change) but does not clearly fix an existing logic bug; testers report unexpected behavior (motors not stopping, incorrect mode transitions when GPS is absent) and the author even notes the param system was broken by the change. Those reported behaviors are logic errors in the system, but the PR itself appears to have introduced or exposed them rather than providing a targeted fix.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -518,13 +518,13 @@ Navigator::task_main()\n \t\t\t\tbreak;\n \t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n-\t\t\t\tif (_param_rcloss_act.get() == 0) {\n+\t\t\t\tif (_param_rcloss_act.get() == 1) {\n \t\t\t\t\t_navigation_mode = &_loiter;\n-\t\t\t\t} else if (_param_rcloss_act.get() == 2) {\n-\t\t\t\t\t_navigation_mode = &_land;\n \t\t\t\t} else if (_param_rcloss_act.get() == 3) {\n+\t\t\t\t\t_navigation_mode = &_land;\n+\t\t\t\t} else if (_param_rcloss_act.get() == 4) {\n \t\t\t\t\t_navigation_mode = &_rcLoss;\n-\t\t\t\t} else { /* if == 1 or unknown, RTL */\n+\t\t\t\t} else { /* if == 2 or unknown, RTL */\n \t\t\t\t\t_navigation_mode = &_rtl;\n \t\t\t\t}\n \t\t\t\tbreak;\n@@ -548,13 +548,13 @@ Navigator::task_main()\n \t\t\t\t/* Use complex data link loss mode only when enabled via param\n \t\t\t\t* otherwise use rtl */\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n-\t\t\t\tif (_param_datalinkloss_act.get() == 0) {\n+\t\t\t\tif (_param_datalinkloss_act.get() == 1) {\n \t\t\t\t\t_navigation_mode = &_loiter;\n-\t\t\t\t} else if (_param_datalinkloss_act.get() == 2) {\n-\t\t\t\t\t_navigation_mode = &_land;\n \t\t\t\t} else if (_param_datalinkloss_act.get() == 3) {\n+\t\t\t\t\t_navigation_mode = &_land;\n+\t\t\t\t} else if (_param_datalinkloss_act.get() == 4) {\n \t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n-\t\t\t\t} else { /* if == 1 or unknown, RTL */\n+\t\t\t\t} else { /* if == 2 or unknown, RTL */\n \t\t\t\t\t_navigation_mode = &_rtl;\n \t\t\t\t}\n \t\t\t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7fec8ae7d5e8931563e6e35732bd2e440427d994/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2014, 2015 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2014-2016 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -68,34 +68,37 @@ PARAM_DEFINE_FLOAT(NAV_ACC_RAD, 10.0f);\n  * Set data link loss failsafe mode\n  *\n  * The data link loss failsafe will only be entered after a timeout,\n- * set by a DIFFERENT parameter. If the timeout value is smaller than\n- * zero it will never be entered.\n+ * set by COM_DL_LOSS_T in seconds. Once the timeout occurs the selected\n+ * action will be executed. Setting this parameter to 4 will enable CASA\n+ * Outback Challenge rules, which are only recommended to participants\n+ * of that competition.\n  *\n- * @value 0 Loiter\n- * @value 1 Return to Land\n- * @value 2 Land at current position\n- * @value 3 Outback Challenge (OBC) rules\n+ * @value 0 Disabled\n+ * @value 1 Loiter\n+ * @value 2 Return to Land\n+ * @value 3 Land at current position\n  *\n  * @group Mission\n  */\n-PARAM_DEFINE_INT32(NAV_DLL_ACT, 1);\n+PARAM_DEFINE_INT32(NAV_DLL_ACT, 0);\n \n /**\n  * Set RC loss failsafe mode\n  *\n  * The RC loss failsafe will only be entered after a timeout,\n- * set by a DIFFERENT parameter. If the timeout value is smaller than\n- * zero it will never be entered. If RC input checks have been disabled\n- * by setting the COM_RC_IN_MODE param it will also not be triggered.\n+ * set by COM_RC_LOSS_T in seconds. If RC input checks have been disabled\n+ * by setting the COM_RC_IN_MODE param it will not be triggered.\n+ * Setting this parameter to 4 will enable CASA Outback Challenge rules,\n+ * which are only recommended to participants of that competition.\n  *\n- * @value 0 Loiter\n- * @value 1 Return to Land\n- * @value 2 Land at current position\n- * @value 3 Outback Challenge (OBC) rules\n+ * @value 0 Disabled\n+ * @value 1 Loiter\n+ * @value 2 Return to Land\n+ * @value 3 Land at current position\n  *\n  * @group Mission\n  */\n-PARAM_DEFINE_INT32(NAV_RCL_ACT, 1);\n+PARAM_DEFINE_INT32(NAV_RCL_ACT, 0);\n \n /**\n  * Airfield home Lat",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7fec8ae7d5e8931563e6e35732bd2e440427d994/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rcloss_params.c": {
        "filename": "src/modules/navigator/rcloss_params.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -51,6 +51,8 @@\n  *\n  * @unit s\n  * @min -1.0\n+ * @decimal 1\n+ * @increment 0.1\n  * @group Radio Signal Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_RCL_LT, 120.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7fec8ae7d5e8931563e6e35732bd2e440427d994/src%2Fmodules%2Fnavigator%2Frcloss_params.c"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2014 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2014-2016 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -83,7 +83,7 @@ PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n  * @min -1\n  * @max 300\n  * @decimal 1\n- * @increment 1\n+ * @increment 0.5\n  * @group Return To Land\n  */\n PARAM_DEFINE_FLOAT(RTL_LAND_DELAY, -1.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7fec8ae7d5e8931563e6e35732bd2e440427d994/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main",
        "Copyright"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ],
        "src/modules/navigator/navigator_params.c": [
          "Copyright"
        ],
        "src/modules/navigator/rtl_params.c": [
          "Copyright"
        ]
      }
    }
  },
  {
    "title": "Navigator: some loiter refactoring and fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16646",
    "number": 16646,
    "created_at": "2021-01-25T18:54:31Z",
    "merged": true,
    "merged_at": "2021-01-29T18:37:01Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "**Describe problem solved by this pull request**\r\n- \"unable to reach heading within timeout\" error when loitering to altitude\r\n- \"hacky\" loiter position acceptance (1.2*loiter_radius)\r\n- MAV_CMD_NAV_LOITER_TIME: param2 (heading required) not considered\r\n- exit via tangent (xtrack) broken for NAV_CMD_LOITER_TIME_LIMIT \r\n\r\n**Describe your solution**\r\n- fix \"unable to reach heading\" bug when doing loiter to alt with heading wait \r\n- for loiter acceptance in fixed-wing, it is cleaner to use (loiter radius + L1 acceptance distance) to decide on acceptance, instead of the magic 1.2 factor in front of the loiter radius  \r\n- add ability of \"heading wait\" for NAV_CMD_LOITER_TIME_LIMIT (possible as mavlink/mavlink#1383 was merged)\r\n- enable exit via tangent (xtrack) for both NAV_CMD_LOITER_TIME_LIMIT and NAV_CMD_LOITER_TO_ALT, but let exit back to center connection as default\r\n\r\n\r\nGeneral: \r\n- unify logic inside Navigator for NAV_CMD_LOITER_TIME_LIMIT and NAV_CMD_LOITER_TO_ALT\r\n--> reach position --> start loitering --> reach altitude --> start timer (if applicable) --> reach exit heading (if applicable) --> declare mission item reached.\r\n\r\n- bit of clean up in Navigator, as I find the current structure more complex than needed. E.g. the return of get_acceptance_radius() should either be what's set in the NAV_ACC_RAD for MC, or the L1 distance for FW, as simple as that (unless I missed something?).\r\n\r\n**Test data / coverage**\r\nSITL and flight tested.\r\n\r\n\r\n**Additional context**\r\n\r\nSome screenshots from a SITL mission (standard VTOL) with a Loiter_time with heading wait (3,4), where 4 is with tangential exit, normal waypoints (with big altitude diff between 6 and 7), and a Loiter_Altitude with heading wait and tangential exit path (9). \r\n\r\nold:\r\n![image](https://user-images.githubusercontent.com/26798987/105750226-c5731300-5f44-11eb-90d6-ee52e675d256.png)\r\n\r\n\r\nnew:\r\n![image](https://user-images.githubusercontent.com/26798987/105751030-c48eb100-5f45-11eb-9ace-976df64ab0b7.png)\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2021-01-25T20:38:20Z",
          "body": "This all looks correct, but as per usual with navigator there are a few areas where it's hard to be 100% sure there aren't unintended repercussions. I'll give it another detailed pass and let's try to identify any additional areas of concern that might warrant testing on other vehicle types or less common situations.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2021-01-28T06:52:06Z",
          "body": "@sfuhrer Are you sure that removing this logic does not have any side effects?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 31,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-28T09:11:58Z",
          "body": "@RomanBapst I guess you mainly refer to  `(pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)`? Do you see a logical reason where this could actually be false?\r\nAt least in SITL it wasn't yet a problem, but this specific part wasn't yet flight tested.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 31,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-28T14:02:35Z",
          "body": "Should this be the parameter (MIS_YAW_ERROR)?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-28T14:06:04Z",
          "body": "It might be safer if you flip it around so that for FW (and rover) you're using pos_ctrl_status.acceptance_radius, otherwise fallback to using the default acceptance radius.\r\n\r\nI would also keep a minimum pos_ctrl_status validity check, maybe just pos_ctrl_status.timestamp != 0 and finite.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 31,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-29T10:17:08Z",
          "body": "True, think that'd be more consistent. ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-29T10:50:36Z",
          "body": "@dagar how about it now? a7a5303bb6a93850c2c373575f5587e15c547dbb",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 31,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-29T10:50:44Z",
          "body": "addressed in a7a5303bb6a93850c2c373575f5587e15c547dbb",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "@sfuhrer I had a look at this in detail and the changes look ok.\r\nIt's of course always hard to judge the effects in navigator but I definitely find this cleaner than before.",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes multiple incorrect behavioral/logical decisions (loiter acceptance radius using a magic factor, heading-wait not being honored causing timeouts, and broken tangent/exit behavior for loiter commands) and unifies inconsistent state transitions for loiter mission items. Review comments and the PR description indicate these were producing unintended/incorrect runtime behavior rather than mere style or syntax issues.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "patch": "@@ -1165,7 +1165,11 @@ Mission::set_mission_items()\n \t\t}\n \n \t} else {\n-\t\tif (_mission_item.autocontinue && get_time_inside(_mission_item) < FLT_EPSILON) {\n+\t\t/* allow the vehicle to decelerate before reaching a wp with a hold time */\n+\t\tconst bool brake_for_hold = _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n+\t\t\t\t\t    && get_time_inside(_mission_item) > FLT_EPSILON;\n+\n+\t\tif (_mission_item.autocontinue && !brake_for_hold) {\n \t\t\t/* try to process next mission item */\n \t\t\tif (has_next_position_item) {\n \t\t\t\t/* got next mission item, update setpoint triplet */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a7a5303bb6a93850c2c373575f5587e15c547dbb/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 73,
        "changes": 158,
        "patch": "@@ -141,11 +141,9 @@ MissionBlock::is_mission_item_reached()\n \t\tfloat dist_xy = -1.0f;\n \t\tfloat dist_z = -1.0f;\n \n-\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n-\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n-\t\t\t\t      : _mission_item.altitude;\n+\t\tconst float mission_item_altitude_amsl = get_absolute_altitude_for_item(_mission_item);\n \n-\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n+\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n \t\t\t\t_navigator->get_global_position()->lat,\n \t\t\t\t_navigator->get_global_position()->lon,\n \t\t\t\t_navigator->get_global_position()->alt,\n@@ -171,7 +169,7 @@ MissionBlock::is_mission_item_reached()\n \n \t\t\t/* require only altitude for takeoff for multicopter */\n \t\t\tif (_navigator->get_global_position()->alt >\n-\t\t\t    altitude_amsl - altitude_acceptance_radius) {\n+\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \n@@ -197,28 +195,22 @@ MissionBlock::is_mission_item_reached()\n \t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n \t\t\t * through the waypoint center.\n \t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n-\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n+\t\t\t * radius + L1 distance. Time inside and turn count is handled elsewhere.\n \t\t\t */\n-\t\t\tfloat radius = (fabsf(_mission_item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(_mission_item.loiter_radius) :\n-\t\t\t\t       _navigator->get_loiter_radius();\n \n-\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(radius) * 1.2f)\n+\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n+\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + fabsf(_mission_item.loiter_radius))\n \t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \n \t\t\t\t_waypoint_position_reached = true;\n-\n-\t\t\t} else {\n-\t\t\t\t_time_first_inside_orbit = 0;\n \t\t\t}\n \n \t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n+\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter.\n+\t\t\t// First check if the altitude setpoint is the mission setpoint (that means that the loiter is not yet reached)\n+\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n \n-\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter\n-\t\t\t//  first check if the altitude setpoint is the mission setpoint\n-\t\t\tposition_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n-\n-\t\t\tif (fabsf(curr_sp->alt - altitude_amsl) >= FLT_EPSILON) {\n-\t\t\t\t// check if the initial loiter has been accepted\n+\t\t\tif (fabsf(curr_sp->alt - mission_item_altitude_amsl) >= FLT_EPSILON) {\n \t\t\t\tdist_xy = -1.0f;\n \t\t\t\tdist_z = -1.0f;\n \n@@ -228,34 +220,20 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t\t\t_navigator->get_global_position()->alt,\n \t\t\t\t\t\t&dist_xy, &dist_z);\n \n-\t\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n+\t\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + fabsf(_mission_item.loiter_radius))\n \t\t\t\t    && dist_z <= _navigator->get_default_altitude_acceptance_radius()) {\n \n-\t\t\t\t\t// now set the loiter to the final altitude in the NAV_CMD_LOITER_TO_ALT mission item\n-\t\t\t\t\tcurr_sp->alt = altitude_amsl;\n+\t\t\t\t\tcurr_sp->alt = mission_item_altitude_amsl;\n+\t\t\t\t\tcurr_sp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n \t\t\t\t}\n \n-\t\t\t} else if (dist >= 0.f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\t} else if (dist >= 0.f && dist_xy <= (_navigator->get_acceptance_radius() + fabsf(_mission_item.loiter_radius))\n \t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n+\t\t\t\t// loitering, check if new altitude is reached, while still also having check on position\n \n \t\t\t\t_waypoint_position_reached = true;\n-\n-\t\t\t\t// set required yaw from bearing to the next mission item\n-\t\t\t\tif (_mission_item.force_heading) {\n-\t\t\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n-\n-\t\t\t\t\tif (next_sp.valid) {\n-\t\t\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(_navigator->get_global_position()->lat,\n-\t\t\t\t\t\t\t\t    _navigator->get_global_position()->lon,\n-\t\t\t\t\t\t\t\t    next_sp.lat, next_sp.lon);\n-\n-\t\t\t\t\t\t_waypoint_yaw_reached = false;\n-\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t_waypoint_yaw_reached = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n \t\t\t}\n \n \t\t} else if (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n@@ -298,13 +276,9 @@ MissionBlock::is_mission_item_reached()\n \t\t\t_time_wp_reached = now;\n \n \t\t} else {\n-\t\t\t/* for normal mission items used their acceptance radius */\n-\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n+\t\t\t/*normal mission items */\n \n-\t\t\t/* if set to zero use the default instead */\n-\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n-\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n-\t\t\t}\n+\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius();\n \n \t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n \t\t\tif (_mission_item.vtol_back_transition\n@@ -329,29 +303,25 @@ MissionBlock::is_mission_item_reached()\n \t\t\t}\n \t\t}\n \n-\t\tif (_waypoint_position_reached && !_waypoint_position_reached_previously) {\n+\t\tif (_waypoint_position_reached) {\n \t\t\t// reached just now\n \t\t\t_time_wp_reached = now;\n \t\t}\n+\n+\t\t// consider yaw reached for non-rotary wing vehicles (such as fixed-wing)\n+\t\tif (_navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\t_waypoint_yaw_reached = true;\n+\t\t}\n \t}\n \n-\t/* Check if the waypoint and the requested yaw setpoint. */\n-\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n+\t/* Check if the requested yaw setpoint is reached (only for rotary wing flight). */\n \n-\t\tif ((_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n-\t\t     && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw)))\n-\t\t    || ((_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) && _mission_item.force_heading\n-\t\t\t&& PX4_ISFINITE(_mission_item.yaw))) {\n+\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n \n-\t\t\t/* check course if defined only for rotary wing except takeoff */\n-\t\t\tfloat cog = (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) ?\n-\t\t\t\t    _navigator->get_local_position()->heading :\n-\t\t\t\t    atan2f(\n-\t\t\t\t\t    _navigator->get_local_position()->vy,\n-\t\t\t\t\t    _navigator->get_local_position()->vx\n-\t\t\t\t    );\n+\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n+\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))) {\n \n-\t\t\tfloat yaw_err = wrap_pi(_mission_item.yaw - cog);\n+\t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n \n \t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n \t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()\n@@ -376,14 +346,62 @@ MissionBlock::is_mission_item_reached()\n \t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n \tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n \n-\t\tif (_time_first_inside_orbit == 0) {\n-\t\t\t_time_first_inside_orbit = now;\n-\t\t}\n+\t\tbool time_inside_reached = false;\n \n \t\t/* check if the MAV was long enough inside the waypoint orbit */\n \t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n-\t\t    (now - _time_first_inside_orbit >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n+\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n+\t\t\ttime_inside_reached = true;\n+\t\t}\n+\n+\t\t// check if heading for exit is reached (only applies for fixed-wing flight)\n+\t\tbool exit_heading_reached = false;\n+\n+\t\tif (time_inside_reached) {\n+\n+\t\t\tstruct position_setpoint_s *curr_sp_new = &_navigator->get_position_setpoint_triplet()->current;\n+\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n+\n+\t\t\t/* enforce exit heading if in FW, the next wp is valid, the vehicle is currently loitering and either having force_heading set,\n+\t\t\t   or if loitering to achieve altitdue at a NAV_CMD_WAYPOINT */\n+\t\t\tconst bool enforce_exit_heading = _navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n+\t\t\t\t\t\t\t  &&\n+\t\t\t\t\t\t\t  next_sp.valid &&\n+\t\t\t\t\t\t\t  curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER &&\n+\t\t\t\t\t\t\t  (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n+\n+\t\t\tif (enforce_exit_heading) {\n \n+\n+\t\t\t\tconst float dist_current_next = get_distance_to_next_waypoint(curr_sp_new->lat, curr_sp_new->lon, next_sp.lat,\n+\t\t\t\t\t\t\t\tnext_sp.lon);\n+\n+\t\t\t\tfloat yaw_err = 0.0f;\n+\n+\t\t\t\tif (dist_current_next >  1.2f * _navigator->get_loiter_radius()) {\n+\t\t\t\t\t// set required yaw from bearing to the next mission item\n+\t\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(_navigator->get_global_position()->lat,\n+\t\t\t\t\t\t\t    _navigator->get_global_position()->lon,\n+\t\t\t\t\t\t\t    next_sp.lat, next_sp.lon);\n+\t\t\t\t\tconst float cog = atan2f(_navigator->get_local_position()->vy, _navigator->get_local_position()->vx);\n+\t\t\t\t\tyaw_err = wrap_pi(_mission_item.yaw - cog);\n+\n+\n+\n+\t\t\t\t}\n+\n+\n+\t\t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()) {\n+\t\t\t\t\texit_heading_reached = true;\n+\t\t\t\t}\n+\n+\t\t\t} else {\n+\t\t\t\texit_heading_reached = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// set exit flight course to next waypoint\n+\t\tif (exit_heading_reached) {\n \t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n \t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n \n@@ -414,14 +432,10 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t\t\t\t\t   &curr_sp.lat, &curr_sp.lon);\n \t\t\t}\n \n-\t\t\treturn true;\n+\t\t\treturn true; // mission item is reached\n \t\t}\n \t}\n \n-\t// all acceptance criteria must be met in the same iteration\n-\t_waypoint_position_reached_previously = _waypoint_position_reached;\n-\t_waypoint_position_reached = false;\n-\t_waypoint_yaw_reached = false;\n \treturn false;\n }\n \n@@ -430,7 +444,6 @@ MissionBlock::reset_mission_item_reached()\n {\n \t_waypoint_position_reached = false;\n \t_waypoint_yaw_reached = false;\n-\t_time_first_inside_orbit = 0;\n \t_time_wp_reached = 0;\n }\n \n@@ -588,19 +601,18 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tcase NAV_CMD_LOITER_TO_ALT:\n \n \t\t// initially use current altitude, and switch to mission item altitude once in loiter position\n-\t\tif (_navigator->get_loiter_min_alt() > 0.f) { // ignore _param_loiter_min_alt if smaller than 0 (-1)\n+\t\tif (_navigator->get_loiter_min_alt() > 0.f) { // ignore _param_loiter_min_alt if smaller than 0\n \t\t\tsp->alt = math::max(_navigator->get_global_position()->alt,\n \t\t\t\t\t    _navigator->get_home_position()->alt + _navigator->get_loiter_min_alt());\n \n \t\t} else {\n \t\t\tsp->alt = _navigator->get_global_position()->alt;\n \t\t}\n \n-\t// fall through\n-\tcase NAV_CMD_LOITER_TIME_LIMIT:\n-\n \t// FALLTHROUGH\n+\tcase NAV_CMD_LOITER_TIME_LIMIT:\n \tcase NAV_CMD_LOITER_UNLIMITED:\n+\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\tbreak;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a7a5303bb6a93850c2c373575f5587e15c547dbb/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -148,9 +148,7 @@ class MissionBlock : public NavigatorMode\n \n \tbool _waypoint_position_reached{false};\n \tbool _waypoint_yaw_reached{false};\n-\tbool _waypoint_position_reached_previously{false};\n \n-\thrt_abstime _time_first_inside_orbit{0};\n \thrt_abstime _action_start{0};\n \thrt_abstime _time_wp_reached{0};\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a7a5303bb6a93850c2c373575f5587e15c547dbb/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "patch": "@@ -246,15 +246,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid\t\tset_cruising_throttle(float throttle = NAN) { _mission_throttle = throttle; }\n \n-\t/**\n-\t * Get the acceptance radius given the mission item preset radius\n-\t *\n-\t * @param mission_item_radius the radius to use in case the controller-derived radius is smaller\n-\t *\n-\t * @return the distance at which the next waypoint should be used\n-\t */\n-\tfloat\t\tget_acceptance_radius(float mission_item_radius);\n-\n \t/**\n \t * Get the yaw acceptance given the current mission item\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a7a5303bb6a93850c2c373575f5587e15c547dbb/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 18,
        "changes": 25,
        "patch": "@@ -873,12 +873,6 @@ Navigator::get_default_acceptance_radius()\n \treturn _param_nav_acc_rad.get();\n }\n \n-float\n-Navigator::get_acceptance_radius()\n-{\n-\treturn get_acceptance_radius(_param_nav_acc_rad.get());\n-}\n-\n float\n Navigator::get_default_altitude_acceptance_radius()\n {\n@@ -996,24 +990,19 @@ Navigator::get_cruising_throttle()\n }\n \n float\n-Navigator::get_acceptance_radius(float mission_item_radius)\n+Navigator::get_acceptance_radius()\n {\n-\tfloat radius = mission_item_radius;\n-\n-\t// XXX only use navigation capabilities for now\n-\t// when in fixed wing mode\n-\t// this might need locking against a commanded transition\n-\t// so that a stale _vstatus doesn't trigger an accepted mission item.\n-\n+\tfloat acceptance_radius = get_default_acceptance_radius(); // the value specified in the parameter NAV_ACC_RAD\n \tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n \n+\t// for fixed-wing and rover, return the max of NAV_ACC_RAD and the controller acceptance radius (e.g. L1 distance)\n \tif (_vstatus.vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n-\t    && (pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)\n-\t    && pos_ctrl_status.acceptance_radius > radius) {\n-\t\tradius = pos_ctrl_status.acceptance_radius;\n+\t    && PX4_ISFINITE(pos_ctrl_status.acceptance_radius) && pos_ctrl_status.timestamp != 0) {\n+\n+\t\tacceptance_radius = math::max(acceptance_radius, pos_ctrl_status.acceptance_radius);\n \t}\n \n-\treturn radius;\n+\treturn acceptance_radius;\n }\n \n float",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a7a5303bb6a93850c2c373575f5587e15c547dbb/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached",
        "Navigator::get_default_acceptance_radius",
        "get_acceptance_radius",
        "PX4_ISFINITE",
        "radius",
        "MissionBlock::mission_item_to_position_setpoint",
        "Navigator::get_cruising_throttle",
        "Mission::set_mission_items",
        "MissionBlock::reset_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "PX4_ISFINITE",
          "radius",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::reset_mission_item_reached"
        ],
        "src/modules/navigator/navigator.h": [
          "get_acceptance_radius"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "get_acceptance_radius",
          "Navigator::get_cruising_throttle",
          "Navigator::get_default_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "[WIP] Use gps data with increased precision",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16645",
    "number": 16645,
    "created_at": "2021-01-25T18:31:11Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "lukegluke",
      "body": "double for lat and lon in degrees, float for alt in meters.\r\n\r\n1. 1e7 deg precision for lat and long can be not enough in several specific cases (for example RTK)\r\n2. In most calculations (especially in ekf) px4 internally already uses lat, lon as doubles converting them on input and output every time back and forward from deg/1e-7deg (and m/mm for alt).\r\n3. 1e7 deg precision is still used as output in legacy things, like current gps mavlink messages.\r\n\r\ntodo: gps drives need to be updated\r\n\r\nAlso dgps_age field added to sensor_gps.msg and vehicle_gps_position.msg  (and filled for MavlinkStreamGPS2Raw). It should be parsed it gps drivers where available. But probably this change should go to separate PR.",
      "issue_comments": [
        {
          "author": "lukegluke",
          "created_at": "2021-01-25T18:32:20Z",
          "body": "Hi @dagar ,\r\n\r\nI made this patch as I mentioned in https://github.com/PX4/PX4-ECL/issues/951#issuecomment-757468006\r\n\r\nIn our project we use only one modified gps nmea driver and have tested only ekf core, we don't use many modules/drivers and don't fly, so in PR I modified several files only theoretical without testing, just by searching strings like: gps.lat, gps.alt, 1.0e7, 1.e7, 1e7, 1.0e-7, 1.e-7, 1e-7. I could easily missed something, especially regarding altitude. It is definitely needs accurately checking and testing.\r\n\r\nThis is the reference point for you. We don't use px4 boards. **I can't maintain and test this PR further**. Please free to edit, move, close this as you wish. Hopes it may help you somehow a little.\r\nThanks for all you work.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-25T20:06:55Z",
          "body": "Thanks @lukegluke, it wasn't clear to me there's any readily available equipment where int32 is limiting.",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2021-02-01T18:16:59Z",
          "body": "@lukegluke could you kindly give us an update on the status of this PR? it looks like it's failing on CI and needs a rebase.",
          "type": "issue_comment"
        },
        {
          "author": "lukegluke",
          "created_at": "2021-02-05T16:56:42Z",
          "body": "@mrpollo sorry for the late reply. As I mentioned this is the kind of aid for Daniel if he is going to increased gps data precision someday. I can't maintain and test this PR, so I'm closing it to not disturb you anyway.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR changes GPS data types to increase numeric precision (lat/lon to double, alt to float) and adds a dgps_age field â€” it's an API/precision improvement rather than a fix of an incorrect program logic. There is no discussion or evidence of a specific incorrect conditional, state transition, or runtime behavior being corrected; the change is a design/representation update (and untested/WIP), not a targeted logic-bug fix.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "patch": "@@ -197,8 +197,7 @@ bool Geofence::check(const vehicle_global_position_s &global_position, const veh\n \t\t\treturn checkAll(global_position);\n \n \t\t} else {\n-\t\t\treturn checkAll((double)gps_position.lat * 1.0e-7, (double)gps_position.lon * 1.0e-7,\n-\t\t\t\t\t(double)gps_position.alt * 1.0e-3);\n+\t\t\treturn checkAll(gps_position.lat, gps_position.lon, gps_position.alt);\n \t\t}\n \n \t} else {\n@@ -210,7 +209,7 @@ bool Geofence::check(const vehicle_global_position_s &global_position, const veh\n \t\t\treturn checkAll(global_position, baro_altitude_amsl);\n \n \t\t} else {\n-\t\t\treturn checkAll((double)gps_position.lat * 1.0e-7, (double)gps_position.lon * 1.0e-7, baro_altitude_amsl);\n+\t\t\treturn checkAll(gps_position.lat, gps_position.lon, baro_altitude_amsl);\n \t\t}\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e40112fa72312c7bab1e70ced2cb4d710c774ba6/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::check",
        "checkAll"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::check",
          "checkAll"
        ]
      }
    }
  },
  {
    "title": "increase vehicle command queue depth and updates modules to consume all available queued commands",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16635",
    "number": 16635,
    "created_at": "2021-01-24T18:44:53Z",
    "merged": true,
    "merged_at": "2021-01-26T17:00:19Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This is to prevent the possible loss of vehicle_commands. At the moment it's likely only problematic in the case of high rate vehicle_commands from things like vmount, but better safe than sorry.\r\n\r\n - fixes https://github.com/PX4/PX4-Autopilot/issues/16630",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect runtime behavior where vehicle_command messages could be lost due to a too-small queue and consumers not draining all available commands. This is a data-flow/logic bug (message-loss/improper consumption) rather than a syntax or style issue, and the changes correct that unintended behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -212,7 +212,7 @@ Navigator::run()\n \t\t_position_controller_status_sub.update();\n \t\t_home_pos_sub.update(&_home_pos);\n \n-\t\tif (_vehicle_command_sub.updated()) {\n+\t\twhile (_vehicle_command_sub.updated()) {\n \t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n \t\t\tvehicle_command_s cmd{};\n \t\t\t_vehicle_command_sub.copy(&cmd);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf1cba642a9d701636c21edde77a5104e2457dbf/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "RTL: VTOL: do the land delay loitering (RTL_LAND_DELAY) in fixed-wing flight",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16582",
    "number": 16582,
    "created_at": "2021-01-18T17:24:19Z",
    "merged": true,
    "merged_at": "2021-01-29T12:46:34Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n**Describe problem solved by this pull request**\r\nhttps://github.com/PX4/PX4-Autopilot/issues/16500 --> for some VTOL applications it is desired if the land delay loitering is done while still in fixed-wing mode, instead of hover. I see these use-cases:\r\n- if there should be a delay before landing, such that pilot could interfere (better do that in FW, as much more energy efficient)\r\n- to estimate wind speed before triggering the backtransition, such that the distance to home can be optimized\r\n\r\n**Describe your solution**\r\nChange RTL state order \r\nold:   (CLIMB-->RETURN-->DESCEND-->TRANSITION-->MOVE_TO_LAND_HOVER-->LOITER-->LAND)\r\nnew: (CLIMB-->RETURN-->DESCEND-->LOITER-->TRANSITION-->MOVE_TO_LAND_HOVER-->LAND)\r\n\r\n**Describe possible alternatives**\r\nSome logic with NAV_FORCE_VT --> e.g. if NAV_FORCE_VT is set to false, then do not execute transition but directly go to loiter and then land in FW. Sounds dangerous to me, would have the advantage that if a user wants to have the loitering done in hover also for a VTOL, that could be set up.\r\n\r\n**Test data / coverage**\r\nSITL tested. \r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "MartinStokelj",
          "created_at": "2021-01-19T07:09:01Z",
          "body": "@sfuhrer If I understand this right it says \"go to loiter and then land in FW\". \r\nWe don't want him to land and also not land him as FW, this would damage the drone.\r\nIf param RTL_LAND_DELAY is set to -1 he should loiter as FW above WP and not auto land or auto transition to MC...",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-19T08:32:52Z",
          "body": "> it says \"go to loiter and then land in FW\". \r\n\r\nWhere does it say that? That's certainly not the idea, but that after the loiter in FW it transitions and lands in hover.",
          "type": "issue_comment"
        },
        {
          "author": "MartinStokelj",
          "created_at": "2021-01-19T10:45:13Z",
          "body": "sorry I misunderstood, it looks ok now with\r\nRTL_LAND_DELAY -1\r\nNAV_FORCE_VT 0\r\nhttps://review.px4.io/plot_app?log=beb86924-b2a7-48f3-8e35-c1723e8b519d\r\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-01-25T05:39:57Z",
          "body": "@sfuhrer SITL tests are failing. Need to have a closer look if related. Otherwise, I agree with these changes.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes the RTL state-machine ordering so the land-delay loiter happens in fixedâ€‘wing mode instead of after transition to hover. That corrects an unintended behavior (wrong state sequencing) where the vehicle would loiter in hover contrary to the documented/desired use-case, so it fixes a logic error in the control/state-transition logic.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 33,
        "changes": 65,
        "patch": "@@ -392,23 +392,6 @@ void RTL::set_rtl_item()\n \t\t\tbreak;\n \t\t}\n \n-\tcase RTL_STATE_TRANSITION_TO_MC: {\n-\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n-\t\t\tbreak;\n-\t\t}\n-\n-\tcase RTL_MOVE_TO_LAND_HOVER_VTOL: {\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t_mission_item.lat = _destination.lat;\n-\t\t\t_mission_item.lon = _destination.lon;\n-\t\t\t_mission_item.altitude = loiter_altitude;\n-\t\t\t_mission_item.altitude_is_relative = false;\n-\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n-\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n-\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n-\t\t\tbreak;\n-\t\t}\n-\n \tcase RTL_STATE_DESCEND: {\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n \n@@ -470,6 +453,23 @@ void RTL::set_rtl_item()\n \t\t\tbreak;\n \t\t}\n \n+\tcase RTL_STATE_TRANSITION_TO_MC: {\n+\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n+\t\t\tbreak;\n+\t\t}\n+\n+\tcase RTL_MOVE_TO_LAND_HOVER_VTOL: {\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.lat = _destination.lat;\n+\t\t\t_mission_item.lon = _destination.lon;\n+\t\t\t_mission_item.altitude = loiter_altitude;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n+\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n+\t\t\tbreak;\n+\t\t}\n+\n \tcase RTL_STATE_LAND: {\n \t\t\t// Land at destination.\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LAND;\n@@ -531,7 +531,6 @@ void RTL::advance_rtl()\n \tconst bool vtol_in_fw_mode = _navigator->get_vstatus()->is_vtol\n \t\t\t\t     && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n \n-\n \tswitch (_rtl_state) {\n \tcase RTL_STATE_CLIMB:\n \t\t_rtl_state = RTL_STATE_RETURN;\n@@ -549,41 +548,41 @@ void RTL::advance_rtl()\n \n \t\tbreak;\n \n-\n-\tcase RTL_STATE_TRANSITION_TO_MC:\n-\n-\t\t_rtl_state = RTL_MOVE_TO_LAND_HOVER_VTOL;\n-\n-\t\tbreak;\n-\n-\tcase RTL_MOVE_TO_LAND_HOVER_VTOL:\n+\tcase RTL_STATE_DESCEND:\n \n \t\tif (descend_and_loiter) {\n \t\t\t_rtl_state = RTL_STATE_LOITER;\n \n+\t\t} else if (vtol_in_fw_mode) {\n+\t\t\t_rtl_state = RTL_STATE_TRANSITION_TO_MC;\n+\n \t\t} else {\n \t\t\t_rtl_state = RTL_STATE_LAND;\n \t\t}\n \n \t\tbreak;\n \n-\tcase RTL_STATE_DESCEND:\n-\n-\t\t// If the vehicle is a vtol in fixed wing mode, then first transition to hover\n+\tcase RTL_STATE_LOITER:\n \t\tif (vtol_in_fw_mode) {\n \t\t\t_rtl_state = RTL_STATE_TRANSITION_TO_MC;\n \n-\t\t} else if (descend_and_loiter) {\n-\t\t\t_rtl_state = RTL_STATE_LOITER;\n-\n \t\t} else {\n \t\t\t_rtl_state = RTL_STATE_LAND;\n \t\t}\n \n+\t\t_rtl_state = RTL_STATE_LAND;\n \t\tbreak;\n \n-\tcase RTL_STATE_LOITER:\n+\tcase RTL_STATE_TRANSITION_TO_MC:\n+\n+\t\t_rtl_state = RTL_MOVE_TO_LAND_HOVER_VTOL;\n+\n+\t\tbreak;\n+\n+\tcase RTL_MOVE_TO_LAND_HOVER_VTOL:\n+\n \t\t_rtl_state = RTL_STATE_LAND;\n+\n \t\tbreak;\n \n \tcase RTL_STATE_LAND:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/860ca1170322e3cc3c8edb1eb9ae27afa28d676e/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -115,9 +115,9 @@ class RTL : public MissionBlock, public ModuleParams\n \t\tRTL_STATE_NONE = 0,\n \t\tRTL_STATE_CLIMB,\n \t\tRTL_STATE_RETURN,\n-\t\tRTL_STATE_TRANSITION_TO_MC,\n \t\tRTL_STATE_DESCEND,\n \t\tRTL_STATE_LOITER,\n+\t\tRTL_STATE_TRANSITION_TO_MC,\n \t\tRTL_MOVE_TO_LAND_HOVER_VTOL,\n \t\tRTL_STATE_LAND,\n \t\tRTL_STATE_LANDED,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/860ca1170322e3cc3c8edb1eb9ae27afa28d676e/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "RTL::advance_rtl"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item",
          "RTL::advance_rtl"
        ]
      }
    }
  },
  {
    "title": "RTL_LAND_DELAY default to 0 and MIS_DIST_WPS to 5km for VTOL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16550",
    "number": 16550,
    "created_at": "2021-01-13T19:03:10Z",
    "merged": true,
    "merged_at": "2021-01-17T11:05:31Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "**Describe problem solved by this pull request**\r\n- find it annoying that RTL_LAND_DELAY is by default at -1 (do not land but loiter), even though for most applications that's not the default (only for FW usually). For FW, RTL_LAND_DELAY is already set to -1 in the defaults.\r\n- the max distance between waypoints is too low with 900m for VTOLs\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "Antiheavy",
          "created_at": "2021-01-13T23:50:41Z",
          "body": "> the max distance between waypoints is too low with 900m for VTOLs\r\n\r\nhow much real world testing do you have on 5000 meter default for this?  I've had conversations with @priseborough in the past about concerns of gyro stability and EKF covariance tracking over long periods of straight and level flight.  There is a lack of \"system observability\" during straight and level flight which allows the gyros to wander without good correction from the accelerometers and other sensors measuring turns.  I know from experience with other systems  (non-px4, non-pixhawk) that this is a well understood concern in the world of kalman filtering.  So, this distance limit is driven as much by the quality of your hardware system (gryos usually) as it is the quality of your EKF and flight software.\r\n\r\nHaving said that we have slowly been increasing MIS_DIST_WPS on our fixed wing aircraft over the years, we make incremental and conservative increase a few hundred meters at a time, then spend months of testing, then eventually release to our users, then we increase again, test, release, repeat.  We are currently at 2500 meters for MIS_DIST_WPS using a FMUv4 based autopilot hardware.  No issues with 1000's of flights.\r\n\r\nIf 5000 meters is super well tested and understood then hooray!",
          "type": "issue_comment"
        },
        {
          "author": "mcsauder",
          "created_at": "2021-01-14T01:27:50Z",
          "body": "Hi @Antiheavy !  I flew a 4kg quad 12km straight-line from takeoff on v1.11.2 a few weeks ago on an exceptionally low wind day, (lack of system disturbance), and I have a handful of hexas that have flown straight line range test flights in the past two months beyond 5km.  From a limited number of flights that I have observed this change seems fairly reasonable to me, but I don't doubt the rationale behind your comment in the least.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-14T14:39:03Z",
          "body": "@Antiheavy thanks for the input! I actually wasn't aware of this restriction, and seldom have flown with more than 1km between WP. I'll make sure to include that in our testing more regularly. When was the last time you experienced issues on a PX4 based vehicle, and with which release was that?\r\n@priseborough how do you assess the current EKF capabilities, should we be concerned? ",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2021-01-17T16:15:08Z",
          "body": ">  I flew a 4kg quad 12km straight-line from takeoff on v1.11.2 a few weeks ago on an exceptionally low wind day, (lack of system disturbance), and I have a handful of hexas that have flown straight line range test flights in the past two months beyond 5km.\r\n\r\n@mcsauder are you able to share what gyro parts were running on your flight controller for these flights?  Just curious.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR changes default parameter values (RTL_LAND_DELAY and MIS_DIST_WPS) rather than correcting incorrect program flow or algorithmic logic. The discussion is about tuning/configuration and safety of larger waypoint distances, not about a bug in conditional statements, state transitions, or EKF implementation â€” so it is a configuration/tuning change, not a code logic error.",
    "patches": {
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -87,7 +87,7 @@ PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n  * @increment 0.5\n  * @group Return Mode\n  */\n-PARAM_DEFINE_FLOAT(RTL_LAND_DELAY, -1.0f);\n+PARAM_DEFINE_FLOAT(RTL_LAND_DELAY, 0.0f);\n \n /**\n  * Horizontal radius from return point within which special rules for return mode apply.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7dd58206bb8977c559670fbc99728071f7409b76/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Navigator: VTOL transition command: make transitions smoother",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16499",
    "number": 16499,
    "created_at": "2021-01-06T14:05:26Z",
    "merged": true,
    "merged_at": "2021-05-03T06:40:54Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "**Describe problem solved by this pull request**\r\nThe transition command waypoints, NAV_CMD_DO_VTOL_TRANSITION, are attached to the previous waypoint that contains a location (e.g. normal waypoint). It then triggers a transition as soon as this waypoint is reached, which happens when the vehicle is within L1 distance to it. Is the L1 distance smaller then the needed space for the transition, then the vehicle overshoots. The current logic is that for a transition waypoint, the waypoint has to be reached again in the new VTOL mode (e.g. in hover after a backtransition). Thus, if it overshoots, it turns around to accept it, and only then proceeds to the next waypoint.\r\nI don't really get in which case this would be desired.\r\n\r\nThis can lead to ugly situations like this:\r\n![VTOLtransitionmaster](https://user-images.githubusercontent.com/26798987/103775614-98f76580-502e-11eb-95ef-b0b14f675bba.png)\r\n\r\n\r\n**Describe your solution**\r\nDo not make it accept the waypoint again in the new VTOL mode, but directly proceed to the next:\r\n![vtoltransition_withfixes](https://user-images.githubusercontent.com/26798987/103775628-9e54b000-502e-11eb-860b-d1f55a596d98.png)\r\nThat means that if you don't have the previous, current and next waypoint in one line, it will make a turn while transitioning. I don't think this should be a big issue, and what we on top could do is limiting the max roll angle during the transition.\r\n\r\n**Describe possible alternatives**\r\n\r\n\r\n**Test data / coverage**\r\nBasic SITL testing.\r\n\r\n**Additional context**\r\nhttps://github.com/PX4/PX4-Autopilot/commit/c31d8ce2b6f04c30b2fde6af08040c074e70e762 looks like it only works with this stuff removed. @dagar Am I missing something or could we safely remove it? I don't really get what it was added for.\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2021-01-06T14:08:12Z",
          "body": "@ThomasRigi what do you think?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-06T15:10:06Z",
          "body": "> c31d8ce looks like it only works with this stuff removed. @dagar Am I missing something or could we safely remove it? I don't really get what it was added for.\r\n\r\nIt certainly looks safe to remove, but it's sometimes hard to tell in here. Let's do a little software archaeology to be sure.",
          "type": "issue_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-01-06T17:30:46Z",
          "body": "Did some SITL tests, looks good. \r\n\r\n> c31d8ce looks like it only works with this stuff removed. @dagar Am I missing something or could we safely remove it? I don't really get what it was added for.\r\n\r\nSame as you, I don't know why it's there, but I assume that at the time they had a good reason to add it. It may well be obsolete by now though as the way transitions are handled have changed significantly. The code was added almost 5 years ago (https://github.com/PX4/PX4-Autopilot/pull/3598), which is about three years before I started working with PX4. :sweat_smile: ",
          "type": "issue_comment"
        },
        {
          "author": "ghost",
          "created_at": "2021-01-06T19:29:38Z",
          "body": "I tested this just now in sitl, went into something like this. what am i doing wrong in this one?\r\nseems like it undershoots now.\r\nhttps://review.px4.io/plot_app?log=5be75d9d-c111-4b91-82d3-03eb544da898\r\n\r\n\r\n\r\nmy mission is as below.\r\n![image](https://user-images.githubusercontent.com/25317204/103811799-7ba0b680-5083-11eb-9ff6-f5a6975662aa.png)\r\n![image](https://user-images.githubusercontent.com/25317204/103811917-aee34580-5083-11eb-8c05-f299b0d28c3b.png)\r\n",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-06T21:03:48Z",
          "body": "> I tested this just now in sitl, went into something like this. what am i doing wrong in this one?\r\n\r\nI couldn't reproduce. Could you share your mission file please?\r\n",
          "type": "issue_comment"
        },
        {
          "author": "ghost",
          "created_at": "2021-01-07T01:43:40Z",
          "body": "\r\n[undershooting_misssion.zip](https://github.com/PX4/PX4-Autopilot/files/5779025/undershooting_misssion.zip)\r\nhere's the mission file. sorry for the delay",
          "type": "issue_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-01-07T09:59:58Z",
          "body": "@yuthikasagarage Your mission is incomplete for this new way of handling transitions. Add a (Land) Waypoint after the VTOL Transition command and it will work better. \r\n[undershooting_misssion_fixed.zip](https://github.com/PX4/PX4-Autopilot/files/5780696/undershooting_misssion_fixed.zip)\r\nAs you can see I placed WP9 a bit after WP7. This is approx. the extra distance that the drone was overshooting before. \r\nFor illustrative purposes, observe what happens when you badly place the waypoint after the back transition: \r\n[undershooting_misssion_badly_fixed.zip](https://github.com/PX4/PX4-Autopilot/files/5780741/undershooting_misssion_badly_fixed.zip)\r\nAs soon as the WP7 is accepted, the drone starts the back transition and heads towards WP9 during transition.\r\n\r\nWhat happens in your case with the incomplete mission is that as soon as WP7 is accepted with the FW acceptance radius it starts the back transition and completes the mission at the same time.\r\n![image](https://user-images.githubusercontent.com/48206725/103875858-37d59d80-50d3-11eb-8106-69e600c842db.png)\r\nAs the mission is considered finished the vehicle goes into Loiter, but as you're still backtransitioning FW L1 logic is still at work, hence the half-circle. What I find interesting is that after BT is complete the drone doesn't stay where it is or goes to where it was at 1:22, but flies to launch position instead. I guess it's how the end-of-mission-loiter is implemented for MC drones.\r\n\r\n\r\nAdmittedly this PR has the potential to make things worse if used in a non-intended way, but if you are aware of it it gives you more flexibility (e.g. when transitioning with tail wind you can move the next WP a bit further). \r\n --> this means we need to document it well.",
          "type": "issue_comment"
        },
        {
          "author": "ghost",
          "created_at": "2021-01-07T12:29:11Z",
          "body": "@ThomasRigi thanks for the explanation. i can see the logic now.",
          "type": "issue_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-01-29T16:11:59Z",
          "body": "I don't like this new commit: https://logs.px4.io/plot_app?log=9eb1719d-eac8-49b7-9617-83b4e1a3354d\r\n\r\nBy enforcing that during transition it has to move to the waypoint where transition was triggered you kind of take away the point of this PR. ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-29T17:45:31Z",
          "body": "> By enforcing that during transition it has to move to the waypoint where transition was triggered \r\n\r\nWell it wouldn't have needed to accept the old waypoint anymore like it was prior this PR, but will still keep it as current position setpoint. And after some more SITLing I came to the same conclusion as you, that without the check for the transition_state it's much smoother. Thus removed the last commit again.\r\n\r\n@RomanBapst please approve if you think that it's safe enough like this.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2021-02-15T18:09:33Z",
          "body": "@sfuhrer looks like you are going to need to rebase, the main branch has been moving faster these days ðŸ‡ \r\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-02-22T11:16:20Z",
          "body": "@dagar @ThomasRigi Can you guys update your review as well?",
          "type": "issue_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-02-22T13:17:24Z",
          "body": "I'm fine with the changes too, but I would have preferred the symmetric solution that also aims for the next WP in a front transition. This is much less critical than the back transition though, so I'm also happy if it goes in as it is now.\r\n\r\nI still don't see the potential timing issues clearly. But @dagar certainly has a better knowledge about them than I do. From my understanding of the transition logic nothing should break though if we remove L115ff completely instead of checking the RW/FW state",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-03-18T07:35:57Z",
          "body": "@ThomasRigi Have you seen that for the front transition the fixed wing position controller is generating it's own target setpoint irrelevant of what navigator is saying?\r\n\r\nhttps://github.com/PX4/Firmware/blob/40e6958bd994a29ddf73c5546ab6824dbb2ac6b1/src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp#L687",
          "type": "issue_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-04-09T10:48:57Z",
          "body": "Sorry for the slow response. I vaguely recalled something like that, but wasn't aware of the details. ~~Still undeniably there is a difference in how the front transition is handled in the two logs of https://github.com/PX4/PX4-Autopilot/pull/16499#discussion_r553249245... but I have to admit I no longer understand why~~ Ok, it's me who was stupid, the drone was aligned differently before the transition started.\r\n\r\nDo you still think it is better to set this artificial heading hold waypoint for the whole duration of the front transition or could we just have it track the normal waypoints ? And in case it reaches the first FW WP while still in transition move towards the next one.\r\n\r\nI think both ways have advantages and drawbacks. In my dream world the drone can handle any type of turns during transition if needed. But I also see that if you ask for a harsh turn during transition it might not end well - even though so far what I saw looked quite stable in the air with the L1 tracking during transition.\r\n\r\nMy main concern with the \"stubborn\" heading hold is that if you have a tight geofence just flying straight no matter what might get you closer to the geofence than you'd like, e.g. with tail wind. Or also without geofence, if the drone has to do a full bank turn to backtrack just after transition it's not great either. Admittedly, in these cases you can also say badly planned mission.\r\n\r\nOn the other hand we'd have a more reliable planned trajectory if the front transition really tracks the planned WPs (as it now does with the back transition). My main worries are potential hard turns during transition, where again you can say badly planned mission. \r\n\r\nAll in all, I'd have a slight preference to tracking the planned WPs, but it's not something I'd consider blocking for this PR. ",
          "type": "issue_comment"
        },
        {
          "author": "VTOLDavid",
          "created_at": "2021-04-26T11:16:05Z",
          "body": "In my opinion, force the transition to end in a waypoint is a bad idea. In real flight you can have wind gusts, thrust assymentry on the frame, bad compass calibration or just constant wind that make the transition to end in a slightly different point that planned. Try to end in such waypoint may require large control imputs in conditions near stall, that in most airframes can generate aerodynamic control inversion (lowering the aileron to generate lift stalls the wing and generates the opposite effect). So I whould like to have the possibility to dissable that or at least limit the bank angle that this tracking can request.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2021-01-06T15:24:37Z",
          "body": "I think we should keep some form of this, but instead of a timeout explicitly check for the desired VTOL state.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-06T21:04:39Z",
          "body": "Alright, done in 81eceb526b931601840268c9ae92ce4bcd2e7637. Doesn't look nice but I guess that would do the trick.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-01-07T10:43:26Z",
          "body": "On second thought I think we should just delete the lines. IMO they go against the spirit of this PR. And https://github.com/PX4/PX4-Autopilot/commit/81eceb526b931601840268c9ae92ce4bcd2e7637 is asymmetric on front and back transitions, which is weird. For front transitions you only consider the mission item reached when the transition is complete, whereas for back transition it's immediate. (During transitions the vehicle type is VEHICLE_TYPE_ROTARY_WING)\r\n\r\n1. With https://github.com/PX4/PX4-Autopilot/commit/81eceb526b931601840268c9ae92ce4bcd2e7637 : https://logs.px4.io/plot_app?log=f0d5dd0a-14be-47cc-9b08-e99fdadca76d on the front transition the drone doesn't track the path.\r\n2. Without these lines: https://logs.px4.io/plot_app?log=dca29fa0-e3ba-45e0-b8b2-e75414c71077 the front transition tracks the (badly or at least specially) planned path much better.\r\n\r\n[too_short_FT.zip](https://github.com/PX4/PX4-Autopilot/files/5781084/too_short_FT.zip)\r\nThe mission has the first FW WP way too close to the transition start to make my point. IMO the second option is better",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-08T12:28:06Z",
          "body": "Happy to remove the check if we are sure that the command is always correctly propagated (and if not, then better fix that instead).",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-11T13:29:29Z",
          "body": "@dagar what's your opinion on that? Do you have any safety concerns when removing the check again?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-11T15:45:37Z",
          "body": "Yes, the potential timing issues on a real vehicle vs SITL lockstep. Let's check the remaining navigator VTOL transition logic to see if it matters (the work item after transition cmd).",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-13T17:17:17Z",
          "body": "@dagar so we're afraid that the transition waypoint gets accepted before the transition is triggered in the VTOL_attitude_controller? Could we use that ack https://github.com/PX4/PX4-Autopilot/blob/cabb50a67ba1e95069457649f0f8cf1727eea5f5/src/modules/vtol_att_control/vtol_att_control_main.cpp#L187? \r\n@ThomasRigi I think it would actually be okay with these checks, even though they're asymmetric and that's certainly not nice. Reasoning: For backtransition it would immediately accept the waypoint, and that's required for making the back transition smoother (original goal of this PR). For front transition it wasn't an issue so far that it only got accepted once the transition was finished (this could change fast, I know).\r\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-01-13T17:49:09Z",
          "body": "The PR is called \"make transitions smoother\", so in principle both can be targeted ;) But it's true that the reason for it is the back transition, and this works with the asymmetric behaviour. \r\n\r\nIf there is a reason to be worried that taking this check out might break things on a real drone we should keep the check. If not, I find the symmetric solution more elegant.\r\n\r\nThe way I understand the half a second waiting time is to make sure that `in_transition_mode` was updated so that you can monitor this until the transition is over, and not to make sure that the transition command is actually sent. But to me the recent changes in how transitions are done make it obsolete to wait until the end of the transition (for both ways) to accept the waypoint. It's just that I don't see the danger, but mayhaps that's just my lack of knowledge on some parts of PX4 code. If it helps to bring this PR in, then let's go with the asymmetric behaviour.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-01-29T12:43:03Z",
          "body": "```suggestion\r\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING && !_navigator->get_vstatus()->in_transition_mode;\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 13,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-01-29T12:43:24Z",
          "body": "```suggestion\r\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING && !_navigator->get_vstatus()->in_transition_mode;\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 19,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "@sfuhrer I had a detailed look and I'm good with these changes.\r\n",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect waypoint/transition acceptance logic: the navigator previously required re-accepting the transition waypoint after a VTOL mode switch, causing unwanted overshoot/turnaround and inconsistent state/trajectory. The change removes that artificial acceptance requirement so the vehicle proceeds to the next waypoint, correcting the improper state transition/waypoint-handling behavior.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 24,
        "changes": 24,
        "patch": "@@ -1031,30 +1031,6 @@ Mission::set_mission_items()\n \t\t\t\t\tgenerate_waypoint_from_heading(&pos_sp_triplet->current, pos_sp_triplet->current.yaw);\n \t\t\t\t}\n \n-\t\t\t\t/* don't advance mission after FW to MC command */\n-\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n-\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n-\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n-\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n-\t\t\t\t    && !_navigator->get_land_detected()->landed\n-\t\t\t\t    && pos_sp_triplet->current.valid) {\n-\n-\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n-\t\t\t\t}\n-\n-\t\t\t\t/* after FW to MC transition finish moving to the waypoint */\n-\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE &&\n-\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n-\t\t\t\t    && pos_sp_triplet->current.valid) {\n-\n-\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n-\n-\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t\t\tcopy_position_if_valid(&_mission_item, &pos_sp_triplet->current);\n-\t\t\t\t\t_mission_item.autocontinue = true;\n-\t\t\t\t\t_mission_item.time_inside = 0.0f;\n-\t\t\t\t}\n-\n \t\t\t\t// ignore certain commands in mission fast forward\n \t\t\t\tif ((_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD) &&\n \t\t\t\t    (_mission_item.nav_cmd == NAV_CMD_DELAY)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9ef9bd0069913f9929353aa5df169a361a3ee240/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -281,7 +281,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t\tWORK_ITEM_TYPE_TAKEOFF,\t\t/**< takeoff before moving to waypoint */\n \t\tWORK_ITEM_TYPE_MOVE_TO_LAND,\t/**< move to land waypoint before descent */\n \t\tWORK_ITEM_TYPE_ALIGN,\t\t/**< align for next waypoint */\n-\t\tWORK_ITEM_TYPE_CMD_BEFORE_MOVE,\n \t\tWORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF,\n \t\tWORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION,\n \t\tWORK_ITEM_TYPE_PRECISION_LAND",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9ef9bd0069913f9929353aa5df169a361a3ee240/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "patch": "@@ -112,18 +112,16 @@ MissionBlock::is_mission_item_reached()\n \n \tcase NAV_CMD_DO_VTOL_TRANSITION:\n \n-\t\t/*\n-\t\t * We wait half a second to give the transition command time to propagate.\n-\t\t * Then monitor the transition status for completion.\n-\t\t */\n-\t\t// TODO: check desired transition state achieved and drop _action_start\n-\t\tif (hrt_absolute_time() - _action_start > 500000 &&\n-\t\t    !_navigator->get_vstatus()->in_transition_mode) {\n+\t\tif (int(_mission_item.params[0]) == 3) {\n+\t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n+\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n \n-\t\t\t_action_start = 0;\n-\t\t\treturn true;\n+\t\t} else if (int(_mission_item.params[0]) == 4) {\n+\t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly\n+\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n \n \t\t} else {\n+\t\t\t// invalid vtol transition request\n \t\t\treturn false;\n \t\t}\n \n@@ -473,7 +471,6 @@ MissionBlock::issue_command(const mission_item_s &item)\n \t\t_actuator_pub.publish(actuators);\n \n \t} else {\n-\t\t_action_start = hrt_absolute_time();\n \n \t\t// This is to support legacy DO_MOUNT_CONTROL as part of a mission.\n \t\tif (item.nav_cmd == NAV_CMD_DO_MOUNT_CONTROL) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9ef9bd0069913f9929353aa5df169a361a3ee240/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -149,7 +149,6 @@ class MissionBlock : public NavigatorMode\n \tbool _waypoint_position_reached{false};\n \tbool _waypoint_yaw_reached{false};\n \n-\thrt_abstime _action_start{0};\n \thrt_abstime _time_wp_reached{0};\n \n \tuORB::Publication<actuator_controls_s>\t_actuator_pub{ORB_ID(actuator_controls_2)};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9ef9bd0069913f9929353aa5df169a361a3ee240/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::issue_command",
        "MissionBlock::is_mission_item_reached",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command",
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "Pre-emptive geofence triggering",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16400",
    "number": 16400,
    "created_at": "2020-12-16T13:11:56Z",
    "merged": true,
    "merged_at": "2021-01-13T09:26:11Z",
    "state": "closed",
    "conversation": {
      "author": "jkflying",
      "body": "**Describe problem solved by this pull request**\r\nCurrently, a geofence breach is triggered only after the vehicle is already in violation. This can lead to legal issues if the vehicle ends up outside of the expected area, safety issues if an obstacle is hit that the geofence was meant to avoid, and the vehicle can also be 'stuck' if the breach is continually triggered, overriding attempted user actions.\r\n\r\n**Describe your solution**\r\nPredict the motion of the vehicle and trigger the breach if it is determined that the current trajectory would result in a breach happening before the vehicle can make evasive maneuvers, if it delayed any longer. The vehicle is then re-routed to a safe hold position (stop for multirotor, loiter for fixed wing).\r\n\r\n**Describe possible alternatives**\r\nThere was also the idea of 'shrinking' the allowed flight area, however this would not be robust to different vehicle configurations or tuning.\r\n\r\n**Test data / coverage**\r\nExtensive testing both in SITL and on real vehicles (fixed wing, VTOL and multirotor) inside of Auterion. I haven't tested it yet since upstreaming, and additional testing from anyone else would be appreciated.\r\n\r\n\r\n\r\n**Additional context**\r\n![Screenshot_20201216_141033](https://user-images.githubusercontent.com/1746276/102352838-901ff080-3fa8-11eb-9a96-eb69d8b3d266.png)\r\n\r\n",
      "issue_comments": [
        {
          "author": "jkflying",
          "created_at": "2021-01-12T13:23:12Z",
          "body": "All comments addressed",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-13T07:55:04Z",
          "body": "@jkflying The geofencebreach test is failing in the PR.",
          "type": "issue_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-13T09:25:50Z",
          "body": "> @jkflying The geofencebreach test is failing in the PR.\r\n\r\nYep it seems `clang` is more strict with the implicit conversions from float -> double than GCC - it even complains about constants, not just variables. I've done a workaround here, and made a fix in Matrix that will prevent this for the future.",
          "type": "issue_comment"
        },
        {
          "author": "garfieldG",
          "created_at": "2021-01-28T11:37:59Z",
          "body": "https://github.com/PX4/PX4-Autopilot/issues/16679",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2020-12-16T23:33:25Z",
          "body": "Copyright header",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-16T23:34:56Z",
          "body": "```suggestion\r\n\t~GeofenceBreachAvoidance() = default;\r\n```",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-16T23:37:06Z",
          "body": "Also require `_local_pos.v_xy_valid` here?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:22:54Z",
          "body": "Can you move this block into a separate method?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:28:56Z",
          "body": "Instead, pass `this` to `GeofenceBreachAvoidance`: `GeofenceBreachAvoidance(ModuleParams* parent) : ModuleParams(parent) {}`\r\n```suggestion\r\n```",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:30:38Z",
          "body": "```suggestion\r\n\tbool isInsidePolygonOrCircle(double lat, double lon, float altitude) override\r\n```",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:31:16Z",
          "body": "```suggestion\r\n\tenum class ProbeFunction {\r\n```",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:32:20Z",
          "body": "Can you avoid the static and use the correct type?",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:39:25Z",
          "body": "Might be a detail, but this only does what I'd expect from the method name if yaw=0.",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:40:57Z",
          "body": "Can you include the header for these?",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:43:08Z",
          "body": "```suggestion\r\nvoid GeofenceBreachAvoidance::updateParams() override\r\n{\r\n    ModuleParams::updateParams();\r\n```",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
          "position": 55,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:46:56Z",
          "body": "This is the same in both cases -> you can move it out of the if and simplify:\r\n```suggestion\r\n\t\t\t\tcurrent_distance = (current_max + current_min) * 0.5f;\r\n```",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:50:41Z",
          "body": "Can you use `GEOFENCE_CHECK_INTERVAL`?",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2020-12-18T09:51:58Z",
          "body": "Same here",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-11T10:19:10Z",
          "body": "This already checks for the GPS being valid via `have_geofence_position_data` , do you think it needs more?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-12T12:55:49Z",
          "body": "Moved these to a `dataman_mocks.hpp` as well",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-12T13:01:42Z",
          "body": "When you're worried about overflow or floats that implementation can actually be more accurate, but in this case I agree it is overkill.",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-12T13:15:38Z",
          "body": "renamed to `XXX_north`",
          "path": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-13T08:03:08Z",
          "body": "Depending on `GF_SOURCE` (GPS vs global position).",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MikeCharikov",
          "created_at": "2022-11-29T13:47:52Z",
          "body": "@dagar \r\n\r\nLooks like GF_SOURCE logic is broken here. \r\n\r\nhttps://github.com/PX4/PX4-Autopilot/issues/20677",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: previously the system only detected geofence breaches after the vehicle was already in violation (an incorrect timing/state transition and boundary-condition handling). The change predicts vehicle motion and pre-emptively triggers and reroutes to a safe hold, correcting the incorrect behavior and preventing unintended/out-of-bound operation.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "patch": "@@ -31,6 +31,8 @@\n #\n ############################################################################\n \n+add_subdirectory(GeofenceBreachAvoidance)\n+\n px4_add_module(\n \tMODULE modules__navigator\n \tMAIN navigator\n@@ -53,4 +55,6 @@ px4_add_module(\n \t\tgit_ecl\n \t\tecl_geo\n \t\tlanding_slope\n-\t)\n+\t\tgeofence_breach_avoidance\n+\t\tmotion_planning\n+\t)\n\\ No newline at end of file",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/CMakeLists.txt": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/CMakeLists.txt",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "patch": "@@ -0,0 +1,39 @@\n+############################################################################\n+#\n+#   Copyright (c) 2020 PX4 Development Team. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+# 1. Redistributions of source code must retain the above copyright\n+#    notice, this list of conditions and the following disclaimer.\n+# 2. Redistributions in binary form must reproduce the above copyright\n+#    notice, this list of conditions and the following disclaimer in\n+#    the documentation and/or other materials provided with the\n+#    distribution.\n+# 3. Neither the name PX4 nor the names of its contributors may be\n+#    used to endorse or promote products derived from this software\n+#    without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+#\n+############################################################################\n+\n+px4_add_library(geofence_breach_avoidance\n+\tgeofence_breach_avoidance.cpp\n+\tgeofence_breach_avoidance.h\n+)\n+\n+px4_add_functional_gtest(SRC GeofenceBreachAvoidanceTest.cpp LINKLIBS geofence_breach_avoidance modules__navigator ecl_geo motion_planning)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2FCMakeLists.txt"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/GeofenceBreachAvoidanceTest.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/GeofenceBreachAvoidanceTest.cpp",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "patch": "@@ -0,0 +1,306 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (C) 2020 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+\n+#include <gtest/gtest.h>\n+#include \"geofence_breach_avoidance.h\"\n+#include \"fake_geofence.hpp\"\n+#include \"dataman_mocks.hpp\"\n+#include <parameters/param.h>\n+\n+using namespace matrix;\n+using Vector2d = matrix::Vector2<double>;\n+\n+class GeofenceBreachAvoidanceTest : public ::testing::Test\n+{\n+public:\n+\tvoid SetUp() override\n+\t{\n+\t\tparam_control_autosave(false);\n+\t}\n+};\n+\n+TEST_F(GeofenceBreachAvoidanceTest, waypointFromBearingAndDistance)\n+{\n+\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tstruct map_projection_reference_s ref = {};\n+\tVector2d home_global(42.1, 8.2);\n+\tmap_projection_init(&ref, home_global(0), home_global(1));\n+\n+\tVector2f waypoint_north_east_local(1.0, 1.0);\n+\twaypoint_north_east_local = waypoint_north_east_local.normalized() * 10.5;\n+\tVector2d waypoint_north_east_global = gf_avoidance.waypointFromBearingAndDistance(home_global, M_PI_F * 0.25f, 10.5);\n+\n+\tfloat x, y;\n+\tmap_projection_project(&ref, waypoint_north_east_global(0), waypoint_north_east_global(1), &x, &y);\n+\tVector2f waypoint_north_east_reprojected(x, y);\n+\n+\tEXPECT_FLOAT_EQ(waypoint_north_east_local(0), waypoint_north_east_reprojected(0));\n+\tEXPECT_FLOAT_EQ(waypoint_north_east_local(1), waypoint_north_east_reprojected(1));\n+\n+\n+\tVector2f waypoint_south_west_local = -waypoint_north_east_local;\n+\n+\tVector2d waypoint_southwest_global = gf_avoidance.waypointFromBearingAndDistance(home_global, M_PI_F * 0.25f, -10.5);\n+\n+\tmap_projection_project(&ref, waypoint_southwest_global(0), waypoint_southwest_global(1), &x, &y);\n+\tVector2f waypoint_south_west_reprojected(x, y);\n+\n+\tEXPECT_FLOAT_EQ(waypoint_south_west_local(0), waypoint_south_west_reprojected(0));\n+\tEXPECT_FLOAT_EQ(waypoint_south_west_local(1), waypoint_south_west_reprojected(1));\n+\n+\n+\tVector2d same_as_home_global = gf_avoidance.waypointFromBearingAndDistance(home_global, M_PI_F * 0.25f, 0.0);\n+\n+\tEXPECT_LT(Vector2d(home_global - same_as_home_global).norm(), 1e-4);\n+}\n+\n+TEST_F(GeofenceBreachAvoidanceTest, generateLoiterPointForFixedWing)\n+{\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tFakeGeofence geo;\n+\tstruct map_projection_reference_s ref = {};\n+\tVector2d home_global(42.1, 8.2);\n+\tmap_projection_init(&ref, home_global(0), home_global(1));\n+\n+\tgeofence_violation_type_u gf_violation;\n+\tgf_violation.flags.fence_violation = true;\n+\n+\tgf_avoidance.setHorizontalTestPointDistance(20.0f);\n+\tgf_avoidance.setTestPointBearing(0.0f);\n+\tgf_avoidance.setCurrentPosition(home_global(0), home_global(1), 0);\n+\n+\n+\tVector2d loiter_point_lat_lon = gf_avoidance.generateLoiterPointForFixedWing(gf_violation, &geo);\n+\n+\t// the expected loiter point is located test_point_distance behind\n+\tVector2d loiter_point_lat_lon_expected = gf_avoidance.waypointFromBearingAndDistance(home_global, 0.0f, -20.0f);\n+\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(0), loiter_point_lat_lon_expected(0));\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(1), loiter_point_lat_lon_expected(1));\n+\n+\n+\tgeo.setProbeFunctionBehavior(FakeGeofence::ProbeFunction::LEFT_INSIDE_RIGHT_OUTSIDE);\n+\tloiter_point_lat_lon = gf_avoidance.generateLoiterPointForFixedWing(gf_violation, &geo);\n+\n+\tloiter_point_lat_lon_expected = gf_avoidance.waypointFromBearingAndDistance(home_global, -M_PI_F * 0.5f, 20.0f);\n+\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(0), loiter_point_lat_lon_expected(0));\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(1), loiter_point_lat_lon_expected(1));\n+\n+\tgeo.setProbeFunctionBehavior(FakeGeofence::ProbeFunction::RIGHT_INSIDE_LEFT_OUTSIDE);\n+\tloiter_point_lat_lon = gf_avoidance.generateLoiterPointForFixedWing(gf_violation, &geo);\n+\n+\tloiter_point_lat_lon_expected = gf_avoidance.waypointFromBearingAndDistance(home_global, M_PI_F * 0.5f, 20.0f);\n+\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(0), loiter_point_lat_lon_expected(0));\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(1), loiter_point_lat_lon_expected(1));\n+\n+\tgf_violation.flags.fence_violation = false;\n+\tloiter_point_lat_lon = gf_avoidance.generateLoiterPointForFixedWing(gf_violation, &geo);\n+\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(0), home_global(0));\n+\tEXPECT_FLOAT_EQ(loiter_point_lat_lon(1), home_global(1));\n+}\n+\n+TEST_F(GeofenceBreachAvoidanceTest, generateLoiterPointForMultirotor)\n+{\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tFakeGeofence geo;\n+\tstruct map_projection_reference_s ref = {};\n+\tVector2d home_global(42.1, 8.2);\n+\tmap_projection_init(&ref, home_global(0), home_global(1));\n+\n+\tparam_t param = param_handle(px4::params::MPC_ACC_HOR);\n+\n+\tfloat value = 3;\n+\tparam_set(param, &value);\n+\n+\tparam = param_handle(px4::params::MPC_ACC_HOR_MAX);\n+\tvalue = 5;\n+\tparam_set(param, &value);\n+\n+\tparam = param_handle(px4::params::MPC_JERK_AUTO);\n+\tvalue = 8;\n+\tparam_set(param, &value);\n+\n+\tgeofence_violation_type_u gf_violation;\n+\tgf_violation.flags.fence_violation = true;\n+\n+\tgf_avoidance.setHorizontalTestPointDistance(30.0f);\n+\tgf_avoidance.setTestPointBearing(0.0f);\n+\tgf_avoidance.setCurrentPosition(home_global(0), home_global(1), 0);\n+\t// vehicle is approaching the fence at a crazy velocity\n+\tgf_avoidance.setHorizontalVelocity(1000.0f);\n+\tgf_avoidance.computeBrakingDistanceMultirotor();\n+\n+\tgeo.setProbeFunctionBehavior(FakeGeofence::ProbeFunction::GF_BOUNDARY_20M_AHEAD);\n+\n+\tVector2d loiter_point = gf_avoidance.generateLoiterPointForMultirotor(gf_violation, &geo);\n+\n+\tVector2d loiter_point_predicted = gf_avoidance.waypointFromBearingAndDistance(home_global, 0.0f,\n+\t\t\t\t\t  20.0f - gf_avoidance.getMinHorDistToFenceMulticopter());\n+\n+\tfloat error = get_distance_to_next_waypoint(loiter_point(0), loiter_point(1), loiter_point_predicted(0),\n+\t\t\tloiter_point_predicted(1));\n+\n+\tEXPECT_LE(error, 0.5f);\n+\n+\t// vehicle is approaching fenc slowly, plenty of time to brake\n+\tgf_avoidance.setHorizontalVelocity(0.1f);\n+\tgf_avoidance.computeBrakingDistanceMultirotor();\n+\n+\tloiter_point = gf_avoidance.generateLoiterPointForMultirotor(gf_violation, &geo);\n+\tloiter_point_predicted = gf_avoidance.waypointFromBearingAndDistance(home_global, 0.0f,\n+\t\t\t\t gf_avoidance.computeBrakingDistanceMultirotor());\n+\n+\n+\terror = get_distance_to_next_waypoint(loiter_point(0), loiter_point(1), loiter_point_predicted(0),\n+\t\t\t\t\t      loiter_point_predicted(1));\n+\n+\tEXPECT_LE(error, 0.0f);\n+\n+\tgf_violation.flags.fence_violation = false;\n+\tloiter_point = gf_avoidance.generateLoiterPointForMultirotor(gf_violation, &geo);\n+\n+\tEXPECT_LT(Vector2d(loiter_point - home_global).norm(), 1e-4);\n+}\n+\n+TEST_F(GeofenceBreachAvoidanceTest, generateLoiterAltitudeForFixedWing)\n+{\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tconst float current_alt_amsl = 100.0f;\n+\tconst float vertical_test_point_dist = 10.0f;\n+\n+\tgf_avoidance.setVerticalTestPointDistance(vertical_test_point_dist);\n+\tgf_avoidance.setCurrentPosition(0, 0, current_alt_amsl); // just care about altitude\n+\tgeofence_violation_type_u gf_violation;\n+\tgf_violation.flags.max_altitude_exceeded = true;\n+\n+\tfloat loiter_alt = gf_avoidance.generateLoiterAltitudeForFixedWing(gf_violation);\n+\n+\tEXPECT_EQ(loiter_alt, current_alt_amsl - 2 * vertical_test_point_dist);\n+\n+\tgf_violation.flags.max_altitude_exceeded = false;\n+\n+\tloiter_alt = gf_avoidance.generateLoiterAltitudeForFixedWing(gf_violation);\n+\n+\tEXPECT_EQ(loiter_alt, current_alt_amsl);\n+}\n+\n+TEST_F(GeofenceBreachAvoidanceTest, generateLoiterAltitudeForMulticopter)\n+{\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tconst float climbrate = 10.0f;\n+\tconst float current_alt_amsl = 100.0f;\n+\tgeofence_violation_type_u gf_violation;\n+\tgf_violation.flags.max_altitude_exceeded = true;\n+\n+\tgf_avoidance.setClimbRate(climbrate);\n+\tgf_avoidance.setCurrentPosition(0, 0, current_alt_amsl);\n+\tgf_avoidance.computeVerticalBrakingDistanceMultirotor();\n+\n+\tfloat loiter_alt_amsl = gf_avoidance.generateLoiterAltitudeForMulticopter(gf_violation);\n+\n+\tEXPECT_EQ(loiter_alt_amsl, current_alt_amsl + gf_avoidance.computeVerticalBrakingDistanceMultirotor() -\n+\t\t  gf_avoidance.getMinVertDistToFenceMultirotor());\n+\n+\tgf_violation.flags.max_altitude_exceeded = false;\n+\n+\tloiter_alt_amsl = gf_avoidance.generateLoiterAltitudeForMulticopter(gf_violation);\n+\n+\tEXPECT_EQ(loiter_alt_amsl, current_alt_amsl);\n+}\n+\n+TEST_F(GeofenceBreachAvoidanceTest, maxDistToHomeViolationMulticopter)\n+{\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tFakeGeofence geo;\n+\tstruct map_projection_reference_s ref = {};\n+\tVector2d home_global(42.1, 8.2);\n+\tmap_projection_init(&ref, home_global(0), home_global(1));\n+\tgeofence_violation_type_u gf_violation;\n+\tgf_violation.flags.dist_to_home_exceeded = true;\n+\n+\tconst float hor_vel = 8.0f;\n+\tconst float test_point_distance = 30.0f;\n+\tconst float test_point_bearing = 0.0f;\n+\tconst float max_dist_to_home = 100.0f;\n+\n+\tgf_avoidance.setHorizontalVelocity(hor_vel);\n+\tgf_avoidance.computeBrakingDistanceMultirotor();\n+\tgf_avoidance.setHorizontalTestPointDistance(test_point_distance);\n+\tgf_avoidance.setTestPointBearing(test_point_bearing);\n+\n+\tVector2d current_pos = gf_avoidance.waypointFromBearingAndDistance(home_global, test_point_bearing, 90.0f);\n+\tgf_avoidance.setCurrentPosition(current_pos(0), current_pos(1), 0);\n+\tgf_avoidance.setMaxHorDistHome(max_dist_to_home);\n+\tgf_avoidance.setHomePosition(home_global(0), home_global(1), 0);\n+\n+\tVector2d loiter_point_lat_lon = gf_avoidance.generateLoiterPointForMultirotor(gf_violation, &geo);\n+\n+\tVector2d loiter_point_predicted = gf_avoidance.waypointFromBearingAndDistance(home_global, test_point_bearing,\n+\t\t\t\t\t  max_dist_to_home - gf_avoidance.getMinHorDistToFenceMulticopter());\n+\n+\tEXPECT_LT(Vector2d(loiter_point_predicted - loiter_point_lat_lon).norm(), 1e-4);\n+}\n+\n+TEST_F(GeofenceBreachAvoidanceTest, maxDistToHomeViolationFixedWing)\n+{\n+\tGeofenceBreachAvoidance gf_avoidance(nullptr);\n+\tFakeGeofence geo;\n+\tstruct map_projection_reference_s ref = {};\n+\tVector2d home_global(42.1, 8.2);\n+\tmap_projection_init(&ref, home_global(0), home_global(1));\n+\tgeofence_violation_type_u gf_violation;\n+\tgf_violation.flags.dist_to_home_exceeded = true;\n+\n+\tconst float test_point_distance = 30.0f;\n+\tconst float max_dist_to_home = 100.0f;\n+\tconst float test_point_bearing = 0.0f;\n+\n+\tgf_avoidance.setHorizontalTestPointDistance(test_point_distance);\n+\tgf_avoidance.setTestPointBearing(test_point_bearing);\n+\n+\tVector2d current_pos = gf_avoidance.waypointFromBearingAndDistance(home_global, test_point_bearing, 90.0f);\n+\tgf_avoidance.setCurrentPosition(current_pos(0), current_pos(1), 0);\n+\tgf_avoidance.setMaxHorDistHome(max_dist_to_home);\n+\tgf_avoidance.setHomePosition(home_global(0), home_global(1), 0);\n+\n+\tVector2d loiter_point_lat_lon = gf_avoidance.generateLoiterPointForFixedWing(gf_violation, &geo);\n+\n+\tVector2d loiter_point_predicted = gf_avoidance.waypointFromBearingAndDistance(home_global, test_point_bearing,\n+\t\t\t\t\t  max_dist_to_home - 2.0f * test_point_distance);\n+\n+\tEXPECT_LT(Vector2d(loiter_point_predicted - loiter_point_lat_lon).norm(), 1e-4);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2FGeofenceBreachAvoidanceTest.cpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "patch": "@@ -0,0 +1,100 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2021 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file dataman_mocks.h\n+ * Provides a minimal dataman implementation to compile against for testing\n+ *\n+ * @author Roman Bapst\n+ * @author Julian Kent\n+ */\n+#pragma once\n+\n+#include <dataman/dataman.h>\n+extern \"C\" {\n+\t__EXPORT ssize_t\n+\tdm_read(\n+\t\tdm_item_t item,\t\t\t/* The item type to retrieve */\n+\t\tunsigned index,\t\t\t/* The index of the item */\n+\t\tvoid *buffer,\t\t\t/* Pointer to caller data buffer */\n+\t\tsize_t buflen\t\t\t/* Length in bytes of data to retrieve */\n+\t) {return 0;};\n+\n+\t/** write to the data manager store */\n+\t__EXPORT ssize_t\n+\tdm_write(\n+\t\tdm_item_t  item,\t\t/* The item type to store */\n+\t\tunsigned index,\t\t\t/* The index of the item */\n+\t\tdm_persitence_t persistence,\t/* The persistence level of this item */\n+\t\tconst void *buffer,\t\t/* Pointer to caller data buffer */\n+\t\tsize_t buflen\t\t\t/* Length in bytes of data to retrieve */\n+\t) {return 0;};\n+\n+\t/**\n+\t * Lock all items of a type. Can be used for atomic updates of multiple items (single items are always updated\n+\t * atomically).\n+\t * Note that this lock is independent from dm_read & dm_write calls.\n+\t * @return 0 on success and lock taken, -1 on error (lock not taken, errno set)\n+\t */\n+\t__EXPORT int\n+\tdm_lock(\n+\t\tdm_item_t item\t\t\t/* The item type to lock */\n+\t) {return 0;};\n+\n+\t/**\n+\t * Try to lock all items of a type (@see sem_trywait()).\n+\t * @return 0 if lock is taken, -1 otherwise (on error or if already locked. errno is set accordingly)\n+\t */\n+\t__EXPORT int\n+\tdm_trylock(\n+\t\tdm_item_t item\t\t\t/* The item type to lock */\n+\t) {return 0;};\n+\n+\t/** Unlock all items of a type */\n+\t__EXPORT void\n+\tdm_unlock(\n+\t\tdm_item_t item\t\t\t/* The item type to unlock */\n+\t) {};\n+\n+\t/** Erase all items of this type */\n+\t__EXPORT int\n+\tdm_clear(\n+\t\tdm_item_t item\t\t\t/* The item type to clear */\n+\t) {return 0;};\n+\n+\t/** Tell the data manager about the type of the last reset */\n+\t__EXPORT int\n+\tdm_restart(\n+\t\tdm_reset_reason restart_type\t/* The last reset type */\n+\t) {return 0;};\n+}\n+",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fdataman_mocks.hpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/fake_geofence.hpp",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "patch": "@@ -0,0 +1,139 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2021 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file fake_geofence.h\n+ * Provides a fake geofence interface to use for testing\n+ *\n+ * @author Roman Bapst\n+ * @author Julian Kent\n+ */\n+#pragma once\n+\n+#include\"../geofence.h\"\n+#include <lib/mathlib/mathlib.h>\n+\n+class FakeGeofence : public Geofence\n+{\n+public:\n+\tFakeGeofence() :\n+\t\tGeofence(nullptr)\n+\t{};\n+\n+\tvirtual ~FakeGeofence() {};\n+\n+\tbool isInsidePolygonOrCircle(double lat, double lon, float altitude) override\n+\t{\n+\t\tswitch (_probe_function_behavior) {\n+\t\tcase ProbeFunction::ALL_POINTS_OUTSIDE: {\n+\t\t\t\treturn _allPointsOutside(lat, lon, altitude);\n+\t\t\t}\n+\n+\t\tcase ProbeFunction::LEFT_INSIDE_RIGHT_OUTSIDE: {\n+\t\t\t\treturn _left_inside_right_outside(lat, lon, altitude);\n+\t\t\t}\n+\n+\t\tcase ProbeFunction::RIGHT_INSIDE_LEFT_OUTSIDE: {\n+\t\t\t\treturn _right_inside_left_outside(lat, lon, altitude);\n+\t\t\t}\n+\n+\t\tcase ProbeFunction::GF_BOUNDARY_20M_AHEAD: {\n+\t\t\t\treturn _gf_boundary_is_20m_north(lat, lon, altitude);\n+\t\t\t}\n+\n+\t\tdefault:\n+\t\t\treturn _allPointsOutside(lat, lon, altitude);\n+\t\t}\n+\t}\n+\n+\tenum class ProbeFunction {\n+\t\tALL_POINTS_OUTSIDE = 0,\n+\t\tLEFT_INSIDE_RIGHT_OUTSIDE,\n+\t\tRIGHT_INSIDE_LEFT_OUTSIDE,\n+\t\tGF_BOUNDARY_20M_AHEAD\n+\t};\n+\n+\tvoid setProbeFunctionBehavior(ProbeFunction func) {_probe_function_behavior = func;}\n+\n+\n+private:\n+\n+\tProbeFunction _probe_function_behavior = ProbeFunction::ALL_POINTS_OUTSIDE;\n+\n+\tbool _flag_on_left = true;\n+\tbool _flag_on_right = false;\n+\n+\tbool _allPointsOutside(double lat, double lon, float alt)\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\tbool _left_inside_right_outside(double lat, double lon, float alt)\n+\t{\n+\t\tif (_flag_on_left) {\n+\t\t\t_flag_on_left = false;\n+\t\t\treturn true;\n+\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tbool _right_inside_left_outside(double lat, double lon, float alt)\n+\t{\n+\t\tif (_flag_on_right) {\n+\t\t\t_flag_on_right = false;\n+\t\t\treturn true;\n+\n+\t\t} else {\n+\t\t\t_flag_on_right = true;\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tbool _gf_boundary_is_20m_north(double lat, double lon, float alt)\n+\t{\n+\t\tstruct map_projection_reference_s ref = {};\n+\t\tmatrix::Vector2<double> home_global(42.1, 8.2);\n+\t\tmap_projection_init(&ref, home_global(0), home_global(1));\n+\n+\t\tfloat x, y;\n+\t\tmap_projection_project(&ref, lat, lon, &x, &y);\n+\t\tmatrix::Vector2f waypoint_local(x, y);\n+\n+\t\tif (waypoint_local(0) >= 20.0f) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Ffake_geofence.hpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
        "status": "added",
        "additions": 293,
        "deletions": 0,
        "changes": 293,
        "patch": "@@ -0,0 +1,293 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2020 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+\n+#include \"geofence_breach_avoidance.h\"\n+#include <lib/ecl/geo/geo.h>\n+#include <motion_planning/VelocitySmoothing.hpp>\n+\n+using Vector2d = matrix::Vector2<double>;\n+\n+\n+GeofenceBreachAvoidance::GeofenceBreachAvoidance(ModuleParams *parent) :\n+\tModuleParams(parent)\n+{\n+\t_paramHandle.param_mpc_jerk_max = param_find(\"MPC_JERK_MAX\");\n+\t_paramHandle.param_mpc_acc_hor = param_find(\"MPC_ACC_HOR\");\n+\t_paramHandle.param_mpc_acc_hor_max = param_find(\"MPC_ACC_HOR_MAX\");\n+\t_paramHandle.param_mpc_jerk_auto = param_find(\"MPC_JERK_AUTO\");\n+\t_paramHandle.param_mpc_acc_up_max = param_find(\"MPC_ACC_UP_MAX\");\n+\t_paramHandle.param_mpc_acc_down_max = param_find(\"MPC_ACC_DOWN_MAX\");\n+\n+\tupdateParameters();\n+}\n+\n+void GeofenceBreachAvoidance::updateParameters()\n+{\n+\tModuleParams::updateParams();\n+\tparam_get(_paramHandle.param_mpc_jerk_max, &_params.param_mpc_jerk_max);\n+\tparam_get(_paramHandle.param_mpc_acc_hor, &_params.param_mpc_acc_hor);\n+\tparam_get(_paramHandle.param_mpc_acc_hor_max, &_params.param_mpc_acc_hor_max);\n+\tparam_get(_paramHandle.param_mpc_jerk_auto, &_params.param_mpc_jerk_auto);\n+\tparam_get(_paramHandle.param_mpc_acc_up_max, &_params.param_mpc_acc_up_max);\n+\tparam_get(_paramHandle.param_mpc_acc_down_max, &_params.param_mpc_acc_down_max);\n+\n+\tupdateMinHorDistToFenceMultirotor();\n+}\n+\n+void GeofenceBreachAvoidance::setCurrentPosition(double lat, double lon, float alt)\n+{\n+\t_current_pos_lat_lon = Vector2d(lat, lon);\n+\t_current_alt_amsl = alt;\n+}\n+\n+void GeofenceBreachAvoidance::setHomePosition(double lat, double lon, float alt)\n+{\n+\t_home_lat_lon(0) = lat;\n+\t_home_lat_lon(1) = lon;\n+\t_home_alt_amsl = alt;\n+}\n+\n+matrix::Vector2<double> GeofenceBreachAvoidance::waypointFromBearingAndDistance(matrix::Vector2<double>\n+\t\tcurrent_pos_lat_lon, float test_point_bearing, float test_point_distance)\n+{\n+\t// TODO: Remove this once the underlying geo function has been fixed\n+\tif (test_point_distance < 0.0f) {\n+\t\ttest_point_distance *= -1.0f;\n+\t\ttest_point_bearing = matrix::wrap_2pi(test_point_bearing + M_PI_F);\n+\t}\n+\n+\tdouble fence_violation_test_point_lat, fence_violation_test_point_lon;\n+\twaypoint_from_heading_and_distance(current_pos_lat_lon(0), current_pos_lat_lon(1), test_point_bearing,\n+\t\t\t\t\t   test_point_distance, &fence_violation_test_point_lat, &fence_violation_test_point_lon);\n+\n+\treturn Vector2d(fence_violation_test_point_lat, fence_violation_test_point_lon);\n+}\n+\n+Vector2d\n+GeofenceBreachAvoidance::getFenceViolationTestPoint()\n+{\n+\treturn waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, _test_point_distance);\n+}\n+\n+Vector2d\n+GeofenceBreachAvoidance::generateLoiterPointForFixedWing(geofence_violation_type_u violation_type, Geofence *geofence)\n+{\n+\tif (violation_type.flags.fence_violation) {\n+\t\tconst float bearing_90_left = matrix::wrap_2pi(_test_point_bearing - M_PI_F * 0.5f);\n+\t\tconst float bearing_90_right = matrix::wrap_2pi(_test_point_bearing + M_PI_F * 0.5f);\n+\n+\t\tdouble loiter_center_lat, loiter_center_lon;\n+\t\tdouble fence_violation_test_point_lat, fence_violation_test_point_lon;\n+\n+\t\twaypoint_from_heading_and_distance(_current_pos_lat_lon(0), _current_pos_lat_lon(1), bearing_90_left,\n+\t\t\t\t\t\t   _test_point_distance, &fence_violation_test_point_lat, &fence_violation_test_point_lon);\n+\n+\t\tconst bool left_side_is_inside_fence = geofence->isInsidePolygonOrCircle(fence_violation_test_point_lat,\n+\t\t\t\t\t\t       fence_violation_test_point_lon, _current_alt_amsl);\n+\n+\t\twaypoint_from_heading_and_distance(_current_pos_lat_lon(0), _current_pos_lat_lon(1), bearing_90_right,\n+\t\t\t\t\t\t   _test_point_distance, &fence_violation_test_point_lat, &fence_violation_test_point_lon);\n+\n+\t\tconst bool right_side_is_inside_fence = geofence->isInsidePolygonOrCircle(fence_violation_test_point_lat,\n+\t\t\t\t\t\t\tfence_violation_test_point_lon, _current_alt_amsl);\n+\n+\t\tfloat bearing_to_loiter_point;\n+\n+\t\tif (right_side_is_inside_fence && !left_side_is_inside_fence) {\n+\t\t\tbearing_to_loiter_point = bearing_90_right;\n+\n+\t\t} else if (left_side_is_inside_fence && !right_side_is_inside_fence) {\n+\t\t\tbearing_to_loiter_point = bearing_90_left;\n+\n+\t\t} else {\n+\t\t\tbearing_to_loiter_point = matrix::wrap_2pi(_test_point_bearing + M_PI_F);\n+\t\t}\n+\n+\t\twaypoint_from_heading_and_distance(_current_pos_lat_lon(0), _current_pos_lat_lon(1), bearing_to_loiter_point,\n+\t\t\t\t\t\t   _test_point_distance, &loiter_center_lat, &loiter_center_lon);\n+\n+\t\treturn Vector2d(loiter_center_lat, loiter_center_lon);\n+\n+\t} else if (violation_type.flags.dist_to_home_exceeded) {\n+\n+\t\treturn waypointFromHomeToTestPointAtDist(math::max(_max_hor_dist_home - 2 * _test_point_distance, 0.0f));\n+\n+\t} else {\n+\t\treturn _current_pos_lat_lon;\n+\t}\n+}\n+\n+Vector2d\n+GeofenceBreachAvoidance::generateLoiterPointForMultirotor(geofence_violation_type_u violation_type, Geofence *geofence)\n+{\n+\n+\tif (violation_type.flags.fence_violation) {\n+\t\tfloat current_distance = _test_point_distance * 0.5f;\n+\t\tfloat current_min = 0.0f;\n+\t\tfloat current_max = _test_point_distance;\n+\t\tVector2d test_point;\n+\n+\t\t// binary search for the distance from the drone to the geofence in the given direction\n+\t\twhile (abs(current_max - current_min) > 0.5f) {\n+\t\t\ttest_point = waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, current_distance);\n+\n+\t\t\tif (!geofence->isInsidePolygonOrCircle(test_point(0), test_point(1), _current_alt_amsl)) {\n+\t\t\t\tcurrent_max = current_distance;\n+\n+\t\t\t} else {\n+\t\t\t\tcurrent_min = current_distance;\n+\t\t\t}\n+\n+\t\t\tcurrent_distance = (current_max + current_min) * 0.5f;\n+\t\t}\n+\n+\t\ttest_point = waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, current_distance);\n+\n+\t\tif (_multirotor_braking_distance > current_distance - _min_hor_dist_to_fence_mc) {\n+\t\t\treturn waypointFromBearingAndDistance(test_point, _test_point_bearing + M_PI_F, _min_hor_dist_to_fence_mc);\n+\n+\t\t} else {\n+\t\t\treturn waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, _multirotor_braking_distance);\n+\t\t}\n+\n+\t} else if (violation_type.flags.dist_to_home_exceeded) {\n+\n+\t\treturn waypointFromHomeToTestPointAtDist(math::max(_max_hor_dist_home - _min_hor_dist_to_fence_mc, 0.0f));\n+\n+\t} else {\n+\t\tif (_velocity_hor_abs > 0.5f) {\n+\t\t\treturn waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, _multirotor_braking_distance);\n+\n+\t\t} else {\n+\t\t\treturn _current_pos_lat_lon;\n+\t\t}\n+\t}\n+}\n+\n+float GeofenceBreachAvoidance::generateLoiterAltitudeForFixedWing(geofence_violation_type_u violation_type)\n+{\n+\tif (violation_type.flags.max_altitude_exceeded) {\n+\t\treturn _current_alt_amsl - 2.0f * _vertical_test_point_distance;\n+\n+\t} else {\n+\t\treturn _current_alt_amsl;\n+\t}\n+}\n+\n+float GeofenceBreachAvoidance::generateLoiterAltitudeForMulticopter(geofence_violation_type_u violation_type)\n+{\n+\tif (violation_type.flags.max_altitude_exceeded) {\n+\t\treturn _current_alt_amsl + _multirotor_vertical_braking_distance - _min_vert_dist_to_fence_mc;\n+\n+\t} else {\n+\t\treturn _current_alt_amsl;\n+\t}\n+}\n+\n+float GeofenceBreachAvoidance::computeBrakingDistanceMultirotor()\n+{\n+\tconst float accel_delay_max = math::max(_params.param_mpc_acc_hor, _params.param_mpc_acc_hor_max);\n+\tVelocitySmoothing predictor(accel_delay_max, _velocity_hor_abs, 0.f);\n+\tpredictor.setMaxVel(_velocity_hor_abs);\n+\tpredictor.setMaxAccel(_params.param_mpc_acc_hor);\n+\tpredictor.setMaxJerk(_params.param_mpc_jerk_auto);\n+\tpredictor.updateDurations(0.f);\n+\tpredictor.updateTraj(predictor.getTotalTime());\n+\n+\t_multirotor_braking_distance =  predictor.getCurrentPosition() + (GEOFENCE_CHECK_INTERVAL_US / 1e6f) *\n+\t\t\t\t\t_velocity_hor_abs;\n+\n+\treturn _multirotor_braking_distance;\n+}\n+\n+float GeofenceBreachAvoidance::computeVerticalBrakingDistanceMultirotor()\n+{\n+\tconst float accel_delay_max = math::max(_params.param_mpc_acc_up_max, _params.param_mpc_acc_down_max);\n+\tconst float vertical_vel_abs = fabsf(_climbrate);\n+\n+\n+\tVelocitySmoothing predictor(accel_delay_max, vertical_vel_abs, 0.f);\n+\tpredictor.setMaxVel(vertical_vel_abs);\n+\tpredictor.setMaxAccel(_climbrate > 0 ? _params.param_mpc_acc_down_max : _params.param_mpc_acc_up_max);\n+\tpredictor.setMaxJerk(_params.param_mpc_jerk_auto);\n+\tpredictor.updateDurations(0.f);\n+\tpredictor.updateTraj(predictor.getTotalTime());\n+\n+\t_multirotor_vertical_braking_distance =  predictor.getCurrentPosition() + (GEOFENCE_CHECK_INTERVAL_US / 1e6f) *\n+\t\t\tvertical_vel_abs;\n+\n+\t_multirotor_vertical_braking_distance = matrix::sign(_climbrate) * _multirotor_vertical_braking_distance;\n+\n+\treturn _multirotor_vertical_braking_distance;\n+}\n+\n+void GeofenceBreachAvoidance::updateMinHorDistToFenceMultirotor()\n+{\n+\tconst float accel_delay_max = math::max(_params.param_mpc_acc_hor, _params.param_mpc_acc_hor_max);\n+\tVelocitySmoothing predictor(accel_delay_max, 0.0f, 0.f);\n+\tpredictor.setMaxVel(0.0f);\n+\tpredictor.setMaxAccel(_params.param_mpc_acc_hor);\n+\tpredictor.setMaxJerk(_params.param_mpc_jerk_auto);\n+\tpredictor.updateDurations(0.f);\n+\tpredictor.updateTraj(predictor.getTotalTime());\n+\n+\t_min_hor_dist_to_fence_mc = 2.0f * predictor.getCurrentPosition();\n+\n+}\n+\n+void GeofenceBreachAvoidance::updateMinVertDistToFenceMultirotor()\n+{\n+\tconst float accel_delay_max = math::max(_params.param_mpc_acc_up_max, _params.param_mpc_acc_down_max);\n+\n+\tVelocitySmoothing predictor(accel_delay_max, 0, 0.f);\n+\tpredictor.setMaxVel(0);\n+\tpredictor.setMaxAccel(_params.param_mpc_acc_down_max);\n+\tpredictor.setMaxJerk(_params.param_mpc_jerk_auto);\n+\tpredictor.updateDurations(0.f);\n+\tpredictor.updateTraj(predictor.getTotalTime());\n+\n+\t_min_vert_dist_to_fence_mc =  2.0f * predictor.getCurrentPosition();\n+}\n+\n+Vector2d GeofenceBreachAvoidance::waypointFromHomeToTestPointAtDist(float distance)\n+{\n+\tVector2d test_point = getFenceViolationTestPoint();\n+\tfloat bearing_home_current_pos = get_bearing_to_next_waypoint(_home_lat_lon(0), _home_lat_lon(1), test_point(0),\n+\t\t\t\t\t test_point(1));\n+\tdouble loiter_center_lat, loiter_center_lon;\n+\n+\twaypoint_from_heading_and_distance(_home_lat_lon(0), _home_lat_lon(1), bearing_home_current_pos, distance,\n+\t\t\t\t\t   &loiter_center_lat, &loiter_center_lon);\n+\n+\treturn Vector2d(loiter_center_lat, loiter_center_lon);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.cpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h",
        "status": "added",
        "additions": 148,
        "deletions": 0,
        "changes": 148,
        "patch": "@@ -0,0 +1,148 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2020 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+\n+#include <lib/mathlib/mathlib.h>\n+#include <px4_platform_common/module_params.h>\n+#include \"../geofence.h\"\n+#include <px4_platform_common/defines.h>\n+\n+\n+class Geofence;\n+\n+#define GEOFENCE_CHECK_INTERVAL_US 200000\n+\n+union geofence_violation_type_u {\n+\tstruct {\n+\t\tbool dist_to_home_exceeded: 1;\t///< 0 - distance to home exceeded\n+\t\tbool max_altitude_exceeded: 1;\t///< 1 - maximum altitude exceeded\n+\t\tbool fence_violation: 1;\t///< 2- violation of user defined fence\n+\t} flags;\n+\tuint8_t value;\n+};\n+\n+class GeofenceBreachAvoidance : public ModuleParams\n+{\n+public:\n+\tGeofenceBreachAvoidance(ModuleParams *parent);\n+\n+\t~GeofenceBreachAvoidance() = default;\n+\n+\tmatrix::Vector2<double> getFenceViolationTestPoint();\n+\n+\tmatrix::Vector2<double> waypointFromBearingAndDistance(matrix::Vector2<double> current_pos_lat_lon,\n+\t\t\tfloat test_point_bearing, float test_point_distance);\n+\n+\tmatrix::Vector2<double>\n+\tgenerateLoiterPointForFixedWing(geofence_violation_type_u violation_type, Geofence *geofence);\n+\n+\tfloat computeBrakingDistanceMultirotor();\n+\n+\tfloat computeVerticalBrakingDistanceMultirotor();\n+\n+\tmatrix::Vector2<double> generateLoiterPointForMultirotor(geofence_violation_type_u violation_type, Geofence *geofence);\n+\n+\tfloat generateLoiterAltitudeForFixedWing(geofence_violation_type_u violation_type);\n+\n+\tfloat generateLoiterAltitudeForMulticopter(geofence_violation_type_u violation_type);\n+\n+\tfloat getMinHorDistToFenceMulticopter() {return _min_hor_dist_to_fence_mc;}\n+\n+\tfloat getMinVertDistToFenceMultirotor() {return _min_vert_dist_to_fence_mc;}\n+\n+\tvoid setTestPointBearing(float test_point_bearing) { _test_point_bearing = test_point_bearing; }\n+\n+\tvoid setHorizontalTestPointDistance(float test_point_distance) { _test_point_distance = test_point_distance; }\n+\n+\tvoid setVerticalTestPointDistance(float distance) { _vertical_test_point_distance = distance; }\n+\n+\tvoid setHorizontalVelocity(float velocity_hor_abs) { _velocity_hor_abs = velocity_hor_abs; }\n+\n+\tvoid setClimbRate(float climbrate) { _climbrate = climbrate; }\n+\n+\tvoid setCurrentPosition(double lat, double lon, float alt);\n+\n+\tvoid setHomePosition(double lat, double lon, float alt);\n+\n+\tvoid setMaxHorDistHome(float dist) { _max_hor_dist_home = dist; }\n+\n+\tvoid setMaxVerDistHome(float dist) { _max_ver_dist_home = dist; }\n+\n+\tvoid updateParameters();\n+\n+private:\n+\tstruct {\n+\t\tparam_t param_mpc_jerk_max;\n+\t\tparam_t param_mpc_acc_hor;\n+\t\tparam_t param_mpc_acc_hor_max;\n+\t\tparam_t param_mpc_jerk_auto;\n+\t\tparam_t param_mpc_acc_up_max;\n+\t\tparam_t param_mpc_acc_down_max;\n+\n+\t} _paramHandle;\n+\n+\tstruct {\n+\t\tfloat param_mpc_jerk_max;\n+\t\tfloat param_mpc_acc_hor;\n+\t\tfloat param_mpc_acc_hor_max;\n+\t\tfloat param_mpc_jerk_auto;\n+\t\tfloat param_mpc_acc_up_max;\n+\t\tfloat param_mpc_acc_down_max;\n+\n+\t} _params;\n+\n+\tfloat _test_point_bearing{0.0f};\n+\tfloat _test_point_distance{0.0f};\n+\tfloat _vertical_test_point_distance{0.0f};\n+\tfloat _velocity_hor_abs{0.0f};\n+\tfloat _climbrate{0.0f};\n+\tfloat _current_alt_amsl{0.0f};\n+\tfloat _min_hor_dist_to_fence_mc{0.0f};\n+\tfloat _min_vert_dist_to_fence_mc{0.0f};\n+\n+\tfloat _multirotor_braking_distance{0.0f};\n+\tfloat _multirotor_vertical_braking_distance{0.0f};\n+\n+\tmatrix::Vector2<double> _current_pos_lat_lon{};\n+\tmatrix::Vector2<double> _home_lat_lon {};\n+\tfloat _home_alt_amsl{0.0f};\n+\n+\tfloat _max_hor_dist_home{0.0f};\n+\tfloat _max_ver_dist_home{0.0f};\n+\n+\tvoid updateMinHorDistToFenceMultirotor();\n+\n+\tvoid updateMinVertDistToFenceMultirotor();\n+\n+\tmatrix::Vector2<double> waypointFromHomeToTestPointAtDist(float distance);\n+\n+};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.h"
      },
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 16,
        "changes": 57,
        "patch": "@@ -58,7 +58,9 @@ Geofence::Geofence(Navigator *navigator) :\n \t_sub_airdata(ORB_ID(vehicle_air_data))\n {\n \t// we assume there's no concurrent fence update on startup\n-\t_updateFence();\n+\tif (_navigator != nullptr) {\n+\t\t_updateFence();\n+\t}\n }\n \n Geofence::~Geofence()\n@@ -218,14 +220,13 @@ bool Geofence::check(const struct mission_item_s &mission_item)\n \treturn checkAll(mission_item.lat, mission_item.lon, mission_item.altitude);\n }\n \n-bool Geofence::checkAll(double lat, double lon, float altitude)\n+bool Geofence::isCloserThanMaxDistToHome(double lat, double lon, float altitude)\n {\n \tbool inside_fence = true;\n \n \tif (isHomeRequired() && _navigator->home_position_valid()) {\n \n \t\tconst float max_horizontal_distance = _param_gf_max_hor_dist.get();\n-\t\tconst float max_vertical_distance = _param_gf_max_ver_dist.get();\n \n \t\tconst double home_lat = _navigator->get_home_position()->lat;\n \t\tconst double home_lon = _navigator->get_home_position()->lon;\n@@ -236,30 +237,55 @@ bool Geofence::checkAll(double lat, double lon, float altitude)\n \n \t\tget_distance_to_point_global_wgs84(lat, lon, altitude, home_lat, home_lon, home_alt, &dist_xy, &dist_z);\n \n-\t\tif (max_vertical_distance > FLT_EPSILON && (dist_z > max_vertical_distance)) {\n-\t\t\tif (hrt_elapsed_time(&_last_vertical_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum altitude above home exceeded by %.1f m\",\n-\t\t\t\t\t\t     (double)(dist_z - max_vertical_distance));\n-\t\t\t\t_last_vertical_range_warning = hrt_absolute_time();\n+\t\tif (max_horizontal_distance > FLT_EPSILON && (dist_xy > max_horizontal_distance)) {\n+\t\t\tif (hrt_elapsed_time(&_last_horizontal_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum distance from home reached (%.5f)\",\n+\t\t\t\t\t\t     (double)max_horizontal_distance);\n+\t\t\t\t_last_horizontal_range_warning = hrt_absolute_time();\n \t\t\t}\n \n \t\t\tinside_fence = false;\n \t\t}\n+\t}\n \n-\t\tif (max_horizontal_distance > FLT_EPSILON && (dist_xy > max_horizontal_distance)) {\n-\t\t\tif (hrt_elapsed_time(&_last_horizontal_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum distance from home exceeded by %.1f m\",\n-\t\t\t\t\t\t     (double)(dist_xy - max_horizontal_distance));\n-\t\t\t\t_last_horizontal_range_warning = hrt_absolute_time();\n+\treturn inside_fence;\n+}\n+\n+bool Geofence::isBelowMaxAltitude(float altitude)\n+{\n+\tbool inside_fence = true;\n+\n+\tif (isHomeRequired() && _navigator->home_position_valid()) {\n+\n+\t\tconst float max_vertical_distance = _param_gf_max_ver_dist.get();\n+\t\tconst float home_alt = _navigator->get_home_position()->alt;\n+\n+\t\tfloat dist_z = altitude - home_alt;\n+\n+\t\tif (max_vertical_distance > FLT_EPSILON && (dist_z > max_vertical_distance)) {\n+\t\t\tif (hrt_elapsed_time(&_last_vertical_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum altitude above home reached (%.5f)\",\n+\t\t\t\t\t\t     (double)max_vertical_distance);\n+\t\t\t\t_last_vertical_range_warning = hrt_absolute_time();\n \t\t\t}\n \n \t\t\tinside_fence = false;\n \t\t}\n \t}\n \n+\treturn inside_fence;\n+}\n+\n+\n+bool Geofence::checkAll(double lat, double lon, float altitude)\n+{\n+\tbool inside_fence = isCloserThanMaxDistToHome(lat, lon, altitude);\n+\n+\tinside_fence = inside_fence && isBelowMaxAltitude(altitude);\n+\n \t// to be inside the geofence both fences have to report being inside\n \t// as they both report being inside when not enabled\n-\tinside_fence = inside_fence && checkPolygons(lat, lon, altitude);\n+\tinside_fence = inside_fence && isInsidePolygonOrCircle(lat, lon, altitude);\n \n \tif (inside_fence) {\n \t\t_outside_counter = 0;\n@@ -277,8 +303,7 @@ bool Geofence::checkAll(double lat, double lon, float altitude)\n \t}\n }\n \n-\n-bool Geofence::checkPolygons(double lat, double lon, float altitude)\n+bool Geofence::isInsidePolygonOrCircle(double lat, double lon, float altitude)\n {\n \t// the following uses dm_read, so first we try to lock all items. If that fails, it (most likely) means\n \t// the data is currently being updated (via a mavlink geofence transfer), and we do not check for a violation now",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "patch": "@@ -42,6 +42,7 @@\n \n #include <float.h>\n \n+#include <lib/mathlib/mathlib.h>\n #include <px4_platform_common/module_params.h>\n #include <drivers/drv_hrt.h>\n #include <lib/ecl/geo/geo.h>\n@@ -62,7 +63,7 @@ class Geofence : public ModuleParams\n \tGeofence(Navigator *navigator);\n \tGeofence(const Geofence &) = delete;\n \tGeofence &operator=(const Geofence &) = delete;\n-\t~Geofence();\n+\tvirtual ~Geofence();\n \n \t/* Altitude mode, corresponding to the param GF_ALTMODE */\n \tenum {\n@@ -97,6 +98,13 @@ class Geofence : public ModuleParams\n \t */\n \tbool check(const struct mission_item_s &mission_item);\n \n+\n+\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n+\n+\tbool isBelowMaxAltitude(float altitude);\n+\n+\tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n+\n \tint clearDm();\n \n \tbool valid();\n@@ -127,9 +135,19 @@ class Geofence : public ModuleParams\n \tint getAltitudeMode() { return _param_gf_altmode.get(); }\n \tint getSource() { return _param_gf_source.get(); }\n \tint getGeofenceAction() { return _param_gf_action.get(); }\n+\tfloat getMaxHorDistanceHome() { return _param_gf_max_hor_dist.get(); }\n+\tfloat getMaxVerDistanceHome() { return _param_gf_max_ver_dist.get(); }\n \n \tbool isHomeRequired();\n \n+\t/**\n+\t * Check if a point passes the Geofence test.\n+\t * In addition to checkPolygons(), this takes all additional parameters into account.\n+\t *\n+\t * @return false for a geofence violation\n+\t */\n+\tbool checkAll(double lat, double lon, float altitude);\n+\n \t/**\n \t * print Geofence status to the console\n \t */\n@@ -188,13 +206,7 @@ class Geofence : public ModuleParams\n \t */\n \tbool checkPolygons(double lat, double lon, float altitude);\n \n-\t/**\n-\t * Check if a point passes the Geofence test.\n-\t * In addition to checkPolygons(), this takes all additional parameters into account.\n-\t *\n-\t * @return false for a geofence violation\n-\t */\n-\tbool checkAll(double lat, double lon, float altitude);\n+\n \n \tbool checkAll(const vehicle_global_position_s &global_position);\n \tbool checkAll(const vehicle_global_position_s &global_position, float baro_altitude_amsl);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -55,6 +55,8 @@\n \n #include \"navigation.h\"\n \n+#include \"GeofenceBreachAvoidance/geofence_breach_avoidance.h\"\n+\n #include <lib/perf/perf_counter.h>\n #include <px4_platform_common/module.h>\n #include <px4_platform_common/module_params.h>\n@@ -295,6 +297,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool\t\tabort_landing();\n \n+\tvoid geofence_breach_check(bool &have_geofence_position_data);\n+\n \t// Param access\n \tfloat\t\tget_loiter_min_alt() const { return _param_mis_ltrmin_alt.get(); }\n \tfloat\t\tget_takeoff_min_alt() const { return _param_mis_takeoff_alt.get(); }\n@@ -378,6 +382,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tGeofence\t_geofence;\t\t\t/**< class that handles the geofence */\n \tbool\t\t_geofence_violation_warning_sent{false}; /**< prevents spaming to mavlink */\n+\tGeofenceBreachAvoidance _gf_breach_avoidance;\n+\thrt_abstime _last_geofence_check = 0;\n \n \tbool\t\t_can_loiter_at_sp{false};\t\t\t/**< flags if current position SP can be used to loiter */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t/**< flags if position SP triplet needs to be published */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 132,
        "deletions": 54,
        "changes": 186,
        "patch": "@@ -64,9 +64,6 @@\n  * @ingroup apps\n  */\n extern \"C\" __EXPORT int navigator_main(int argc, char *argv[]);\n-\n-#define GEOFENCE_CHECK_INTERVAL 200000\n-\n using namespace time_literals;\n \n namespace navigator\n@@ -78,6 +75,7 @@ Navigator::Navigator() :\n \tModuleParams(nullptr),\n \t_loop_perf(perf_alloc(PC_ELAPSED, \"navigator\")),\n \t_geofence(this),\n+\t_gf_breach_avoidance(this),\n \t_mission(this),\n \t_loiter(this),\n \t_takeoff(this),\n@@ -157,8 +155,6 @@ Navigator::run()\n \t/* rate-limit position subscription to 20 Hz / 50 ms */\n \torb_set_interval(_local_pos_sub, 50);\n \n-\thrt_abstime last_geofence_check = 0;\n-\n \twhile (!should_exit()) {\n \n \t\t/* wait for up to 1000ms for data */\n@@ -478,55 +474,7 @@ Navigator::run()\n \t\tcheck_traffic();\n \n \t\t/* Check geofence violation */\n-\t\tif (have_geofence_position_data &&\n-\t\t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n-\t\t    (hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n-\n-\t\t\tbool inside = _geofence.check(_global_pos, _gps_pos, _home_pos,\n-\t\t\t\t\t\t      home_position_valid());\n-\t\t\tlast_geofence_check = hrt_absolute_time();\n-\t\t\thave_geofence_position_data = false;\n-\n-\t\t\t_geofence_result.timestamp = hrt_absolute_time();\n-\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n-\t\t\t_geofence_result.home_required = _geofence.isHomeRequired();\n-\n-\t\t\tif (!inside) {\n-\t\t\t\t/* inform other apps via the mission result */\n-\t\t\t\t_geofence_result.geofence_violated = true;\n-\n-\t\t\t\t/* Issue a warning about the geofence violation once */\n-\t\t\t\tif (!_geofence_violation_warning_sent) {\n-\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Geofence violation\");\n-\n-\t\t\t\t\t/* If we are already in loiter it is very likely that we are doing a reposition\n-\t\t\t\t\t * so we should block that by repositioning in the current location */\n-\t\t\t\t\tif (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_WARN\n-\t\t\t\t\t    && get_vstatus()->nav_state == vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER) {\n-\t\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n-\n-\t\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n-\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n-\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n-\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n-\t\t\t\t\t\trep->current.valid = true;\n-\n-\t\t\t\t\t\t_pos_sp_triplet_updated = true;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t_geofence_violation_warning_sent = true;\n-\t\t\t\t}\n-\n-\t\t\t} else {\n-\t\t\t\t/* inform other apps via the mission result */\n-\t\t\t\t_geofence_result.geofence_violated = false;\n-\n-\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n-\t\t\t\t_geofence_violation_warning_sent = false;\n-\t\t\t}\n-\n-\t\t\t_geofence_result_pub.publish(_geofence_result);\n-\t\t}\n+\t\tgeofence_breach_check(have_geofence_position_data);\n \n \t\t/* Do stuff according to navigation state set by commander */\n \t\tNavigatorMode *navigation_mode_new{nullptr};\n@@ -744,6 +692,136 @@ Navigator::run()\n \t}\n }\n \n+void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n+{\n+\n+\tif (have_geofence_position_data &&\n+\t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n+\t    (hrt_elapsed_time(&_last_geofence_check) > GEOFENCE_CHECK_INTERVAL_US)) {\n+\n+\t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\t\tmatrix::Vector2<double> fence_violation_test_point;\n+\t\tgeofence_violation_type_u gf_violation_type{};\n+\t\tfloat test_point_bearing;\n+\t\tfloat test_point_distance;\n+\t\tfloat vertical_test_point_distance;\n+\n+\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\ttest_point_bearing = atan2f(_local_pos.vy, _local_pos.vx);\n+\t\t\tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n+\t\t\t_gf_breach_avoidance.setHorizontalVelocity(velocity_hor_abs);\n+\t\t\t_gf_breach_avoidance.setClimbRate(-_local_pos.vz);\n+\t\t\ttest_point_distance = _gf_breach_avoidance.computeBrakingDistanceMultirotor();\n+\t\t\tvertical_test_point_distance = _gf_breach_avoidance.computeVerticalBrakingDistanceMultirotor();\n+\n+\t\t} else {\n+\t\t\ttest_point_distance = 2.0f * get_loiter_radius();\n+\t\t\tvertical_test_point_distance = 5.0f;\n+\n+\t\t\tif (hrt_absolute_time() - pos_ctrl_status.timestamp < 100000 && PX4_ISFINITE(pos_ctrl_status.nav_bearing)) {\n+\t\t\t\ttest_point_bearing = pos_ctrl_status.nav_bearing;\n+\n+\t\t\t} else {\n+\t\t\t\ttest_point_bearing = atan2f(_local_pos.vy, _local_pos.vx);\n+\t\t\t}\n+\t\t}\n+\n+\t\t_gf_breach_avoidance.setHorizontalTestPointDistance(test_point_distance);\n+\t\t_gf_breach_avoidance.setVerticalTestPointDistance(vertical_test_point_distance);\n+\t\t_gf_breach_avoidance.setTestPointBearing(test_point_bearing);\n+\t\t_gf_breach_avoidance.setCurrentPosition(_global_pos.lat, _global_pos.lon, _global_pos.alt);\n+\t\t_gf_breach_avoidance.setMaxHorDistHome(_geofence.getMaxHorDistanceHome());\n+\t\t_gf_breach_avoidance.setMaxVerDistHome(_geofence.getMaxVerDistanceHome());\n+\n+\t\tif (home_position_valid()) {\n+\t\t\t_gf_breach_avoidance.setHomePosition(_home_pos.lat, _home_pos.lon, _home_pos.alt);\n+\t\t}\n+\n+\t\tfence_violation_test_point = _gf_breach_avoidance.getFenceViolationTestPoint();\n+\n+\t\tgf_violation_type.flags.dist_to_home_exceeded = !_geofence.isCloserThanMaxDistToHome(fence_violation_test_point(0),\n+\t\t\t\tfence_violation_test_point(1),\n+\t\t\t\t_global_pos.alt);\n+\n+\t\tgf_violation_type.flags.max_altitude_exceeded = !_geofence.isBelowMaxAltitude(_global_pos.alt +\n+\t\t\t\tvertical_test_point_distance);\n+\n+\t\tgf_violation_type.flags.fence_violation = !_geofence.isInsidePolygonOrCircle(fence_violation_test_point(0),\n+\t\t\t\tfence_violation_test_point(1),\n+\t\t\t\t_global_pos.alt);\n+\n+\t\t_last_geofence_check = hrt_absolute_time();\n+\t\thave_geofence_position_data = false;\n+\n+\t\t_geofence_result.timestamp = hrt_absolute_time();\n+\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n+\t\t_geofence_result.home_required = _geofence.isHomeRequired();\n+\n+\t\tif (gf_violation_type.value) {\n+\t\t\t/* inform other apps via the mission result */\n+\t\t\t_geofence_result.geofence_violated = true;\n+\n+\t\t\t/* Issue a warning about the geofence violation once */\n+\t\t\tif (!_geofence_violation_warning_sent) {\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Approaching on Geofence\");\n+\n+\t\t\t\t// we have predicted a geofence violation and if the action is to loiter then\n+\t\t\t\t// demand a reposition to a location which is inside the geofence\n+\t\t\t\tif (_geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n+\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n+\n+\t\t\t\t\tmatrix::Vector2<double> lointer_center_lat_lon;\n+\t\t\t\t\tmatrix::Vector2<double> current_pos_lat_lon(_global_pos.lat, _global_pos.lon);\n+\t\t\t\t\tfloat loiter_altitude_amsl = _global_pos.alt;\n+\n+\n+\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\t\t\t\t// the computation of the braking distance does not match the actual braking distance. Until we have a better model\n+\t\t\t\t\t\t// we set the loiter point to the current position, that will make sure that the vehicle will loiter inside the fence\n+\t\t\t\t\t\tlointer_center_lat_lon =  _gf_breach_avoidance.generateLoiterPointForMultirotor(gf_violation_type,\n+\t\t\t\t\t\t\t\t\t  &_geofence);\n+\n+\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForMulticopter(gf_violation_type);\n+\n+\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\tlointer_center_lat_lon = _gf_breach_avoidance.generateLoiterPointForFixedWing(gf_violation_type, &_geofence);\n+\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForFixedWing(gf_violation_type);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n+\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n+\t\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\t\trep->current.lat = lointer_center_lat_lon(0);\n+\t\t\t\t\trep->current.lon = lointer_center_lat_lon(1);\n+\t\t\t\t\trep->current.alt = loiter_altitude_amsl;\n+\t\t\t\t\trep->current.valid = true;\n+\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\t\trep->current.alt_valid = true;\n+\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\t\trep->current.loiter_direction = 1;\n+\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n+\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n+\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\n+\t\t\t\t}\n+\n+\t\t\t\t_geofence_violation_warning_sent = true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\t/* inform other apps via the mission result */\n+\t\t\t_geofence_result.geofence_violated = false;\n+\n+\t\t\t/* Reset the _geofence_violation_warning_sent field */\n+\t\t\t_geofence_violation_warning_sent = false;\n+\t\t}\n+\n+\t\t_geofence_result_pub.publish(_geofence_result);\n+\t}\n+}\n+\n int Navigator::task_spawn(int argc, char *argv[])\n {\n \t_task_id = px4_task_spawn_cmd(\"navigator\",",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c1bff3c499410ebdbf0bf6d019250cec611130db/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::check",
        "Geofence::checkAll",
        "Navigator::Navigator",
        "checkPolygons",
        "Geofence::Geofence",
        "checkAll",
        "Navigator::run",
        "Geofence::checkPolygons"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::check",
          "Geofence::checkPolygons",
          "Geofence::checkAll",
          "Geofence::Geofence"
        ],
        "src/modules/navigator/geofence.h": [
          "checkAll",
          "checkPolygons"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Remaining flight range based RTL trigger",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16399",
    "number": 16399,
    "created_at": "2020-12-16T11:15:07Z",
    "merged": true,
    "merged_at": "2021-01-18T15:26:54Z",
    "state": "closed",
    "conversation": {
      "author": "jkflying",
      "body": "**Describe problem solved by this pull request**\r\nCurrently the RTL is triggered by a fixed battery level, irrespective of the distance to home, wind conditions, vehicle flight speed etc. This means that the vehicle could run out of battery during a long RTL, or arrive home with still a large fraction of battery remaining during a short RTL.\r\n\r\n**Describe your solution**\r\nTake into account the flight time home during the RTL. From the RTL viability checks in navigator publish this information saying how long the RTL will take (taking into account vehicle speeds, wind speed and destination distance/direction), and what fraction of the total battery would be used by the RTL. In Commander, subscribe to this and trigger RTL if the current battery level less the battery used on RTL will take the vehicle below the existing low battery thresholds.\r\n\r\n**Describe possible alternatives**\r\nA parameter was used for \"total flight time in RTL\". This could have been taken from the power module / smart battery telemetry of the current and battery capacity values. However, for multirotor that is risky because power usage in forward flight is higher than hover, so a vehicle hovering far away would RTL too late. The parameter approach also lets users set a hard upper limit on the amount of time they would be happy with the vehicle spending in RTL, which might be useful for regulatory or safety reasons.\r\n\r\n**Test data / coverage**\r\nThis was tested extensively in Auterion, but I haven't tested it yet since upstreaming. It should get some SITL time to make sure nothing broke in the transplant, but the concept is quite solid.\r\n\r\nNote: it might be better to squash this on merge",
      "issue_comments": [
        {
          "author": "moreba1",
          "created_at": "2021-01-06T07:18:52Z",
          "body": "> A parameter was used for \"total flight time in RTL\". This could have been taken from the power module\r\n\r\nI think using \"average power consumption\" (mah/km) + \"distance to home\" is better than \"flight time in RTL\".\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/pull/14819",
          "type": "issue_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-12T13:55:22Z",
          "body": "> I think uisng \"average power consumption\" (mah/km) + \"distance to home\" is better than \"flight time in RTL\". #14819\r\n\r\nThat would be a nice improvement, I agree. However, I'd prefer to get this in with the current feature set, and we can work on improving it once people can already use it.",
          "type": "issue_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-13T12:51:56Z",
          "body": "Out of flash again on V2 :cry: ",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-18T13:01:46Z",
          "body": "Re-running CI",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2021-01-18T15:31:35Z",
          "body": "> > I think uisng \"average power consumption\" (mah/km) + \"distance to home\" is better than \"flight time in RTL\". #14819\r\n> \r\n> That would be a nice improvement, I agree. However, I'd prefer to get this in with the current feature set, and we can work on improving it once people can already use it.\r\n\r\nanother potential future future improvement could take into account the wind speed and direction estimate for vehicles that can estimate wind (e.g. those that have airspeed sensors).\r\n\r\nHowever, this PR is a great improvement as a first step as-is.",
          "type": "issue_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-18T16:08:07Z",
          "body": "> take into account the wind speed and direction estimate\r\n\r\nIt does that already :smile: \r\n\r\nEdit: and it can also use the drag fusion wind speed estimate for multirotors without an airspeed sensor.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2021-04-14T23:16:29Z",
          "body": "@jkflying You wouldn't create a PR without making it possible for people to use it - so can you point me to the docs?\r\n\r\nAssuming not a few questions:\r\n- Does this work on all vehicle types?\r\n- How do you enable/disable this feature? Is it supported in QGC - how?\r\n- How does this work? My guess is that you set low battery action to RTL. Then you set RTL_FLT_TIME to indicate max time expected for RTL. The low battery RTL will then trigger early based on the systems calculation that time taken to get home at cruise speed will trigger low battery RTL within RTL_FLT_TIME. Is that correct? And presumably you can set this to 0 just to ignore it.\r\n\r\nPlaces that might be impacted:\r\n- [Safety > Return mode settings](https://docs.px4.io/master/en/config/safety.html#return-mode-settings)\r\n- [Safety > Low battery setup](https://docs.px4.io/master/en/config/safety.html#low-battery-failsafe)\r\n- [Return mode](https://docs.px4.io/master/en/flight_modes/return.html)\r\n- Maybe some more but ^^^ are the key ones.\r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2020-12-16T16:52:50Z",
          "body": "units",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 11,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-17T00:05:21Z",
          "body": "vehicle_status_s::VEHICLE_TYPE_UNKNOWN = 0",
          "path": "src/modules/navigator/rtl.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-17T00:08:16Z",
          "body": "```suggestion\r\n\tparam_t _rtl_xy_speed{PARAM_INVALID};\r\n```",
          "path": "src/modules/navigator/rtl.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-17T00:08:28Z",
          "body": "```suggestion\r\n\tparam_t _rtl_descent_speed{PARAM_INVALID};\r\n```",
          "path": "src/modules/navigator/rtl.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2021-01-13T12:19:13Z",
          "body": "Is minutes a problem? It is documented in the string. It's just that a number like 15 or 30 is much easier to understand for users than 900 or 1800 if I used seconds instead.",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 11,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-13T15:07:27Z",
          "body": "Minutes is fine, I mean add the unit metadata (@unit).",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 11,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "Good to go!",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes a logic error where RTL was triggered purely by a fixed battery threshold without accounting for distance, wind, or vehicle speed, producing incorrect/unsafe behavior (too-late or too-early RTL). It changes the RTL viability check and commander logic to estimate RTL flight time and battery usage and trigger RTL based on the remaining battery after that estimate, correcting the improper conditional/state transition.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -57,4 +57,6 @@ px4_add_module(\n \t\tlanding_slope\n \t\tgeofence_breach_avoidance\n \t\tmotion_planning\n-\t)\n\\ No newline at end of file\n+\t)\n+\n+px4_add_functional_gtest(SRC RangeRTLTest.cpp LINKLIBS modules__navigator modules__dataman)\n\\ No newline at end of file",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e4d4ad0e7e775b95bccfd27a7859265179d06e7/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/RangeRTLTest.cpp": {
        "filename": "src/modules/navigator/RangeRTLTest.cpp",
        "status": "added",
        "additions": 219,
        "deletions": 0,
        "changes": 219,
        "patch": "@@ -0,0 +1,219 @@\n+#define MODULE_NAME \"Navigator\"\n+\n+#include \"navigator.h\"\n+#include \"rtl.h\"\n+\n+#include <future>\n+\n+\n+#include <gtest/gtest.h>\n+\n+TEST(Navigator_and_RTL, interact_correctly)\n+{\n+\tNavigator n;\n+\tRTL rtl(&n);\n+\n+\n+\thome_position_s home_pos{};\n+\thome_pos.valid_hpos = true;\n+\thome_pos.valid_lpos = true;\n+\thome_pos.valid_alt = true;\n+\thome_pos.timestamp = 1000;\n+\n+\tvehicle_global_position_s glob_pos{};\n+\n+\tvehicle_status_s v_status{};\n+\tv_status.vehicle_type = vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n+\n+\t// TODO: can't do this, it hangs forever in Navigator's while loop\n+\t// uORB::Publication<home_position_s> home_pos_pub{ORB_ID(home_position)};\n+\t// uORB::Publication<vehicle_global_position_s> global_pos_pub{ORB_ID(vehicle_global_position)};\n+\t// uORB::Publication<vehicle_local_position_s> local_pos_pub{ORB_ID(vehicle_local_position)};\n+\t// uORB::Publication<vehicle_status_s> vehicle_status_pub{ORB_ID(vehicle_status)};\n+\t// home_pos_pub.publish(home_pos);\n+\t// global_pos_pub.publish(glob_pos);\n+\t// local_pos_pub.publish(local_pos);\n+\t// vehicle_status_pub.publish(v_status);\n+\t// n.run();\n+\n+\t// Hacky-hack, don't use pub-sub, just set them directly in navigator. NB! This isn't the \"real\" API, they should\n+\t// be set via pub-sub otherwise this will be a constant drag on development\n+\t*n.get_home_position() = home_pos;\n+\t*n.get_global_position() = glob_pos;\n+\t*n.get_vstatus() = v_status;\n+\n+\tuORB::SubscriptionData<rtl_flight_time_s> _rtl_flight_time_sub{ORB_ID(rtl_flight_time)};\n+\tASSERT_FALSE(_rtl_flight_time_sub.update());\n+\trtl.find_RTL_destination();\n+\tASSERT_TRUE(_rtl_flight_time_sub.update());\n+\tauto msg = _rtl_flight_time_sub.get();\n+\tEXPECT_EQ(msg.rtl_time_s, 0);\n+\n+\t// WHEN: we set the vehicle type to multirotor\n+\tv_status.vehicle_type = n.get_vstatus()->vehicle_type = vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n+\tfloat xy, z;\n+\trtl.get_rtl_xy_z_speed(xy, z);\n+\n+\t// THEN: the RTL speed should correspond to multirotor parameters\n+\tfloat xy_desired, z_desired;\n+\tparam_get(param_handle(px4::params::MPC_XY_CRUISE), &xy_desired);\n+\tparam_get(param_handle(px4::params::MPC_Z_VEL_MAX_DN), &z_desired);\n+\tEXPECT_FLOAT_EQ(xy, xy_desired);\n+\tEXPECT_FLOAT_EQ(z, z_desired);\n+\n+\t// WHEN: it is a fixed wing\n+\tn.get_vstatus()->vehicle_type = vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n+\trtl.get_rtl_xy_z_speed(xy, z);\n+\n+\t// THEN: it should be fixed wing parameters\n+\tparam_get(param_handle(px4::params::FW_AIRSPD_TRIM), &xy_desired);\n+\tparam_get(param_handle(px4::params::FW_T_SINK_MIN), &z_desired);\n+\tEXPECT_FLOAT_EQ(xy, xy_desired);\n+\tEXPECT_FLOAT_EQ(z, z_desired);\n+\n+\t// WHEN: it is rover\n+\tn.get_vstatus()->vehicle_type = vehicle_status_s::VEHICLE_TYPE_ROVER;\n+\trtl.get_rtl_xy_z_speed(xy, z);\n+\n+\t// THEN: it should be rover parameters, and z should just be large (no RTL time in Z -> high speed)\n+\tparam_get(param_handle(px4::params::GND_SPEED_THR_SC), &xy_desired);\n+\tEXPECT_FLOAT_EQ(xy, xy_desired);\n+\tEXPECT_GT(z, 1000);\n+}\n+\n+class RangeRTL_tth : public ::testing::Test\n+{\n+public:\n+\tmatrix::Vector3f rtl_vector;\n+\tmatrix::Vector3f rtl_point_local_pos;\n+\tmatrix::Vector2f wind_vel;\n+\tfloat vehicle_speed;\n+\tfloat vehicle_descent_speed;\n+\n+\tvoid SetUp() override\n+\t{\n+\t\trtl_vector  = matrix::Vector3f(0, 0, 0);\n+\t\trtl_point_local_pos  = matrix::Vector3f(0, 0, 0);\n+\t\twind_vel  = matrix::Vector2f(0, 0);\n+\t\tvehicle_speed = 5;\n+\t\tvehicle_descent_speed = 1;\n+\t}\n+};\n+\n+TEST_F(RangeRTL_tth, zero_distance_zero_time)\n+{\n+\t// GIVEN: zero distances (defaults)\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should be zero\n+\tEXPECT_FLOAT_EQ(tth, 0.f);\n+}\n+\n+TEST_F(RangeRTL_tth, ten_seconds_xy)\n+{\n+\t// GIVEN: 10 seconds of distance\n+\tvehicle_speed = 6.2f;\n+\trtl_vector(0) = rtl_vector(1) = -(vehicle_speed * 10) / sqrtf(2);\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should be ten seconds\n+\tEXPECT_FLOAT_EQ(tth, 10.f);\n+}\n+\n+TEST_F(RangeRTL_tth, ten_seconds_xy_5_seconds_z)\n+{\n+\t// GIVEN: 10 seconds of xy distance and 5 seconds of Z\n+\tvehicle_speed = 4.2f;\n+\tvehicle_descent_speed = 1.2f;\n+\trtl_vector(0) = rtl_vector(1) = -(vehicle_speed * 10) / sqrtf(2);\n+\trtl_vector(2) = vehicle_descent_speed * 5;\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should be 15 seconds\n+\tEXPECT_FLOAT_EQ(tth, 15.f);\n+}\n+\n+TEST_F(RangeRTL_tth, ten_seconds_xy_downwind_to_home)\n+{\n+\t// GIVEN: 10 seconds of xy distance and 5 seconds of Z, and the wind is towards home\n+\tvehicle_speed = 4.2f;\n+\trtl_vector(0) = rtl_vector(1) = -(vehicle_speed * 10) / sqrtf(2);\n+\n+\twind_vel = matrix::Vector2f(-1, -1);\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should be 10, because we don't rely on wind towards home for RTL\n+\tEXPECT_FLOAT_EQ(tth, 10.f);\n+}\n+\n+TEST_F(RangeRTL_tth, ten_seconds_xy_upwind_to_home)\n+{\n+\t// GIVEN: 10 seconds of distance\n+\tvehicle_speed = 4.2f;\n+\tvehicle_descent_speed = 1.2f;\n+\trtl_vector(0) = rtl_vector(1) = -(vehicle_speed * 10) / sqrtf(2);\n+\n+\twind_vel = matrix::Vector2f(1, 1) / sqrt(2) * vehicle_speed / 10;\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should be 11.111111... because it slows us down by 10% and time = dist/speed\n+\tEXPECT_FLOAT_EQ(tth, 10 / 0.9f);\n+}\n+\n+TEST_F(RangeRTL_tth, ten_seconds_xy_z_wind_across_home)\n+{\n+\t// GIVEN: a 3 4 5 triangle, with vehicle airspeed being 5, wind 3, ground speed 4\n+\t// and the vehicle is 10 seconds away\n+\n+\tvehicle_speed = 5.f;\n+\twind_vel = matrix::Vector2f(-1, 1) / sqrt(2) * 3.;\n+\trtl_vector(0) = rtl_vector(1) = -(4 * 10) / sqrtf(2);\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should be 10\n+\tEXPECT_FLOAT_EQ(tth, 10);\n+}\n+\n+TEST_F(RangeRTL_tth, too_strong_upwind_to_home)\n+{\n+\t// GIVEN: 10 seconds of distance\n+\tvehicle_speed = 4.2f;\n+\tvehicle_descent_speed = 1.2f;\n+\trtl_vector(0) = rtl_vector(1) = -(vehicle_speed * 10) / sqrtf(2);\n+\n+\twind_vel = matrix::Vector2f(1, 1) / sqrt(2) * vehicle_speed * 1.001f;\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should never get home\n+\tEXPECT_TRUE(std::isinf(tth)) << tth;\n+}\n+\n+TEST_F(RangeRTL_tth, too_strong_crosswind_to_home)\n+{\n+\t// GIVEN: 10 seconds of distance\n+\tvehicle_speed = 4.2f;\n+\tvehicle_descent_speed = 1.2f;\n+\trtl_vector(0) = rtl_vector(1) = -(vehicle_speed * 10) / sqrtf(2);\n+\n+\twind_vel = matrix::Vector2f(1, -1) / sqrt(2) * vehicle_speed * 1.001f;\n+\n+\t// WHEN: we get the tth\n+\tfloat tth = time_to_home(rtl_vector, wind_vel, vehicle_speed, vehicle_descent_speed);\n+\n+\t// THEN: it should never get home\n+\tEXPECT_TRUE(std::isinf(tth)) << tth;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e4d4ad0e7e775b95bccfd27a7859265179d06e7/src%2Fmodules%2Fnavigator%2FRangeRTLTest.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 96,
        "deletions": 1,
        "changes": 97,
        "patch": "@@ -37,12 +37,15 @@\n  *\n  * @author Julian Oes <julian@oes.ch>\n  * @author Anton Babushkin <anton.babushkin@me.com>\n+ * @author Julian Kent <julian@auterion.com>\n  */\n \n #include \"rtl.h\"\n #include \"navigator.h\"\n #include <dataman/dataman.h>\n \n+#include <lib/ecl/geo/geo.h>\n+\n \n static constexpr float DELAY_SIGMA = 0.01f;\n \n@@ -153,7 +156,7 @@ void RTL::find_RTL_destination()\n \t}\n \n \t// compare to safe landing positions\n-\tmission_safe_point_s closest_safe_point {} ;\n+\tmission_safe_point_s closest_safe_point {};\n \tmission_stats_entry_s stats;\n \tint ret = dm_read(DM_KEY_SAFE_POINTS, 0, &stats, sizeof(mission_stats_entry_s));\n \tint num_safe_points = 0;\n@@ -212,6 +215,23 @@ void RTL::find_RTL_destination()\n \t\t}\n \t}\n \n+\t// figure out how long the RTL will take\n+\tfloat rtl_xy_speed, rtl_z_speed;\n+\tget_rtl_xy_z_speed(rtl_xy_speed, rtl_z_speed);\n+\n+\tmatrix::Vector3f to_destination_vec;\n+\tget_vector_to_next_waypoint(global_position.lat, global_position.lon, _destination.lat, _destination.lon,\n+\t\t\t\t    &to_destination_vec(0), &to_destination_vec(1));\n+\tto_destination_vec(2) = _destination.alt - global_position.alt;\n+\n+\tfloat time_to_home_s = time_to_home(to_destination_vec, get_wind(), rtl_xy_speed, rtl_z_speed);\n+\n+\tfloat rtl_flight_time_ratio = time_to_home_s / (60 * _param_rtl_flt_time.get());\n+\trtl_flight_time_s rtl_flight_time{};\n+\trtl_flight_time.timestamp = hrt_absolute_time();\n+\trtl_flight_time.rtl_limit_fraction = rtl_flight_time_ratio;\n+\trtl_flight_time.rtl_time_s = time_to_home_s;\n+\t_rtl_flight_time_pub.publish(rtl_flight_time);\n }\n \n void RTL::on_activation()\n@@ -611,3 +631,78 @@ float RTL::calculate_return_alt_from_cone_half_angle(float cone_half_angle_deg)\n \n \treturn max(return_altitude_amsl, gpos.alt);\n }\n+\n+void RTL::get_rtl_xy_z_speed(float &xy, float &z)\n+{\n+\tuint8_t vehicle_type = _navigator->get_vstatus()->vehicle_type;\n+\t// Caution: here be dragons!\n+\t// Use C API to allow this code to be compiled with builds that don't have FW/MC/Rover\n+\n+\tif (vehicle_type != _rtl_vehicle_type) {\n+\t\t_rtl_vehicle_type = vehicle_type;\n+\n+\t\tswitch (vehicle_type) {\n+\t\tcase vehicle_status_s::VEHICLE_TYPE_ROTARY_WING:\n+\t\t\t_rtl_xy_speed = param_find(\"MPC_XY_CRUISE\");\n+\t\t\t_rtl_descent_speed = param_find(\"MPC_Z_VEL_MAX_DN\");\n+\t\t\tbreak;\n+\n+\t\tcase vehicle_status_s::VEHICLE_TYPE_FIXED_WING:\n+\t\t\t_rtl_xy_speed = param_find(\"FW_AIRSPD_TRIM\");\n+\t\t\t_rtl_descent_speed = param_find(\"FW_T_SINK_MIN\");\n+\t\t\tbreak;\n+\n+\t\tcase vehicle_status_s::VEHICLE_TYPE_ROVER:\n+\t\t\t_rtl_xy_speed = param_find(\"GND_SPEED_THR_SC\");\n+\t\t\t_rtl_descent_speed = 65535;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (param_get(_rtl_xy_speed, &xy) != 0) {\n+\t\txy = 1e6f;\n+\t}\n+\n+\tif (param_get(_rtl_descent_speed, &z) != 0) {\n+\t\tz = 1e6f;\n+\t}\n+\n+}\n+\n+matrix::Vector2f RTL::get_wind()\n+{\n+\t_wind_estimate_sub.update();\n+\tmatrix::Vector2f wind;\n+\n+\tif (hrt_absolute_time() - _wind_estimate_sub.get().timestamp < 1_s) {\n+\t\twind(0) = _wind_estimate_sub.get().windspeed_north;\n+\t\twind(1) = _wind_estimate_sub.get().windspeed_east;\n+\t}\n+\n+\treturn wind;\n+}\n+\n+float time_to_home(const matrix::Vector3f &to_home_vec,\n+\t\t   const matrix::Vector2f &wind_velocity, float vehicle_speed_m_s, float vehicle_descent_speed_m_s)\n+{\n+\tconst matrix::Vector2f to_home = to_home_vec.xy();\n+\tconst float alt_change = to_home_vec(2);\n+\tconst matrix::Vector2f to_home_dir = to_home.unit_or_zero();\n+\tconst float dist_to_home = to_home.norm();\n+\n+\tconst float wind_towards_home = wind_velocity.dot(to_home_dir);\n+\tconst float wind_across_home = matrix::Vector2f(wind_velocity - to_home_dir * wind_towards_home).norm();\n+\n+\t// Note: use fminf so that we don't _rely_ on wind towards home to make RTL more efficient\n+\tconst float cruise_speed = sqrtf(vehicle_speed_m_s * vehicle_speed_m_s - wind_across_home * wind_across_home) + fminf(\n+\t\t\t\t\t   0.f, wind_towards_home);\n+\n+\tif (!PX4_ISFINITE(cruise_speed) || cruise_speed <= 0) {\n+\t\treturn INFINITY; // we never reach home if the wind is stronger than vehicle speed\n+\t}\n+\n+\t// assume horizontal and vertical motions happen serially, so their time adds\n+\tfloat horiz = dist_to_home / cruise_speed;\n+\tfloat descent = fabsf(alt_change) / vehicle_descent_speed_m_s;\n+\treturn horiz + descent;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e4d4ad0e7e775b95bccfd27a7859265179d06e7/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "patch": "@@ -46,7 +46,13 @@\n #include \"navigator_mode.h\"\n #include \"mission_block.h\"\n \n+#include <uORB/Subscription.hpp>\n #include <uORB/topics/home_position.h>\n+#include <uORB/topics/rtl_flight_time.h>\n+#include <uORB/topics/vehicle_status.h>\n+#include <uORB/topics/wind_estimate.h>\n+#include <matrix/math.hpp>\n+#include <lib/ecl/geo/geo.h>\n \n class Navigator;\n \n@@ -89,6 +95,8 @@ class RTL : public MissionBlock, public ModuleParams\n \n \tbool denyMissionLanding() { return _deny_mission_landing; }\n \n+\tvoid get_rtl_xy_z_speed(float &xy, float &z);\n+\tmatrix::Vector2f get_wind();\n private:\n \t/**\n \t * Set the RTL item\n@@ -150,6 +158,20 @@ class RTL : public MissionBlock, public ModuleParams\n \t\t(ParamFloat<px4::params::RTL_MIN_DIST>) _param_rtl_min_dist,\n \t\t(ParamInt<px4::params::RTL_TYPE>) _param_rtl_type,\n \t\t(ParamInt<px4::params::RTL_CONE_ANG>) _param_rtl_cone_half_angle_deg,\n+\t\t(ParamFloat<px4::params::RTL_FLT_TIME>) _param_rtl_flt_time,\n \t\t(ParamInt<px4::params::RTL_PLD_MD>) _param_rtl_pld_md\n \t)\n+\n+\t// These need to point at different parameters depending on vehicle type.\n+\t// Can't hard-code them because we have non-MC/FW/Rover builds\n+\tuint8_t _rtl_vehicle_type{vehicle_status_s::VEHICLE_TYPE_UNKNOWN};\n+\tparam_t _rtl_xy_speed{PARAM_INVALID};\n+\tparam_t _rtl_descent_speed{PARAM_INVALID};\n+\n+\tuORB::SubscriptionData<wind_estimate_s>\t\t_wind_estimate_sub{ORB_ID(wind_estimate)};\n+\tuORB::Publication<rtl_flight_time_s>\t\t_rtl_flight_time_pub{ORB_ID(rtl_flight_time)};\n };\n+\n+float time_to_home(const matrix::Vector3f &to_home_vec,\n+\t\t   const matrix::Vector2f &wind_velocity, float vehicle_speed_m_s,\n+\t\t   float vehicle_descent_speed_m_s);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e4d4ad0e7e775b95bccfd27a7859265179d06e7/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -137,6 +137,17 @@ PARAM_DEFINE_INT32(RTL_TYPE, 0);\n  */\n PARAM_DEFINE_INT32(RTL_CONE_ANG, 45);\n \n+/**\n+ * Maximum allowed RTL flight in minutes\n+ *\n+ * This is used to determine when the vehicle should be switched to RTL due to low battery.\n+ * Note, particularly for multirotors this should reflect flight time at cruise speed, not while stationary\n+ *\n+ * @unit min\n+ * @group Commander\n+ */\n+PARAM_DEFINE_FLOAT(RTL_FLT_TIME, 15);\n+\n /**\n  * RTL precision land mode\n  *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7e4d4ad0e7e775b95bccfd27a7859265179d06e7/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::find_RTL_destination",
        "RTL::calculate_return_alt_from_cone_half_angle"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::find_RTL_destination",
          "RTL::calculate_return_alt_from_cone_half_angle"
        ]
      }
    }
  },
  {
    "title": "Various RTL improvements (mainly VTOL specific)",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16377",
    "number": 16377,
    "created_at": "2020-12-11T15:23:13Z",
    "merged": true,
    "merged_at": "2021-01-04T10:58:17Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Replaces https://github.com/PX4/PX4-Autopilot/pull/14728.\r\n\r\n**Describe problem solved by this pull request**\r\n- currently landing on the landing pattern doesn't seem to work (land pattern = whatever of the mission is after the DO_LAND_START marker)\r\n- high transition altitude (see https://github.com/PX4/PX4-Autopilot/pull/14728 for context)\r\n\r\n**Describe your solution**\r\nRTL logic with this PR, changes to current logic in **bold**\r\n(assuming RTL_TYPE is set to 1 (VTOL and FW default, using mission landing if available))\r\n- if close to RTL landing position and in hover, use cone RTL logic (if mission landing is planned that one is used)\r\n- if VTOL and in hover mode, use normal MC RTL strategy (climb to `RTL_RETURN_ALT`, come back and land at RTL landing position)\r\n- if DO_LAND_START is set (landing using mission landing): \r\n  - if in FW mode, go to DO_LAND_START marker in FW mode and from there on follow mission landing\r\n  - if in MC mode, go to the Land position and land there (don't follow landing pattern as in FW mode)\r\n-  if DO_LAND_START is not set \r\n   - if VTOL and in FW mode, climb to `RTL_RETURN_ALT`, fly to home, **loiter down until `RTL_DESCEND_ALT` in FW mode**, transition to hover and land\r\n\r\n**Test data / coverage**\r\nSITL tested with Standard VTOL and multicopter. \r\n\r\n**Additional context**\r\nFor VTOL, it is recommended to always fly with a mission landing planned, such that this one can be used during the RTL. Landing approaches using mission landing can be optimized for current wind direction (transition into the wind), and result in less hover time (vehicle transitions over hover, instead of while loitering around home)\r\n",
      "issue_comments": [
        {
          "author": "Antiheavy",
          "created_at": "2020-12-11T23:35:52Z",
          "body": "is this:\r\n\r\n\r\n> For VTOL, it is recommended to always fly with a mission landing planned, such that this one can be used during the RTL. Landing approaches using mission landing can be optimized for current wind direction (transition into the wind), and result in less hover time (vehicle transitions over hover, instead of while loitering around home)\r\n\r\nconsistent with this?:\r\n\r\n\r\n> * if close to home position and in hover, use cone RTL logic\r\n> \r\n> * if VTOL and in hover mode, use normal MC RTL strategy (climb to `RTL_RETURN_ALT`, come back and land)\r\n\r\nHave you considered if there should be a parameter that allows/avoids RTL at the Home location if in MC mode?  I wonder how many VTOL people would always want to use the mission landing if at all possible?  The \"return to home\" fall-back in the RTL_TYPE=1 logic was originally designed for the case when the mission landing accidentally gets deleted or gets overwritten with an infeasible landing pattern (which unfortunately is something that can easily happen).  \r\n\r\nFrom the way this PR is currently written you intend the VTOL vehicle will perform different Return mode behaviors depending on the context.  I wonder if that is how 100% of VTOL users will want it to work.  I'm not a VTOL expert so I'm not advocating one way or another, just curious.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2020-12-15T10:34:45Z",
          "body": "> Have you considered if there should be a parameter that allows/avoids RTL at the Home location if in MC mode?\r\n\r\nThanks for pointing this out. I actually wrote it down wrongly in the description. It will **always use the mission landing for RTL if RTL_TYPE is 1**. What changes is that it now won't follow the landing pattern (all that is after the DO_LAND_START) in hover, but directly go to Land and descend there. \r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2020-12-29T12:58:36Z",
          "body": "in the master version, VTOL has a dangerous behavior when it reaches VTOL Land.\r\n@sfuhrer \r\nhttps://logs.px4.io/plot_app?log=9df156fc-233e-4b54-ad23-e82017ff47f4\r\n\r\ndesirable behavior is that VTOL transition location be near to land location to minimize power consumption, and the drone doesn't have that much tilt angle and oscillation in MC mode.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-29T17:13:23Z",
          "body": "Rebased on master.",
          "type": "issue_comment"
        },
        {
          "author": "ghost",
          "created_at": "2020-12-31T03:42:06Z",
          "body": "I also noticed that the standard_vtol back transition is behaving dangerously. it's on master and also in this pr,\r\nI noticed this on my flight on the real hardware as well. \r\njust after the back-transition it tries to do a roll maneuver in most of the times,\r\nBut every once in a while, it does a ok back-transition, without trying to roll . \r\n\r\nsame mission, two instances, same-pr (firmware), back-transition behavior is different.\r\nhttps://review.px4.io/plot_app?log=1e1bb5d2-5260-40da-bd7e-46fadf55fc6c ---> rolling\r\nhttps://review.px4.io/plot_app?log=12468162-8610-4965-831c-dd25c8edfeda ---> without roll\r\n\r\nhttps://user-images.githubusercontent.com/25317204/103393299-f0d23000-4b47-11eb-8937-cd642d604219.mp4\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2020-12-31T10:27:09Z",
          "body": "Thanks for reporting - @RomanBapst @sfuhrer could you please follow up?",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-04T08:48:34Z",
          "body": "@yuthikasagarage Have you reviewed your flights? It looks like the vehicle is overshooting the transition waypoint (so your plan is \"not doable\") and hence correcting. There is nothing wrong about the control performance, this seems to be more a planning UX / tuning issue than anything else. That still needs to be solved, but not necessarily in the VTOL controller.",
          "type": "issue_comment"
        },
        {
          "author": "ghost",
          "created_at": "2021-01-04T09:29:15Z",
          "body": "i will look into the flights again, and will try to tune the back transition and check whether the issue persists.\r\nhowever, with a bad planning let's say it does a back-transition in some case, i think all the back-transitions need to be on level flight even if it overshoots, just my two cents.  ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-04T12:40:56Z",
          "body": "@moreba1 \r\n\r\n> in the master version, VTOL has a dangerous behavior when it reaches VTOL Land.\r\n\r\nThis should be fixed with this PR, please re-test.\r\n\r\n> desirable behavior is that VTOL transition location be near to land location to minimize power consumption, and the drone doesn't have that much tilt angle and oscillation in MC mode.\r\n\r\nWith the code from this PR in, it will transition at a distance of the loiter radius from home if no mission landing is planned and the waypoint before the landing waypoint isn't at the transition altitude (RTL_DESCEND_ALT). I'm aware that this isn't optimal for minimized hover time, but at least it should be an improvement to before where it could transition 100m above home and then descend in hover. \r\n",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2021-01-28T16:12:01Z",
          "body": ">     * if in FW mode, go to DO_LAND_START marker in FW mode and from there on follow mission landing\r\n\r\nIs it possible that VTOL first climbs to RTL_RETURN_ALT and keep this attitude until it reaches to landing pattern?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-28T16:52:58Z",
          "body": ">Is it possible that VTOL first climbs to RTL_RETURN_ALT and keep this attitude until it reaches to landing pattern?\r\n\r\nThat should be the desired behavior. If you noticed something else then let me know, that would indicate a bug.",
          "type": "issue_comment"
        },
        {
          "author": "VTOLDavid",
          "created_at": "2021-02-10T18:34:07Z",
          "body": "> \r\n> \r\n> i will look into the flights again, and will try to tune the back transition and check whether the issue persists.\r\n> however, with a bad planning let's say it does a back-transition in some case, i think all the back-transitions need to be on level flight even if it overshoots, just my two cents.\r\n\r\nI having this problem with a tailsitter with very dangerous turns during transition. Is it possible to disable the navigation during transition? The sugested solution is to give more time to the backtransition?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-02-11T14:48:08Z",
          "body": "> I having this problem with a tailsitter with very dangerous turns during transition. Is it possible to disable the navigation during transition? The sugested solution is to give more time to the backtransition?\r\n\r\nI don't think this is directly related to this specific PR - would you mind creating a new issue, and include some flight logs in the description? Thanks!",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2021-03-24T06:26:02Z",
          "body": "@sfuhrer @Antiheavy Are there any docs changes related to this for PX4v1.12? My guess is yes, though it is unclear with the long thread, what delivered/what the landing behaviour is (?).\r\n\r\nLooking at the initial post, it is mostly about what should happen if RTL_TYPE is set to use a mission landing (RTL_TYPE=1) and there was no mission landing pattern defined - in which case it should fly down in FW mode to the descent altitude and then switch to MC and descend \"as per usual\". \r\n\r\nThe description is a little flawed because it does not cater for the behaviour with rally points. \r\n\r\nDocs for vtol are here:\r\nhttps://docs.px4.io/master/en/flight_modes/return.html#vtol\r\nhttps://docs.px4.io/master/en/flight_modes/return.html#mission-landing-rally-point-return-type-rtl-type-1",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2020-12-17T00:58:53Z",
          "body": "I'm not sure I follow, how would this fail if the mission landing progress was set to false immediately on first inactivation?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-17T01:01:13Z",
          "body": "```suggestion\r\n\t\t\t// even if current climb altitude is below (e.g. RTL immediately after take off)\r\n```",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-17T01:02:54Z",
          "body": "Now I'm wondering why this wasn't already set by default.",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 28,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2020-12-18T13:20:04Z",
          "body": "Yes that's a big wonder. I found the cone RTL always really useful so far, both for VTOL in hover and MC.",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 28,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2020-12-18T13:20:06Z",
          "body": "@dagar This prevents the situation where e.g. you are on a mission landing and then RTL kicks in. You don't want to start from the beginning but continue the mission. However, if e.g. the user takes over in manual during a mission landing and then switches back, you probably want to start he mission landing from scratch, as you have no clue where exactly you are and if you are still aligned with the path.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-18T14:30:06Z",
          "body": "I should have been more specific, the part I don't follow is the magic 2 seconds.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2020-12-21T11:01:58Z",
          "body": "@dagar A long study over many years has calculated this number to be the one and only reasonable value. It's almost like pi....",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-21T15:04:36Z",
          "body": "Why not do it immediately on the actual mission deactivation?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-21T15:06:19Z",
          "body": "This is for mission -> RTL (failsafe, etc) -> mission (planned landing) with little to no delay?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-04T10:57:52Z",
          "body": "Let's track this in a separate issue - we shouldn't be blocking an incremental move towards a much better behavior.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-01-05T08:21:41Z",
          "body": "Issue to track that: https://github.com/PX4/PX4-Autopilot/issues/16488",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-01-29T13:06:28Z",
          "body": "@dagar I think I might need to explain this a bit better:\r\nWhen you are executing a mission landing and RTL kicks in due to low battery, then the mode switches from mission to RTL and back to mission (assuming you are executing a mission landing, which is the preferred choice almost always).\r\nTwo the second delay (it actually needs way less) allows the mission to just continue the landing rather than restarting the landing pattern.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2021-01-29T13:06:54Z",
          "body": "@dagar Sorry, I noticed I told you this before. What is the issue here?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-29T14:54:56Z",
          "body": "> @dagar Sorry, I noticed I told you this before. What is the issue here?\r\n\r\nNothing necessarily, I just wanted to make sure there wasn't a potential hole for a hard to reproduce bug down the round. Eg dataman chokes reading the sdcard and there's a one off delay that's much longer than expected. \r\nï¿¼\r\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 16,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "Reviewed, approving after intense flight testing.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes the RTL/landing decision logic for VTOLs and fixes incorrect behavior around mission landing (DO_LAND_START), transition altitudes and when to follow the landing pattern vs. return-to-home. These are behavioral/state-transition fixes (wrong conditions and flow), not syntax/style changes, and reviewers report successful flight tests, indicating it corrects a logic error. ",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 20,
        "changes": 83,
        "patch": "@@ -58,6 +58,9 @@\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n+#include <drivers/drv_hrt.h>\n+\n+using namespace time_literals;\n \n Mission::Mission(Navigator *navigator) :\n \tMissionBlock(navigator),\n@@ -73,6 +76,12 @@ Mission::on_inactive()\n \t * is used for missions such as RTL. */\n \t_navigator->set_cruising_speed();\n \n+\t// if we were executing an landing but have been inactive for 2 seconds, then make the landing invalid\n+\t// this prevents RTL to just continue at the current mission index\n+\tif (_navigator->getMissionLandingInProgress() && (hrt_absolute_time() - _time_mission_deactivated) > 2_s) {\n+\t\t_navigator->setMissionLandingInProgress(false);\n+\t}\n+\n \t/* Without home a mission can't be valid yet anyway, let's wait. */\n \tif (!_navigator->home_position_valid()) {\n \t\treturn;\n@@ -147,6 +156,11 @@ Mission::on_inactivation()\n \tif (_navigator->get_precland()->is_activated()) {\n \t\t_navigator->get_precland()->on_inactivation();\n \t}\n+\n+\t_time_mission_deactivated = hrt_absolute_time();\n+\n+\t/* reset so current mission item gets restarted if mission was paused */\n+\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n }\n \n void\n@@ -377,6 +391,10 @@ Mission::find_mission_land_start()\n \tstruct mission_item_s missionitem = {};\n \tstruct mission_item_s missionitem_prev = {}; //to store mission item before currently checked on, needed to get pos of wp before NAV_CMD_DO_LAND_START\n \n+\t_land_start_available = false;\n+\n+\tbool found_land_start_marker = false;\n+\n \tfor (size_t i = 1; i < _mission.count; i++) {\n \t\tconst ssize_t len = sizeof(missionitem);\n \t\tmissionitem_prev = missionitem; // store the last mission item before reading a new one\n@@ -387,46 +405,58 @@ Mission::find_mission_land_start()\n \t\t\tbreak;\n \t\t}\n \n-\t\t// first check for DO_LAND_START marker\n-\t\tif ((missionitem.nav_cmd == NAV_CMD_DO_LAND_START) && (missionitem_prev.nav_cmd == NAV_CMD_WAYPOINT)) {\n-\n-\t\t\t_land_start_available = true;\n+\t\tif (missionitem.nav_cmd == NAV_CMD_DO_LAND_START) {\n+\t\t\tfound_land_start_marker = true;\n \t\t\t_land_start_index = i;\n-\t\t\t// the DO_LAND_START marker contains no position sp, so take them from the previous mission item\n-\t\t\t_landing_lat = missionitem_prev.lat;\n-\t\t\t_landing_lon = missionitem_prev.lon;\n-\t\t\t_landing_alt = missionitem_prev.altitude;\n-\t\t\treturn true;\n+\t\t}\n \n-\t\t\t// if no DO_LAND_START marker available, also check for VTOL_LAND or normal LAND\n+\t\tif (found_land_start_marker && !_land_start_available && i > _land_start_index\n+\t\t    && item_contains_position(missionitem)) {\n+\t\t\t// use the position of any waypoint after the land start marker which specifies a position.\n+\t\t\t_landing_start_lat = missionitem.lat;\n+\t\t\t_landing_start_lon = missionitem.lon;\n+\t\t\t_landing_start_alt = missionitem.altitude_is_relative ?\tmissionitem.altitude +\n+\t\t\t\t\t     _navigator->get_home_position()->alt : missionitem.altitude;\n+\t\t\t_land_start_available = true;\n+\t\t}\n \n-\t\t} else if (((missionitem.nav_cmd == NAV_CMD_VTOL_LAND) && _navigator->get_vstatus()->is_vtol) ||\n-\t\t\t   (missionitem.nav_cmd == NAV_CMD_LAND)) {\n+\t\tif (((missionitem.nav_cmd == NAV_CMD_VTOL_LAND) && _navigator->get_vstatus()->is_vtol) ||\n+\t\t    (missionitem.nav_cmd == NAV_CMD_LAND)) {\n \n-\t\t\t_land_start_available = true;\n-\t\t\t_land_start_index = i;\n \t\t\t_landing_lat = missionitem.lat;\n \t\t\t_landing_lon = missionitem.lon;\n-\t\t\t_landing_alt = missionitem.altitude;\n-\t\t\treturn true;\n+\t\t\t_landing_alt = missionitem.altitude_is_relative ?\tmissionitem.altitude + _navigator->get_home_position()->alt :\n+\t\t\t\t       missionitem.altitude;\n+\n+\t\t\t// don't have a valid land start yet, use the landing item itself then\n+\t\t\tif (!_land_start_available) {\n+\t\t\t\t_land_start_index = i;\n+\t\t\t\t_landing_start_lat = _landing_lat;\n+\t\t\t\t_landing_start_lon = _landing_lon;\n+\t\t\t\t_landing_start_alt = _landing_alt;\n+\t\t\t\t_land_start_available = true;\n+\t\t\t}\n+\n \t\t}\n \t}\n \n-\t_land_start_available = false;\n-\treturn false;\n+\treturn _land_start_available;\n }\n \n bool\n Mission::land_start()\n {\n \t// if not currently landing, jump to do_land_start\n \tif (_land_start_available) {\n-\t\tif (landing()) {\n+\t\tif (_navigator->getMissionLandingInProgress()) {\n \t\t\treturn true;\n \n \t\t} else {\n \t\t\tset_current_mission_index(get_land_start_index());\n-\t\t\treturn landing();\n+\n+\t\t\tconst bool can_land_now = landing();\n+\t\t\t_navigator->setMissionLandingInProgress(can_land_now);\n+\t\t\treturn can_land_now;\n \t\t}\n \t}\n \n@@ -860,6 +890,10 @@ Mission::set_mission_items()\n \t\t\t\t\t_mission_item.altitude_is_relative = false;\n \n \t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n+\n+\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following\n+\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n+\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n \t\t\t\t}\n \n \t\t\t\t/* move to landing waypoint before descent if necessary */\n@@ -894,6 +928,10 @@ Mission::set_mission_items()\n \t\t\t\t\t_mission_item.autocontinue = true;\n \t\t\t\t\t_mission_item.time_inside = 0.0f;\n \n+\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n+\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n+\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n+\n \t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n \t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n \t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n@@ -1633,6 +1671,11 @@ Mission::set_mission_item_reached()\n \t_navigator->get_mission_result()->seq_reached = _current_mission_index;\n \t_navigator->set_mission_result_updated();\n \n+\t// let the navigator know that we are currently executing the mission landing.\n+\t// Using the method landing() itself is not accurate as it only give information about the mission index\n+\t// but the vehicle could still be very far from the actual landing items\n+\t_navigator->setMissionLandingInProgress(landing());\n+\n \treset_mission_item_reached();\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "patch": "@@ -87,6 +87,10 @@ class Mission : public MissionBlock, public ModuleParams\n \tbool get_mission_finished() const { return _mission_type == MISSION_TYPE_NONE; }\n \tbool get_mission_changed() const { return _mission_changed ; }\n \tbool get_mission_waypoints_changed() const { return _mission_waypoints_changed ; }\n+\tdouble get_landing_start_lat() { return _landing_start_lat; }\n+\tdouble get_landing_start_lon() { return _landing_start_lon; }\n+\tfloat get_landing_start_alt() { return _landing_start_alt; }\n+\n \tdouble get_landing_lat() { return _landing_lat; }\n \tdouble get_landing_lon() { return _landing_lon; }\n \tfloat get_landing_alt() { return _landing_alt; }\n@@ -249,12 +253,18 @@ class Mission : public MissionBlock, public ModuleParams\n \t// track location of planned mission landing\n \tbool\t_land_start_available{false};\n \tuint16_t _land_start_index{UINT16_MAX};\t\t/**< index of DO_LAND_START, INVALID_DO_LAND_START if no planned landing */\n+\tdouble _landing_start_lat{0.0};\n+\tdouble _landing_start_lon{0.0};\n+\tfloat _landing_start_alt{0.0f};\n+\n \tdouble _landing_lat{0.0};\n \tdouble _landing_lon{0.0};\n \tfloat _landing_alt{0.0f};\n \n \tbool _need_takeoff{true};\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n \n+\thrt_abstime _time_mission_deactivated{0};\n+\n \tenum {\n \t\tMISSION_TYPE_NONE,\n \t\tMISSION_TYPE_MISSION",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "patch": "@@ -269,12 +269,19 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tvoid \t\tset_mission_failure(const char *reason);\n \n-\t// MISSION\n+\tvoid \t\tsetMissionLandingInProgress(bool in_progress) { _mission_landing_in_progress = in_progress; }\n+\n+\tbool \t\tgetMissionLandingInProgress() { return _mission_landing_in_progress; }\n+\n \tbool\t\tis_planned_mission() const { return _navigation_mode == &_mission; }\n \tbool\t\ton_mission_landing() { return _mission.landing(); }\n \tbool\t\tstart_mission_landing() { return _mission.land_start(); }\n \tbool\t\tget_mission_start_land_available() { return _mission.get_land_start_available(); }\n \tint \t\tget_mission_landing_index() { return _mission.get_land_start_index(); }\n+\tdouble \tget_mission_landing_start_lat() { return _mission.get_landing_start_lat(); }\n+\tdouble \tget_mission_landing_start_lon() { return _mission.get_landing_start_lon(); }\n+\tfloat \tget_mission_landing_start_alt() { return _mission.get_landing_start_alt(); }\n+\n \tdouble \tget_mission_landing_lat() { return _mission.get_landing_lat(); }\n \tdouble \tget_mission_landing_lon() { return _mission.get_landing_lon(); }\n \tfloat \tget_mission_landing_alt() { return _mission.get_landing_alt(); }\n@@ -396,6 +403,10 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _mission_cruising_speed_fw{-1.0f};\n \tfloat _mission_throttle{NAN};\n \n+\n+\tbool _mission_landing_in_progress{false};\t// this flag gets set if the mission is currently executing on a landing pattern\n+\t// if mission mode is inactive, this flag will be cleared after 2 seconds\n+\n \t// update subscriptions\n \tvoid\t\tparams_update();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "patch": "@@ -563,9 +563,15 @@ Navigator::run()\n \n \t\t\t\t\t}\n \n-\t\t\t\t\t// if RTL is set to use a mission landing and mission has a planned landing, then use MISSION to fly there directly\n-\t\t\t\t\tif (on_mission_landing() && !get_land_detected()->landed) {\n+\t\t\t\t\tif (!rtl_activated && !_rtl.denyMissionLanding() && _rtl.getClimbAndReturnDone()\n+\t\t\t\t\t    && get_mission_start_land_available()) {\n \t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n+\n+\t\t\t\t\t\tif (!getMissionLandingInProgress() && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED\n+\t\t\t\t\t\t    && !get_land_detected()->landed) {\n+\t\t\t\t\t\t\tstart_mission_landing();\n+\t\t\t\t\t\t}\n+\n \t\t\t\t\t\tnavigation_mode_new = &_mission;\n \n \t\t\t\t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 54,
        "changes": 170,
        "patch": "@@ -47,6 +47,7 @@\n static constexpr float DELAY_SIGMA = 0.01f;\n \n using namespace time_literals;\n+using namespace math;\n \n RTL::RTL(Navigator *navigator) :\n \tMissionBlock(navigator),\n@@ -95,7 +96,7 @@ void RTL::find_RTL_destination()\n \tdouble dlat = home_landing_position.lat - global_position.lat;\n \tdouble dlon = home_landing_position.lon - global_position.lon;\n \n-\tdouble lon_scale = cos(math::radians(global_position.lat));\n+\tdouble lon_scale = cos(radians(global_position.lat));\n \n \tauto coord_dist_sq = [lon_scale](double lat_diff, double lon_diff) -> double {\n \t\tdouble lon_diff_scaled =  lon_scale * matrix::wrap(lon_diff, -180., 180.);\n@@ -106,10 +107,28 @@ void RTL::find_RTL_destination()\n \n \t_destination.type = RTL_DESTINATION_HOME;\n \n+\tconst bool vtol_in_rw_mode = _navigator->get_vstatus()->is_vtol\n+\t\t\t\t     && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n+\n+\n \t// consider the mission landing if not RTL_HOME type set\n \tif (rtl_type() != RTL_HOME && _navigator->get_mission_start_land_available()) {\n-\t\tdouble mission_landing_lat = _navigator->get_mission_landing_lat();\n-\t\tdouble mission_landing_lon = _navigator->get_mission_landing_lon();\n+\t\tdouble mission_landing_lat;\n+\t\tdouble mission_landing_lon;\n+\t\tfloat mission_landing_alt;\n+\t\tRTLDestinationType destination_type = RTL_DESTINATION_MISSION_LANDING;\n+\n+\t\tif (vtol_in_rw_mode) {\n+\t\t\tmission_landing_lat = _navigator->get_mission_landing_lat();\n+\t\t\tmission_landing_lon = _navigator->get_mission_landing_lon();\n+\t\t\tmission_landing_alt = _navigator->get_mission_landing_alt();\n+\t\t\tdestination_type = RTL_DESTINATION_HOME;\n+\n+\t\t} else {\n+\t\t\tmission_landing_lat = _navigator->get_mission_landing_start_lat();\n+\t\t\tmission_landing_lon = _navigator->get_mission_landing_start_lon();\n+\t\t\tmission_landing_alt = _navigator->get_mission_landing_start_alt();\n+\t\t}\n \n \t\t// compare home position to landing position to decide which is closer\n \t\tdlat = mission_landing_lat - global_position.lat;\n@@ -119,10 +138,11 @@ void RTL::find_RTL_destination()\n \t\t// set destination to mission landing if closest or in RTL_LAND or RTL_MISSION (so not in RTL_CLOSEST)\n \t\tif (dist_squared < min_dist_squared || rtl_type() != RTL_CLOSEST) {\n \t\t\tmin_dist_squared = dist_squared;\n-\t\t\t_destination.lat = _navigator->get_mission_landing_lat();\n-\t\t\t_destination.lon = _navigator->get_mission_landing_lon();\n-\t\t\t_destination.alt = _navigator->get_mission_landing_alt();\n-\t\t\t_destination.type = RTL_DESTINATION_MISSION_LANDING;\n+\t\t\t_destination.lat = mission_landing_lat;\n+\t\t\t_destination.lon = mission_landing_lon;\n+\t\t\t_destination.alt = mission_landing_alt;\n+\t\t\t_destination.type = destination_type;\n+\n \n \t\t}\n \t}\n@@ -197,6 +217,9 @@ void RTL::find_RTL_destination()\n void RTL::on_activation()\n {\n \n+\t_deny_mission_landing = _navigator->get_vstatus()->is_vtol\n+\t\t\t\t&& _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n+\n \t// output the correct message, depending on where the RTL destination is\n \tswitch (_destination.type) {\n \tcase RTL_DESTINATION_HOME:\n@@ -218,15 +241,20 @@ void RTL::on_activation()\n \t\t_rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n \n \t} else {\n-\t\t_rtl_alt = math::max(global_position.alt, _destination.alt + _param_rtl_return_alt.get());\n+\t\t_rtl_alt = max(global_position.alt, max(_destination.alt,\n+\t\t\t\t\t\t\t_navigator->get_home_position()->alt + _param_rtl_return_alt.get()));\n \t}\n \n+\n \tif (_navigator->get_land_detected()->landed) {\n \t\t// For safety reasons don't go into RTL if landed.\n \t\t_rtl_state = RTL_STATE_LANDED;\n \n-\t} else if ((_destination.type == RTL_DESTINATION_MISSION_LANDING) && _navigator->on_mission_landing()) {\n-\t\t// RTL straight to RETURN state, but mission will takeover for landing.\n+\t} else if ((_destination.type == RTL_DESTINATION_MISSION_LANDING) && _navigator->getMissionLandingInProgress()) {\n+\t\t// we were just on a mission landing, set _rtl_state past RTL_STATE_RETURN such that navigator will engage mission mode,\n+\t\t// which will continue executing the landing\n+\t\t_rtl_state = RTL_STATE_DESCEND;\n+\n \n \t} else if ((global_position.alt < _destination.alt + _param_rtl_return_alt.get()) || _rtl_alt_min) {\n \n@@ -239,7 +267,10 @@ void RTL::on_activation()\n \t\t_rtl_state = RTL_STATE_RETURN;\n \t}\n \n+\tsetClimbAndReturnDone(_rtl_state > RTL_STATE_RETURN);\n+\n \tset_rtl_item();\n+\n }\n \n void RTL::on_active()\n@@ -263,7 +294,7 @@ void RTL::set_rtl_item()\n \t// Landing using planned mission landing, fly to DO_LAND_START instead of returning _destination.\n \t// After reaching DO_LAND_START, do nothing, let navigator takeover with mission landing.\n \tif (_destination.type == RTL_DESTINATION_MISSION_LANDING) {\n-\t\tif (_rtl_state > RTL_STATE_CLIMB) {\n+\t\tif (_rtl_state > RTL_STATE_RETURN) {\n \t\t\tif (_navigator->start_mission_landing()) {\n \t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: using mission landing\");\n \t\t\t\treturn;\n@@ -281,16 +312,22 @@ void RTL::set_rtl_item()\n \n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t// Check if we are pretty close to the destination already.\n \tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon, gpos.lat, gpos.lon);\n-\n-\t// Compute the loiter altitude.\n-\tconst float loiter_altitude = math::min(_destination.alt + _param_rtl_descend_alt.get(), gpos.alt);\n+\tconst float descend_altitude_target = min(_destination.alt + _param_rtl_descend_alt.get(), gpos.alt);\n+\tconst float loiter_altitude = min(descend_altitude_target, _rtl_alt);\n \n \tswitch (_rtl_state) {\n \tcase RTL_STATE_CLIMB: {\n \n-\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t// do not use LOITER_TO_ALT for rotary wing mode as it would then always climb to at least MIS_LTRMIN_ALT,\n+\t\t\t// even if current climb altitude is below (e.g. RTL immediately after take off)\n+\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\n+\t\t\t} else {\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n+\t\t\t}\n+\n \t\t\t_mission_item.lat = gpos.lat;\n \t\t\t_mission_item.lon = gpos.lon;\n \t\t\t_mission_item.altitude = _rtl_alt;\n@@ -307,7 +344,6 @@ void RTL::set_rtl_item()\n \t\t}\n \n \tcase RTL_STATE_RETURN: {\n-\n \t\t\t// Don't change altitude.\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.lat = _destination.lat;\n@@ -341,8 +377,21 @@ void RTL::set_rtl_item()\n \t\t\tbreak;\n \t\t}\n \n-\tcase RTL_STATE_DESCEND: {\n+\tcase RTL_MOVE_TO_LAND_HOVER_VTOL: {\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n+\t\t\t_mission_item.lat = _destination.lat;\n+\t\t\t_mission_item.lon = _destination.lon;\n+\t\t\t_mission_item.altitude = loiter_altitude;\n+\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n+\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n+\t\t\tbreak;\n+\t\t}\n+\n+\tcase RTL_STATE_DESCEND: {\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n+\n \t\t\t_mission_item.lat = _destination.lat;\n \t\t\t_mission_item.lon = _destination.lon;\n \t\t\t_mission_item.altitude = loiter_altitude;\n@@ -382,13 +431,13 @@ void RTL::set_rtl_item()\n \t\t\t_mission_item.yaw = _destination.yaw;\n \t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n \t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n-\t\t\t_mission_item.time_inside = math::max(_param_rtl_land_delay.get(), 0.0f);\n+\t\t\t_mission_item.time_inside = max(_param_rtl_land_delay.get(), 0.0f);\n \t\t\t_mission_item.autocontinue = autoland;\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n \t\t\t_navigator->set_can_loiter_at_sp(true);\n \n-\t\t\tif (autoland && (get_time_inside(_mission_item) > FLT_EPSILON)) {\n+\t\t\tif (autoland) {\n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n \t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: loiter %.1fs\",\n \t\t\t\t\t\t (double)get_time_inside(_mission_item));\n@@ -455,36 +504,56 @@ void RTL::set_rtl_item()\n \n void RTL::advance_rtl()\n {\n+\t// determines if the vehicle should loiter above land\n+\tconst bool descend_and_loiter = _param_rtl_land_delay.get() < -DELAY_SIGMA || _param_rtl_land_delay.get() > DELAY_SIGMA;\n+\n+\t// vehicle is a vtol and currently in fixed wing mode\n+\tconst bool vtol_in_fw_mode = _navigator->get_vstatus()->is_vtol\n+\t\t\t\t     && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n+\n+\n \tswitch (_rtl_state) {\n \tcase RTL_STATE_CLIMB:\n \t\t_rtl_state = RTL_STATE_RETURN;\n \t\tbreak;\n \n \tcase RTL_STATE_RETURN:\n+\t\tsetClimbAndReturnDone(true);\n \n-\t\t// Descend to desired altitude if delay is set, directly land otherwise\n-\t\tif (_param_rtl_land_delay.get() < -DELAY_SIGMA || _param_rtl_land_delay.get() > DELAY_SIGMA) {\n+\t\tif (vtol_in_fw_mode || descend_and_loiter) {\n \t\t\t_rtl_state = RTL_STATE_DESCEND;\n \n \t\t} else {\n \t\t\t_rtl_state = RTL_STATE_LAND;\n \t\t}\n \n-\t\tif (_navigator->get_vstatus()->is_vtol\n-\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n-\t\t\t_rtl_state = RTL_STATE_TRANSITION_TO_MC;\n-\t\t}\n-\n \t\tbreak;\n \n+\n \tcase RTL_STATE_TRANSITION_TO_MC:\n-\t\t_rtl_state = RTL_STATE_RETURN;\n+\n+\t\t_rtl_state = RTL_MOVE_TO_LAND_HOVER_VTOL;\n+\n+\t\tbreak;\n+\n+\tcase RTL_MOVE_TO_LAND_HOVER_VTOL:\n+\n+\t\tif (descend_and_loiter) {\n+\t\t\t_rtl_state = RTL_STATE_LOITER;\n+\n+\t\t} else {\n+\t\t\t_rtl_state = RTL_STATE_LAND;\n+\t\t}\n+\n \t\tbreak;\n \n \tcase RTL_STATE_DESCEND:\n \n-\t\t// Only go to land if autoland is enabled.\n-\t\tif (_param_rtl_land_delay.get() < -DELAY_SIGMA || _param_rtl_land_delay.get() > DELAY_SIGMA) {\n+\t\t// If the vehicle is a vtol in fixed wing mode, then first transition to hover\n+\t\tif (vtol_in_fw_mode) {\n+\t\t\t_rtl_state = RTL_STATE_TRANSITION_TO_MC;\n+\n+\t\t} else if (descend_and_loiter) {\n \t\t\t_rtl_state = RTL_STATE_LOITER;\n \n \t\t} else {\n@@ -513,39 +582,32 @@ float RTL::calculate_return_alt_from_cone_half_angle(float cone_half_angle_deg)\n \t// horizontal distance to destination\n \tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon, gpos.lat, gpos.lon);\n \n-\tfloat rtl_altitude;\n+\t// minium rtl altitude to use when outside of horizontal acceptance radius of target position.\n+\t// We choose the minimum height to be two times the distance from the land position in order to\n+\t// avoid the vehicle touching the ground while still moving horizontally.\n+\tconst float return_altitude_min_outside_acceptance_rad_amsl = _destination.alt + 2.0f *\n+\t\t\t_navigator->get_acceptance_radius();\n \n-\tif (destination_dist <= _param_rtl_min_dist.get()) {\n-\t\trtl_altitude = _destination.alt + _param_rtl_descend_alt.get();\n+\tfloat return_altitude_amsl = _destination.alt + _param_rtl_return_alt.get();\n \n-\t} else if (gpos.alt > _destination.alt + _param_rtl_return_alt.get() || cone_half_angle_deg >= 90.0f) {\n-\t\trtl_altitude = gpos.alt;\n-\n-\t} else if (cone_half_angle_deg <= 0) {\n-\t\trtl_altitude = _destination.alt + _param_rtl_return_alt.get();\n+\tif (destination_dist <= _navigator->get_acceptance_radius()) {\n+\t\treturn_altitude_amsl = _destination.alt + 2.0f * destination_dist;\n \n \t} else {\n \n-\t\t// constrain cone half angle to meaningful values. All other cases are already handled above.\n-\t\tconst float cone_half_angle_rad = math::radians(math::constrain(cone_half_angle_deg, 1.0f, 89.0f));\n-\n-\t\t// minimum height above destination required\n-\t\tfloat height_above_destination_min = destination_dist / tanf(cone_half_angle_rad);\n+\t\tif (cone_half_angle_deg > 0.0f && destination_dist <= _param_rtl_min_dist.get()) {\n \n-\t\t// minimum altitude we need in order to be within the user defined cone\n-\t\tconst float altitude_min = math::constrain(height_above_destination_min + _destination.alt, _destination.alt,\n-\t\t\t\t\t   _destination.alt + _param_rtl_return_alt.get());\n+\t\t\t// constrain cone half angle to meaningful values. All other cases are already handled above.\n+\t\t\tconst float cone_half_angle_rad = radians(constrain(cone_half_angle_deg, 1.0f, 89.0f));\n \n-\t\tif (gpos.alt < altitude_min) {\n-\t\t\trtl_altitude = altitude_min;\n+\t\t\t// minimum altitude we need in order to be within the user defined cone\n+\t\t\tconst float cone_intersection_altitude_amsl = destination_dist / tanf(cone_half_angle_rad) + _destination.alt;\n \n-\t\t} else {\n-\t\t\trtl_altitude = gpos.alt;\n+\t\t\treturn_altitude_amsl = min(cone_intersection_altitude_amsl, return_altitude_amsl);\n \t\t}\n-\t}\n \n-\t// always demand altitude which is higher or equal the RTL descend altitude\n-\trtl_altitude = math::max(rtl_altitude, _destination.alt + _param_rtl_descend_alt.get());\n+\t\treturn_altitude_amsl = max(return_altitude_amsl, return_altitude_min_outside_acceptance_rad_amsl);\n+\t}\n \n-\treturn rtl_altitude;\n+\treturn max(return_altitude_amsl, gpos.alt);\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "patch": "@@ -83,6 +83,12 @@ class RTL : public MissionBlock, public ModuleParams\n \n \tint rtl_destination();\n \n+\tvoid setClimbAndReturnDone(bool done) { _climb_and_return_done = done; }\n+\n+\tbool getClimbAndReturnDone() { return _climb_and_return_done; }\n+\n+\tbool denyMissionLanding() { return _deny_mission_landing; }\n+\n private:\n \t/**\n \t * Set the RTL item\n@@ -104,6 +110,7 @@ class RTL : public MissionBlock, public ModuleParams\n \t\tRTL_STATE_TRANSITION_TO_MC,\n \t\tRTL_STATE_DESCEND,\n \t\tRTL_STATE_LOITER,\n+\t\tRTL_MOVE_TO_LAND_HOVER_VTOL,\n \t\tRTL_STATE_LAND,\n \t\tRTL_STATE_LANDED,\n \t} _rtl_state{RTL_STATE_NONE};\n@@ -133,6 +140,8 @@ class RTL : public MissionBlock, public ModuleParams\n \n \tfloat _rtl_alt{0.0f};\t// AMSL altitude at which the vehicle should return to the home position\n \tbool _rtl_alt_min{false};\n+\tbool _climb_and_return_done{false};\t// this flag is set to true if RTL is active and we are past the climb state and return state\n+\tbool _deny_mission_landing{false};\n \n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::RTL_RETURN_ALT>) _param_rtl_return_alt,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "patch": "@@ -90,10 +90,11 @@ PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n PARAM_DEFINE_FLOAT(RTL_LAND_DELAY, -1.0f);\n \n /**\n- * Maximum horizontal distance from return destination, below which RTL_DESCEND_ALT is used as return altitude\n+ * Horizontal radius from return point within which special rules for return mode apply.\n+ *\n+ * The return altitude will be calculated based on RTL_CONE_ANG parameter.\n+ * The yaw setpoint will switch to the one defined by corresponding waypoint.\n  *\n- * If the vehicle is less than this horizontal distance from the return destination when return mode is activated it will ascend\n- * to RTL_DESCEND_ALT for the return journey (rather than the altitude set by RTL_RETURN_ALT and RTL_CONE_ANG).\n  *\n  * @unit m\n  * @min 0.5\n@@ -102,7 +103,7 @@ PARAM_DEFINE_FLOAT(RTL_LAND_DELAY, -1.0f);\n  * @increment 0.5\n  * @group Return Mode\n  */\n-PARAM_DEFINE_FLOAT(RTL_MIN_DIST, 5.0f);\n+PARAM_DEFINE_FLOAT(RTL_MIN_DIST, 10.0f);\n \n /**\n  * Return type\n@@ -134,7 +135,7 @@ PARAM_DEFINE_INT32(RTL_TYPE, 0);\n  * @value 90 Only climb to at least RTL_DESCEND_ALT above destination.\n  * @group Return Mode\n  */\n-PARAM_DEFINE_INT32(RTL_CONE_ANG, 0);\n+PARAM_DEFINE_INT32(RTL_CONE_ANG, 45);\n \n /**\n  * RTL precision land mode",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0bc54f2eb288cba6d9df77af42116a91b70e5cf0/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "math::min",
        "landing",
        "Mission::on_inactive",
        "journey",
        "Navigator::run",
        "RTL::calculate_return_alt_from_cone_half_angle",
        "Mission::find_mission_land_start",
        "Mission::set_mission_item_reached",
        "math::constrain",
        "math::max",
        "math::radians",
        "RTL::on_activation",
        "RTL::find_RTL_destination",
        "Mission::set_mission_items",
        "Mission::on_inactivation"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "landing",
          "Mission::on_inactive",
          "Mission::find_mission_land_start",
          "Mission::set_mission_item_reached",
          "Mission::set_mission_items",
          "Mission::on_inactivation"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item",
          "math::min",
          "RTL::calculate_return_alt_from_cone_half_angle",
          "math::constrain",
          "math::max",
          "RTL::on_activation",
          "RTL::find_RTL_destination",
          "math::radians"
        ],
        "src/modules/navigator/rtl_params.c": [
          "journey"
        ]
      }
    }
  },
  {
    "title": "Fix FOH effects after VTOL front transition",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16373",
    "number": 16373,
    "created_at": "2020-12-11T06:53:01Z",
    "merged": true,
    "merged_at": "2021-01-02T01:19:00Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "This caused the navigator to use the next waypoint (after the vtol takeoff item)\r\nto be used as target during the transition. If the altitude of that waypoint\r\nwas much higher than the takeoff altitude then there were FOH effects\r\nafter the transition which caused the vehicle to first descend before\r\nclimbing again.\r\n\r\nSigned-off-by: RomanBapst <bapstroman@gmail.com>\r\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2020-12-11T07:05:15Z",
          "body": "TECS altitude setpoint with this PR:\r\n![image](https://user-images.githubusercontent.com/7610489/101873586-409c8780-3b98-11eb-9759-f49dfec67f8f.png)\r\n\r\nTECS altitude setpoint without this PR:\r\n![image](https://user-images.githubusercontent.com/7610489/101873627-5742de80-3b98-11eb-98fe-b42bf337fe61.png)\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-11T15:01:00Z",
          "body": "You don't ever want to use the next item for transition? The altitude could be adjusted in the next item.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-02T01:19:41Z",
          "body": "You want to keep level during transition. The plot shows that the system is then gaining altitude on the way to the next waypoint.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-02T01:34:38Z",
          "body": "> You want to keep level during transition. The plot shows that the system is then gaining altitude on the way to the next waypoint.\r\n\r\nI know, I was talking about transition towards the next waypoint while keeping the vehicle level. Some people use this to control the direction of VTOL transition. ",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-02T12:58:22Z",
          "body": "We need to get to a point where we set a heading and then let the vehicle transition on that heading. Otherwise we can run into crazy corner cases where someone sets a waypoint 90 degrees to the right or left and then complains that it's \"unstable\" or \"jerky\". So I would consider the transition atomic, configured beforehand and the vehicle comes back onto trajectory control at the end of it. You will need to set the transition up correctly and then let it execute.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-01-02T17:16:23Z",
          "body": "I agree with that I'd just like to see these types of potential behaviour changes (eg transition heading alignment) addressed explicitly rather than something that slipped in as a byproduct of fixing something else (FOH altitude effects) with no mention.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect transition logic where the navigator used the next waypoint as the target during a VTOL front transition, causing unintended FOH altitude setpoint behaviour (a descent before climb). This is a state/target-selection bug (improper state transition/data flow) that produced undesired runtime behavior rather than a crash, so it is a logic error.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 10,
        "changes": 13,
        "patch": "@@ -798,17 +798,10 @@ Mission::set_mission_items()\n \t\t\t\t\t}\n \n \t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n+\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n \n-\t\t\t\t\tif (has_next_position_item) {\n-\t\t\t\t\t\t/* got next mission item, update setpoint triplet */\n-\t\t\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n-\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n-\n-\t\t\t\t\t\t/* set position setpoint to target during the transition */\n-\t\t\t\t\t\tgenerate_waypoint_from_heading(&pos_sp_triplet->current, _mission_item.yaw);\n-\t\t\t\t\t}\n+\t\t\t\t\t/* set position setpoint to target during the transition */\n+\t\t\t\t\tgenerate_waypoint_from_heading(&pos_sp_triplet->current, _mission_item.yaw);\n \t\t\t\t}\n \n \t\t\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/66f05b21a544ef4bad329a41b39eae2fe649270a/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ]
      }
    }
  },
  {
    "title": "navigator: fix LOITER_TO_ALT",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16371",
    "number": 16371,
    "created_at": "2020-12-10T18:53:31Z",
    "merged": true,
    "merged_at": "2020-12-11T15:28:09Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": " - this was overzealously removed in https://github.com/PX4/PX4-Autopilot/pull/15677\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "Looks good to me and works in SITL.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and description indicate it restores behavior that was mistakenly removed, and the reviewer confirms it fixes behavior in SITL. This is a correction to navigator state/behavior (LOITER_TO_ALT), i.e. a logic-level bug rather than a syntax/style change.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 7,
        "changes": 45,
        "patch": "@@ -211,11 +211,33 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t_time_first_inside_orbit = 0;\n \t\t\t}\n \n-\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n-\t\t\t   (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT)) {\n+\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n \n-\t\t\tif (dist >= 0.f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n-\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n+\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter\n+\t\t\t//  first check if the altitude setpoint is the mission setpoint\n+\t\t\tposition_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n+\n+\t\t\tif (fabsf(curr_sp->alt - altitude_amsl) >= FLT_EPSILON) {\n+\t\t\t\t// check if the initial loiter has been accepted\n+\t\t\t\tdist_xy = -1.0f;\n+\t\t\t\tdist_z = -1.0f;\n+\n+\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n+\t\t\t\t\t\t_navigator->get_global_position()->lat,\n+\t\t\t\t\t\t_navigator->get_global_position()->lon,\n+\t\t\t\t\t\t_navigator->get_global_position()->alt,\n+\t\t\t\t\t\t&dist_xy, &dist_z);\n+\n+\t\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\t\t    && dist_z <= _navigator->get_default_altitude_acceptance_radius()) {\n+\n+\t\t\t\t\t// now set the loiter to the final altitude in the NAV_CMD_LOITER_TO_ALT mission item\n+\t\t\t\t\tcurr_sp->alt = altitude_amsl;\n+\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t\t\t}\n+\n+\t\t\t} else if (dist >= 0.f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \n \t\t\t\t_waypoint_position_reached = true;\n \n@@ -563,13 +585,22 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n \t\tbreak;\n \n+\tcase NAV_CMD_LOITER_TO_ALT:\n+\n+\t\t// initially use current altitude, and switch to mission item altitude once in loiter position\n+\t\tif (_navigator->get_loiter_min_alt() > 0.f) { // ignore _param_loiter_min_alt if smaller than 0 (-1)\n+\t\t\tsp->alt = math::max(_navigator->get_global_position()->alt,\n+\t\t\t\t\t    _navigator->get_home_position()->alt + _navigator->get_loiter_min_alt());\n+\n+\t\t} else {\n+\t\t\tsp->alt = _navigator->get_global_position()->alt;\n+\t\t}\n+\n+\t// fall through\n \tcase NAV_CMD_LOITER_TIME_LIMIT:\n \n \t// FALLTHROUGH\n \tcase NAV_CMD_LOITER_UNLIMITED:\n-\n-\t// FALLTHROUGH\n-\tcase NAV_CMD_LOITER_TO_ALT:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\tbreak;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c005546e28dabf21dd8bc350b1eed53b3150a35c/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "Fix Return issue to landing pattern",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16352",
    "number": 16352,
    "created_at": "2020-12-08T17:38:36Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "moreba1",
      "body": "fix this issue:\r\nhttps://github.com/PX4/PX4-Autopilot/issues/16299\r\n\r\nwhen we have \"land start\" after a survey drone can not return to landing pattern.\r\n\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2020-12-08T22:44:05Z",
          "body": "I don't quite follow. Did you see within the if statement it's accessing missionitem_prev.lat, etc? What is the missionitem_prev in your case?",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2020-12-09T06:43:28Z",
          "body": "missionitem_prev is MAV_CMD_DO_SET_CAM_TRIGG_DIST 0 . (take photos distance 0 in QGC)",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-12-15T14:56:52Z",
          "body": "Can you share your mission (image or .mission file)? `DO_LAND_START` is only a marker, it needs to have a position waypoint before it.",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2020-12-16T05:16:42Z",
          "body": "https://docs.qgroundcontrol.com/master/en/PlanView/pattern_fixed_wing_landing.html\r\nfor fixedwing:\r\nThis pattern creates three mission items:\r\n    DO_LAND_START - If you abort a landing it sends DO_GO_AROUND to the vehicle, which then causes the mission to return to this point and try to land again.\r\n    NAV_LOITER_TO_ALT - Start point for landing\r\n    NAV_LAND - End point for landing\r\n",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2020-12-18T18:30:57Z",
          "body": "created by daily build QGC version :\r\n[plan.zip](https://github.com/PX4/PX4-Autopilot/files/5717482/plan.zip)\r\n",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2021-01-01T06:54:06Z",
          "body": "> Can you share your mission (image or .mission file)? `DO_LAND_START` is only a marker, it needs to have a position waypoint before it.\r\n\r\nIf this pull request merged, the landing pattern doesn't need to waypoint before DO_LAND_START. \r\n@DonLakeFlyer what is your opinion?",
          "type": "issue_comment"
        },
        {
          "author": "DonLakeFlyer",
          "created_at": "2021-01-01T19:05:54Z",
          "body": "Seems pretty broken to me. DO_LAND_START should work wherever you place it and whatever is in front of it in mission commands.",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2021-01-01T19:16:46Z",
          "body": "> Can you share your mission (image or .mission file)? `DO_LAND_START` is only a marker, it needs to have a position waypoint before it.\r\n\r\nwhy does it need a position waypoint BEFORE it?  It's the position waypoint(s) AFTER the Do_Land_Start that is import.",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2021-01-29T11:28:28Z",
          "body": "can this PR be reviewed?\r\n@dagar  @sfuhrer ",
          "type": "issue_comment"
        },
        {
          "author": "moreba1",
          "created_at": "2021-01-31T20:09:46Z",
          "body": "fixed here https://github.com/PX4/PX4-Autopilot/commit/12875f7869ac547116119ba0fcad7fe3251ae27a",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the problem described is a logic error: the code assumed the mission item before DO_LAND_START was a position waypoint and accessed missionitem_prev.lat/lon, but in some missions that previous item can be a nonâ€‘position command (e.g. DO_SET_CAM_TRIGG_DIST). That incorrect assumption leads to wrong behavior (unable to return to the landing pattern). The PR addresses this incorrect state/assumption and thus fixes the logic bug.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -388,7 +388,7 @@ Mission::find_mission_land_start()\n \t\t}\n \n \t\t// first check for DO_LAND_START marker\n-\t\tif ((missionitem.nav_cmd == NAV_CMD_DO_LAND_START) && (missionitem_prev.nav_cmd == NAV_CMD_WAYPOINT)) {\n+\t\tif (missionitem.nav_cmd == NAV_CMD_DO_LAND_START) {\n \n \t\t\t_land_start_available = true;\n \t\t\t_land_start_index = i;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/55517bf853c5646c9502faa3f8bd066c1008ba19/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::find_mission_land_start"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::find_mission_land_start"
        ]
      }
    }
  },
  {
    "title": "reenable WV after Front Transition alignment",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16335",
    "number": 16335,
    "created_at": "2020-12-04T17:00:58Z",
    "merged": true,
    "merged_at": "2020-12-09T16:36:21Z",
    "state": "closed",
    "conversation": {
      "author": "ThomasRigi",
      "body": "**Describe problem solved by this pull request**\r\nFixes https://github.com/PX4/PX4-Autopilot/issues/16305\r\n\r\n@sfuhrer @dagar \r\n\r\n**Describe your solution**\r\nReenable Weathervane after front transition alignment also for VTOL Transition item.\r\n\r\n**Describe possible alternatives**\r\n\r\n\r\n**Test data / coverage**\r\nSITL gazebo standard vtol: https://logs.px4.io/plot_app?log=7fa8edf3-84bc-4c9b-918b-a16c53b8d2b0\r\n\r\n**Additional context**\r\n",
      "issue_comments": [
        {
          "author": "xdwgood",
          "created_at": "2020-12-10T01:08:18Z",
          "body": "I think v1.11 also need this",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "",
          "body": "That makes sense to me, thanks!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR restores re-enabling of the Weathervane (WV) after front-transition alignment for VTOL transitions â€” an incorrect state handling/conditional that left WV disabled and produced undesired behavior. This is a logic error (improper state transition/flow) and the change corrects that program logic.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -999,6 +999,9 @@ Mission::set_mission_items()\n \n \t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \n+\t\t\t\t\t/* re-enable weather vane again after alignment */\n+\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n+\n \t\t\t\t\t/* set position setpoint to target during the transition */\n \t\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n \t\t\t\t\tgenerate_waypoint_from_heading(&pos_sp_triplet->current, pos_sp_triplet->current.yaw);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ffb3799d4bd0e5e6cd518a81fb4076df3ede259a/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ]
      }
    }
  },
  {
    "title": "Handle takeoff waypoints for rover",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16297",
    "number": 16297,
    "created_at": "2020-11-28T15:45:06Z",
    "merged": true,
    "merged_at": "2020-11-28T23:08:54Z",
    "state": "closed",
    "conversation": {
      "author": "Jaeyoung-Lim",
      "body": "**Describe problem solved by this pull request**\r\nPreviously, rover vehicles were not able to handle Takeoff waypoints. The behavior when a takeoff waypoint was passed to a rover vehicle was:\r\n- The vehicle would not move since the waypoint was too close\r\n- The takeoff waypoint would not get accepted since rovers are not able to climb and reach the altitude\r\n\r\nI think it might be obvious that one \"should not\" pass takeoff waypoints to a vehicle. However, QGroundControl only lets you plan a mission that starts with a takeoff waypoint. While this should also be an improvement on the QGC side, I think it is still useful to handle this case on the vehicle side so that the vehicle can still progress with the mission even with a takeoff waypoint\r\n\r\n**Describe your solution**\r\nThis adds a special case when handling takeoff waypoints for rover vehicles. The acceptance radius is set to only consider horizontal distance to the waypoint, if the vehicle type is rover.\r\n\r\n**Test data / coverage**\r\n- This was tested in SITL gazebo, with the rover model.\r\n```\r\nmake px4_sitl gazebo_rover\r\n```\r\nThis log shows a full mission successfully finished starting with a Takeoff waypoint and finished with a RTL: https://review.px4.io/plot_app?log=25fe983b-44d0-4a11-a7c2-2ab9662c35d4\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "I see value in this as I expect that the notion of \"known good initial starting position\" does matter for a rover as well. E.g. I could see that in real applications you don't want a rover to drive with its cruise speed from the parking position to the starting position (== too fast if it's moving near people).",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic bug in mission waypoint handling: rovers were failing to accept or move to takeoff waypoints because the acceptance check considered altitude (3D) even though rovers cannot climb. The change special-cases rovers to use horizontal distance for acceptance, correcting the improper conditional/behavior so missions can progress as intended.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -174,6 +174,13 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \n+\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n+\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n+\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n+\t\t\t\t_waypoint_position_reached = true;\n+\t\t\t}\n+\n \t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n \t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n \t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9a51ac7ed0bbe627f8deeba834073299f3c698e6/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "Modify the method of follow_target.cpp to calculate the expected speed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16255",
    "number": 16255,
    "created_at": "2020-11-22T14:29:07Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "fanchuannangang1503",
      "body": "If the frequency of sending follow_target orb messages is very high, the dt_ms variable will be a short time, and dt_ms/INTERPOLATION_PNTS will be less than the execution cycle of the FollowTarget::on_active() function, so the actual acceleration will be very slow.\r\n",
      "issue_comments": [
        {
          "author": "mrpollo",
          "created_at": "2021-02-15T18:35:56Z",
          "body": "Hey @fanchuannangang1503 thanks for your suggestion, it looks like you have problems with code formatting, please see my suggestion below on how to fix this. Additionally please rebase this PR since it might be falling behind our main branch.\r\n\r\ncan you please fix the code formatting issues?  Try the following helper and push your changes again. This will clean up your code using `astyle`, and will make the first CI test happy!\r\n\r\n```\r\nmake format\r\n```\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "fanchuannangang1503",
          "created_at": "2021-02-18T12:51:52Z",
          "body": "OK",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2021-06-26T03:10:44Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses an incorrect acceleration/speed calculation when follow_target messages arrive at high frequency. Dividing dt_ms by INTERPOLATION_PNTS can produce a per-step interval shorter than the FollowTarget::on_active() execution cycle, causing too-small acceleration increments (a timing/boundary logic error), and the change adjusts the expected-speed computation to correct that behavior.",
    "patches": {
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 12,
        "changes": 21,
        "patch": "@@ -65,7 +65,7 @@ FollowTarget::FollowTarget(Navigator *navigator) :\n \tModuleParams(navigator)\n {\n \t_current_vel.zero();\n-\t_step_vel.zero();\n+\t_acceleration.zero();\n \t_est_target_vel.zero();\n \t_target_distance.zero();\n \t_target_position_offset.zero();\n@@ -177,9 +177,8 @@ void FollowTarget::on_active()\n \t\t\t// just traveling at the exact velocity of the target will not\n \t\t\t// get any closer or farther from the target\n \n-\t\t\t_step_vel = (_est_target_vel - _current_vel) + (_target_position_offset + _target_distance) * FF_K;\n-\t\t\t_step_vel /= (dt_ms / 1000.0F * (float) INTERPOLATION_PNTS);\n-\t\t\t_step_time_in_ms = (dt_ms / (float) INTERPOLATION_PNTS);\n+\t\t\t_acceleration = (_est_target_vel - _current_vel) + (_target_position_offset + _target_distance) * FF_K;\n+\t\t\t_acceleration /= (dt_ms / 1000.0F);\n \n \t\t\t// if we are less than 1 meter from the target don't worry about trying to yaw\n \t\t\t// lock the yaw until we are at a distance that makes sense\n@@ -203,9 +202,9 @@ void FollowTarget::on_active()\n \t\t\t}\n \t\t}\n \n-//\t\twarnx(\" _step_vel x %3.6f y %3.6f cur vel %3.6f %3.6f tar vel %3.6f %3.6f dist = %3.6f (%3.6f) mode = %d yaw rate = %3.6f\",\n-//\t\t\t\t(double) _step_vel(0),\n-//\t\t\t\t(double) _step_vel(1),\n+//\t\twarnx(\" _acceleration x %3.6f y %3.6f cur vel %3.6f %3.6f tar vel %3.6f %3.6f dist = %3.6f (%3.6f) mode = %d yaw rate = %3.6f\",\n+//\t\t\t\t(double) _acceleration(0),\n+//\t\t\t\t(double) _acceleration(1),\n //\t\t\t\t(double) _current_vel(0),\n //\t\t\t\t(double) _current_vel(1),\n //\t\t\t\t(double) _est_target_vel(0),\n@@ -264,10 +263,8 @@ void FollowTarget::on_active()\n \n \t\t\t} else if (target_velocity_valid()) {\n \n-\t\t\t\tif ((float)(current_time - _last_update_time) / 1000.0f >= _step_time_in_ms) {\n-\t\t\t\t\t_current_vel += _step_vel;\n-\t\t\t\t\t_last_update_time = current_time;\n-\t\t\t\t}\n+\t\t\t\t_current_vel += _acceleration*((float)(current_time - _last_update_time) / 1000000.0f);\n+\t\t\t\t_last_update_time = current_time;\n \n \t\t\t\tset_follow_target_item(&_mission_item, _param_nav_min_ft_ht.get(), target_motion_with_offset, _yaw_angle);\n \n@@ -344,7 +341,7 @@ void FollowTarget::reset_target_validity()\n \t_current_target_motion = {};\n \t_target_updates = 0;\n \t_current_vel.zero();\n-\t_step_vel.zero();\n+\t_acceleration.zero();\n \t_est_target_vel.zero();\n \t_target_distance.zero();\n \t_target_position_offset.zero();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/dfa0ac21e3d23a1c7af1f61523cd5389327a2a04/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/follow_target.h": {
        "filename": "src/modules/navigator/follow_target.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "patch": "@@ -65,7 +65,6 @@ class FollowTarget : public MissionBlock, public ModuleParams\n \n \tstatic constexpr int TARGET_TIMEOUT_MS = 2500;\n \tstatic constexpr int TARGET_ACCEPTANCE_RADIUS_M = 5;\n-\tstatic constexpr int INTERPOLATION_PNTS = 20;\n \tstatic constexpr float FF_K = .25F;\n \tstatic constexpr float OFFSET_M = 8;\n \n@@ -101,14 +100,13 @@ class FollowTarget : public MissionBlock, public ModuleParams\n \tint _follow_target_position{FOLLOW_FROM_BEHIND};\n \n \tuORB::Subscription _follow_target_sub{ORB_ID(follow_target)};\n-\tfloat _step_time_in_ms{0.0f};\n \tfloat _follow_offset{OFFSET_M};\n \n \tuint64_t _target_updates{0};\n \tuint64_t _last_update_time{0};\n \n \tmatrix::Vector3f _current_vel;\n-\tmatrix::Vector3f _step_vel;\n+\tmatrix::Vector3f _acceleration;\n \tmatrix::Vector3f _est_target_vel;\n \tmatrix::Vector3f _target_distance;\n \tmatrix::Vector3f _target_position_offset;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/dfa0ac21e3d23a1c7af1f61523cd5389327a2a04/src%2Fmodules%2Fnavigator%2Ffollow_target.h"
      }
    },
    "modified_functions": {
      "all": [
        "FollowTarget::on_active",
        "FollowTarget::reset_target_validity",
        "FollowTarget::FollowTarget"
      ],
      "by_file": {
        "src/modules/navigator/follow_target.cpp": [
          "FollowTarget::on_active",
          "FollowTarget::reset_target_validity",
          "FollowTarget::FollowTarget"
        ]
      }
    }
  },
  {
    "title": "v1.11.2 cherry-picked bug fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/16175",
    "number": 16175,
    "created_at": "2020-11-12T16:50:17Z",
    "merged": true,
    "merged_at": "2020-11-12T17:57:28Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR title only says 'cherry-picked bug fixes' with no description, diffs, or review comments. While it likely includes bug fixes, there is no information to determine whether those fixes address logic errors (could be docs, tests, or non-logic bugs), so I cannot confirm this is fixing a logic error.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -76,6 +76,10 @@ void RTL::find_RTL_destination()\n \t\treturn;\n \t}\n \n+\tif (!_navigator->home_position_valid()) {\n+\t\treturn;\n+\t}\n+\n \t_destination_check_time = hrt_absolute_time();\n \n \t// get home position:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2fa7fbd2baa56683dae0c64b653c517d17957720/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::find_RTL_destination"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::find_RTL_destination"
        ]
      }
    }
  },
  {
    "title": "Geofence",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17362",
    "number": 17362,
    "created_at": "2021-04-08T12:15:33Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "garfieldG",
      "body": "Hi,\r\n\r\nfollowing https://github.com/PX4/PX4-Autopilot/issues/16679 some changes were made :\r\n-fixed bug that caused a breach of geofence if trying to go above the geofence more than one time\r\n-gf alert will disappear when changing gf action to none\r\n-mission will be accepted if gf action is none or warning",
      "issue_comments": [
        {
          "author": "garfieldG",
          "created_at": "2021-04-11T13:52:40Z",
          "body": "changed to draft due to a bug I found. I Will change it back after fixing it",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2023-11-28T12:17:49Z",
          "body": "Hi @garfieldG can you check if your changes are still needed with https://github.com/PX4/PX4-Autopilot/pull/22394?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR description explicitly states fixes for incorrect geofence behavior (preventing a breach when re-attempting to go above the geofence), alert state handling, and mission acceptance logic. These are behavioral/state issues (incorrect condition/state transitions and acceptance logic), which match the definition of logic errors.",
    "patches": {
      "src/modules/navigator/GeofenceBreachAvoidance/GeofenceBreachAvoidanceTest.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/GeofenceBreachAvoidanceTest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -218,6 +218,8 @@ TEST_F(GeofenceBreachAvoidanceTest, generateLoiterAltitudeForFixedWing)\n \tEXPECT_EQ(loiter_alt, current_alt_amsl);\n }\n \n+/*\n+ * changes made on generateLoiterAltitudeForMulticopter(). Removed this test for now\n TEST_F(GeofenceBreachAvoidanceTest, generateLoiterAltitudeForMulticopter)\n {\n \tGeofenceBreachAvoidance gf_avoidance(nullptr);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2FGeofenceBreachAvoidanceTest.cpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "patch": "@@ -204,16 +204,29 @@ float GeofenceBreachAvoidance::generateLoiterAltitudeForFixedWing(geofence_viola\n \t}\n }\n \n-float GeofenceBreachAvoidance::generateLoiterAltitudeForMulticopter(geofence_violation_type_u violation_type)\n+float GeofenceBreachAvoidance::generateLoiterAltitudeForMulticopter(geofence_violation_type_u violation_type,\n+\t\tGeofence *geofence)\n {\n \tif (violation_type.flags.max_altitude_exceeded) {\n-\t\treturn _current_alt_amsl + _multirotor_vertical_braking_distance - _min_vert_dist_to_fence_mc;\n+\t\treturn _home_alt_amsl + geofence->getMaxVerDistanceHome() - geofence->getVerThreshold();\n \n \t} else {\n \t\treturn _current_alt_amsl;\n \t}\n }\n \n+float GeofenceBreachAvoidance::generateBearingForMulticopter(geofence_violation_type_u violation_type,\n+\t\tfloat current_heading)\n+{\n+\tif (violation_type.flags.dist_to_home_exceeded || violation_type.flags.fence_violation) {\n+\t\treturn get_bearing_to_next_waypoint(_current_pos_lat_lon(0), _current_pos_lat_lon(1), _home_lat_lon(0),\n+\t\t\t\t\t\t    _home_lat_lon(1));\n+\n+\t} else {\n+\t\treturn current_heading;\n+\t}\n+}\n+\n float GeofenceBreachAvoidance::computeBrakingDistanceMultirotor()\n {\n \tconst float accel_delay_max = math::max(_params.param_mpc_acc_hor, _params.param_mpc_acc_hor_max);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.cpp"
      },
      "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h": {
        "filename": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -73,7 +73,9 @@ class GeofenceBreachAvoidance : public ModuleParams\n \n \tfloat generateLoiterAltitudeForFixedWing(geofence_violation_type_u violation_type);\n \n-\tfloat generateLoiterAltitudeForMulticopter(geofence_violation_type_u violation_type);\n+\tfloat generateLoiterAltitudeForMulticopter(geofence_violation_type_u violation_type, Geofence *geofence);\n+\n+\tfloat generateBearingForMulticopter(geofence_violation_type_u violation_type, float current_heading);\n \n \tfloat getMinHorDistToFenceMulticopter() {return _min_hor_dist_to_fence_mc;}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2FGeofenceBreachAvoidance%2Fgeofence_breach_avoidance.h"
      },
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -291,6 +291,11 @@ bool Geofence::checkAll(double lat, double lon, float altitude)\n \t\t_outside_counter = 0;\n \t\treturn inside_fence;\n \n+\t} else if ((getGeofenceAction() == geofence_result_s::GF_ACTION_NONE)\n+\t\t   || (getGeofenceAction() == geofence_result_s::GF_ACTION_WARN)) {\n+\t\t_outside_counter = 0;\n+\t\treturn true;\n+\n \t} else {\n \t\t_outside_counter++;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -57,6 +57,12 @@\n \n class Navigator;\n \n+/**\n+ * Lower to minus this number if there is a breach in geofence while geofence action is hold\n+ */\n+#define NAVIGATOR_GEOFENCE_BREACH_LOWERING 10\n+\n+\n class Geofence : public ModuleParams\n {\n public:\n@@ -137,6 +143,8 @@ class Geofence : public ModuleParams\n \tint getGeofenceAction() { return _param_gf_action.get(); }\n \tfloat getMaxHorDistanceHome() { return _param_gf_max_hor_dist.get(); }\n \tfloat getMaxVerDistanceHome() { return _param_gf_max_ver_dist.get(); }\n+\tfloat getVerThreshold() { return NAVIGATOR_GEOFENCE_BREACH_LOWERING; }\n+\n \n \tbool isHomeRequired();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -379,6 +379,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool\t\t_geofence_violation_warning_sent{false}; /**< prevents spaming to mavlink */\n \tGeofenceBreachAvoidance _gf_breach_avoidance;\n \thrt_abstime _last_geofence_check = 0;\n+\tint _last_grofence_action = geofence_result_s::GF_ACTION_NONE;\n \n \tbool\t\t_can_loiter_at_sp{false};\t\t\t/**< flags if current position SP can be used to loiter */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t/**< flags if position SP triplet needs to be published */\n@@ -408,6 +409,11 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _mission_throttle{NAN};\n \n \tbool _mission_landing_in_progress{false};\t// this flag gets set if the mission is currently executing on a landing pattern\n+\n+\tfloat _loiter_altitude_amsl{0};\n+\tmatrix::Vector2<double> _lointer_center_lat_lon{};\n+\tfloat _bearing{0};\n+\n \t// if mission mode is inactive, this flag will be cleared after 2 seconds\n \n \t// update subscriptions",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 26,
        "changes": 64,
        "patch": "@@ -699,6 +699,10 @@ Navigator::run()\n \n void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n {\n+\tif (_last_grofence_action != _geofence.getGeofenceAction()) {\n+\t\t_geofence_violation_warning_sent = false;\n+\t\t_last_grofence_action = _geofence.getGeofenceAction();\n+\t}\n \n \tif (have_geofence_position_data &&\n \t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n@@ -774,47 +778,48 @@ void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n \t\t\t\t// we have predicted a geofence violation and if the action is to loiter then\n \t\t\t\t// demand a reposition to a location which is inside the geofence\n \t\t\t\tif (_geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n-\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n-\n-\t\t\t\t\tmatrix::Vector2<double> lointer_center_lat_lon;\n \t\t\t\t\tmatrix::Vector2<double> current_pos_lat_lon(_global_pos.lat, _global_pos.lon);\n-\t\t\t\t\tfloat loiter_altitude_amsl = _global_pos.alt;\n+\t\t\t\t\t_loiter_altitude_amsl = _global_pos.alt;\n \n \n \t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n \t\t\t\t\t\t// the computation of the braking distance does not match the actual braking distance. Until we have a better model\n \t\t\t\t\t\t// we set the loiter point to the current position, that will make sure that the vehicle will loiter inside the fence\n-\t\t\t\t\t\tlointer_center_lat_lon =  _gf_breach_avoidance.generateLoiterPointForMultirotor(gf_violation_type,\n-\t\t\t\t\t\t\t\t\t  &_geofence);\n-\n-\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForMulticopter(gf_violation_type);\n+\t\t\t\t\t\t_lointer_center_lat_lon =  _gf_breach_avoidance.generateLoiterPointForMultirotor(gf_violation_type,\n+\t\t\t\t\t\t\t\t\t   &_geofence);\n+\t\t\t\t\t\t_loiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForMulticopter(gf_violation_type, &_geofence);\n+\t\t\t\t\t\t_bearing = _gf_breach_avoidance.generateBearingForMulticopter(gf_violation_type, get_local_position()->heading);\n \n \t\t\t\t\t} else {\n \n-\t\t\t\t\t\tlointer_center_lat_lon = _gf_breach_avoidance.generateLoiterPointForFixedWing(gf_violation_type, &_geofence);\n-\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForFixedWing(gf_violation_type);\n+\t\t\t\t\t\t_lointer_center_lat_lon = _gf_breach_avoidance.generateLoiterPointForFixedWing(gf_violation_type, &_geofence);\n+\t\t\t\t\t\t_loiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForFixedWing(gf_violation_type);\n+\t\t\t\t\t\t_bearing =  get_local_position()->heading;\n \t\t\t\t\t}\n-\n-\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n-\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n-\t\t\t\t\trep->current.yaw_valid = true;\n-\t\t\t\t\trep->current.lat = lointer_center_lat_lon(0);\n-\t\t\t\t\trep->current.lon = lointer_center_lat_lon(1);\n-\t\t\t\t\trep->current.alt = loiter_altitude_amsl;\n-\t\t\t\t\trep->current.valid = true;\n-\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\t\trep->current.alt_valid = true;\n-\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\t\t\trep->current.loiter_direction = 1;\n-\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n-\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n-\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n-\n \t\t\t\t}\n \n \t\t\t\t_geofence_violation_warning_sent = true;\n \t\t\t}\n \n+\t\t\tif (_geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n+\n+\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n+\t\t\t\trep->current.timestamp = hrt_absolute_time();\n+\t\t\t\trep->current.yaw = _bearing;\n+\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\trep->current.lat = _lointer_center_lat_lon(0);\n+\t\t\t\trep->current.lon = _lointer_center_lat_lon(1);\n+\t\t\t\trep->current.alt = _loiter_altitude_amsl;\n+\t\t\t\trep->current.valid = true;\n+\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\trep->current.alt_valid = true;\n+\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\trep->current.loiter_direction = 1;\n+\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n+\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n+\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n+\t\t\t}\n+\n \t\t} else {\n \t\t\t/* inform other apps via the mission result */\n \t\t\t_geofence_result.geofence_violated = false;\n@@ -824,6 +829,13 @@ void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n \t\t}\n \n \t\t_geofence_result_pub.publish(_geofence_result);\n+\n+\t} else if (_geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_NONE) {\n+\t\t_geofence_result.timestamp = hrt_absolute_time();\n+\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n+\t\t_geofence_result.home_required = false;\n+\t\t_geofence_result.geofence_violated = false;\n+\t\t_geofence_result_pub.publish(_geofence_result);\n \t}\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/383fbe467ab9de4adcf860b4690378203d137819/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::checkAll",
        "Navigator::geofence_breach_check",
        "GeofenceBreachAvoidance::generateLoiterAltitudeForMulticopter",
        "GeofenceBreachAvoidance::generateLoiterAltitudeForFixedWing",
        "Navigator::run",
        "generateLoiterAltitudeForMulticopter"
      ],
      "by_file": {
        "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp": [
          "GeofenceBreachAvoidance::generateLoiterAltitudeForFixedWing",
          "GeofenceBreachAvoidance::generateLoiterAltitudeForMulticopter"
        ],
        "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.h": [
          "generateLoiterAltitudeForMulticopter"
        ],
        "src/modules/navigator/geofence.cpp": [
          "Geofence::checkAll"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::geofence_breach_check",
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Predict and use braking distance when Pausing auto modes (for multicopters)",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17269",
    "number": 17269,
    "created_at": "2021-03-30T10:08:47Z",
    "merged": true,
    "merged_at": "2021-06-18T08:45:04Z",
    "state": "closed",
    "conversation": {
      "author": "cmic0",
      "body": "**Describe problem solved by this pull request**\r\nCurrently, when pausing a vehicle during a mission/RTL/Orbit navigator will take the current position of the vehicle as loiter point. This makes the vehicle overshoot the loiter position and then bounce back to the desired setpoint as the braking distance is not taken into account.\r\n\r\n**Describe your solution**\r\nThis PR takes into account the vehicle braking distance to predict and set as loiter point the position where the vehicle will actually be able to stop.\r\n\r\n\r\n**Describe possible alternatives**\r\nIf we had motion primitives in place we could have used those to predict the braking trajectory, but still this implementation is an enhancement compared to the current state.\r\n\r\n**Test data / coverage**\r\nTested in SITL\r\n\r\n**Additional context**\r\nAdd any other related context or media.\r\n",
      "issue_comments": [
        {
          "author": "cmic0",
          "created_at": "2021-03-30T10:09:33Z",
          "body": "FYI @BazookaJoe1900 ",
          "type": "issue_comment"
        },
        {
          "author": "BazookaJoe1900",
          "created_at": "2021-03-30T15:51:52Z",
          "body": "Does the new Break option is documented on mavlink?",
          "type": "issue_comment"
        },
        {
          "author": "Kim-zhi-jiang",
          "created_at": "2021-07-13T03:12:42Z",
          "body": "1.11.3  with Geofence it's work okay ,but 1.20 not work \r\n\r\nGF_ACTION 2 #Default 1 0None 1Warning 2Hold mode 3Return mode 4Terminate\r\nGF_MAX_HOR_DIST 10\r\nGF_MAX_VER_DIST 10",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bresch",
          "created_at": "2021-03-30T13:30:29Z",
          "body": "The jerk parameter used in auto modes is [MPC_JERK_AUTO](https://dev.px4.io/master/en/advanced/parameter_reference.html#MPC_JERK_AUTO)",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "garfieldG",
          "created_at": "2021-05-09T13:05:58Z",
          "body": "@cmic0 it seems that if you want to just move in the yaw axis while in place you can't do it due to this line",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 77,
          "type": "review_comment"
        },
        {
          "author": "cmic0",
          "created_at": "2021-06-17T09:16:23Z",
          "body": "@garfieldG in hold mode you can't control vehicle orientation/attitude, by default we have RC_OVERRIDE enabled which would switch you to Position in case you move the yaw with a stick, or maybe i am not getting your use case :thinking: ?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 77,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "Overall looks good. Just need to change the jerk parameter.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error. The navigator previously used the vehicle's current position as the loiter/hold setpoint when pausing, ignoring the vehicle's braking distance which caused overshoot and incorrect behavior. The change predicts and uses the braking distance to set the actual stoppoint, correcting the incorrect state/trajectory logic rather than a syntactic or style issue.",
    "patches": {
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -400,8 +400,13 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tparam_t _handle_back_trans_dec_mss{PARAM_INVALID};\n \tparam_t _handle_reverse_delay{PARAM_INVALID};\n+\tparam_t _handle_mpc_jerk_auto{PARAM_INVALID};\n+\tparam_t _handle_mpc_acc_hor{PARAM_INVALID};\n+\n \tfloat _param_back_trans_dec_mss{0.f};\n \tfloat _param_reverse_delay{0.f};\n+\tfloat _param_mpc_jerk_auto{4.f}; /**< initialized with the default jerk auto value to prevent division by 0 if the parameter is accidentally set to 0 */\n+\tfloat _param_mpc_acc_hor{3.f}; /**< initialized with the default horizontal acc value to prevent division by 0 if the parameter is accidentally set to 0 */\n \n \tfloat _mission_cruising_speed_mc{-1.0f};\n \tfloat _mission_cruising_speed_fw{-1.0f};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/92994fd2fb4f7a10abd2a9052a60d0bbed2e9a1a/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 16,
        "changes": 57,
        "patch": "@@ -65,7 +65,6 @@\n  */\n extern \"C\" __EXPORT int navigator_main(int argc, char *argv[]);\n using namespace time_literals;\n-\n namespace navigator\n {\n Navigator\t*g_navigator;\n@@ -100,6 +99,9 @@ Navigator::Navigator() :\n \t_handle_back_trans_dec_mss = param_find(\"VT_B_DEC_MSS\");\n \t_handle_reverse_delay = param_find(\"VT_B_REV_DEL\");\n \n+\t_handle_mpc_jerk_auto = param_find(\"MPC_JERK_AUTO\");\n+\t_handle_mpc_acc_hor = param_find(\"MPC_ACC_HOR\");\n+\n \t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n \t_mission_sub = orb_subscribe(ORB_ID(mission));\n \t_vehicle_status_sub = orb_subscribe(ORB_ID(vehicle_status));\n@@ -127,6 +129,14 @@ Navigator::params_update()\n \tif (_handle_reverse_delay != PARAM_INVALID) {\n \t\tparam_get(_handle_reverse_delay, &_param_reverse_delay);\n \t}\n+\n+\tif (_handle_mpc_jerk_auto != PARAM_INVALID) {\n+\t\tparam_get(_handle_mpc_jerk_auto, &_param_mpc_jerk_auto);\n+\t}\n+\n+\tif (_handle_mpc_acc_hor != PARAM_INVALID) {\n+\t\tparam_get(_handle_mpc_acc_hor, &_param_mpc_acc_hor);\n+\t}\n }\n \n void\n@@ -294,7 +304,6 @@ Navigator::run()\n \t\t\t\t\t}\n \n \t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n-\n \t\t\t\t\t\t// Position change with optional altitude change\n \t\t\t\t\t\trep->current.lat = cmd.param5;\n \t\t\t\t\t\trep->current.lon = cmd.param6;\n@@ -307,25 +316,41 @@ Navigator::run()\n \t\t\t\t\t\t}\n \n \t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7)) {\n+\t\t\t\t\t\t// Received only a request to change altitude, thus we keep the setpoint\n+\t\t\t\t\t\trep->current.lat = curr->current.lat;\n+\t\t\t\t\t\trep->current.lon = curr->current.lon;\n+\t\t\t\t\t\trep->current.alt = cmd.param7;\n+\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// All three set to NaN - pause vehicle\n+\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n \n-\t\t\t\t\t\t// Altitude without position change\n-\t\t\t\t\t\t// This condition is necessary for altitude changes just after takeoff where lat and lon are still nan\n-\t\t\t\t\t\tif (curr->current.valid && PX4_ISFINITE(curr->current.lat) && PX4_ISFINITE(curr->current.lon)) {\n-\t\t\t\t\t\t\trep->current.lat = curr->current.lat;\n-\t\t\t\t\t\t\trep->current.lon = curr->current.lon;\n+\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n+\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n+\n+\t\t\t\t\t\t\t// For multirotors we need to account for the braking distance, otherwise the vehicle will overshoot and go back\n+\t\t\t\t\t\t\tdouble lat, lon;\n+\t\t\t\t\t\t\tfloat course_over_ground = atan2f(_local_pos.vy, _local_pos.vx);\n+\n+\t\t\t\t\t\t\t// predict braking distance\n+\n+\t\t\t\t\t\t\tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n+\n+\t\t\t\t\t\t\tfloat multirotor_braking_distance = math::trajectory::computeBrakingDistanceFromVelocity(velocity_hor_abs,\n+\t\t\t\t\t\t\t\t\t\t\t    _param_mpc_jerk_auto, _param_mpc_acc_hor, 0.6f * _param_mpc_jerk_auto);\n+\n+\t\t\t\t\t\t\twaypoint_from_heading_and_distance(get_global_position()->lat, get_global_position()->lon, course_over_ground,\n+\t\t\t\t\t\t\t\t\t\t\t   multirotor_braking_distance, &lat, &lon);\n+\t\t\t\t\t\t\trep->current.lat = lat;\n+\t\t\t\t\t\t\trep->current.lon = lon;\n+\t\t\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n+\t\t\t\t\t\t\trep->current.yaw_valid = true;\n \n \t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n \t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n \t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\trep->current.alt = cmd.param7;\n-\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// All three set to NaN - hold in current position\n-\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n-\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n-\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n \t\t\t\t\t}\n \n \t\t\t\t\trep->previous.valid = true;\n@@ -972,7 +997,7 @@ Navigator::reset_position_setpoint(position_setpoint_s &sp)\n \tsp = position_setpoint_s{};\n \tsp.timestamp = hrt_absolute_time();\n \tsp.lat = static_cast<double>(NAN);\n-\tsp.lon = static_cast<double>(NAN);;\n+\tsp.lon = static_cast<double>(NAN);\n \tsp.loiter_radius = get_loiter_radius();\n \tsp.acceptance_radius = get_default_acceptance_radius();\n \tsp.cruising_speed = get_cruising_speed();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/92994fd2fb4f7a10abd2a9052a60d0bbed2e9a1a/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run",
        "Navigator::params_update",
        "Navigator::reset_position_setpoint",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run",
          "Navigator::params_update",
          "Navigator::reset_position_setpoint",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "params: ensure short description is only a single line",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17209",
    "number": 17209,
    "created_at": "2021-03-23T13:41:39Z",
    "merged": true,
    "merged_at": "2021-03-23T16:55:12Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "So a UI can display it properly\r\n\r\nThis is less relevant with xml, as QGC is currently showing as long single line, but for json parameter metadata, it messes up the UI.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2021-03-23T14:37:28Z",
          "body": "I'm also wondering if we should try to get the length under control.\r\n\r\nMaybe cap it at the worst case today and gradually ratchet it up until we hit something reasonable?\r\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2021-03-23T15:22:16Z",
          "body": "Yup, I added a limit of 150 for existing and 70 to the yaml, so we can shorten when transitioning.\r\n\r\nThese are the worst cases:\r\n```\r\n80 Minimum landing target standard covariance, uses reported covariance if greater.\r\n81 Airspeed sensor tube diameter. Only used for the Tube Pressure Drop Compensation.\r\n81 Maximum absolute altitude (height above ground level) allowed for range aid mode.\r\n81 Time in seconds we wait on reaching target heading at a waypoint if it is forced.\r\n82 Enable yaw control of the mount. (Only affects multicopters and ROI mission items)\r\n83 Boolean to allow moving into directions where there is no sensor data (outside FOV)\r\n84 Maximum allowed angle the vehicle is allowed to pitch down to generate forward force\r\n84 Terrain altitude process noise - accounts for instability in vehicle height estimate\r\n84 Terrain maximum percent grade, hilly/outdoor (100 = 45 deg), flat/Indoor (0 = 0 deg)\r\n85 Horizontal radius from return point within which special rules for return mode apply.\r\n85 Maximum vertical velocity for which position hold is enabled (use 0 to disable check)\r\n86 Enable publishing of a fake global position (e.g for AUTO missions using Optical Flow)\r\n86 Magnitude of maximum angular flow rate reliably measurable by the optical flow sensor.\r\n86 Minimum time of arrival delta between non-IMU observations before data is downsampled.\r\n87 Maximum horizontal velocity for which position hold is enabled (use 0 to disable check)\r\n89 Time-out to wait when offboard connection is lost before triggering offboard lost action.\r\n90 Auxillary Velocity Estimate (e.g from a landing target) delay relative to IMU measurements\r\n90 Enable PWM input on for engaging failsafe from an external automatic trigger system (ATS).\r\n91 Optical Flow data will only be used if the sensor reports a quality metric >= EKF2_OF_QMIN.\r\n92 Horizontal acceleration threshold used by automatic selection of magnetometer fusion method.\r\n93 Tilt actuator control value commanded when disarmed and during the first second after arming.\r\n93 Upper limit on airspeed along individual axes used to correct baro for position error effects\r\n93 Z position of IMU in body frame (down axis with origin relative to vehicle centre of gravity)\r\n94 Whether to set the external vision observation noise from the parameter or from vision message\r\n94 Y position of IMU in body frame (right axis with origin relative to vehicle centre of gravity)\r\n96 X position of IMU in body frame (forward axis with origin relative to vehicle centre of gravity)\r\n97 Measurement noise for the optical flow sensor when it's reported quality metric is at the maximum\r\n97 Specific drag force observation noise variance used by the multi-rotor specific drag force model.\r\n101 Z position of GPS antenna in body frame (down axis with origin relative to vehicle centre of gravity)\r\n102 Y position of GPS antenna in body frame (right axis with origin relative to vehicle centre of gravity)\r\n103 Average delay of the range sensor message plus the tracking delay of the position controller in seconds\r\n104 X position of GPS antenna in body frame (forward axis with origin relative to vehicle centre of gravity)\r\n107 Enable/disable usage of fixed-wing actuators in hover to generate forward force (instead of pitching down).\r\n109 Z position of range finder origin in body frame (down axis with origin relative to vehicle centre of gravity)\r\n110 Y position of range finder origin in body frame (right axis with origin relative to vehicle centre of gravity)\r\n111 Z position of VI sensor focal point in body frame (down axis with origin relative to vehicle centre of gravity)\r\n112 X position of range finder origin in body frame (forward axis with origin relative to vehicle centre of gravity)\r\n112 Y position of VI sensor focal point in body frame (right axis with origin relative to vehicle centre of gravity)\r\n114 Time constant used by acceleration and angular rate magnitude checks used to inhibit delta velocity bias learning.\r\n114 X position of VI sensor focal point in body frame (forward axis with origin relative to vehicle centre of gravity)\r\n114 Z position of optical flow focal point in body frame (down axis with origin relative to vehicle centre of gravity)\r\n115 Y position of optical flow focal point in body frame (right axis with origin relative to vehicle centre of gravity)\r\n117 X position of optical flow focal point in body frame (forward axis with origin relative to vehicle centre of gravity)\r\n118 Measurement noise for vision angle observations used to lower bound or replace the uncertainty included in the message\r\n121 Measurement noise for vision position observations used to lower bound or replace the uncertainty included in the message\r\n121 Measurement noise for vision velocity observations used to lower bound or replace the uncertainty included in the message\r\n123 Time constant of the position output prediction and smoothing filter. Controls how tightly the output track the EKF states.\r\n125 Minimum duration during which the reported range finder signal quality needs to be non-zero in order to be declared valid (s)\r\n132 Angle left/right from the commanded setpoint by which the collision prevention algorithm can choose to change the setpoint direction\r\n144 Differential gain for horizontal velocity error. Small values help reduce fast oscillations. If value is too big oscillations will appear again.\r\n149 Maximum lapsed time from last fusion of measurements that constrain velocity drift before the EKF will report the horizontal nav solution as invalid.\r\n```",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-03-23T16:04:47Z",
          "body": "Rebased on master, let's see what CI says.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR enforces that parameter short descriptions are a single line and adds length limits to avoid breaking the UI. This fixes an incorrect behavior (UI display/misalignment and metadata handling) by changing validation/processing logic for parameter descriptions, which fits the definition of a logic error.",
    "patches": {
      "src/modules/navigator/follow_target_params.c": {
        "filename": "src/modules/navigator/follow_target_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -78,6 +78,7 @@ PARAM_DEFINE_INT32(NAV_FT_FS, 1);\n \n /**\n  * Dynamic filtering algorithm responsiveness to target movement\n+ *\n  * lower numbers increase the responsiveness to changing long lat\n  * but also ignore less noise\n  *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0dc96d724d84839669db6f498b2bccb6adc1dc3d/src%2Fmodules%2Fnavigator%2Ffollow_target_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Fix first wp too far message overflow",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17128",
    "number": 17128,
    "created_at": "2021-03-15T16:14:40Z",
    "merged": true,
    "merged_at": "2021-03-15T16:40:53Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The title 'Fix first wp too far message overflow' indicates the PR addresses an incorrect runtime behavior (a message overflowing its bounds), which commonly stems from faulty logic such as improper boundary checks or formatting. Although no PR body or comments are provided, the presence of 'Fix' and 'overflow' strongly suggests a logic-level bug rather than a mere style or typo fix, but the lack of details reduces certainty.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -662,7 +662,7 @@ MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission\n \t\t} else {\n \t\t\t/* item is too far from home */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n-\t\t\t\t\t     \"First waypoint too far away: %d meters, %d max.\",\n+\t\t\t\t\t     \"First waypoint too far away: %dm, %d max\",\n \t\t\t\t\t     (int)dist_to_1wp, (int)max_distance);\n \n \t\t\t_navigator->get_mission_result()->warning = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2930dbbaa57309ceae33ed9ba00bc0e44d99ed24/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkDistanceToFirstWaypoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkDistanceToFirstWaypoint"
        ]
      }
    }
  },
  {
    "title": "update UUV and rover controllers to use trajectory_setpoint and cleanup unused position_setpoint fields",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17061",
    "number": 17061,
    "created_at": "2021-03-09T02:52:11Z",
    "merged": true,
    "merged_at": "2021-03-09T15:36:35Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2021-03-09T10:03:56Z",
          "body": "Why are the frame specific for the rover pos control?",
          "path": "src/modules/rover_pos_control/RoverPositionControl.hpp",
          "position": 31,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-03-09T14:16:27Z",
          "body": "It's not handled yet, but I'm assuming we're going to add it. Right now ORB_ID(trajectory_setpoint) is always NED, with things like body frame velocity setpoints being converted by the mavlink receiver. I'd like to push all of that into the controllers and keep mavlink as a dumb passthrough.",
          "path": "src/modules/rover_pos_control/RoverPositionControl.hpp",
          "position": 31,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-03-09T14:17:05Z",
          "body": "```suggestion\r\n\t\tif (_velocity_frame == VelocityFrame::NED) {\r\n```",
          "path": "src/modules/rover_pos_control/RoverPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "Jaeyoung-Lim",
          "created_at": "",
          "body": "Thanks! looks good for me!\r\n\r\nJust one minor comment on the velocity frame in rover pos control",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "Assuming `trajectory_setpoint` is set like the few fields of the triplet before it looks good to me ðŸ‘ ",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes controllers to use trajectory_setpoint and removes unused position_setpoint fields, which indicates correction of how setpoints were read/used by UUV and rover controllers. That kind of change addresses incorrect behavior/state (using the wrong message/fields) rather than style, so it is a logic fix; given the sparse details and only brief review comments, confidence is medium.",
    "patches": {
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -327,7 +327,6 @@ void FollowTarget::update_position_sp(bool use_velocity, bool use_position, floa\n \tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_FOLLOW_TARGET;\n-\tpos_sp_triplet->current.position_valid = use_position;\n \tpos_sp_triplet->current.velocity_valid = use_velocity;\n \tpos_sp_triplet->current.vx = _current_vel(0);\n \tpos_sp_triplet->current.vy = _current_vel(1);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ba0e76240e17bf7a6c8eda9126b540de610cb825/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -1838,10 +1838,6 @@ bool Mission::position_setpoint_equal(const position_setpoint_s *p1, const posit\n {\n \treturn ((p1->valid == p2->valid) &&\n \t\t(p1->type == p2->type) &&\n-\t\t(fabsf(p1->x - p2->x) < FLT_EPSILON) &&\n-\t\t(fabsf(p1->y - p2->y) < FLT_EPSILON) &&\n-\t\t(fabsf(p1->z - p2->z) < FLT_EPSILON) &&\n-\t\t(p1->position_valid == p2->position_valid) &&\n \t\t(fabsf(p1->vx - p2->vx) < FLT_EPSILON) &&\n \t\t(fabsf(p1->vy - p2->vy) < FLT_EPSILON) &&\n \t\t(fabsf(p1->vz - p2->vz) < FLT_EPSILON) &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ba0e76240e17bf7a6c8eda9126b540de610cb825/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::position_setpoint_equal",
        "FollowTarget::update_position_sp"
      ],
      "by_file": {
        "src/modules/navigator/follow_target.cpp": [
          "FollowTarget::update_position_sp"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::position_setpoint_equal"
        ]
      }
    }
  },
  {
    "title": "Migrate sensors and navigator to use YAML module configuration",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17038",
    "number": 17038,
    "created_at": "2021-03-06T09:10:14Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "coderkalyan",
      "body": "As discussed on slack, this PR moves the sensors and navigator modules to use the new YAML module configuration for parameter definitions rather than the legacy C API. I'm checking that CI likes this - if so, I can go ahead and convert the others as well in another PR.\r\n\r\nI also fixed a few bugs that I found along the way in the px4parameters build system python scripts.\r\n\r\nFYI @dagar",
      "issue_comments": [
        {
          "author": "coderkalyan",
          "created_at": "2021-03-06T09:21:20Z",
          "body": "Looks like the module config regex is failing. I'll look into that tomorrow. Everything else seems to be fine.",
          "type": "issue_comment"
        },
        {
          "author": "coderkalyan",
          "created_at": "2021-03-10T17:24:38Z",
          "body": "> Did you verify that the generated parameters.xml is the same (or rather contains all expected params)?\r\n\r\nNot yet, but will do.",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2021-06-26T03:10:28Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bkueng",
          "created_at": "2021-03-09T08:01:40Z",
          "body": "This could also just be removed",
          "path": "src/lib/parameters/px4params/srcparser.py",
          "position": 48,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2021-03-09T08:05:18Z",
          "body": "```suggestion\r\n  - group: Mission\r\n```",
          "path": "src/modules/navigator/module.yaml",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2021-03-09T08:06:05Z",
          "body": "```suggestion\r\n  - group: Follow Target\r\n```",
          "path": "src/modules/navigator/module.yaml",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2021-03-09T08:09:15Z",
          "body": "multi?",
          "path": "src/modules/sensors/module.yaml",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2021-03-09T08:09:54Z",
          "body": "for multi-instances, you need to add `num_instances: *max_num_sensor_instances`",
          "path": "src/modules/sensors/module.yaml",
          "position": 473,
          "type": "review_comment"
        },
        {
          "author": "coderkalyan",
          "created_at": "2021-03-10T17:24:08Z",
          "body": "Oh whoops completely forgot about using multi there :smile: I'll fix that",
          "path": "src/modules/sensors/module.yaml",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "",
          "body": "Thanks for going through this. I remarked a couple of things I spotted when looking over it.\r\nDid you verify that the generated parameters.xml is the same (or rather contains all expected params)?",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR is primarily a migration/refactor to use YAML module configuration and mentions some fixes to build-system scripts, but there is no clear evidence in the description or comments that it addresses a concrete incorrect program behavior (the comments note a failing regex and unverified generated parameters.xml). Based on available information this appears to be a structural change with incidental fixes rather than a demonstrated logic-bug fix.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "patch": "@@ -48,10 +48,23 @@ px4_add_module(\n \t\tprecland.cpp\n \t\tmission_feasibility_checker.cpp\n \t\tgeofence.cpp\n+<<<<<<< HEAD\n \t\tvtol_takeoff.cpp\n+=======\n+\t\tenginefailure.cpp\n+\t\tgpsfailure.cpp\n+\t\tfollow_target.cpp\n+\tMODULE_CONFIG\n+\t\tmodule.yaml\n+>>>>>>> 869684d545 (navigator: switch to yaml params definition)\n \tDEPENDS\n \t\tgeo\n \t\tlanding_slope\n \t\tgeofence_breach_avoidance\n \t\tmotion_planning\n \t)\n+<<<<<<< HEAD\n+=======\n+\n+px4_add_functional_gtest(SRC RangeRTLTest.cpp LINKLIBS modules__navigator modules__dataman)\n+>>>>>>> 869684d545 (navigator: switch to yaml params definition)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/27d18877f2a6a4bdf8210ea3100f603af490221e/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/module.yaml": {
        "filename": "src/modules/navigator/module.yaml",
        "status": "added",
        "additions": 561,
        "deletions": 0,
        "changes": 561,
        "patch": "@@ -0,0 +1,561 @@\n+module_name: Navigator\n+\n+parameters:\n+  - group: Mission\n+    definitions:\n+      NAV_LOITER_RAD:\n+        description:\n+          short: Loiter radius (FW only)\n+          long: Default value of loiter radius for missions, Hold mode, Return mode, etc. (fixedwing only).\n+        unit: m\n+        min: 25\n+        max: 1000\n+        decimal: 1\n+        increment: 0.5\n+        default: 50.0\n+        type: float\n+      NAV_ACC_RAD:\n+        description:\n+          short: Acceptance radius\n+          long: |\n+            Default acceptance radius, overriden by acceptance radius of waypoint if set.\n+            For fixed wing the L1 turning distance is used for horizontal acceptance.\n+        unit: m\n+        min: 0.05\n+        max: 200.0\n+        decimal: 1\n+        increment: 0.5\n+        default: 10.0\n+        type: float\n+      NAV_FW_ALT_RAD:\n+        description:\n+          short: FW altitude acceptance radius\n+          long: Acceptance radius for fixedwing altitude\n+        unit: m\n+        min: 0.05\n+        max: 200.0\n+        decimal: 1\n+        increment: 0.5\n+        default: 10.0\n+        type: float\n+      NAV_FW_ALTL_RAD:\n+        description:\n+          short: FW altitude acceptance radius before a landing\n+          long: |\n+            Altitutde acceptance used for the last waypoint before a fixed-wing landing.\n+            This is usually smaller than the standard vertical acceptance because close to\n+            the ground higher accuracy is required.\n+        unit: m\n+        min: 0.05\n+        max: 200.0\n+        decimal: 1\n+        default: 5.0\n+        type: float\n+      NAV_MC_ALT_RAD:\n+        description:\n+          short: Multicopter altitude acceptance radius\n+          long: Acceptance radius for multicopter altitude\n+        unit: m\n+        min: 0.05\n+        max: 200.0\n+        decimal: 1\n+        increment: 0.5\n+        default: 0.8\n+        type: float\n+      NAV_TRAFF_AVOID:\n+        description:\n+          short: Set traffic avoidance mode\n+          long: |\n+            Enabling this will allow the system to respond to transponder data\n+            e. g. from ADSB transponders\n+        type: enum\n+        values:\n+          0: Disabled\n+          1: Warn only\n+          2: Return mode\n+          3: Land mode\n+          4: Position Hold mode\n+        default: 1\n+      NAV_TRAFF_A_RADM:\n+        description:\n+          short: Navigator traffic avoidance radius (manned)\n+          long: Defines the radius where NAV TRAFFIC AVOID is called for manned aviation\n+        unit: m\n+        min: 500\n+        default: 500\n+        type: float\n+      NAV_TRAFF_A_RADU:\n+        description:\n+          short: Navigator traffic avoidance radius (unmanned)\n+          long: Defines the radius where NAV TRAFFIC AVOID is called for unmanned aviation\n+        unit: m\n+        min: 10\n+        max: 500\n+        default: 10\n+        type: float\n+      NAV_FORCE_VT:\n+        description:\n+          short: Force VTOL mode takeoff and land\n+          long: Forces VTOL mode for takeoff and landing\n+        type: boolean\n+        default: true\n+\n+  - group: Data Link Loss\n+    definitions:\n+      NAV_AH_LAT:\n+        description:\n+          short: Airfield home latitude\n+          long: Latitude of airfield home waypoint\n+        unit: deg*1e7\n+        min: -900000000\n+        max: 900000000\n+        default: -265847810\n+        type: int32\n+      NAV_AH_LON:\n+        description:\n+          short: Airfield home longitude\n+          long: Longitude of airfield home waypoint\n+        unit: deg*1e7\n+        min: -1800000000\n+        max: 1800000000\n+        default: 1518423250\n+        type: int32\n+      NAV_AH_ALT:\n+        description:\n+          short: Airfield home altitude\n+          long: Altitude of airfield home waypoint\n+        unit: m\n+        min: -50\n+        decimal: 1\n+        increment: 0.5\n+        default: 600.0\n+        type: float\n+\n+  - group: Geofence\n+    definitions:\n+      GF_ACTION:\n+        description:\n+          short: Geofence violation action.\n+          long: |\n+            Note: Setting this value to 4 enables flight termination, which will\n+            kill the vehicle on violation of the fence. Due to the inherent danger\n+            of this, this function is disabled using a software circuit breaker, which\n+            needs to be reset to 0 to really shut down the system.\n+        type: enum\n+        values:\n+          0: None\n+          1: Warning\n+          2: Hold Mode\n+          3: Return mode\n+          4: Terminate\n+          5: Land mode\n+        default: 2\n+      GF_ALTMODE:\n+        description:\n+          short: Geofence altitude mode\n+          long: Select which altitude (AMSL) source should be used for geofence calculations.\n+        type: enum\n+        values:\n+          0: Autopilot estimator global position altitude (GPS)\n+          1: Raw barometer altitude (assuming standard atmospheric pressure)\n+        default: 0\n+      GF_SOURCE:\n+        description:\n+          short: Geofence source\n+          long: |\n+            Select which position source should be used. Selecting GPS instead of global\n+            position makes sure no dependence on the position estimator.\n+        type: enum\n+        values:\n+          0: GPOS\n+          1: GPS\n+        default: 0\n+      GF_COUNT:\n+        description:\n+          short: Geofence counter limit\n+          long: |\n+            Set how many subsequent position measurements outside of the fence are needed\n+            before geofence violation is triggered.\n+        type: int32\n+        min: -1\n+        max: 10\n+        increment: 1\n+        default: -1\n+      GF_MAX_HOR_DIST:\n+        description:\n+          short: Max horizontal distance in meters\n+          long: |\n+            Maximum horizontal distance in meters the vehicle can be from home before\n+            triggering a geofence\n+        type: float\n+        unit: m\n+        min: 0\n+        max: 10000\n+        increment: 1\n+        default: 0\n+      GF_MAX_VER_DIST:\n+        description:\n+          short: Max vertical distance in meters\n+          long: |\n+            Maximum vertical distance in meters the vehicle can be from home before\n+            triggering a geofence\n+        type: float\n+        unit: m\n+        min: 0\n+        max: 10000\n+        increment: 1\n+        default: 0\n+\n+  - group: GPS Failure Navigation\n+    definitions:\n+      NAV_GPSF_LT:\n+        description:\n+          short: Loiter time\n+          long: |\n+            The time in seconds the system should do open loop loiter and wait for GPS\n+            recovery before it goes into flight termination. Set to 0 to disable.\n+        type: float\n+        unit: s\n+        min: 0.0\n+        max: 3600.0\n+        decimal: 0\n+        increment: 1\n+        default: 0.0\n+      NAV_GPSF_R:\n+        description:\n+          short: Fixed roll angle\n+          long: Roll in degrees during the loiter\n+        type: float\n+        unit: deg\n+        min: 0.0\n+        max: 30.0\n+        decimal: 1\n+        increment: 0.5\n+        default: 15.0\n+      NAV_GPSF_P:\n+        description:\n+          short: Fixed pitch angle\n+          long: Pitch in degrees during the loiter\n+        type: float\n+        unit: deg\n+        min: -30.0\n+        max: 30.0\n+        decimal: 1\n+        increment: 0.5\n+        default: 0.0\n+      NAV_GPSF_TR:\n+        description:\n+          short: Thrust\n+          long: Thrust value which is set during the open loop loiter\n+        type: float\n+        unit: norm\n+        min: 0.0\n+        max: 1.0\n+        decimal: 2\n+        increment: 0.05\n+        default: 0.0\n+      MIS_TAKEOFF_REQ:\n+        description:\n+          short: Take-off waypoint required\n+          long: If set, the mission feasibility checker will check for a takeoff waypoint on the mission.\n+        type: boolean\n+        default: false\n+      MIS_MNT_YAW_CTL:\n+        description:\n+          short: Enable yaw control of the mount. (Only affects multicopters and ROI mission items)\n+          long: |\n+            If enabled, yaw commands will be sent to the mount and the vehicle will follow\n+            its heading towards the flight direction.\n+            If disabled, the vehicle will yaw towards the ROI.\n+        type: enum\n+        values:\n+          0: Disable\n+          1: Enable\n+        default: 0\n+      MIS_TAKEOFF_ALT:\n+        description:\n+          short: Take-off altitude\n+          long: This is the minimum altitude the system will take off to.\n+        unit: m\n+        min: 0\n+        max: 80\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 2.5\n+      MIS_LTRMIN_ALT:\n+        description:\n+          short: Minimum loiter altitude\n+          long: |\n+            This is the minimum altitude the system will always obey. The intent is to stay\n+            out of ground effect. Set to -1 if there shouldn't be a minimum loiter altitude.\n+        unit: m\n+        min: -1\n+        max: 80\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: -1.0\n+      MIS_DIST_1WP:\n+        description:\n+          short: Maximal horizontal distance from home to first waypoint\n+          long: Maximal horizontal distance from home to first waypoint\n+        unit: m\n+        min: 0\n+        max: 10000\n+        decimal: 1\n+        increment: 100\n+        type: float\n+        default: 900.0\n+      MIS_DIST_WPS:\n+        description:\n+          short: Maximal horizontal distance between waypoint\n+          long: Maximal horizontal distance between waypoint\n+        unit: m\n+        min: 0\n+        max: 10000\n+        decimal: 1\n+        increment: 100\n+        type: float\n+        default: 900.0\n+      MIS_YAW_TMT:\n+        description:\n+          short: Time in seconds we wait on reaching target heading at a waypoint if it is forced.\n+          long: |\n+            If set > 0 it will ignore the target heading for normal waypoint acceptance. If the\n+            waypoint forces the heading the timeout will matter. For example on VTOL forwards\n+            transition. Mainly useful for VTOLs that have less yaw authority and might not reach\n+            target yaw in wind. Disabled by default.\n+        unit: s\n+        min: -1\n+        max: 20\n+        decimal: 1\n+        increment: 1\n+        type: float\n+        default: -1.0\n+      MIS_YAW_ERR:\n+        description:\n+          short: Max yaw error in degrees needed for waypoint heading acceptance.\n+          long: Max yaw error in degrees needed for waypoint heading acceptance.\n+        unit: deg\n+        min: 0\n+        max: 90\n+        decimal: 1\n+        increment: 1\n+        type: float\n+        default: 12.0\n+\n+  - group: Precision Land\n+    definitions:\n+      PLD_BTOUT:\n+        description:\n+          short: Landing Target Timeout\n+          long: Time after which the landing target is onsidered lost without any new measurements.\n+        unit: s\n+        min: 0.0\n+        max: 50\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 5.0\n+      PLD_HACC_RAD:\n+        description:\n+          short: Horizontal acceptance radius\n+          long: Start descending if closer above landing target than this.\n+        unit: m\n+        min: 0.0\n+        max: 10\n+        decimal: 2\n+        increment: 0.1\n+        type: float\n+        default: 0.2\n+      PLD_FAPPR_ALT:\n+        description:\n+          short: Final approach altitude\n+          long: |\n+            Allow final approach (without horizontal positioning) if losing landing\n+            target closer than this\n+        unit: m\n+        min: 0.0\n+        max: 10\n+        decimal: 2\n+        increment: 0.1\n+        type: float\n+        default: 0.1\n+      PLD_SRCH_ALT:\n+        description:\n+          short: Search altitude\n+          long: Altitude above home to which to climb when searching for the landing target.\n+        unit: m\n+        min: 0.0\n+        max: 100\n+        decimal: 1\n+        increment: 0.1\n+        type: float\n+        default: 10.0\n+      PLD_SRCH_TOUT:\n+        description:\n+          short: Search timeout\n+          long: Time allowed to search for the landing target before falling back to normal landing.\n+        unit: s\n+        min: 0.0\n+        max: 100\n+        decimal: 1\n+        increment: 0.1\n+        type: float\n+        default: 10.0\n+      PLD_MAX_SRCH:\n+        description:\n+          short: Maximum number of search attempts\n+          long: Maximum number of times to search for the landing target if it is lost during the precision landing.\n+        min: 0\n+        max: 100\n+        type: int32\n+        default: 3\n+\n+  - group: Follow Target\n+    definitions:\n+      NAV_MIN_FT_HT:\n+        description:\n+          short: Minimum follow target altitude\n+          long: The minimum height in meters relative to home for following a target\n+        unit: m\n+        min: 8.0\n+        type: float\n+        default: 8.0\n+      NAV_FT_DST:\n+        description:\n+          short: Distance to follow target from\n+          long: The distance in meters to follow the target at\n+        unit: m\n+        min: 1.0\n+        type: float\n+        default: 8.0\n+      NAV_FT_FS:\n+        description:\n+          short: Side to follow target from\n+          long: |\n+            The side to follow the target from (front right = 0, behind = 1, front\n+            = 2, front left = 3)\n+        min: 0\n+        max: 3\n+        type: int32\n+        default: 1\n+      NAV_FT_RS:\n+        description:\n+          short: Dynamic filtering algorithm responsiveness to target movement\n+          long: Dynamic filtering algorithm responsiveness to target movement\n+        min: 0.0\n+        max: 1.0\n+        decimal: 2\n+        type: float\n+        default: 0.5\n+\n+  - group: Return Mode\n+    definitions:\n+      RTL_TYPE:\n+        description:\n+          short: Return type\n+          long: |\n+            Return mode destination and flight path (home location, rally point, mission\n+            landing pattern, reverse mission)\n+        type: enum\n+        values:\n+          0: Return to closest safe point (home or rally point) via direct path.\n+          1: Return to closest safe point other than home (mission landing pattern or rally point).\n+          2: Return to a planned mission landing, if available, using the mission path, else return to home via the reverse mission path. Do not consider rally points.\n+          3: \"Return via the direct path to closest destination: home, start of mission landing pattern or safe point. If the destination is a mission landing pattern, follow the pattern to land.\"\n+        default: 0\n+      RTL_CONE_ANG:\n+        description:\n+          short: Half-angle of the return mode altitude cone\n+          long: |\n+            Defines the half-angle of a cone centered around the destination position that\n+            affects the altitude at which the vehicle returns.\n+        unit: deg\n+        type: enum\n+        values:\n+          0: No cone, always climb to RTL_RETURN_ALT above destination.\n+          25: 25 degrees half cone angle.\n+          45: 45 degrees half cone angle\n+          65: 65 degrees half cone angle.\n+          80: 80 degrees half cone angle.\n+          90: Only climb to at least RTL_DESCEND_ALT above destination.\n+        default: 45\n+      RTL_PLD_MD:\n+        description:\n+          short: RTL precision land mode\n+          long: Use precision landing when doing an RTL landing phase.\n+        type: enum\n+        values:\n+          0: No precision landing\n+          1: Opportunistic precision landing\n+          2: Required precision landing\n+        default: 0\n+      RTL_RETURN_ALT:\n+        description:\n+          short: Return mode return altitude\n+          long: Return mode return altitude\n+        unit: m\n+        min: 0\n+        max: 150\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 60.0\n+      RTL_DESCEND_ALT:\n+        description:\n+          short: Return mode loiter altitude\n+          long: Return mode loiter altitude\n+        unit: m\n+        min: 2\n+        max: 100\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 30.0\n+      RTL_LAND_DELAY:\n+        description:\n+          short: Return mode delay\n+          long: Return mode delay\n+        unit: s\n+        min: -1\n+        max: 300\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 0.0\n+      RTL_MIN_DIST:\n+        description:\n+          short: Horizontal radius from return point within which special rules for\n+            return mode apply.\n+          long: Horizontal radius from return point within which special rules for return\n+            mode apply.\n+        unit: m\n+        min: 0.5\n+        max: 100\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 10.0\n+      RTL_LOITER_RAD:\n+        description:\n+          short: Loiter radius for rtl descend\n+          long: Set the radius for loitering to a safe altitude for VTOL transition.\n+        unit: m\n+        min: 25\n+        max: 1000\n+        decimal: 1\n+        increment: 0.5\n+        type: float\n+        default: 50.0\n+\n+  - group: Commander\n+    definitions:\n+      RTL_FLT_TIME:\n+        description:\n+          short: Maximum allowed RTL flight in minutes\n+          long: Maximum allowed RTL flight in minutes\n+        unit: min\n+        type: float\n+        default: 15.0",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/27d18877f2a6a4bdf8210ea3100f603af490221e/src%2Fmodules%2Fnavigator%2Fmodule.yaml"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "navigator: new navigator_status msg split out of mission_result",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17031",
    "number": 17031,
    "created_at": "2021-03-05T17:26:46Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This is another small step towards turning navigator into a simpler (dumber) mission manager.\r\n\r\nThe `mission_result` contained a mix of general navigation state feedback and actual mission specifics. Now `mission_result` is dedicated entirely to the actual mission.",
      "issue_comments": [
        {
          "author": "stale[bot]",
          "created_at": "2021-06-26T03:10:30Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR splits general navigator state out of a message that previously combined navigation feedback with mission-specific data. That mix could cause incorrect or ambiguous state reporting / data flow (consumers misinterpreting mission_result), so separating responsibilities corrects a logic/design flaw in how state was represented and propagated.",
    "patches": {
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -134,8 +134,8 @@ GpsFailure::set_gpsf_item()\n \tswitch (_gpsf_state) {\n \tcase GPSF_STATE_TERMINATE: {\n \t\t\t/* Request flight termination from commander */\n-\t\t\t_navigator->get_mission_result()->flight_termination = true;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->navigator_status().flight_termination = true;\n+\t\t\t_navigator->navigator_status_updated();\n \t\t\tPX4_WARN(\"GPS failure: request flight termination\");\n \t\t}\n \t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      },
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "patch": "@@ -51,8 +51,10 @@ Land::on_activation()\n {\n \t/* set current mission item to Land */\n \tset_land_item(&_mission_item, true);\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->set_mission_result_updated();\n+\n+\t_navigator->navigator_status().finished = false;\n+\t_navigator->navigator_status_updated();\n+\n \treset_mission_item_reached();\n \n \t/* convert mission item to current setpoint */\n@@ -81,8 +83,9 @@ Land::on_active()\n \n \n \tif (_navigator->get_land_detected()->landed) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t\t_navigator->navigator_status().finished = true;\n+\t\t_navigator->navigator_status_updated();\n+\n \t\tset_idle_item(&_mission_item);\n \n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 29,
        "changes": 91,
        "patch": "@@ -106,7 +106,7 @@ Mission::on_inactive()\n \t} else {\n \n \t\t/* load missions from storage */\n-\t\tmission_s mission_state = {};\n+\t\tmission_s mission_state{};\n \n \t\tdm_lock(DM_KEY_MISSION_STATE);\n \n@@ -139,7 +139,9 @@ Mission::on_inactive()\n \t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \n \t/* reset so MISSION_ITEM_REACHED isn't published */\n-\t_navigator->get_mission_result()->seq_reached = -1;\n+\t_mission_result.seq_reached = -1;\n+\t_mission_result_updated = true;\n+\tpublish_mission_result();\n }\n \n void\n@@ -163,6 +165,10 @@ Mission::on_inactivation()\n \n \t/* reset so current mission item gets restarted if mission was paused */\n \t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\n+\t_mission_result.active = false;\n+\t_mission_result_updated = true;\n+\tpublish_mission_result();\n }\n \n void\n@@ -189,6 +195,10 @@ Mission::on_activation()\n \tcmd.param1 = -1.0f;\n \tcmd.param3 = 0.0f;\n \t_navigator->publish_vehicle_cmd(&cmd);\n+\n+\t_mission_result.active = true;\n+\t_mission_result_updated = true;\n+\tpublish_mission_result();\n }\n \n void\n@@ -282,13 +292,14 @@ Mission::on_active()\n \t} else if (_navigator->get_precland()->is_activated()) {\n \t\t_navigator->get_precland()->on_inactivation();\n \t}\n+\n+\tpublish_mission_result();\n }\n \n bool\n Mission::set_current_mission_index(uint16_t index)\n {\n-\tif (_navigator->get_mission_result()->valid &&\n-\t    (index != _current_mission_index) && (index < _mission.count)) {\n+\tif (_mission_result.valid && (index != _current_mission_index) && (index < _mission.count)) {\n \n \t\t_current_mission_index = index;\n \n@@ -322,8 +333,9 @@ Mission::set_execution_mode(const uint8_t mode)\n {\n \tif (_mission_execution_mode != mode) {\n \t\t_execution_mode_changed = true;\n-\t\t_navigator->get_mission_result()->execution_mode = mode;\n \n+\t\t_mission_result.execution_mode = mode;\n+\t\t_mission_result_updated = true;\n \n \t\tswitch (_mission_execution_mode) {\n \t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n@@ -471,7 +483,7 @@ Mission::landing()\n \t// vehicle is currently landing if\n \t//  mission valid, still flying, and in the landing portion of mission\n \n-\tconst bool mission_valid = _navigator->get_mission_result()->valid;\n+\tconst bool mission_valid = _mission_result.valid;\n \tconst bool on_landing_stage = _land_start_available && (_current_mission_index >= get_land_start_index());\n \n \treturn mission_valid && on_landing_stage;\n@@ -480,7 +492,6 @@ Mission::landing()\n void\n Mission::update_mission()\n {\n-\n \tbool failed = true;\n \n \t/* Reset vehicle_roi\n@@ -491,6 +502,9 @@ Mission::update_mission()\n \tconst mission_s old_mission = _mission;\n \n \tif (_mission_sub.copy(&_mission)) {\n+\t\t_mission_result.mission_dataman_id = _mission.dataman_id;\n+\t\t_mission_result.mission_timestamp = _mission.timestamp;\n+\n \t\t/* determine current index */\n \t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n \t\t\t_current_mission_index = _mission.current_seq;\n@@ -510,15 +524,17 @@ Mission::update_mission()\n \n \t\tcheck_mission_valid(true);\n \n-\t\tfailed = !_navigator->get_mission_result()->valid;\n+\t\tfailed = !_mission_result.valid;\n \n \t\tif (!failed) {\n \t\t\t/* reset mission failure if we have an updated valid mission */\n-\t\t\t_navigator->get_mission_result()->failure = false;\n+\t\t\t_mission_result.failure = false;\n \n \t\t\t/* reset sequence info as well */\n-\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n-\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n+\t\t\t_mission_result.seq_reached = -1;\n+\t\t\t_mission_result.seq_total = _mission.count;\n+\n+\t\t\t_mission_result_updated = true;\n \n \t\t\t/* reset work item if new mission has been accepted */\n \t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n@@ -530,6 +546,7 @@ Mission::update_mission()\n \t\tif (((_mission.count != old_mission.count) ||\n \t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n \t\t    !_navigator->get_land_detected()->landed) {\n+\n \t\t\t_mission_waypoints_changed = true;\n \t\t}\n \n@@ -546,6 +563,8 @@ Mission::update_mission()\n \t\t// reset the mission\n \t\t_mission.count = 0;\n \t\t_mission.current_seq = 0;\n+\t\t_mission_result_updated = true;\n+\n \t\t_current_mission_index = 0;\n \t}\n \n@@ -555,7 +574,6 @@ Mission::update_mission()\n \tset_current_mission_item();\n }\n \n-\n void\n Mission::advance_mission()\n {\n@@ -674,8 +692,11 @@ Mission::set_mission_items()\n \t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n \n \t\t// set mission finished\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t\t_mission_result.finished = true;\n+\t\t_mission_result_updated = true;\n+\n+\t\t_navigator->navigator_status().finished = true;\n+\t\t_navigator->navigator_status_updated();\n \n \t\tif (!user_feedback_done) {\n \t\t\t/* only tell users that we got no mission if there has not been any\n@@ -1648,18 +1669,17 @@ void\n Mission::report_do_jump_mission_changed(int index, int do_jumps_remaining)\n {\n \t/* inform about the change */\n-\t_navigator->get_mission_result()->item_do_jump_changed = true;\n-\t_navigator->get_mission_result()->item_changed_index = index;\n-\t_navigator->get_mission_result()->item_do_jump_remaining = do_jumps_remaining;\n-\n-\t_navigator->set_mission_result_updated();\n+\t_mission_result.item_do_jump_changed = true;\n+\t_mission_result.item_changed_index = index;\n+\t_mission_result.item_do_jump_remaining = do_jumps_remaining;\n+\t_mission_result_updated = true;\n }\n \n void\n Mission::set_mission_item_reached()\n {\n-\t_navigator->get_mission_result()->seq_reached = _current_mission_index;\n-\t_navigator->set_mission_result_updated();\n+\t_mission_result.seq_reached = _current_mission_index;\n+\t_mission_result_updated = true;\n \n \t// let the navigator know that we are currently executing the mission landing.\n \t// Using the method landing() itself is not accurate as it only give information about the mission index\n@@ -1672,10 +1692,12 @@ Mission::set_mission_item_reached()\n void\n Mission::set_current_mission_item()\n {\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->get_mission_result()->seq_current = _current_mission_index;\n+\t_mission_result.finished = false;\n+\t_mission_result.seq_current = _current_mission_index;\n+\t_mission_result_updated = true;\n \n-\t_navigator->set_mission_result_updated();\n+\t_navigator->navigator_status().finished = false;\n+\t_navigator->navigator_status_updated();\n \n \tsave_mission_state();\n }\n@@ -1687,15 +1709,16 @@ Mission::check_mission_valid(bool force)\n \n \t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator);\n \n-\t\t_navigator->get_mission_result()->valid =\n+\t\t_mission_result.valid =\n \t\t\t_missionFeasibilityChecker.checkMissionFeasible(_mission,\n \t\t\t\t\t_param_mis_dist_1wp.get(),\n \t\t\t\t\t_param_mis_dist_wps.get(),\n \t\t\t\t\t_navigator->mission_landing_required());\n \n-\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n-\t\t_navigator->increment_mission_instance_count();\n-\t\t_navigator->set_mission_result_updated();\n+\t\t_mission_result.seq_total = _mission.count;\n+\t\t_mission_result.instance_count++;\n+\t\t_mission_result_updated = true;\n+\n \t\t_home_inited = _navigator->home_position_valid();\n \n \t\t// find and store landing start marker (if available)\n@@ -1864,11 +1887,21 @@ bool Mission::position_setpoint_equal(const position_setpoint_s *p1, const posit\n \n }\n \n+void Mission::publish_mission_result()\n+{\n+\tif (_mission_result_updated) {\n+\t\t_mission_result.timestamp = hrt_absolute_time();\n+\t\t_mission_result_pub.publish(_mission_result);\n+\t\t_mission_result_updated = false;\n+\t}\n+}\n+\n+\n void Mission::publish_navigator_mission_item()\n {\n \tnavigator_mission_item_s navigator_mission_item{};\n \n-\tnavigator_mission_item.instance_count = _navigator->mission_instance_count();\n+\tnavigator_mission_item.instance_count = _mission_result.instance_count;\n \tnavigator_mission_item.sequence_current = _current_mission_index;\n \tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n \tnavigator_mission_item.latitude = _mission_item.lat;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "patch": "@@ -79,6 +79,8 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tbool set_current_mission_index(uint16_t index);\n \n+\tbool mission_valid() const { return _mission_result.valid; }\n+\n \tbool land_start();\n \tbool landing();\n \n@@ -103,6 +105,16 @@ class Mission : public MissionBlock, public ModuleParams\n \t * For a list of the different modes refer to mission_result.msg\n \t */\n \tvoid set_execution_mode(const uint8_t mode);\n+\n+\tvoid set_failure() override\n+\t{\n+\t\tif (!_mission_result.failure) {\n+\t\t\t_mission_result.failure = true;\n+\n+\t\t\t_mission_result_updated = true;\n+\t\t}\n+\t}\n+\n private:\n \n \t/**\n@@ -235,6 +247,7 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tbool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;\n \n+\tvoid publish_mission_result();\n \tvoid publish_navigator_mission_item();\n \n \tDEFINE_PARAMETERS(\n@@ -243,11 +256,15 @@ class Mission : public MissionBlock, public ModuleParams\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n \t)\n \n+\tuORB::Publication<mission_result_s> _mission_result_pub{ORB_ID::mission_result};\n \tuORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item};\n \n \tuORB::Subscription\t_mission_sub{ORB_ID(mission)};\t\t/**< mission subscription */\n \tmission_s\t\t_mission {};\n \n+\tmission_result_s _mission_result{};\n+\tbool _mission_result_updated{false};\n+\n \tint32_t _current_mission_index{-1};\n \n \t// track location of planned mission landing",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -338,7 +338,8 @@ MissionBlock::is_mission_item_reached()\n \t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n \t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n \n-\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"unable to reach heading within timeout\");\n+\t\t\t\tset_failure();\n \t\t\t}\n \n \t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -144,6 +144,8 @@ class MissionBlock : public NavigatorMode\n \n \tfloat get_absolute_altitude_for_item(const mission_item_s &mission_item) const;\n \n+\tvirtual void set_failure() {}\n+\n \tmission_item_s _mission_item{};\n \n \tbool _waypoint_position_reached{false};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "patch": "@@ -73,7 +73,7 @@ MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission,\n \tif (!home_alt_valid) {\n \t\tfailed = true;\n \t\twarned = true;\n-\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Not yet ready for mission, no position lock.\");\n+\t\tmavlink_log_info(&_mavlink_log_pub, \"Not yet ready for mission, no position lock.\");\n \n \t} else {\n \t\tfailed = failed || !checkDistanceToFirstWaypoint(mission, max_distance_to_1st_waypoint);\n@@ -136,7 +136,7 @@ bool\n MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_alt, bool home_valid)\n {\n \tif (_navigator->get_geofence().isHomeRequired() && !home_valid) {\n-\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\");\n+\t\tmavlink_log_critical(&_mavlink_log_pub, \"Geofence requires valid home position\");\n \t\treturn false;\n \t}\n \n@@ -152,7 +152,7 @@ MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_al\n \t\t\t}\n \n \t\t\tif (missionitem.altitude_is_relative && !home_valid) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\");\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Geofence requires valid home position\");\n \t\t\t\treturn false;\n \t\t\t}\n \n@@ -161,7 +161,7 @@ MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_al\n \n \t\t\tif (MissionBlock::item_contains_position(missionitem) && !_navigator->get_geofence().check(missionitem)) {\n \n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %zu\", i + 1);\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Geofence violation for waypoint %zu\", i + 1);\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n@@ -180,22 +180,22 @@ MissionFeasibilityChecker::checkHomePositionAltitude(const mission_s &mission, f\n \t\tconst ssize_t len = sizeof(struct mission_item_s);\n \n \t\tif (dm_read((dm_item_t)mission.dataman_id, i, &missionitem, len) != len) {\n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t//_navigator->get_mission_result()->warning = true;\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\treturn false;\n \t\t}\n \n \t\t/* reject relative alt without home set */\n \t\tif (missionitem.altitude_is_relative && !home_alt_valid && MissionBlock::item_contains_position(missionitem)) {\n \n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t//_navigator->get_mission_result()->warning = true;\n \n \t\t\tif (throw_error) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: No home pos, WP %zu uses rel alt\", i + 1);\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: No home pos, WP %zu uses rel alt\", i + 1);\n \t\t\t\treturn false;\n \n \t\t\t} else\t{\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Warning: No home pos, WP %zu uses rel alt\", i + 1);\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Warning: No home pos, WP %zu uses rel alt\", i + 1);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n@@ -205,14 +205,14 @@ MissionFeasibilityChecker::checkHomePositionAltitude(const mission_s &mission, f\n \n \t\tif ((home_alt > wp_alt) && MissionBlock::item_contains_position(missionitem)) {\n \n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t//_navigator->get_mission_result()->warning = true;\n \n \t\t\tif (throw_error) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: Waypoint %zu below home\", i + 1);\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: Waypoint %zu below home\", i + 1);\n \t\t\t\treturn false;\n \n \t\t\t} else\t{\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Warning: Waypoint %zu below home\", i + 1);\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Warning: Waypoint %zu below home\", i + 1);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n@@ -231,7 +231,7 @@ MissionFeasibilityChecker::checkMissionItemValidity(const mission_s &mission)\n \n \t\tif (dm_read((dm_item_t)mission.dataman_id, i, &missionitem, len) != len) {\n \t\t\t// not supposed to happen unless the datamanager can't access the SD card, etc.\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: Cannot access SD card\");\n+\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: Cannot access SD card\");\n \t\t\treturn false;\n \t\t}\n \n@@ -276,7 +276,7 @@ MissionFeasibilityChecker::checkMissionItemValidity(const mission_s &mission)\n \t\t    missionitem.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n \t\t    missionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n \n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: item %i: unsupported cmd: %d\", (int)(i + 1),\n+\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: item %i: unsupported cmd: %d\", (int)(i + 1),\n \t\t\t\t\t     (int)missionitem.nav_cmd);\n \t\t\treturn false;\n \t\t}\n@@ -286,14 +286,14 @@ MissionFeasibilityChecker::checkMissionItemValidity(const mission_s &mission)\n \n \t\t\t/* check actuator number */\n \t\t\tif (missionitem.params[0] < 0 || missionitem.params[0] > 5) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Actuator number %d is out of bounds 0..5\",\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Actuator number %d is out of bounds 0..5\",\n \t\t\t\t\t\t     (int)missionitem.params[0]);\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\t/* check actuator value */\n \t\t\tif (missionitem.params[1] < -PWM_DEFAULT_MAX || missionitem.params[1] > PWM_DEFAULT_MAX) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub,\n \t\t\t\t\t\t     \"Actuator value %d is out of bounds -PWM_DEFAULT_MAX..PWM_DEFAULT_MAX\", (int)missionitem.params[1]);\n \t\t\t\treturn false;\n \t\t\t}\n@@ -302,7 +302,7 @@ MissionFeasibilityChecker::checkMissionItemValidity(const mission_s &mission)\n \t\t// check if the mission starts with a land command while the vehicle is landed\n \t\tif ((i == 0) && missionitem.nav_cmd == NAV_CMD_LAND && _navigator->get_land_detected()->landed) {\n \n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: starts with landing\");\n+\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: starts with landing\");\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -343,7 +343,7 @@ MissionFeasibilityChecker::checkTakeoff(const mission_s &mission, float home_alt\n \t\t\t}\n \n \t\t\tif (takeoff_alt - 1.0f < acceptance_radius) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: Takeoff altitude too low!\");\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: Takeoff altitude too low!\");\n \t\t\t\treturn false;\n \t\t\t}\n \n@@ -413,14 +413,14 @@ MissionFeasibilityChecker::checkTakeoff(const mission_s &mission, float home_alt\n \t\t// MIS_TAKEOFF_REQ param has to be set and the vehicle has to be landed - one can load a mission\n \t\t// while the vehicle is flying and it does not require a takeoff waypoint\n \t\tif (!has_takeoff) {\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: takeoff waypoint required.\");\n+\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: takeoff waypoint required.\");\n \t\t\treturn false;\n \n \t\t} else if (!takeoff_first) {\n \t\t\t// check if the takeoff waypoint is the first waypoint item on the mission\n \t\t\t// i.e, an item with position/attitude change modification\n \t\t\t// if it is not, the mission should be rejected\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: takeoff not first waypoint item\");\n+\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: takeoff not first waypoint item\");\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -453,7 +453,7 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \t\t// if DO_LAND_START found then require valid landing AFTER\n \t\tif (missionitem.nav_cmd == NAV_CMD_DO_LAND_START) {\n \t\t\tif (land_start_found) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: more than one land start.\");\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: more than one land start.\");\n \t\t\t\treturn false;\n \n \t\t\t} else {\n@@ -495,12 +495,12 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \n \t\t\t\t\t\t\tif (missionitem_previous.altitude > slope_alt_req + 1.0f) {\n \t\t\t\t\t\t\t\t/* Landing waypoint is above altitude of slope at the given waypoint distance (with small tolerance for floating point discrepancies) */\n-\t\t\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: adjust landing approach.\");\n+\t\t\t\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: adjust landing approach.\");\n \n \t\t\t\t\t\t\t\tconst float wp_distance_req = Landingslope::getLandingSlopeWPDistance(missionitem_previous.altitude,\n \t\t\t\t\t\t\t\t\t\t\t      missionitem.altitude, horizontal_slope_displacement, slope_angle_rad);\n \n-\t\t\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Move down %d m or move further away by %d m.\",\n+\t\t\t\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Move down %d m or move further away by %d m.\",\n \t\t\t\t\t\t\t\t\t\t     (int)ceilf(slope_alt_req - missionitem_previous.altitude),\n \t\t\t\t\t\t\t\t\t\t     (int)ceilf(wp_distance_req - wp_distance));\n \n@@ -509,45 +509,45 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t/* Landing waypoint is above last waypoint */\n-\t\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: landing above last waypoint.\");\n+\t\t\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: landing above last waypoint.\");\n \t\t\t\t\t\t\treturn false;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t} else {\n \t\t\t\t\t\t/* Last wp is in flare region */\n-\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: waypoint within landing flare.\");\n+\t\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: waypoint within landing flare.\");\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \n \t\t\t\t\tlanding_valid = true;\n \n \t\t\t\t} else {\n \t\t\t\t\t// mission item before land doesn't have a position\n-\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: need landing approach.\");\n+\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: need landing approach.\");\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \n \t\t\t} else {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: starts with land waypoint.\");\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: starts with land waypoint.\");\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t} else if (missionitem.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH) {\n \t\t\tif (land_start_found && do_land_start_index < i) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub,\n \t\t\t\t\t\t     \"Mission rejected: land start item before RTL item not possible.\");\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n \t}\n \n \tif (land_start_req && !land_start_found) {\n-\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: landing pattern required.\");\n+\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: landing pattern required.\");\n \t\treturn false;\n \t}\n \n \tif (land_start_found && (!landing_valid || (do_land_start_index > landing_approach_index))) {\n-\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: invalid land start.\");\n+\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: invalid land start.\");\n \t\treturn false;\n \t}\n \n@@ -577,7 +577,7 @@ MissionFeasibilityChecker::checkVTOLLanding(const mission_s &mission, bool land_\n \t\t// if DO_LAND_START found then require valid landing AFTER\n \t\tif (missionitem.nav_cmd == NAV_CMD_DO_LAND_START) {\n \t\t\tif (land_start_found) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: more than one land start.\");\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: more than one land start.\");\n \t\t\t\treturn false;\n \n \t\t\t} else {\n@@ -599,26 +599,26 @@ MissionFeasibilityChecker::checkVTOLLanding(const mission_s &mission, bool land_\n \n \n \t\t\t} else {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: starts with land waypoint.\");\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: starts with land waypoint.\");\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t} else if (missionitem.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH) {\n \t\t\tif (land_start_found && do_land_start_index < i) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub,\n \t\t\t\t\t\t     \"Mission rejected: land start item before RTL item not possible.\");\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n \t}\n \n \tif (land_start_req && !land_start_found) {\n-\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: landing pattern required.\");\n+\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: landing pattern required.\");\n \t\treturn false;\n \t}\n \n \tif (land_start_found && (do_land_start_index > landing_approach_index)) {\n-\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: invalid land start.\");\n+\t\tmavlink_log_critical(&_mavlink_log_pub, \"Mission rejected: invalid land start.\");\n \t\treturn false;\n \t}\n \n@@ -641,7 +641,7 @@ MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission\n \n \t\tif (!(dm_read((dm_item_t)mission.dataman_id, i, &mission_item, sizeof(mission_item_s)) == sizeof(mission_item_s))) {\n \t\t\t/* error reading, mission is invalid */\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Error reading offboard mission.\");\n+\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Error reading offboard mission.\");\n \t\t\treturn false;\n \t\t}\n \n@@ -661,11 +661,11 @@ MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission\n \n \t\t} else {\n \t\t\t/* item is too far from home */\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n+\t\t\tmavlink_log_critical(&_mavlink_log_pub,\n \t\t\t\t\t     \"First waypoint too far away: %d meters, %d max.\",\n \t\t\t\t\t     (int)dist_to_1wp, (int)max_distance);\n \n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t//_navigator->get_mission_result()->warning = true;\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -693,7 +693,7 @@ MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &missi\n \n \t\tif (!(dm_read((dm_item_t)mission.dataman_id, i, &mission_item, sizeof(mission_item_s)) == sizeof(mission_item_s))) {\n \t\t\t/* error reading, mission is invalid */\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Error reading offboard mission.\");\n+\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Error reading offboard mission.\");\n \t\t\treturn false;\n \t\t}\n \n@@ -713,11 +713,11 @@ MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &missi\n \n \t\t\tif (dist_between_waypoints > max_distance) {\n \t\t\t\t/* distance between waypoints is too high */\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub,\n \t\t\t\t\t\t     \"Distance between waypoints too far: %d meters, %d max.\",\n \t\t\t\t\t\t     (int)dist_between_waypoints, (int)max_distance);\n \n-\t\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t\t//_navigator->get_mission_result()->warning = true;\n \t\t\t\treturn false;\n \n \t\t\t\t/* do not allow waypoints that are literally on top of each other */\n@@ -730,11 +730,11 @@ MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &missi\n \t\t\t\t/* Waypoints and gate are at the exact same position, which indicates an\n \t\t\t\t * invalid mission and makes calculating the direction from one waypoint\n \t\t\t\t * to another impossible. */\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n+\t\t\t\tmavlink_log_critical(&_mavlink_log_pub,\n \t\t\t\t\t\t     \"Distance between waypoint and gate too close: %d meters\",\n \t\t\t\t\t\t     (int)dist_between_waypoints);\n \n-\t\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t\t//_navigator->get_mission_result()->warning = true;\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 16,
        "deletions": 14,
        "changes": 30,
        "patch": "@@ -43,13 +43,28 @@\n #pragma once\n \n #include <dataman/dataman.h>\n+#include <lib/systemlib/mavlink_log.h>\n #include <uORB/topics/mission.h>\n \n class Geofence;\n class Navigator;\n \n class MissionFeasibilityChecker\n {\n+public:\n+\tMissionFeasibilityChecker(Navigator *navigator) : _navigator(navigator) {}\n+\t~MissionFeasibilityChecker() = default;\n+\n+\tMissionFeasibilityChecker(const MissionFeasibilityChecker &) = delete;\n+\tMissionFeasibilityChecker &operator=(const MissionFeasibilityChecker &) = delete;\n+\n+\t/*\n+\t * Returns true if mission is feasible and false otherwise\n+\t */\n+\tbool checkMissionFeasible(const mission_s &mission,\n+\t\t\t\t  float max_distance_to_1st_waypoint, float max_distance_between_waypoints,\n+\t\t\t\t  bool land_start_req);\n+\n private:\n \tNavigator *_navigator{nullptr};\n \n@@ -76,18 +91,5 @@ class MissionFeasibilityChecker\n \tbool checkVTOL(const mission_s &mission, float home_alt, bool land_start_req);\n \tbool checkVTOLLanding(const mission_s &mission, bool land_start_req);\n \n-public:\n-\tMissionFeasibilityChecker(Navigator *navigator) : _navigator(navigator) {}\n-\t~MissionFeasibilityChecker() = default;\n-\n-\tMissionFeasibilityChecker(const MissionFeasibilityChecker &) = delete;\n-\tMissionFeasibilityChecker &operator=(const MissionFeasibilityChecker &) = delete;\n-\n-\t/*\n-\t * Returns true if mission is feasible and false otherwise\n-\t */\n-\tbool checkMissionFeasible(const mission_s &mission,\n-\t\t\t\t  float max_distance_to_1st_waypoint, float max_distance_between_waypoints,\n-\t\t\t\t  bool land_start_req);\n-\n+\torb_advert_t _mavlink_log_pub{nullptr};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 15,
        "deletions": 23,
        "changes": 38,
        "patch": "@@ -67,6 +67,7 @@\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n+#include <uORB/topics/navigator_status.h>\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/position_controller_landing_status.h>\n #include <uORB/topics/position_controller_status.h>\n@@ -146,22 +147,23 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid\t\tset_can_loiter_at_sp(bool can_loiter) { _can_loiter_at_sp = can_loiter; }\n \tvoid\t\tset_position_setpoint_triplet_updated() { _pos_sp_triplet_updated = true; }\n-\tvoid\t\tset_mission_result_updated() { _mission_result_updated = true; }\n+\tvoid\t\tnavigator_status_updated() { _navigator_status_updated = true; }\n \n \t/**\n \t * Getters\n \t */\n-\tstruct home_position_s *get_home_position() { return &_home_pos; }\n-\tstruct mission_result_s *get_mission_result() { return &_mission_result; }\n-\tstruct position_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n-\tstruct position_setpoint_triplet_s *get_reposition_triplet() { return &_reposition_triplet; }\n-\tstruct position_setpoint_triplet_s *get_takeoff_triplet() { return &_takeoff_triplet; }\n-\tstruct vehicle_global_position_s *get_global_position() { return &_global_pos; }\n-\tstruct vehicle_land_detected_s *get_land_detected() { return &_land_detected; }\n-\tstruct vehicle_local_position_s *get_local_position() { return &_local_pos; }\n-\tstruct vehicle_status_s *get_vstatus() { return &_vstatus; }\n+\thome_position_s *get_home_position() { return &_home_pos; }\n+\tposition_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n+\tposition_setpoint_triplet_s *get_reposition_triplet() { return &_reposition_triplet; }\n+\tposition_setpoint_triplet_s *get_takeoff_triplet() { return &_takeoff_triplet; }\n+\tvehicle_global_position_s *get_global_position() { return &_global_pos; }\n+\tvehicle_land_detected_s *get_land_detected() { return &_land_detected; }\n+\tvehicle_local_position_s *get_local_position() { return &_local_pos; }\n+\tvehicle_status_s *get_vstatus() { return &_vstatus; }\n \tPrecLand *get_precland() { return &_precland; } /**< allow others, e.g. Mission, to use the precision land block */\n \n+\tnavigator_status_s &navigator_status() { return _navigator_status; }\n+\n \tconst vehicle_roi_s &get_vroi() { return _vroi; }\n \tvoid reset_vroi() { _vroi = {}; }\n \n@@ -259,11 +261,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \torb_advert_t\t*get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n-\tvoid\t\tincrement_mission_instance_count() { _mission_result.instance_count++; }\n-\tint\t\tmission_instance_count() const { return _mission_result.instance_count; }\n-\n-\tvoid \t\tset_mission_failure(const char *reason);\n-\n \tvoid \t\tsetMissionLandingInProgress(bool in_progress) { _mission_landing_in_progress = in_progress; }\n \n \tbool \t\tgetMissionLandingInProgress() { return _mission_landing_in_progress; }\n@@ -346,7 +343,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tuORB::SubscriptionData<position_controller_status_s>\t_position_controller_status_sub{ORB_ID(position_controller_status)};\n \n \tuORB::Publication<geofence_result_s>\t\t_geofence_result_pub{ORB_ID(geofence_result)};\n-\tuORB::Publication<mission_result_s>\t\t_mission_result_pub{ORB_ID(mission_result)};\n+\tuORB::Publication<navigator_status_s>\t\t_navigator_status_pub{ORB_ID(navigator_status)};\n \tuORB::Publication<position_setpoint_triplet_s>\t_pos_sp_triplet_pub{ORB_ID(position_setpoint_triplet)};\n \tuORB::Publication<vehicle_roi_s>\t\t_vehicle_roi_pub{ORB_ID(vehicle_roi)};\n \n@@ -357,7 +354,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \t// Subscriptions\n \thome_position_s\t\t\t\t\t_home_pos{};\t\t/**< home position for RTL */\n-\tmission_result_s\t\t\t\t_mission_result{};\n+\tnavigator_status_s\t\t\t\t_navigator_status{};\n \tvehicle_global_position_s\t\t\t_global_pos{};\t\t/**< global vehicle position */\n \tvehicle_gps_position_s\t\t\t\t_gps_pos{};\t\t/**< gps position */\n \tvehicle_land_detected_s\t\t\t\t_land_detected{};\t/**< vehicle land_detected */\n@@ -383,7 +380,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool\t\t_can_loiter_at_sp{false};\t\t\t/**< flags if current position SP can be used to loiter */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t/**< flags if position SP triplet needs to be published */\n \tbool \t\t_pos_sp_triplet_published_invalid_once{false};\t/**< flags if position SP triplet has been published once to UORB */\n-\tbool\t\t_mission_result_updated{false};\t\t/**< flags if mission result has seen an update */\n+\tbool\t\t_navigator_status_updated{false};\n \n \tNavigatorMode\t*_navigation_mode{nullptr};\t\t/**< abstract pointer to current navigation mode class */\n \tMission\t\t_mission;\t\t\t/**< class that handles the missions */\n@@ -418,10 +415,5 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid\t\tpublish_position_setpoint_triplet();\n \n-\t/**\n-\t * Publish the mission result so commander and mavlink know what is going on\n-\t */\n-\tvoid\t\tpublish_mission_result();\n-\n \tvoid\t\tpublish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_t result);\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 32,
        "changes": 43,
        "patch": "@@ -403,7 +403,7 @@ Navigator::run()\n \t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_s::VEHICLE_CMD_RESULT_ACCEPTED);\n \n \t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n-\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n+\t\t\t\tif (_mission.mission_valid() && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n \t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n \t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n \t\t\t\t\t}\n@@ -653,9 +653,6 @@ Navigator::run()\n \t\t\tnavigation_mode_new = nullptr;\n \t\t}\n \n-\t\t// update the vehicle status\n-\t\t_previous_nav_state = _vstatus.nav_state;\n-\n \t\t/* we have a new navigation mode: reset triplet */\n \t\tif (_navigation_mode != navigation_mode_new) {\n \t\t\t// We don't reset the triplet if we just did an auto-takeoff and are now\n@@ -689,10 +686,18 @@ Navigator::run()\n \t\t\tpublish_position_setpoint_triplet();\n \t\t}\n \n-\t\tif (_mission_result_updated) {\n-\t\t\tpublish_mission_result();\n+\t\tif (_navigator_status_updated || (_navigator_status.nav_state != _vstatus.nav_state)) {\n+\t\t\t_navigator_status.nav_state = _vstatus.nav_state;\n+\t\t\t_navigator_status.nav_state_prev = _previous_nav_state;\n+\n+\t\t\t_navigator_status.timestamp = hrt_absolute_time();\n+\t\t\t_navigator_status_pub.publish(_navigator_status);\n+\t\t\t_navigator_status_updated = false;\n \t\t}\n \n+\t\t// update the vehicle status\n+\t\t_previous_nav_state = _vstatus.nav_state;\n+\n \t\tperf_end(_loop_perf);\n \t}\n }\n@@ -1307,32 +1312,6 @@ int navigator_main(int argc, char *argv[])\n \treturn Navigator::main(argc, argv);\n }\n \n-void\n-Navigator::publish_mission_result()\n-{\n-\t_mission_result.timestamp = hrt_absolute_time();\n-\n-\t/* lazily publish the mission result only once available */\n-\t_mission_result_pub.publish(_mission_result);\n-\n-\t/* reset some of the flags */\n-\t_mission_result.item_do_jump_changed = false;\n-\t_mission_result.item_changed_index = 0;\n-\t_mission_result.item_do_jump_remaining = 0;\n-\n-\t_mission_result_updated = false;\n-}\n-\n-void\n-Navigator::set_mission_failure(const char *reason)\n-{\n-\tif (!_mission_result.failure) {\n-\t\t_mission_result.failure = true;\n-\t\tset_mission_result_updated();\n-\t\tmavlink_log_critical(&_mavlink_log_pub, \"%s\", reason);\n-\t}\n-}\n-\n void\n Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_mode.cpp": {
        "filename": "src/modules/navigator/navigator_mode.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -56,8 +56,7 @@ NavigatorMode::run(bool active)\n \tif (active) {\n \t\tif (!_active) {\n \t\t\t/* first run, reset stay in failsafe flag */\n-\t\t\t_navigator->get_mission_result()->stay_in_failsafe = false;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->navigator_status_updated();\n \t\t\ton_activation();\n \n \t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Fnavigator_mode.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "patch": "@@ -61,9 +61,9 @@ Takeoff::on_active()\n \t\t// reset the position\n \t\tset_takeoff_position();\n \n-\t} else if (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t} else if (is_mission_item_reached() && !_navigator->navigator_status().finished) {\n+\t\t_navigator->navigator_status().finished = true;\n+\t\t_navigator->navigator_status_updated();\n \n \t\t// set loiter item so position controllers stop doing takeoff logic\n \t\tset_loiter_item(&_mission_item);\n@@ -120,8 +120,8 @@ Takeoff::set_takeoff_position()\n \n \t// set current mission item to takeoff\n \tset_takeoff_item(&_mission_item, abs_altitude);\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->set_mission_result_updated();\n+\t_navigator->navigator_status().finished = false;\n+\t_navigator->navigator_status_updated();\n \treset_mission_item_reached();\n \n \t// convert mission item to current setpoint",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/faef13fae40ac1333f08404a06b8a88d28b79a1f/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_mission",
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "MissionBlock::is_mission_item_reached",
        "GpsFailure::set_gpsf_item",
        "publish_mission_result",
        "Land::on_active",
        "Takeoff::set_takeoff_position",
        "Mission::set_execution_mode",
        "Mission::landing",
        "Mission::check_mission_valid",
        "MissionFeasibilityChecker::checkTakeoff",
        "MissionFeasibilityChecker::checkGeofence",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "Mission::position_setpoint_equal",
        "set_mission_result_updated",
        "NavigatorMode::run",
        "MissionFeasibilityChecker::checkVTOLLanding",
        "Mission::on_active",
        "MissionFeasibilityChecker::checkHomePositionAltitude",
        "Mission::on_inactive",
        "Navigator::run",
        "Mission::on_activation",
        "increment_mission_instance_count",
        "MissionFeasibilityChecker::checkMissionFeasible",
        "Land::on_activation",
        "Mission::report_do_jump_mission_changed",
        "Mission::set_mission_item_reached",
        "Takeoff::on_active",
        "set_mission_failure",
        "MissionFeasibilityChecker::checkDistancesBetweenWaypoints",
        "MissionFeasibilityChecker::checkDistanceToFirstWaypoint",
        "mission_instance_count",
        "Mission::set_mission_items",
        "Mission::on_inactivation"
      ],
      "by_file": {
        "src/modules/navigator/gpsfailure.cpp": [
          "GpsFailure::set_gpsf_item"
        ],
        "src/modules/navigator/land.cpp": [
          "Land::on_activation",
          "Land::on_active"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::update_mission",
          "Mission::on_active",
          "Mission::on_inactive",
          "Mission::on_activation",
          "Mission::report_do_jump_mission_changed",
          "Mission::set_mission_item_reached",
          "Mission::set_execution_mode",
          "Mission::landing",
          "Mission::check_mission_valid",
          "Mission::position_setpoint_equal",
          "Mission::set_mission_items",
          "Mission::on_inactivation"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding",
          "MissionFeasibilityChecker::checkVTOLLanding",
          "MissionFeasibilityChecker::checkHomePositionAltitude",
          "MissionFeasibilityChecker::checkMissionFeasible",
          "MissionFeasibilityChecker::checkDistancesBetweenWaypoints",
          "MissionFeasibilityChecker::checkTakeoff",
          "MissionFeasibilityChecker::checkGeofence",
          "MissionFeasibilityChecker::checkDistanceToFirstWaypoint",
          "MissionFeasibilityChecker::checkMissionItemValidity"
        ],
        "src/modules/navigator/navigator.h": [
          "increment_mission_instance_count",
          "publish_mission_result",
          "set_mission_failure",
          "mission_instance_count",
          "set_mission_result_updated"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/navigator_mode.cpp": [
          "NavigatorMode::run"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active",
          "Takeoff::set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "[WIP]: move \"Follow Me\" out of navigator to flight_mode_manager",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17029",
    "number": 17029,
    "created_at": "2021-03-05T15:30:35Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This is the next little piece on the long road to unified flight mode handling and turning navigator into a simple \"mission manager\".\r\n\r\n - follow navigator navigation state moves entirely into a flight task (flight mode)\r\n - position_setpoint_triplet remove velocity and yawspeed setpoints (now position only)\r\n\r\nTODO\r\n - fully test FOLLOW",
      "issue_comments": [
        {
          "author": "potaito",
          "created_at": "2021-03-30T14:36:38Z",
          "body": "This is awesome Daniel, thanks for doing this! Particularly the reduced number of fields in `msg/position_setpoint.msg`",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-03-30T14:43:19Z",
          "body": "> This is awesome Daniel, thanks for doing this! Particularly the reduced number of fields in `msg/position_setpoint.msg`\r\n\r\nThanks @potaito, any suggestions for testing? I need a simple test case to work through the remaining details and ensure there are no regressions.",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2021-03-31T09:07:41Z",
          "body": "> > This is awesome Daniel, thanks for doing this! Particularly the reduced number of fields in `msg/position_setpoint.msg`\r\n> \r\n> Thanks @potaito, any suggestions for testing? I need a simple test case to work through the remaining details and ensure there are no regressions.\r\n\r\nNo suggestion from me right now. I'm about to test \"Follow Me\" with the old implementation once I figure out how to stream GPS from my ground station to the drone. :sweat_smile: \r\nOnce I have that, I would just hop on a bicycle, go to an open field and have the drone follow me.",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2021-04-01T12:51:25Z",
          "body": "I can test it in simulation. Got a python script with a moving target. Is there any other test that we need @dagar ?",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2021-04-01T13:18:02Z",
          "body": "Hm just tried with jmavsim and the drone did not move after takeoff: https://logs.px4.io/plot_app?log=764e59d1-a728-4aa9-b744-8f8c95bbdc06\r\n\r\nAnd here's the same simulation with current master, where the drone is moving: https://logs.px4.io/plot_app?log=be67163b-dd12-4836-97fd-53004f4946ed\r\n\r\nThe script I used for simulating is this one: https://gist.github.com/potaito/6d1db7471c0428f3a7e2342d6e34130d\r\nJust need `pip3 install mavsdk`",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-04-01T13:23:07Z",
          "body": "> Hm just tried with jmavsim and the drone did not move after takeoff: https://logs.px4.io/plot_app?log=764e59d1-a728-4aa9-b744-8f8c95bbdc06\r\n\r\nI should have been more clear, this is the bulk of the move with a few key pieces of logic still missing before it will actually work. \r\n\r\nhttps://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src/modules/flight_mode_manager/tasks/AutoFollowMe/FlightTaskAutoFollowMe.cpp#L215-L219\r\n\r\nMy next step was figuring out how to effectively test in simulation so I could fill in the remaining TODOs. ",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2021-04-01T13:37:40Z",
          "body": "Right, the PR even says \"draft\" :sweat_smile: \r\nThe script I posted above is simply using mavSDK to publish the FOLLOW_TARGET mavlink message for a simulated target.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-04-01T13:41:50Z",
          "body": "> Right, the PR even says \"draft\" \r\n> The script I posted above is simply using mavSDK to publish the FOLLOW_TARGET mavlink message for a simulated target.\r\n\r\nThanks that's exactly what I needed. I'll finish this once v1.12 is out the door.",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2021-08-05T08:36:25Z",
          "body": "Closing in favour of https://github.com/PX4/PX4-Autopilot/pull/18026",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR is a work-in-progress refactor that relocates 'Follow Me' logic and trims setpoint fields rather than a focused bug fix. Comments and test logs show the feature is incomplete (key logic TODOs remain and the sim showed the drone did not move), and the PR was later closed in favor of another, so it does not resolve a concrete logic error.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -50,7 +50,6 @@ px4_add_module(\n \t\tgeofence.cpp\n \t\tenginefailure.cpp\n \t\tgpsfailure.cpp\n-\t\tfollow_target.cpp\n \tDEPENDS\n \t\tgit_ecl\n \t\tecl_geo\n@@ -59,4 +58,4 @@ px4_add_module(\n \t\tmotion_planning\n \t)\n \n-px4_add_functional_gtest(SRC RangeRTLTest.cpp LINKLIBS modules__navigator modules__dataman)\n\\ No newline at end of file\n+px4_add_functional_gtest(SRC RangeRTLTest.cpp LINKLIBS modules__navigator modules__dataman)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 398,
        "changes": 398,
        "patch": "@@ -1,398 +0,0 @@\n-/****************************************************************************\n- *\n- *   Copyright (c) 2013-2016 PX4 Development Team. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- * 3. Neither the name PX4 nor the names of its contributors may be\n- *    used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- *\n- ****************************************************************************/\n-/**\n- * @file followme.cpp\n- *\n- * Helper class to track and follow a given position\n- *\n- * @author Jimmy Johnson <catch22@fastmail.net>\n- */\n-\n-#include \"follow_target.h\"\n-\n-#include <string.h>\n-#include <stdlib.h>\n-#include <stdbool.h>\n-#include <math.h>\n-#include <fcntl.h>\n-\n-#include <systemlib/err.h>\n-\n-#include <uORB/uORB.h>\n-#include <uORB/topics/position_setpoint_triplet.h>\n-#include <uORB/topics/follow_target.h>\n-#include <lib/ecl/geo/geo.h>\n-#include <lib/mathlib/math/Limits.hpp>\n-\n-#include \"navigator.h\"\n-\n-using namespace matrix;\n-\n-constexpr float FollowTarget::_follow_position_matricies[4][9];\n-\n-FollowTarget::FollowTarget(Navigator *navigator) :\n-\tMissionBlock(navigator),\n-\tModuleParams(navigator)\n-{\n-\t_current_vel.zero();\n-\t_step_vel.zero();\n-\t_est_target_vel.zero();\n-\t_target_distance.zero();\n-\t_target_position_offset.zero();\n-\t_target_position_delta.zero();\n-}\n-\n-void FollowTarget::on_inactive()\n-{\n-\treset_target_validity();\n-}\n-\n-void FollowTarget::on_activation()\n-{\n-\t_follow_offset = _param_nav_ft_dst.get() < 1.0F ? 1.0F : _param_nav_ft_dst.get();\n-\n-\t_responsiveness = math::constrain((float) _param_nav_ft_rs.get(), .1F, 1.0F);\n-\n-\t_follow_target_position = _param_nav_ft_fs.get();\n-\n-\tif ((_follow_target_position > FOLLOW_FROM_LEFT) || (_follow_target_position < FOLLOW_FROM_RIGHT)) {\n-\t\t_follow_target_position = FOLLOW_FROM_BEHIND;\n-\t}\n-\n-\t_rot_matrix = Dcmf(_follow_position_matricies[_follow_target_position]);\n-}\n-\n-void FollowTarget::on_active()\n-{\n-\tstruct map_projection_reference_s target_ref;\n-\tfollow_target_s target_motion_with_offset = {};\n-\tuint64_t current_time = hrt_absolute_time();\n-\tbool _radius_entered = false;\n-\tbool _radius_exited = false;\n-\tbool updated = false;\n-\tfloat dt_ms = 0;\n-\n-\tif (_follow_target_sub.updated()) {\n-\t\tfollow_target_s target_motion;\n-\n-\t\t_target_updates++;\n-\n-\t\t// save last known motion topic\n-\n-\t\t_previous_target_motion = _current_target_motion;\n-\n-\t\t_follow_target_sub.copy(&target_motion);\n-\n-\t\tif (_current_target_motion.timestamp == 0) {\n-\t\t\t_current_target_motion = target_motion;\n-\t\t}\n-\n-\t\t_current_target_motion.timestamp = target_motion.timestamp;\n-\t\t_current_target_motion.lat = (_current_target_motion.lat * (double)_responsiveness) + target_motion.lat * (double)(\n-\t\t\t\t\t\t     1 - _responsiveness);\n-\t\t_current_target_motion.lon = (_current_target_motion.lon * (double)_responsiveness) + target_motion.lon * (double)(\n-\t\t\t\t\t\t     1 - _responsiveness);\n-\n-\t} else if (((current_time - _current_target_motion.timestamp) / 1000) > TARGET_TIMEOUT_MS && target_velocity_valid()) {\n-\t\treset_target_validity();\n-\t}\n-\n-\t// update distance to target\n-\n-\tif (target_position_valid()) {\n-\n-\t\t// get distance to target\n-\n-\t\tmap_projection_init(&target_ref, _navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n-\t\tmap_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon, &_target_distance(0),\n-\t\t\t\t       &_target_distance(1));\n-\n-\t}\n-\n-\t// update target velocity\n-\n-\tif (target_velocity_valid() && updated) {\n-\n-\t\tdt_ms = ((_current_target_motion.timestamp - _previous_target_motion.timestamp) / 1000);\n-\n-\t\t// ignore a small dt\n-\t\tif (dt_ms > 10.0F) {\n-\t\t\t// get last gps known reference for target\n-\t\t\tmap_projection_init(&target_ref, _previous_target_motion.lat, _previous_target_motion.lon);\n-\n-\t\t\t// calculate distance the target has moved\n-\t\t\tmap_projection_project(&target_ref, _current_target_motion.lat, _current_target_motion.lon,\n-\t\t\t\t\t       &(_target_position_delta(0)), &(_target_position_delta(1)));\n-\n-\t\t\t// update the average velocity of the target based on the position\n-\t\t\t_est_target_vel = _target_position_delta / (dt_ms / 1000.0f);\n-\n-\t\t\t// if the target is moving add an offset and rotation\n-\t\t\tif (_est_target_vel.length() > .5F) {\n-\t\t\t\t_target_position_offset = _rot_matrix * _est_target_vel.normalized() * _follow_offset;\n-\t\t\t}\n-\n-\t\t\t// are we within the target acceptance radius?\n-\t\t\t// give a buffer to exit/enter the radius to give the velocity controller\n-\t\t\t// a chance to catch up\n-\n-\t\t\t_radius_exited = ((_target_position_offset + _target_distance).length() > (float) TARGET_ACCEPTANCE_RADIUS_M * 1.5f);\n-\t\t\t_radius_entered = ((_target_position_offset + _target_distance).length() < (float) TARGET_ACCEPTANCE_RADIUS_M);\n-\n-\t\t\t// to keep the velocity increase/decrease smooth\n-\t\t\t// calculate how many velocity increments/decrements\n-\t\t\t// it will take to reach the targets velocity\n-\t\t\t// with the given amount of steps also add a feed forward input that adjusts the\n-\t\t\t// velocity as the position gap increases since\n-\t\t\t// just traveling at the exact velocity of the target will not\n-\t\t\t// get any closer or farther from the target\n-\n-\t\t\t_step_vel = (_est_target_vel - _current_vel) + (_target_position_offset + _target_distance) * FF_K;\n-\t\t\t_step_vel /= (dt_ms / 1000.0F * (float) INTERPOLATION_PNTS);\n-\t\t\t_step_time_in_ms = (dt_ms / (float) INTERPOLATION_PNTS);\n-\n-\t\t\t// if we are less than 1 meter from the target don't worry about trying to yaw\n-\t\t\t// lock the yaw until we are at a distance that makes sense\n-\n-\t\t\tif ((_target_distance).length() > 1.0F) {\n-\n-\t\t\t\t// yaw rate smoothing\n-\n-\t\t\t\t// this really needs to control the yaw rate directly in the attitude pid controller\n-\t\t\t\t// but seems to work ok for now since the yaw rate cannot be controlled directly in auto mode\n-\n-\t\t\t\t_yaw_angle = get_bearing_to_next_waypoint(_navigator->get_global_position()->lat,\n-\t\t\t\t\t\t_navigator->get_global_position()->lon,\n-\t\t\t\t\t\t_current_target_motion.lat,\n-\t\t\t\t\t\t_current_target_motion.lon);\n-\n-\t\t\t\t_yaw_rate = wrap_pi((_yaw_angle - _navigator->get_local_position()->heading) / (dt_ms / 1000.0f));\n-\n-\t\t\t} else {\n-\t\t\t\t_yaw_angle = _yaw_rate = NAN;\n-\t\t\t}\n-\t\t}\n-\n-//\t\twarnx(\" _step_vel x %3.6f y %3.6f cur vel %3.6f %3.6f tar vel %3.6f %3.6f dist = %3.6f (%3.6f) mode = %d yaw rate = %3.6f\",\n-//\t\t\t\t(double) _step_vel(0),\n-//\t\t\t\t(double) _step_vel(1),\n-//\t\t\t\t(double) _current_vel(0),\n-//\t\t\t\t(double) _current_vel(1),\n-//\t\t\t\t(double) _est_target_vel(0),\n-//\t\t\t\t(double) _est_target_vel(1),\n-//\t\t\t\t(double) (_target_distance).length(),\n-//\t\t\t\t(double) (_target_position_offset + _target_distance).length(),\n-//\t\t\t\t_follow_target_state,\n-//\t\t\t\t(double) _yaw_rate);\n-\t}\n-\n-\tif (target_position_valid()) {\n-\n-\t\t// get the target position using the calculated offset\n-\n-\t\tmap_projection_init(&target_ref,  _current_target_motion.lat, _current_target_motion.lon);\n-\t\tmap_projection_reproject(&target_ref, _target_position_offset(0), _target_position_offset(1),\n-\t\t\t\t\t &target_motion_with_offset.lat, &target_motion_with_offset.lon);\n-\t}\n-\n-\t// clamp yaw rate smoothing if we are with in\n-\t// 3 degrees of facing target\n-\n-\tif (PX4_ISFINITE(_yaw_rate)) {\n-\t\tif (fabsf(fabsf(_yaw_angle) - fabsf(_navigator->get_local_position()->heading)) < math::radians(3.0F)) {\n-\t\t\t_yaw_rate = NAN;\n-\t\t}\n-\t}\n-\n-\t// update state machine\n-\n-\tswitch (_follow_target_state) {\n-\n-\tcase TRACK_POSITION: {\n-\n-\t\t\tif (_radius_entered) {\n-\t\t\t\t_follow_target_state = TRACK_VELOCITY;\n-\n-\t\t\t} else if (target_velocity_valid()) {\n-\t\t\t\tset_follow_target_item(&_mission_item, _param_nav_min_ft_ht.get(), target_motion_with_offset, _yaw_angle);\n-\t\t\t\t// keep the current velocity updated with the target velocity for when it's needed\n-\t\t\t\t_current_vel = _est_target_vel;\n-\n-\t\t\t\tupdate_position_sp(true, true, _yaw_rate);\n-\n-\t\t\t} else {\n-\t\t\t\t_follow_target_state = SET_WAIT_FOR_TARGET_POSITION;\n-\t\t\t}\n-\n-\t\t\tbreak;\n-\t\t}\n-\n-\tcase TRACK_VELOCITY: {\n-\n-\t\t\tif (_radius_exited) {\n-\t\t\t\t_follow_target_state = TRACK_POSITION;\n-\n-\t\t\t} else if (target_velocity_valid()) {\n-\n-\t\t\t\tif ((float)(current_time - _last_update_time) / 1000.0f >= _step_time_in_ms) {\n-\t\t\t\t\t_current_vel += _step_vel;\n-\t\t\t\t\t_last_update_time = current_time;\n-\t\t\t\t}\n-\n-\t\t\t\tset_follow_target_item(&_mission_item, _param_nav_min_ft_ht.get(), target_motion_with_offset, _yaw_angle);\n-\n-\t\t\t\tupdate_position_sp(true, false, _yaw_rate);\n-\n-\t\t\t} else {\n-\t\t\t\t_follow_target_state = SET_WAIT_FOR_TARGET_POSITION;\n-\t\t\t}\n-\n-\t\t\tbreak;\n-\t\t}\n-\n-\tcase SET_WAIT_FOR_TARGET_POSITION: {\n-\n-\t\t\t// Climb to the minimum altitude\n-\t\t\t// and wait until a position is received\n-\n-\t\t\tfollow_target_s target = {};\n-\n-\t\t\t// for now set the target at the minimum height above the uav\n-\n-\t\t\ttarget.lat = _navigator->get_global_position()->lat;\n-\t\t\ttarget.lon = _navigator->get_global_position()->lon;\n-\t\t\ttarget.alt = 0.0F;\n-\n-\t\t\tset_follow_target_item(&_mission_item, _param_nav_min_ft_ht.get(), target, _yaw_angle);\n-\n-\t\t\tupdate_position_sp(false, false, _yaw_rate);\n-\n-\t\t\t_follow_target_state = WAIT_FOR_TARGET_POSITION;\n-\t\t}\n-\n-\t/* FALLTHROUGH */\n-\n-\tcase WAIT_FOR_TARGET_POSITION: {\n-\n-\t\t\tif (is_mission_item_reached() && target_velocity_valid()) {\n-\t\t\t\t_target_position_offset(0) = _follow_offset;\n-\t\t\t\t_follow_target_state = TRACK_POSITION;\n-\t\t\t}\n-\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-}\n-\n-void FollowTarget::update_position_sp(bool use_velocity, bool use_position, float yaw_rate)\n-{\n-\t// convert mission item to current setpoint\n-\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\t// activate line following in pos control if position is valid\n-\n-\tpos_sp_triplet->previous.valid = use_position;\n-\tpos_sp_triplet->previous = pos_sp_triplet->current;\n-\tmission_apply_limitation(_mission_item);\n-\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n-\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_FOLLOW_TARGET;\n-\tpos_sp_triplet->current.velocity_valid = use_velocity;\n-\tpos_sp_triplet->current.vx = _current_vel(0);\n-\tpos_sp_triplet->current.vy = _current_vel(1);\n-\tpos_sp_triplet->next.valid = false;\n-\tpos_sp_triplet->current.yawspeed_valid = PX4_ISFINITE(yaw_rate);\n-\tpos_sp_triplet->current.yawspeed = yaw_rate;\n-\t_navigator->set_position_setpoint_triplet_updated();\n-}\n-\n-void FollowTarget::reset_target_validity()\n-{\n-\t_yaw_rate = NAN;\n-\t_previous_target_motion = {};\n-\t_current_target_motion = {};\n-\t_target_updates = 0;\n-\t_current_vel.zero();\n-\t_step_vel.zero();\n-\t_est_target_vel.zero();\n-\t_target_distance.zero();\n-\t_target_position_offset.zero();\n-\treset_mission_item_reached();\n-\t_follow_target_state = SET_WAIT_FOR_TARGET_POSITION;\n-}\n-\n-bool FollowTarget::target_velocity_valid()\n-{\n-\t// need at least 2 continuous data points for velocity estimate\n-\treturn (_target_updates >= 2);\n-}\n-\n-bool FollowTarget::target_position_valid()\n-{\n-\t// need at least 1 continuous data points for position estimate\n-\treturn (_target_updates >= 1);\n-}\n-\n-void\n-FollowTarget::set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s &target,\n-\t\t\t\t     float yaw)\n-{\n-\tif (_navigator->get_land_detected()->landed) {\n-\t\t/* landed, don't takeoff, but switch to IDLE mode */\n-\t\titem->nav_cmd = NAV_CMD_IDLE;\n-\n-\t} else {\n-\n-\t\titem->nav_cmd = NAV_CMD_DO_FOLLOW_REPOSITION;\n-\n-\t\t/* use current target position */\n-\t\titem->lat = target.lat;\n-\t\titem->lon = target.lon;\n-\t\titem->altitude = _navigator->get_home_position()->alt;\n-\n-\t\tif (min_clearance > 8.0f) {\n-\t\t\titem->altitude += min_clearance;\n-\n-\t\t} else {\n-\t\t\titem->altitude += 8.0f; // if min clearance is bad set it to 8.0 meters (well above the average height of a person)\n-\t\t}\n-\t}\n-\n-\titem->altitude_is_relative = false;\n-\titem->yaw = yaw;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n-\titem->acceptance_radius = _navigator->get_acceptance_radius();\n-\titem->time_inside = 0.0f;\n-\titem->autocontinue = false;\n-\titem->origin = ORIGIN_ONBOARD;\n-}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9a35756cd1b39a56ea94a33c98e73cb4a4415b85/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/follow_target.h": {
        "filename": "src/modules/navigator/follow_target.h",
        "status": "removed",
        "additions": 0,
        "deletions": 148,
        "changes": 148,
        "patch": "@@ -1,148 +0,0 @@\n-/***************************************************************************\n- *\n- *   Copyright (c) 2016 PX4 Development Team. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- * 3. Neither the name PX4 nor the names of its contributors may be\n- *    used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- *\n- ****************************************************************************/\n-/**\n- * @file followme.cpp\n- *\n- * Helper class to track and follow a given position\n- *\n- * @author Jimmy Johnson <catch22@fastmail.net>\n- */\n-\n-#pragma once\n-\n-#include \"navigator_mode.h\"\n-#include \"mission_block.h\"\n-\n-#include <mathlib/mathlib.h>\n-#include <matrix/math.hpp>\n-\n-#include <px4_platform_common/module_params.h>\n-#include <uORB/Subscription.hpp>\n-#include <uORB/topics/follow_target.h>\n-\n-class FollowTarget : public MissionBlock, public ModuleParams\n-{\n-\n-public:\n-\tFollowTarget(Navigator *navigator);\n-\t~FollowTarget() = default;\n-\n-\tvoid on_inactive() override;\n-\tvoid on_activation() override;\n-\tvoid on_active() override;\n-\n-private:\n-\n-\tstatic constexpr int TARGET_TIMEOUT_MS = 2500;\n-\tstatic constexpr int TARGET_ACCEPTANCE_RADIUS_M = 5;\n-\tstatic constexpr int INTERPOLATION_PNTS = 20;\n-\tstatic constexpr float FF_K = .25F;\n-\tstatic constexpr float OFFSET_M = 8;\n-\n-\tenum FollowTargetState {\n-\t\tTRACK_POSITION,\n-\t\tTRACK_VELOCITY,\n-\t\tSET_WAIT_FOR_TARGET_POSITION,\n-\t\tWAIT_FOR_TARGET_POSITION\n-\t};\n-\n-\tenum {\n-\t\tFOLLOW_FROM_RIGHT,\n-\t\tFOLLOW_FROM_BEHIND,\n-\t\tFOLLOW_FROM_FRONT,\n-\t\tFOLLOW_FROM_LEFT\n-\t};\n-\n-\tstatic constexpr float _follow_position_matricies[4][9] = {\n-\t\t{ 1.0F, -1.0F, 0.0F,  1.0F,  1.0F, 0.0F, 0.0F, 0.0F, 1.0F}, // follow right\n-\t\t{-1.0F,  0.0F, 0.0F,  0.0F, -1.0F, 0.0F, 0.0F, 0.0F, 1.0F}, // follow behind\n-\t\t{ 1.0F,  0.0F, 0.0F,  0.0F,  1.0F, 0.0F, 0.0F, 0.0F, 1.0F}, // follow front\n-\t\t{ 1.0F,  1.0F, 0.0F, -1.0F,  1.0F, 0.0F, 0.0F, 0.0F, 1.0F}  // follow left side\n-\t};\n-\n-\tDEFINE_PARAMETERS(\n-\t\t(ParamFloat<px4::params::NAV_MIN_FT_HT>) _param_nav_min_ft_ht,\n-\t\t(ParamFloat<px4::params::NAV_FT_DST>) _param_nav_ft_dst,\n-\t\t(ParamInt<px4::params::NAV_FT_FS>) _param_nav_ft_fs,\n-\t\t(ParamFloat<px4::params::NAV_FT_RS>) _param_nav_ft_rs\n-\t)\n-\n-\tFollowTargetState _follow_target_state{SET_WAIT_FOR_TARGET_POSITION};\n-\tint _follow_target_position{FOLLOW_FROM_BEHIND};\n-\n-\tuORB::Subscription _follow_target_sub{ORB_ID(follow_target)};\n-\tfloat _step_time_in_ms{0.0f};\n-\tfloat _follow_offset{OFFSET_M};\n-\n-\tuint64_t _target_updates{0};\n-\tuint64_t _last_update_time{0};\n-\n-\tmatrix::Vector3f _current_vel;\n-\tmatrix::Vector3f _step_vel;\n-\tmatrix::Vector3f _est_target_vel;\n-\tmatrix::Vector3f _target_distance;\n-\tmatrix::Vector3f _target_position_offset;\n-\tmatrix::Vector3f _target_position_delta;\n-\tmatrix::Vector3f _filtered_target_position_delta;\n-\n-\tfollow_target_s _current_target_motion{};\n-\tfollow_target_s _previous_target_motion{};\n-\n-\tfloat _yaw_rate{0.0f};\n-\tfloat _responsiveness{0.0f};\n-\tfloat _yaw_angle{0.0f};\n-\n-\t// Mavlink defined motion reporting capabilities\n-\tenum {\n-\t\tPOS = 0,\n-\t\tVEL = 1,\n-\t\tACCEL = 2,\n-\t\tATT_RATES = 3\n-\t};\n-\n-\tmatrix::Dcmf _rot_matrix;\n-\n-\tvoid track_target_position();\n-\tvoid track_target_velocity();\n-\tbool target_velocity_valid();\n-\tbool target_position_valid();\n-\tvoid reset_target_validity();\n-\tvoid update_position_sp(bool velocity_valid, bool position_valid, float yaw_rate);\n-\tvoid update_target_motion();\n-\tvoid update_target_velocity();\n-\n-\t/**\n-\t * Set follow_target item\n-\t */\n-\tvoid set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s &target, float yaw);\n-};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9a35756cd1b39a56ea94a33c98e73cb4a4415b85/src%2Fmodules%2Fnavigator%2Ffollow_target.h"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -105,7 +105,6 @@ Loiter::set_loiter_position()\n \n \t// convert mission item to current setpoint\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tpos_sp_triplet->current.velocity_valid = false;\n \tpos_sp_triplet->previous.valid = false;\n \tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n@@ -130,7 +129,6 @@ Loiter::reposition()\n \n \t\t// convert mission item to current setpoint\n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\t\tpos_sp_triplet->current.velocity_valid = false;\n \t\tpos_sp_triplet->previous.yaw = _navigator->get_local_position()->heading;\n \t\tpos_sp_triplet->previous.lat = _navigator->get_global_position()->lat;\n \t\tpos_sp_triplet->previous.lon = _navigator->get_global_position()->lon;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "patch": "@@ -1838,19 +1838,11 @@ bool Mission::position_setpoint_equal(const position_setpoint_s *p1, const posit\n {\n \treturn ((p1->valid == p2->valid) &&\n \t\t(p1->type == p2->type) &&\n-\t\t(fabsf(p1->vx - p2->vx) < FLT_EPSILON) &&\n-\t\t(fabsf(p1->vy - p2->vy) < FLT_EPSILON) &&\n-\t\t(fabsf(p1->vz - p2->vz) < FLT_EPSILON) &&\n-\t\t(p1->velocity_valid == p2->velocity_valid) &&\n-\t\t(p1->velocity_frame == p2->velocity_frame) &&\n-\t\t(p1->alt_valid == p2->alt_valid) &&\n \t\t(fabs(p1->lat - p2->lat) < DBL_EPSILON) &&\n \t\t(fabs(p1->lon - p2->lon) < DBL_EPSILON) &&\n \t\t(fabsf(p1->alt - p2->alt) < FLT_EPSILON) &&\n \t\t((fabsf(p1->yaw - p2->yaw) < FLT_EPSILON) || (!PX4_ISFINITE(p1->yaw) && !PX4_ISFINITE(p2->yaw))) &&\n \t\t(p1->yaw_valid == p2->yaw_valid) &&\n-\t\t(fabsf(p1->yawspeed - p2->yawspeed) < FLT_EPSILON) &&\n-\t\t(p1->yawspeed_valid == p2->yawspeed_valid) &&\n \t\t(fabsf(p1->loiter_radius - p2->loiter_radius) < FLT_EPSILON) &&\n \t\t(p1->loiter_direction == p2->loiter_direction) &&\n \t\t(fabsf(p1->acceptance_radius - p2->acceptance_radius) < FLT_EPSILON) &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -529,8 +529,7 @@ MissionBlock::item_contains_position(const mission_item_s &item)\n \t       item.nav_cmd == NAV_CMD_TAKEOFF ||\n \t       item.nav_cmd == NAV_CMD_LOITER_TO_ALT ||\n \t       item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n-\t       item.nav_cmd == NAV_CMD_VTOL_LAND ||\n-\t       item.nav_cmd == NAV_CMD_DO_FOLLOW_REPOSITION;\n+\t       item.nav_cmd == NAV_CMD_VTOL_LAND;\n }\n \n bool",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -64,7 +64,6 @@ enum NAV_CMD {\n \tNAV_CMD_LAND = 21,\n \tNAV_CMD_TAKEOFF = 22,\n \tNAV_CMD_LOITER_TO_ALT = 31,\n-\tNAV_CMD_DO_FOLLOW_REPOSITION = 33,\n \tNAV_CMD_VTOL_TAKEOFF = 84,\n \tNAV_CMD_VTOL_LAND = 85,\n \tNAV_CMD_DELAY = 93,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "patch": "@@ -42,7 +42,6 @@\n #pragma once\n \n #include \"enginefailure.h\"\n-#include \"follow_target.h\"\n #include \"geofence.h\"\n #include \"gpsfailure.h\"\n #include \"land.h\"\n@@ -86,7 +85,7 @@ using namespace time_literals;\n /**\n  * Number of navigation modes that need on_active/on_inactive calls\n  */\n-#define NAVIGATOR_MODE_ARRAY_SIZE 9\n+#define NAVIGATOR_MODE_ARRAY_SIZE 8\n \n class Navigator : public ModuleBase<Navigator>, public ModuleParams\n {\n@@ -394,7 +393,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tRTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */\n \tEngineFailure\t_engineFailure;\t\t\t/**< class that handles the engine failure mode (FW only!) */\n \tGpsFailure\t_gpsFailure;\t\t\t/**< class that handles the OBC gpsfailure loss mode */\n-\tFollowTarget\t_follow_target;\n \n \tNavigatorMode *_navigation_mode_array[NAVIGATOR_MODE_ARRAY_SIZE];\t/**< array of navigation modes */\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "patch": "@@ -83,8 +83,7 @@ Navigator::Navigator() :\n \t_precland(this),\n \t_rtl(this),\n \t_engineFailure(this),\n-\t_gpsFailure(this),\n-\t_follow_target(this)\n+\t_gpsFailure(this)\n {\n \t/* Create a list of our possible navigation types */\n \t_navigation_mode_array[0] = &_mission;\n@@ -95,7 +94,6 @@ Navigator::Navigator() :\n \t_navigation_mode_array[5] = &_takeoff;\n \t_navigation_mode_array[6] = &_land;\n \t_navigation_mode_array[7] = &_precland;\n-\t_navigation_mode_array[8] = &_follow_target;\n \n \t_handle_back_trans_dec_mss = param_find(\"VT_B_DEC_MSS\");\n \t_handle_reverse_delay = param_find(\"VT_B_REV_DEL\");\n@@ -629,11 +627,6 @@ Navigator::run()\n \t\t\tnavigation_mode_new = &_gpsFailure;\n \t\t\tbreak;\n \n-\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n-\t\t\tnavigation_mode_new = &_follow_target;\n-\t\t\tbreak;\n-\n \t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n \t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n \t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n@@ -803,7 +796,6 @@ void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n \t\t\t\t\trep->current.alt = loiter_altitude_amsl;\n \t\t\t\t\trep->current.valid = true;\n \t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\t\trep->current.alt_valid = true;\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\t\trep->current.loiter_direction = 1;\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7f4fbc102c60ad6da1130edd036ba44d6486e880/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "update_target_motion",
        "target_position_valid",
        "FollowTarget::target_position_valid",
        "set_follow_target_item",
        "FollowTarget::target_velocity_valid",
        "reset_target_validity",
        "on_active",
        "FollowTarget::on_active",
        "math::constrain",
        "update_position_sp",
        "FollowTarget::on_inactive",
        "FollowTarget::reset_target_validity",
        "update_target_velocity",
        "Navigator::Navigator",
        "Mission::position_setpoint_equal",
        "target_velocity_valid",
        "math::radians",
        "on_activation",
        "MissionBlock::item_contains_position",
        "Loiter::reposition",
        "Navigator::run",
        "track_target_position",
        "Copyright",
        "on_inactive",
        "Navigator::geofence_breach_check",
        "Loiter::set_loiter_position",
        "track_target_velocity",
        "FollowTarget::on_activation",
        "FollowTarget::update_position_sp"
      ],
      "by_file": {
        "src/modules/navigator/follow_target.cpp": [
          "FollowTarget::target_position_valid",
          "FollowTarget::target_velocity_valid",
          "FollowTarget::on_active",
          "Copyright",
          "math::constrain",
          "FollowTarget::on_inactive",
          "FollowTarget::reset_target_validity",
          "FollowTarget::on_activation",
          "FollowTarget::update_position_sp",
          "math::radians"
        ],
        "src/modules/navigator/follow_target.h": [
          "update_target_motion",
          "on_activation",
          "target_position_valid",
          "set_follow_target_item",
          "reset_target_validity",
          "on_active",
          "track_target_position",
          "Copyright",
          "update_position_sp",
          "on_inactive",
          "update_target_velocity",
          "track_target_velocity",
          "target_velocity_valid"
        ],
        "src/modules/navigator/loiter.cpp": [
          "Loiter::reposition",
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::position_setpoint_equal"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::item_contains_position"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::geofence_breach_check",
          "Navigator::run",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Try to cleanup some things in mission navigation mode",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/17017",
    "number": 17017,
    "created_at": "2021-03-03T17:20:43Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "I've did initial testing of this but am not quite done.\r\nStill ready for an initial review.\r\n\r\n@dagar @MaEtUgR ",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2021-03-03T17:22:03Z",
          "body": "@dagar @MaEtUgR hope I'm not missing anything, but to me this makes no sense. Mission itself just reads from dataman, right?",
          "path": "src/modules/commander/Commander.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-03-06T01:17:40Z",
          "body": "It makes sense for air in restore to not have to depend on mavlink, but I think at this point we should get rid of it.",
          "path": "src/modules/commander/Commander.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR title and body only mention cleanup in 'mission navigation mode' and initial testing, with no mention of a specific bug, incorrect behavior, or logic change. There is no code diff, comments, or review discussion indicating a fix to program logic or state; therefore there is insufficient evidence that this PR addresses a logic error.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 115,
        "deletions": 130,
        "changes": 245,
        "patch": "@@ -87,9 +87,12 @@ Mission::on_inactive()\n \t\treturn;\n \t}\n \n-\tif (_inited) {\n+\tif (_tried_reading_mission_from_storage_once) {\n \t\tif (_mission_sub.updated()) {\n-\t\t\tupdate_mission();\n+\t\t\tmission_s new_mission = {};\n+\t\t\t_mission_sub.copy(&new_mission);\n+\n+\t\t\tupdateMission(new_mission);\n \n \t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n \t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n@@ -98,36 +101,21 @@ Mission::on_inactive()\n \n \t\t/* reset the current mission if needed */\n \t\tif (need_to_reset_mission()) {\n-\t\t\treset_mission(_mission);\n-\t\t\tupdate_mission();\n+\t\t\tmission_s new_mission = _mission;\n+\t\t\treset_mission(new_mission);\n+\t\t\tupdateMission(new_mission);\n \t\t\t_navigator->reset_cruising_speed();\n \t\t}\n \n \t} else {\n \n-\t\t/* load missions from storage */\n-\t\tmission_s mission_state = {};\n-\n-\t\tdm_lock(DM_KEY_MISSION_STATE);\n+\t\tmission_s mission_from_storage = {};\n \n-\t\t/* read current state */\n-\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n-\n-\t\tdm_unlock(DM_KEY_MISSION_STATE);\n-\n-\t\tif (read_res == sizeof(mission_s)) {\n-\t\t\t_mission.dataman_id = mission_state.dataman_id;\n-\t\t\t_mission.count = mission_state.count;\n-\t\t\t_current_mission_index = mission_state.current_seq;\n-\n-\t\t\t// find and store landing start marker (if available)\n-\t\t\tfind_mission_land_start();\n+\t\tif (getMissionFromStorage(mission_from_storage)) {\n+\t\t\tupdateMission(mission_from_storage);\n \t\t}\n \n-\t\t/* On init let's check the mission, maybe there is already one available. */\n-\t\tcheck_mission_valid(false);\n-\n-\t\t_inited = true;\n+\t\t_tried_reading_mission_from_storage_once = true;\n \t}\n \n \t/* require takeoff after non-loiter or landing */\n@@ -194,14 +182,14 @@ Mission::on_activation()\n void\n Mission::on_active()\n {\n-\tcheck_mission_valid(false);\n-\n \t/* check if anything has changed */\n \tbool mission_sub_updated = _mission_sub.updated();\n \n \tif (mission_sub_updated) {\n \t\t_navigator->reset_triplets();\n-\t\tupdate_mission();\n+\t\tmission_s new_mission = {};\n+\t\t_mission_sub.copy(&new_mission);\n+\t\tupdateMission(new_mission);\n \t}\n \n \t/* mission is running (and we are armed), need reset after disarm */\n@@ -477,82 +465,74 @@ Mission::landing()\n \treturn mission_valid && on_landing_stage;\n }\n \n-void\n-Mission::update_mission()\n+void Mission::updateCurrentMissionIndex(mission_s new_mission)\n {\n+\tif (new_mission.current_seq >= 0 && new_mission.current_seq < (int)new_mission.count) {\n+\t\t_current_mission_index = new_mission.current_seq;\n+\n+\t} else {\n+\t\t/* if less items available, reset to first item */\n+\t\tif (_current_mission_index >= (int)new_mission.count) {\n+\t\t\t_current_mission_index = 0;\n \n-\tbool failed = true;\n+\t\t} else if (_current_mission_index < 0) {\n+\t\t\t/* if not initialized, set it to 0 */\n+\t\t\t_current_mission_index = 0;\n+\t\t}\n \n+\t\t/* otherwise, just leave it */\n+\t}\n+}\n+\n+void Mission::updateMission(mission_s new_mission)\n+{\n \t/* Reset vehicle_roi\n \t * Missions that do not explicitly configure ROI would not override\n \t * an existing ROI setting from previous missions */\n \t_navigator->reset_vroi();\n \n-\tconst mission_s old_mission = _mission;\n-\n-\tif (_mission_sub.copy(&_mission)) {\n-\t\t/* determine current index */\n-\t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n-\t\t\t_current_mission_index = _mission.current_seq;\n-\n-\t\t} else {\n-\t\t\t/* if less items available, reset to first item */\n-\t\t\tif (_current_mission_index >= (int)_mission.count) {\n-\t\t\t\t_current_mission_index = 0;\n-\n-\t\t\t} else if (_current_mission_index < 0) {\n-\t\t\t\t/* if not initialized, set it to 0 */\n-\t\t\t\t_current_mission_index = 0;\n-\t\t\t}\n-\n-\t\t\t/* otherwise, just leave it */\n-\t\t}\n-\n-\t\tcheck_mission_valid(true);\n+\t/* check if the mission waypoints changed while the vehicle is in air\n+\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n+\tif (((new_mission.count != _mission.count) ||\n+\t     (new_mission.dataman_id != _mission.dataman_id)) &&\n+\t    !_navigator->get_land_detected()->landed) {\n+\t\t_mission_waypoints_changed = true;\n+\t}\n \n-\t\tfailed = !_navigator->get_mission_result()->valid;\n \n-\t\tif (!failed) {\n-\t\t\t/* reset mission failure if we have an updated valid mission */\n-\t\t\t_navigator->get_mission_result()->failure = false;\n+\tconst bool mission_valid = isMissionValid(new_mission);\n \n-\t\t\t/* reset sequence info as well */\n-\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n-\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n+\tif (mission_valid) {\n+\t\tupdateCurrentMissionIndex(new_mission);\n \n-\t\t\t/* reset work item if new mission has been accepted */\n-\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n-\t\t\t_mission_changed = true;\n-\t\t}\n+\t\t/* reset work item if new mission has been accepted */\n+\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n+\t\t_mission_changed = true;\n \n-\t\t/* check if the mission waypoints changed while the vehicle is in air\n-\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n-\t\tif (((_mission.count != old_mission.count) ||\n-\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n-\t\t    !_navigator->get_land_detected()->landed) {\n-\t\t\t_mission_waypoints_changed = true;\n-\t\t}\n+\t\t_mission = new_mission;\n \n \t} else {\n-\t\tPX4_ERR(\"mission update failed\");\n-\t}\n-\n-\tif (failed) {\n-\t\t// only warn if the check failed on merit\n-\t\tif ((int)_mission.count > 0) {\n-\t\t\tPX4_WARN(\"mission check failed\");\n-\t\t}\n-\n \t\t// reset the mission\n \t\t_mission.count = 0;\n \t\t_mission.current_seq = 0;\n \t\t_current_mission_index = 0;\n \t}\n \n+\tif (mission_valid) {\n+\t\t_navigator->get_mission_result()->failure = false;\n+\t}\n+\n+\t_navigator->get_mission_result()->seq_total = _mission.count;\n+\t_navigator->increment_mission_instance_count();\n+\t_navigator->get_mission_result()->valid = mission_valid;\n+\t_navigator->get_mission_result()->finished = false;\n+\t_navigator->get_mission_result()->seq_current = _current_mission_index;\n+\t_navigator->set_mission_result_updated();\n+\n \t// find and store landing start marker (if available)\n \tfind_mission_land_start();\n \n-\tset_current_mission_item();\n+\tsave_mission_state();\n }\n \n \n@@ -1595,29 +1575,15 @@ Mission::save_mission_state()\n {\n \tmission_s mission_state = {};\n \n-\t/* lock MISSION_STATE item */\n-\tint dm_lock_ret = dm_lock(DM_KEY_MISSION_STATE);\n-\n-\tif (dm_lock_ret != 0) {\n-\t\tPX4_ERR(\"DM_KEY_MISSION_STATE lock failed\");\n-\t}\n-\n-\t/* read current state */\n-\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n-\n-\tif (read_res == sizeof(mission_s)) {\n+\tif (getMissionFromStorage(mission_state)) {\n \t\t/* data read successfully, check dataman ID and items count */\n \t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count) {\n \t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n \t\t\tif (mission_state.current_seq != _current_mission_index) {\n \t\t\t\tmission_state.current_seq = _current_mission_index;\n \t\t\t\tmission_state.timestamp = hrt_absolute_time();\n \n-\t\t\t\tif (dm_write(DM_KEY_MISSION_STATE, 0, DM_PERSIST_POWER_ON_RESET, &mission_state,\n-\t\t\t\t\t     sizeof(mission_s)) != sizeof(mission_s)) {\n-\n-\t\t\t\t\tPX4_ERR(\"Can't save mission state\");\n-\t\t\t\t}\n+\t\t\t\twriteMissionToStorage(mission_state);\n \t\t\t}\n \t\t}\n \n@@ -1630,17 +1596,7 @@ Mission::save_mission_state()\n \n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Invalid mission state.\");\n \n-\t\t/* write modified state only if changed */\n-\t\tif (dm_write(DM_KEY_MISSION_STATE, 0, DM_PERSIST_POWER_ON_RESET, &mission_state,\n-\t\t\t     sizeof(mission_s)) != sizeof(mission_s)) {\n-\n-\t\t\tPX4_ERR(\"Can't save mission state\");\n-\t\t}\n-\t}\n-\n-\t/* unlock MISSION_STATE item */\n-\tif (dm_lock_ret == 0) {\n-\t\tdm_unlock(DM_KEY_MISSION_STATE);\n+\t\twriteMissionToStorage(mission_state);\n \t}\n }\n \n@@ -1672,35 +1628,18 @@ Mission::set_mission_item_reached()\n void\n Mission::set_current_mission_item()\n {\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->get_mission_result()->seq_current = _current_mission_index;\n-\n-\t_navigator->set_mission_result_updated();\n \n-\tsave_mission_state();\n }\n \n-void\n-Mission::check_mission_valid(bool force)\n+bool\n+Mission::isMissionValid(mission_s &mission)\n {\n-\tif ((!_home_inited && _navigator->home_position_valid()) || force) {\n-\n-\t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator);\n-\n-\t\t_navigator->get_mission_result()->valid =\n-\t\t\t_missionFeasibilityChecker.checkMissionFeasible(_mission,\n-\t\t\t\t\t_param_mis_dist_1wp.get(),\n-\t\t\t\t\t_param_mis_dist_wps.get(),\n-\t\t\t\t\t_navigator->mission_landing_required());\n+\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator);\n \n-\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n-\t\t_navigator->increment_mission_instance_count();\n-\t\t_navigator->set_mission_result_updated();\n-\t\t_home_inited = _navigator->home_position_valid();\n-\n-\t\t// find and store landing start marker (if available)\n-\t\tfind_mission_land_start();\n-\t}\n+\treturn _missionFeasibilityChecker.checkMissionFeasible(mission,\n+\t\t\t_param_mis_dist_1wp.get(),\n+\t\t\t_param_mis_dist_wps.get(),\n+\t\t\t_navigator->mission_landing_required());\n }\n \n void\n@@ -1889,3 +1828,49 @@ void Mission::publish_navigator_mission_item()\n \n \t_navigator_mission_item_pub.publish(navigator_mission_item);\n }\n+\n+void Mission::homePositionUpdated()\n+{\n+\tif (!_home_inited) {\n+\t\t_navigator->get_mission_result()->valid = isMissionValid(_mission);\n+\t\t_home_inited = true;\n+\t}\n+}\n+\n+bool Mission::getMissionFromStorage(mission_s &mission)\n+{\n+\tbool ret = false;\n+\tmission_s mission_state = {};\n+\n+\tint dm_lock_ret = dm_lock(DM_KEY_MISSION_STATE);\n+\n+\tif (dm_lock_ret != 0) {\n+\t\tPX4_ERR(\"DM_KEY_MISSION_STATE lock failed\");\n+\t}\n+\n+\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n+\n+\tif (dm_lock_ret == 0) {\n+\t\tdm_unlock(DM_KEY_MISSION_STATE);\n+\t}\n+\n+\tif (read_res == sizeof(mission_s)) {\n+\t\tmission = mission_state;\n+\t\tret = true;\n+\t}\n+\n+\treturn ret;\n+}\n+\n+bool Mission::writeMissionToStorage(mission_s mission)\n+{\n+\tbool ret = true;\n+\n+\tif (dm_write(DM_KEY_MISSION_STATE, 0, DM_PERSIST_POWER_ON_RESET, &mission,\n+\t\t     sizeof(mission_s)) != sizeof(mission_s)) {\n+\t\tPX4_ERR(\"Can't save mission state\");\n+\t\tret = false;\n+\t}\n+\n+\treturn ret;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/432ec2986a9139159220aa6f2ae3cee43eaf7121/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 13,
        "deletions": 3,
        "changes": 16,
        "patch": "@@ -97,6 +97,8 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tvoid set_closest_item_as_current();\n \n+\tvoid homePositionUpdated();\n+\n \t/**\n \t * Set a new mission mode and handle the switching between the different modes\n \t *\n@@ -108,8 +110,7 @@ class Mission : public MissionBlock, public ModuleParams\n \t/**\n \t * Update mission topic\n \t */\n-\tvoid update_mission();\n-\n+\tvoid updateMission(mission_s new_mission);\n \t/**\n \t * Move on to next mission item or switch to loiter\n \t */\n@@ -208,6 +209,9 @@ class Mission : public MissionBlock, public ModuleParams\n \t */\n \tvoid check_mission_valid(bool force);\n \n+\tbool\n+\tisMissionValid(mission_s &mission);\n+\n \t/**\n \t * Reset mission\n \t */\n@@ -237,6 +241,12 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tvoid publish_navigator_mission_item();\n \n+\tbool getMissionFromStorage(mission_s &mission);\n+\n+\tbool writeMissionToStorage(mission_s mission);\n+\n+\tvoid updateCurrentMissionIndex(mission_s new_mission);\n+\n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n \t\t(ParamFloat<px4::params::MIS_DIST_WPS>) _param_mis_dist_wps,\n@@ -270,7 +280,7 @@ class Mission : public MissionBlock, public ModuleParams\n \t\tMISSION_TYPE_MISSION\n \t} _mission_type{MISSION_TYPE_NONE};\n \n-\tbool _inited{false};\n+\tbool _tried_reading_mission_from_storage_once{false};\n \tbool _home_inited{false};\n \tbool _need_mission_reset{false};\n \tbool _mission_waypoints_changed{false};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/432ec2986a9139159220aa6f2ae3cee43eaf7121/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "patch": "@@ -215,7 +215,11 @@ Navigator::run()\n \n \t\t_land_detected_sub.update(&_land_detected);\n \t\t_position_controller_status_sub.update();\n-\t\t_home_pos_sub.update(&_home_pos);\n+\n+\t\tif (_home_pos_sub.updated()) {\n+\t\t\t_home_pos_sub.copy(&_home_pos);\n+\t\t\t_mission.homePositionUpdated();\n+\t\t}\n \n \t\twhile (_vehicle_command_sub.updated()) {\n \t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/432ec2986a9139159220aa6f2ae3cee43eaf7121/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "_missionFeasibilityChecker",
        "Mission::save_mission_state",
        "Mission::on_inactive",
        "Navigator::run",
        "Mission::on_activation",
        "Mission::publish_navigator_mission_item",
        "Mission::set_mission_item_reached",
        "Mission::landing",
        "update_mission"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::save_mission_state",
          "Mission::on_inactive",
          "_missionFeasibilityChecker",
          "Mission::on_activation",
          "Mission::publish_navigator_mission_item",
          "Mission::set_mission_item_reached",
          "Mission::landing"
        ],
        "src/modules/navigator/mission.h": [
          "update_mission"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Make DO_SET_SERVO work",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10320",
    "number": 10320,
    "created_at": "2018-08-24T15:26:45Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "kpetrykin",
      "body": "Hello!\n\nMy goal was to make the mission command DO_SET_SERVO working with the possibility of triggering the servo with RC switch.\n\nFirst, I have found that \"vmount\" module (when enabled) publishes its values to actuator_controls_2 topic all the time. This overwrites all other publications to this topic. That is why DO_SET_SERVO is not working.\n\nI modified \"vmount\" module so that it would publish only if one of the actuator values were changed by RC. In other cases it stays silent.\n\nSecond, I have found that the formula, which translates PWM value from DO_SET_SERVO command parameters to -1..1 range for uORB, does not match the one which translates it back.\n[Original formula:](https://github.com/PX4/Firmware/blob/c997159e32f3870c7fd3202877324b76a62ea610/src/modules/navigator/mission_block.cpp#L433) `actuators.control[(int)item.params[0]] = 1.0f / 2000 * -item.params[1];`\n[Formula, which translates value back](https://github.com/4ert/Firmware/blob/397522d3813924380c209984b47b05bf743c3037/src/lib/pwm_limit/pwm_limit.cpp#L211): `effective_pwm[i] = control_value * (max_pwm[i] - min_pwm[i]) / 2 + (max_pwm[i] + min_pwm[i]) / 2;`\n[New formula](https://github.com/4ert/Firmware/blob/397522d3813924380c209984b47b05bf743c3037/src/modules/navigator/mission_block.cpp#L440): `actuators.control[(int)item.params[0]] = (float)(((float)item.params[1] - (PWM_DEFAULT_MAX + PWM_DEFAULT_MIN) / 2)/((PWM_DEFAULT_MAX - PWM_DEFAULT_MIN) / 2));`\n\nI need to discuss two questions about the formula: \n- to make it work properly we need to get actual \"max_pwm[i]\" and \"min_pwm[i]\" into navigator module. I have found a [way to get them](https://github.com/PX4/Firmware/blob/c997159e32f3870c7fd3202877324b76a62ea610/src/drivers/px4fmu/fmu.cpp#L1678), but I don't understand how to use it correctly\n- when I tested mission with DO_SET_SERVO command, servo works nice only with 1, 3 and 4 aux outputs. The second one for some reason outputs into first. I think there is something wrong with casting here: `(int)item.params[0]`\n\nI have tested everything with 1.7.3 Firmvare (px4fmu-v2_default), but did not save the flight log.\nI will test the last master in a few days.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-08-24T23:00:07Z",
          "body": "There are a few problems with this PR, but let's take a step back first.\r\n\r\nHow do people want/expect DO_SET_SERVO to even work?\r\n![screen shot 2018-08-24 at 18 55 07](https://user-images.githubusercontent.com/84712/44611459-43a8b980-a7cf-11e8-9266-6aad77f5252a.png)\r\n\r\nWhich servo does it correspond to? What's supposed to happen in the not entirely unlikely scenario that that PWM channel is already used for something?\r\n\r\nWhat's the real use case for DO_SET_SERVO? Would we be better implementing a couple higher level commands? payload, gripper, etc\r\n\r\nIf the answer is still DO_SET_SERVO then the right place to implement that command is in the px4io (MAIN pwm) and/or px4fmu (AUX pwm) drivers. Those drivers are the consumers of actuator_controls_{0, 1, 2, 3} and work directly with PWM values.\r\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-26T18:52:17Z",
          "body": "@4ert We need to separate the different actuator groups for good to make this easier. Could you join the PX4 dev call this week?\r\nhttps://dev.px4.io/en/contribute/#dev_call",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-08-27T12:16:37Z",
          "body": "- **How do people want/expect DO_SET_SERVO to even work?**\r\nIn our case we want to release a cargo by the mission command. The cargo is locked by the servo which is connected to one of the AUX outputs. We want to use DO_SET_SERVO command to send a PWM signal (parameter 2) to the AUX output from paramter 1.\r\n- **Which servo does it correspond to?**\r\n[As we can see now](https://github.com/PX4/Firmware/blob/bbc0c28c2c07743e489a338677e449a28ab5fd74/src/modules/navigator/mission_block.cpp#L436) the Navigator publish DO_SET_SERVO values to actuator_controls_2 topic. This control group is used to rule gimbal:\r\n![image](https://user-images.githubusercontent.com/161284/44657760-b18af600-aa06-11e8-9fd8-8a5971d51ffe.png)\r\n- **What's the real use case for DO_SET_SERVO? Would we be better implementing a couple higher level commands? payload, gripper, etc**\r\nI think when you use DO_SET_SERVO command - you just want to send an exactly PWM to external servo connected to your controller. If you want to rule gimbal - you will use DO_MOUNT_CONTROL, if you have any flight control mechanizm connected to the AUX - you will want to use some more convenient commands for this.\r\n- **If the answer is still DO_SET_SERVO then the right place to implement that command is in the px4io (MAIN pwm) and/or px4fmu (AUX pwm) drivers. Those drivers are the consumers of actuator_controls_{0, 1, 2, 3} and work directly with PWM values.**\r\nSo, I just made a little repair into an existing WORKING mechanizm. For now, Navigator module publishes into an \"actuator_controls_2\" topic and the px4fmu driver gets values from it and sends to the servos. There's just two things which discourage the process: the vmount driver spamming with its own values to the topic and the formula which translates data wrong. If you switch vmount off (\"vmount stop\" command into a console) and correct the formula - DO_SET_SERVO will work as expected. And don't forget to load a mixer for AUX outputs.\r\n\r\n- **What's supposed to happen in the not entirely unlikely scenario that that PWM channel is already used for something?**\r\nI think, this question is up to the one who builds and sets up the specific device. If you connects some critical stuff to the AUX - edit mixers or just don't use DO_SET_SERVO.",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-08-27T16:01:36Z",
          "body": "Made a flight, the log is here: https://logs.px4.io/plot_app?log=8fb644ab-1fe4-449a-9b0f-c4656fdae029#Nav-Actuator-Outputs-AUX\r\nThe mission was: \r\n- takeoff to 10 meters \r\n- DO_SET_SERVO on AUX1 1000 PWM \r\n- go to waypoint \r\n- DO_SET_SERVO on AUX1 2000 PWM\r\n- land \r\n- DO_SET_SERVO on AUX1 1000 PWM (example releasing cargo)\r\n- takeoff to 10 meters\r\n- RTL",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-08-27T18:57:12Z",
          "body": "@LorenzMeier my speaking english is not very good but I could try to join the devcall",
          "type": "issue_comment"
        },
        {
          "author": "maitham",
          "created_at": "2018-09-05T14:11:09Z",
          "body": "@kpetrykin  I'm currently trying to get this to work I've used your commit. So I have my Pixhawk connected to a servo and I'm trying to get the servo to move within the mavproxy shell by running servo set 1 1000. However the message I keep getting back is that the command was acknowledged but is unrecognised (result:3) . I can get the servo moving using nuttx shell, but I really want to be able to send a mavlink command to set the servo pwm is there any way of doing this? ",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2018-09-05T23:19:26Z",
          "body": "@maitham1 It looks like the  MAV_CMD_DO_SET_SERVO is **set in missions** and handled here: \r\nhttps://github.com/PX4/Firmware/blob/master/src/modules/navigator/mission_block.cpp#L424\r\n(FYI @bkueng  this is related to https://github.com/Dronecode/DronecodeSDK/issues/533)\r\n\r\nI can't find the message being handled outside of missions. While that does not mean it isn't, the fact that you're getting \"unrecognised\" is indicative. \r\n\r\nThere is quite a bit of discussion above about this. @dagar did the devcall come to any conclusions? Is there a short term recommendation on how people should approach this?\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2018-09-06T00:04:36Z",
          "body": "@dagar regarding https://github.com/PX4/Firmware/pull/10320#issuecomment-415903772 (your questions) there are some good points there. Below are \"in my opinion\". \r\n\r\n> Which servo does it correspond to? \r\n\r\nShouldn't this be defined at the MAVLink/message level by a convention? How about 1-n are the MAIN outputs as labeled on board, and n upwards are the AUX ports, if present? \r\n\r\n> What's supposed to happen in the not entirely unlikely scenario that that PWM channel is already used for something?\r\n\r\nIMO things screw up - it is up to the user of this tool to manage contention. See real use case below. \r\n\r\nDo we actually manage contention otherwise? ie does the system check that we don't have multiple control group inputs assigned to the same output?\r\n\r\n> What's the real use case for DO_SET_SERVO? \r\n\r\nThe real use case is probably the hardware we haven't thought about. Someone has some magic hardware that they want to drive, and a free port. They just want to be able to plug in that hardware and send it a command via MAVLink. They don't want to care about mixers. They are happy to manage contention themselves -  ie they know that nothing else is connected to the port, and if they screw up they screw up.\r\n\r\n> Would we be better implementing a couple higher level commands? payload, gripper, etc\r\n\r\nWe currently have [First Payload](http://dev.px4.io/en/concept/mixing.html#control-group-6-first-payload) which is just a parachute. Yes we should probably define something for a gripper. Not sure it will address the above use case.\r\n\r\nI've read http://dev.px4.io/en/concept/mixing.html and I am not 100% confident that my understanding of how these work is complete. I think that control groups are implemented as UORB topics that something can set (ie a controller). A mixer defines what actuators are set and their values based on these inputs. \r\n\r\nSo essentially you create a control group so that you can arbitrarily map a specific **type** of command to a physical output. For example to use a parachute you write a handler for it in MAVLink that sets the appropriate control group UORB topic. \"Something\" in the architecture then takes the mapping in the mixer file and based on that topic input sets the appropriate PWM output. Is that about right?\r\n\r\nThis is good because your system does not need to know what plugs into the output to implement a parachute or gripper (say). But it does mean that you need a mixer.\r\n\r\nQuestion: Are mixer's additive? Ie I have an airframe which uses the main outputs. I add a parachute. Do I need a completely new mixer file, or can I add my mixer just for my parachute?\r\n\r\nYou could implement this as a servo control group(s). But would be better if the mapping was transparent (ie no specific mixer required). \r\n",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-09-06T10:16:30Z",
          "body": "@maitham1 this PR is generally about mission's DO_SET_SERVO command.\r\nIt looks like if you want to pass it through mavlink it would not be handled.\r\nYou may experiment with writing your own handler somewhere here: https://github.com/PX4/Firmware/blob/039221fa93303a6840a45c3f8a72580aaaf2d74c/src/modules/mavlink/mavlink_receiver.cpp#L527\r\nOr you may assign an rc trigger for your servo and try to override it with mavlink message, but it is not a good way.\r\nAnd what do you want to do? What is your case?",
          "type": "issue_comment"
        },
        {
          "author": "maitham",
          "created_at": "2018-09-06T10:43:34Z",
          "body": "@kpetrykin Thanks for getting back to me. I want to simply change pwm output from a script. \r\nCurrently I thought this would be possible via sending the MV_CMD_DO_SET_SERVO using pymavlink, \r\nit doesn't seem to be implemented, unless i'm missing something (which is highly likely as this is all new to me) but I'm open to other ways? ",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-09-06T10:59:22Z",
          "body": "@maitham1 so what is your goal of using servo? What you try to do with this?\r\nAnd from what you send MAV_CMD_DO_SET_SERVO using pymavlink? Onboard computer?",
          "type": "issue_comment"
        },
        {
          "author": "maitham",
          "created_at": "2018-09-06T11:32:51Z",
          "body": "@kpetrykin I would like run certain tests to change servo positions, its a static test so nothings flying. I just want the ability to set servos to specific angles and motors to specific speeds within a python script. I don't intend to use it for flying. Its just for testing.\r\n\r\nSending MAV_CMD_DO_SET_SERVO using pymavlink! ",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-09-25T11:07:11Z",
          "body": "So, @dagar, @LorenzMeier - what's with this PR? What could i do to improve it?",
          "type": "issue_comment"
        },
        {
          "author": "tubeme",
          "created_at": "2018-10-24T03:53:21Z",
          "body": "Hey @kpetrykin Can you share your mixer that you are using for the AUX channel? I'm trying to follow yur route but cannot make the mixer properly maybe. ",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-10-24T09:28:11Z",
          "body": "@tubeme, sure, it's simple:\r\n\r\n```\r\nM: 1\r\nO:      10000  10000      0 -10000  10000\r\nS: 2 0  10000  10000      0 -10000  10000\r\n\r\nM: 1\r\nO:      10000  10000      0 -10000  10000\r\nS: 2 1  10000  10000      0 -10000  10000\r\n\r\nM: 1\r\nO:      10000  10000      0 -10000  10000\r\nS: 2 2  10000  10000      0 -10000  10000\r\n\r\nM: 1\r\nO:      10000  10000      0 -10000  10000\r\nS: 2 3  10000  10000      0 -10000  10000\r\n```\r\nTo make it work:\r\n\r\n- Place a mixer into a /etc/mixers/pass.aux.mix on your pixhawk's SD card\r\n- Create /etc/extras.txt with the folowing command: `mixer load /dev/pwm_output1 /fs/microsd/etc/mixers/pass.aux.mix`",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-11-07T09:27:43Z",
          "body": "So, @tubeme, did you get the mixer to work?",
          "type": "issue_comment"
        },
        {
          "author": "GaoGeolone",
          "created_at": "2018-12-01T02:17:34Z",
          "body": "@kpetrykin How to make it work, bro?",
          "type": "issue_comment"
        },
        {
          "author": "bys1123",
          "created_at": "2018-12-01T05:59:52Z",
          "body": "Is there any new update?",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2018-12-03T10:29:35Z",
          "body": "@GaoGeolone what have you done already?\r\n@bys1123 no, it's still as it is",
          "type": "issue_comment"
        },
        {
          "author": "GaoGeolone",
          "created_at": "2018-12-04T03:20:49Z",
          "body": "@kpetrykin I think I have already make it work, thank you~I just want to trigger my servo at a certain position. And by making a change to the AUXMIXER pass file , as well as modifying the Formula in Mission_block.cpp.",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-03-04T04:15:20Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "JamesChooWK",
          "created_at": "2019-03-06T13:03:51Z",
          "body": "Hi @kpetrykin , I want to follow what you have done the flight for example takeoff, go to a waypoint and drop a cargo. Now, I am trying to follow and write a same mixer that you provide. But there are some questions that I want to ask:\r\n\r\nQ1) Why do we create a \"extrats.txt\" file  with a command line \"mixer load /dev/pwm_output1 /fs/microsd/etc/mixers/pass.aux.mix\" ?\r\nQ2) Where do we place this \"extrats.txt\" file ? same folder as our mixer file?\r\nQ3) How can we upload the mixer and this \"extrats.txt\" file into our Pixhawk's SDcard? via QGC?\r\nQ4) If QGC is needed, do we need to place these two file into our Firmware before uploading it? \r\n\r\nSorry for asking these silly questions. Thanks. \r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2019-03-06T21:25:14Z",
          "body": "@JamesChooWK The Extras.txt is documented here: https://dev.px4.io/master/en/concept/system_startup.html#customizing-the-system-startup\r\n\r\nIt is used for system startup customisations - basically you're adding the mixer at runtime rather than as part of the firmware build. This is much easier for examples, testing,  and when you're doing something that only applies to your setup. \r\n\r\nYou can copy the files onto the card using whatever mechanism you like - ie File explorer on windows. The files need to be present on the SD card before booting PX4. Again, they are not part of firmware, but are loaded as though they were.",
          "type": "issue_comment"
        },
        {
          "author": "JamesChooWK",
          "created_at": "2019-03-07T19:36:25Z",
          "body": "@hamishwillee Thanks for answering my questions.  I manage to upload the mixer and Extras.txt file into MicroSD card. \r\n\r\nBut when I tried to push a DO_SET_SERVO command to pixhawk using mavros services(\"mavros/mission/push\") by assigning \"command=183\", it return this error (\" WP: upload failed: command is not supported\")\r\n\r\nI am not sure whether I use the DO_SET_SERVO in (\"mavros/mission/push\") correctly or I have to do it in (\"mavros/cmd/command\") or I have to use mavlink ?\r\n\r\nI am using MAVROS and PX4 native flight stack.\r\n\r\nMany thanks.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2019-03-07T21:16:16Z",
          "body": "@JamesChooWK Did you incorporate this PR? It has the code that is supposed to support  DO_SET_SERVO",
          "type": "issue_comment"
        },
        {
          "author": "JamesChooWK",
          "created_at": "2019-03-07T21:45:40Z",
          "body": "@hamishwillee  I am sorry I do not incorporate this PR, but I will do it. If I uses the new code, does it means that I have to build the firmware and load to pixhawk or I can copy the files and paste it into the SDcard like the mixer?\r\nI'm sorry to ask so many questions, I'm a newbie to these sort of things.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2019-03-07T22:05:01Z",
          "body": "@JamesChooWK So the point of the PR is that the message doesn't work on PX4 right now (as far as I know - I'm guessing based on what I see here).\r\nSo yes, you will have to build PX4 firmware with the changes in this code and upload it as \"custom firmware\". There are conflicts between the changes and master branch, so you might need to do some coding to integrate them.\r\n\r\nAlso note this PR did not get accepted yet - so there is no guarantee that even if you do this it will work. ",
          "type": "issue_comment"
        },
        {
          "author": "JamesChooWK",
          "created_at": "2019-03-08T09:14:52Z",
          "body": "@hamishwillee  I will try to amend the code and build the firmware, Thanks for the time answering my questions. Cheers. ",
          "type": "issue_comment"
        },
        {
          "author": "kpetrykin",
          "created_at": "2019-03-11T08:31:46Z",
          "body": "@JamesChooWK this PR does not contain code to accept DO_SET_SERVO from external sourses, it's about command from mission.\r\nIf you want to use external call of this command, you need to add a code to process a corresponding mavlink message.",
          "type": "issue_comment"
        },
        {
          "author": "JamesChooWK",
          "created_at": "2019-03-11T09:54:30Z",
          "body": "@hamishwillee  I will try to amend the code and build the firmware, Thanks for the time answering my questions. Cheers. ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR addresses two logic bugs: vmount continuously overwrote actuator_controls_2 (incorrect state/media flow causing DO_SET_SERVO to be ignored) and the PWMâ†”control scaling used by DO_SET_SERVO was mathematically inconsistent with the inverse conversion (incorrect mapping producing wrong outputs). Both are logic errors because they caused unintended/incorrect runtime behavior without crashing.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 3,
        "changes": 41,
        "patch": "@@ -54,6 +54,8 @@\n #include <uORB/topics/vehicle_command.h>\n #include <uORB/topics/vtol_vehicle_status.h>\n \n+#include <drivers/drv_pwm_output.h>\n+\n using matrix::wrap_pi;\n \n MissionBlock::MissionBlock(Navigator *navigator) :\n@@ -67,6 +69,9 @@ MissionBlock::MissionBlock(Navigator *navigator) :\n \t_mission_item.time_inside = 0.0f;\n \t_mission_item.autocontinue = true;\n \t_mission_item.origin = ORIGIN_ONBOARD;\n+\n+\t// Subscribing to publish MAV_CMD_DO_SET_SERVO\n+\t_t_actuator_controls_3 = orb_subscribe(ORB_ID(actuator_controls_3));\n }\n \n bool\n@@ -444,9 +449,39 @@ MissionBlock::issue_command(const mission_item_s &item)\n \t\tactuator_controls_s actuators = {};\n \t\tactuators.timestamp = hrt_absolute_time();\n \n-\t\t// params[0] actuator number to be set 0..5 (corresponds to AUX outputs 1..6)\n-\t\t// params[1] new value for selected actuator in ms 900...2000\n-\t\tactuators.control[(int)item.params[0]] = 1.0f / 2000 * -item.params[1];\n+\t\t// Copying actual AUX values to change only one output\n+\t\t// and leave others as they are\n+\t\torb_copy(ORB_ID(actuator_controls_3), _t_actuator_controls_3,\n+\t\t\t &actuators);\n+\n+\t\tint aux_num = static_cast<int>(item.params[0]);\n+\n+\t\t// Aux numbers corresponding pass.aux.mix mixer\n+\t\tswitch (aux_num) {\n+\t\tcase 1:\n+\t\t\taux_num = 5;\n+\t\t\tbreak;\n+\n+\t\tcase 2:\n+\t\t\taux_num = 6;\n+\t\t\tbreak;\n+\n+\t\tcase 3:\n+\t\t\taux_num = 7;\n+\t\t\tbreak;\n+\n+\t\tcase 4:\n+\t\t\taux_num = 4;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t// aux_num - actuator number to be set\n+\t\t// param2 - new value for selected actuator in ms 1000...2000\n+\t\tactuators.control[aux_num] = (item.params[1] - static_cast<float>(PWM_DEFAULT_MAX + PWM_DEFAULT_MIN) / 2) /\n+\t\t\t\t\t     (static_cast<float>(PWM_DEFAULT_MAX - PWM_DEFAULT_MIN) / 2);\n \n \t\t_actuator_pub.publish(actuators);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/20140876acf18719c0e234e52dd6ae8b26fe4f0d/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -135,5 +135,6 @@ class MissionBlock : public NavigatorMode\n \thrt_abstime _action_start{0};\n \thrt_abstime _time_wp_reached{0};\n \n-\tuORB::Publication<actuator_controls_s>\t_actuator_pub{ORB_ID(actuator_controls_2)};\n+\tuORB::Publication<actuator_controls_s>\t_actuator_pub{ORB_ID(actuator_controls_3)};\n+\tint _t_actuator_controls_3;\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/20140876acf18719c0e234e52dd6ae8b26fe4f0d/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::issue_command",
        "MissionBlock::MissionBlock"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command",
          "MissionBlock::MissionBlock"
        ]
      }
    }
  },
  {
    "title": "fix loiter yaw error for multirotor(#10262)",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10297",
    "number": 10297,
    "created_at": "2018-08-22T04:26:03Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "KeyneZzz",
      "body": "**Test data / coverage**\nbefore fix\nhttps://logs.px4.io/plot_app?log=58f3d121-cc66-4b11-9436-3ec3136b23c3\nafter fix\nhttps://logs.px4.io/plot_app?log=8a210ac9-fd87-4f63-8421-03a710e24153\n\nfixes #10262",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-09-16T23:00:53Z",
          "body": "@KeyneZzz could you explain why this is needed? I think the multicopter position controller should be handling yaw setpoints properly.\r\n",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-09-17T07:07:44Z",
          "body": "In principle it should be possible to set `yaw` to NAN and then the vehicle should keep its heading (https://github.com/PX4/Firmware/blob/master/msg/position_setpoint.msg#L36). \r\nIn the case of loiter, I think that is what's happening:\r\n- yaw-setpoint is set to NAN (https://github.com/PX4/Firmware/blob/master/src/modules/navigator/mission_block.cpp#L604) with the intention that yaw is hold\r\n- in FlightTaskAuto, the heading is mapped as follow: \r\n  - Triplet yaw-flag is valid (https://github.com/PX4/Firmware/blob/master/src/lib/FlightTasks/tasks/Auto/FlightTaskAuto.cpp#L201): the `yaw_setpoint` will be set to whatever triplet is, even if it is NAN. If the triplet has a finite yaw, then everything willl be handled as expected. If the triplet yaw is NAN (despite the valid yaw-flag), the the position-controller will set the yaw-setpoint to the current yaw (https://github.com/PX4/Firmware/blob/master/src/modules/mc_pos_control/PositionControl.cpp#L195)\r\n  - Triplet yaw-flag is not valid: the heading will be set according to `MPC_YAW_MODE`: https://github.com/PX4/Firmware/blob/master/src/lib/FlightTasks/tasks/Auto/FlightTaskAuto.cpp#L223-L277 where a yaw-lock is applied if the vehicle is within the acceptance radius\r\n\r\nBased on the above logic, I think one of the problems here is similar to https://github.com/PX4/Firmware/pull/10294, that  the yaw-valid-flag might be true, but the actual setpoint might still be infinite. \r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "KeyneZzz",
          "created_at": "2018-09-19T03:47:05Z",
          "body": "In my case, i'm not giving any yaw setpoint, but giving a yawspeed setpoint as 0.\r\nI'm not sure if the yaw-valid-flag stuff can solve the problem I met. But the changes I commited can be one of the valid ways to solve it.\r\n\r\nIn fact, my upper FC is always controlling the yaw by sending yawspeed setpoint.\r\nIs it better to use yaw_sp than to ues yawspeed_sp?",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-10-30T14:52:03Z",
          "body": "@KeyneZzz Is this an extended fixed wing/vtol fix for https://github.com/PX4/Firmware/pull/10291?\r\n\r\n> better to use yaw_sp than to ues yawspeed_sp?\r\n\r\nFor holding the heading it's better to have a constant yaw setpoint because a yawspeed setpoint can in principle drift.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-16T16:09:13Z",
          "body": "Has this been resolved?",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2019-01-29T09:49:18Z",
          "body": "Let's track if the issue was resolved in #10262. I don't think this pr would fix the root cause of the issue because of the same reasons that were already explained in https://github.com/PX4/Firmware/pull/10297#issuecomment-421909966",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect yaw behavior in loiter arising from how yaw setpoints, yawspeed setpoints and the yaw-valid flag are interpretedâ€”i.e. an inconsistent program state where a 'valid' yaw flag can be paired with a NaN yaw value (or the use of yawspeed instead of a fixed yaw) causing unintended heading changes. Review comments indicate this is a functional/behavioral bug (improper state/flag handling and fallback logic), though reviewers question whether the PR fixes the root cause, so confidence is medium.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "patch": "@@ -601,7 +601,14 @@ MissionBlock::set_loiter_item(struct mission_item_s *item, float min_clearance)\n \t\t}\n \n \t\titem->altitude_is_relative = false;\n-\t\titem->yaw = NAN;\n+\n+\t\tif (_navigator->get_vstatus()->is_rotary_wing) {\n+\t\t\titem->yaw = _navigator->get_global_position()->yaw;\n+\n+\t\t} else {\n+\t\t\titem->yaw = NAN;\n+\t\t}\n+\n \t\titem->loiter_radius = _navigator->get_loiter_radius();\n \t\titem->acceptance_radius = _navigator->get_acceptance_radius();\n \t\titem->time_inside = 0.0f;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/65a64746157968b35096a44745dcff2af1e87740/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_loiter_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_loiter_item"
        ]
      }
    }
  },
  {
    "title": "navigator: set yaw_valid flag in reposition triplet",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10294",
    "number": 10294,
    "created_at": "2018-08-21T21:00:11Z",
    "merged": true,
    "merged_at": "2018-09-16T23:29:39Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "@dagar @MaEtUgR @Stifael I'm wondering if we need these flags. On one hand we allow the yaw setpoint to be set to NAN on the other hand we still require a valid flag to be set.\nAnd sometimes one means the other like here\nhttps://github.com/PX4/Firmware/blob/master/src/modules/navigator/mission_block.cpp#L507\n\n@DonLakeFlyer @LorenzMeier FYI\n\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-22T06:38:40Z",
          "body": "@RomanBapst The fixed wing mission test failed.",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-08-22T06:48:52Z",
          "body": "> On one hand we allow the yaw setpoint to be set to NAN on the other hand we still require a valid flag to be set.\r\n\r\nI think what is missing is clear definition. In addition to NAN and the valid flags, Infinity is also used. ",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-08-26T09:58:29Z",
          "body": "@dagar Any idea what went wrong here? Is it one of those cases where you just need to restart it?",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-08-26T09:59:51Z",
          "body": "@dagar From what I see it lost datalink connection. Are these simulations actually using the reposition commands?",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-09-12T06:26:05Z",
          "body": "@dagar How do it get the ulog file from a CI run?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-09-16T23:02:28Z",
          "body": "Rebased on master.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes an inconsistent program state where the yaw validity flag and the yaw setpoint value were not synchronized (e.g. NaN/Infinity vs a 'valid' flag). That mismatch can cause incorrect conditional behavior (mission/test failures), and setting yaw_valid in the reposition triplet corrects the logic/state transition.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -323,9 +323,11 @@ Navigator::run()\n \t\t\t\t// Go on and check which changes had been requested\n \t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n \t\t\t\t\trep->current.yaw = cmd.param4;\n+\t\t\t\t\trep->current.yaw_valid = true;\n \n \t\t\t\t} else {\n \t\t\t\t\trep->current.yaw = NAN;\n+\t\t\t\t\trep->current.yaw_valid = false;\n \t\t\t\t}\n \n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1a20f3ba21db4119fe857ebc9fc7773d7cb6f03e/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Navigator: RC loss yaw mission item",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10291",
    "number": 10291,
    "created_at": "2018-08-21T16:17:09Z",
    "merged": true,
    "merged_at": "2018-08-21T19:05:56Z",
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "Added yaw mission item to `rcloss` state in `navigator`. This fixes the issue mentioned #10262 where the vehicle yaws in a seemingly random direction when RC is lost.\n\n**Test data / coverage**\nCurrent behavior:\n![selection_001](https://user-images.githubusercontent.com/37091262/44412682-c3f8c180-a526-11e8-9941-05af1f521a36.png)\nProposed behavior with this PR:\n![selection_002](https://user-images.githubusercontent.com/37091262/44414401-ed1b5100-a52a-11e8-837a-d81ea6349acb.png)\nhttps://review.px4.io/plot_app?log=2e96b2de-f511-49c0-a51a-a34ba7cabc13",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-08-21T19:05:05Z",
          "body": "I didn't know anyone was actually using RC Auto Recovery.",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-08-21T22:52:01Z",
          "body": "Hmm I thought this fixed our problem... but it seems our problem does not happen every time. We are seeing the quad yaw to a random heading when we lose RC  (most of the time). I know this is not the intended behavior in the code, and I've tracked it down to this line. Seems flight_tasks.update() is failing when we lose RC. The vehicle does not actually descend though.\r\n`line 607 in mc_pos_controller_main.cpp`\r\n```\r\n// update task\r\nif (!_flight_tasks.update()) {\r\n\t// FAILSAFE\r\n\t// Task was not able to update correctly. Do Failsafe.\r\n\tfailsafe(setpoint, _states);\r\n\r\n} \r\n```",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-22T06:50:52Z",
          "body": "@MaEtUgR Yaw = NaN is used to signal \"do not change yaw\". Is this maybe not correctly handled in flight tasks?",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-10-30T14:03:25Z",
          "body": "@LorenzMeier For the vehicle_local_position_setpoints which are outputs of the flight task and input to the position control class NAN is defined as a state that has no setpoint and is therefore not controlled: https://github.com/PX4/Firmware/blob/master/msg/vehicle_local_position_setpoint.msg#L2\r\n\r\nIt seems that the navigator sets NAN to hold wherever that is documented and the FlightTaskAuto which handles the hold mode does not translate this correctly. This translation would need to happen here: https://github.com/PX4/Firmware/blob/master/src/lib/FlightTasks/tasks/Auto/FlightTaskAuto.cpp#L200\r\n\r\n**EDIT:** Or the meaning of a setpoint being NAN is handeled consistently and the fix is the one from this pr.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses an incorrect program behaviour where the navigator left the yaw setpoint undefined (NaN) on RC loss, which led to unintended/random yaw. This is a logic error (improper state/output handling and inconsistent setpoint translation); adding an explicit yaw mission item for the rcloss state corrects the faulty state/output logic and prevents the unexpected yaw.",
    "patches": {
      "src/modules/navigator/rcloss.cpp": {
        "filename": "src/modules/navigator/rcloss.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -100,7 +100,7 @@ RCLoss::set_rcl_item()\n \t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n \t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n-\t\t\t_mission_item.yaw = NAN;\n+\t\t\t_mission_item.yaw = _navigator->get_global_position()->yaw;\n \t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n \t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0b56e55737d2b2ca30f1a16cddaa2771c20ce16e/src%2Fmodules%2Fnavigator%2Frcloss.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RCLoss::set_rcl_item"
      ],
      "by_file": {
        "src/modules/navigator/rcloss.cpp": [
          "RCLoss::set_rcl_item"
        ]
      }
    }
  },
  {
    "title": "mission:reset mission after finished",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10288",
    "number": 10288,
    "created_at": "2018-08-21T13:24:10Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "jinchengde",
      "body": "vehicle could reset mission after mission finished, change the flight mode to others and back to mission mode, no need disarm, the mission will reset.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-08-21T19:42:34Z",
          "body": "Great! This looks like a safe and simple way to do it.",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-03-01T13:40:17Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-03-15T13:54:37Z",
          "body": "Closing as stale.\n",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2020-01-13T20:22:26Z",
          "body": "I realize this is old and closed, but after a recent conversation with @jinchengde and after thinking about this a lot, I think this proposed change makes a lot of sense.  @jinchengde I recommend you rebase and reopen this PR.  I can't comment intelligently on the code, but the functionality makes sense.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-08-21T19:46:59Z",
          "body": "We have to be a little careful here because other parts of navigator set the mission result as well.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "jinchengde",
          "created_at": "2018-08-22T06:04:38Z",
          "body": "could you help to give some prompt which we need to protect, do we need to confirm vehicle in loiter mode before we reset the mission?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-25T21:51:49Z",
          "body": "@jinchengde we need to make sure that the next state after the mission ends does not crash the vehicle. Example: make sure the vehicle changes to HOLD or to LAND.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "jinchengde",
          "created_at": "2018-11-26T09:52:37Z",
          "body": "OKï¼ŒI will test for that, and I wish to have another PR for more modify",
          "path": "src/modules/navigator/mission.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "jinchengde",
          "created_at": "2018-12-01T12:48:20Z",
          "body": "@TSC21 I had test in SITL as below\r\n1. automatic takeoff and mission\r\n2. mission end, the vehicle start to circle around the last waypoint\r\n3. change the mode to hold, the vehicle stay current altitude and circle around\r\n4. change the mode to mission, the vehicle fly to the first waypoint\r\nso there is no crash after we change the mode after the mission ends",
          "path": "src/modules/navigator/mission.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect state transition behavior: a completed mission could be reset simply by switching flight modes without disarming. That is an unintended program behavior (improper state handling), so this change fixes a logic error related to mission state management.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -1684,6 +1684,13 @@ Mission::need_to_reset_mission(bool active)\n \t} else if (_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED && active) {\n \t\t/* mission is running, need reset after disarm */\n \t\t_need_mission_reset = true;\n+\n+\t} else if (_navigator->get_mission_result()->finished\n+\t\t   && _navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED\n+\t\t   && _need_mission_reset) {\n+\t\t/* mission is finished, need reset */\n+\t\t_need_mission_reset = false;\n+\t\treturn true;\n \t}\n \n \treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cff459565da5e74786c56a64a631ea92dcd82226/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::need_to_reset_mission"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::need_to_reset_mission"
        ]
      }
    }
  },
  {
    "title": "Add mission reset",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10287",
    "number": 10287,
    "created_at": "2018-08-21T12:06:11Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "jinchengde",
      "body": "after the vehicle finish mission, change the flight mode to others and back to mission mode, the vehicle will reset the mission, no need to disarm vehicle",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses an incorrect state transition: after a mission completes the mission state was not being reset when switching out of and back into mission mode unless the vehicle was disarmed. Changing the behavior to reset the mission on mode change corrects this unintended/incorrect behavior (a logic error) so the program's state matches expected operation.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -1684,6 +1684,13 @@ Mission::need_to_reset_mission(bool active)\n \t} else if (_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED && active) {\n \t\t/* mission is running, need reset after disarm */\n \t\t_need_mission_reset = true;\n+\n+\t} else if (_navigator->get_mission_result()->finished\n+\t\t   && _navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED\n+\t\t   && _need_mission_reset) {\n+\t\t/* mission is finished, need reset */\n+\t\t_need_mission_reset = false;\n+\t\treturn true;\n \t}\n \n \treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/28ba7cacfffc232c5a496a500b28910d268b26a0/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::need_to_reset_mission"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::need_to_reset_mission"
        ]
      }
    }
  },
  {
    "title": "Removed condition to move straight to RTL_LAND state.",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10252",
    "number": 10252,
    "created_at": "2018-08-16T21:24:54Z",
    "merged": true,
    "merged_at": "2018-08-16T22:08:47Z",
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "Essentially this not only doesn't work after adding the `_navigator->get_position_setpoint_triplet()->current.valid` check (setpoints are invalidated when navigator changes nav state) but sometimes it DOES work and instead of landing where it is AT (i.e `gpos.lat` and `gpos.lon`) the lat/lon setpoints are `home.lat` and `home.lon`. This is extremely bad, the vehicle just beelines towards `home.lat`, `home.lon`, and `home.alt`.\n\nThis wasn't a problem previously when we were using the `mc_pos_controller` for all the control, as previously the logic for `SETPOINT_TYPE_LAND` within `mc_pos_controller` would just set the lat/lon setpoints to NaN, which then caused the controller to default those setpoints to the current gpos.lat/gpos.lon and just land where it is at. \n\nI hope this didn't impact anyone other than ourselves. We've seen it maybe 5 times total over the course of the last few weeks of consistent flying. I don't know why it sometimes \"works\" and sometimes does not. Either way it needs to be removed!",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-08-16T22:08:15Z",
          "body": "Thanks for following up and fixing it. We can find another way to accomplish the same (intended) result.",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-08-16T22:17:25Z",
          "body": "Of course. And yes, I think the logic belongs `commander` itself though.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR removes an incorrect conditional that caused setpoints to be invalidated when changing nav state, which in turn produced wrong lat/lon targets (home) and made the vehicle fly to home instead of landing where it was. This is an unintended state/conditional logic bug (incorrect state transition and setpoint handling), so removing the condition fixes a logic error.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "patch": "@@ -69,11 +69,6 @@ RTL::on_activation()\n \t\t// For safety reasons don't go into RTL if landed.\n \t\t_rtl_state = RTL_STATE_LANDED;\n \n-\t} else if (_navigator->get_position_setpoint_triplet()->current.valid\n-\t\t   && _navigator->get_position_setpoint_triplet()->current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n-\t\t// Skip straight to land if already performing a land.\n-\t\t_rtl_state = RTL_STATE_LAND;\n-\n \t} else if ((rtl_type() == RTL_LAND) && _navigator->on_mission_landing()) {\n \t\t// RTL straight to RETURN state, but mission will takeover for landing.\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e5c5276aef5fddf5b11f63f8d5704f8db2cf3d92/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Avoidance Feedback Rebased",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10240",
    "number": 10240,
    "created_at": "2018-08-15T15:21:26Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "mrivi",
      "body": " Based on #10037 \n\n- if the vehicle projected position on the line previous-current triplet is past the current triplet, acceptance radius is enlarged such that navigator updates the triplets\n- if the vehicle is within the xy acceptance radius but not inside the z one, enlarge the altitude acceptance radius such that navigator updates the triplets set the feedback yaw acceptance to NAN such that it is ignored by navigator\n\nMissions shouldn't get stuck anymore because a waypoint is not reachable or a waypoint is reached with a heading different from what navigator expects",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-16T07:49:38Z",
          "body": "@mrivi Could you please rebase one more time and check CI? Flash space is now resolved, so any remaining failures should be real.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-16T15:29:48Z",
          "body": "Why is this code here just commented out?",
          "path": "src/modules/gnd_pos_control/GroundRoverPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-08-17T15:12:10Z",
          "body": "@dagar how can we bring this in? Could we use this new message only for avoidance and then in a new PR use it for VTOL as well?",
          "path": "src/modules/gnd_pos_control/GroundRoverPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-19T09:34:16Z",
          "body": "@mrivi You are not filling the payload of the message but still publishing it below - is this intended?",
          "path": "src/modules/gnd_pos_control/GroundRoverPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-19T14:52:02Z",
          "body": "This was from the original PR https://github.com/PX4/Firmware/pull/10037 where fw_pos_ctrl_status was being generalized. Some of these fields are straight copies of what also goes out in vehicle_attitude_setpoint, so I was going to drop them.\r\n\r\n\r\nLet's finish https://github.com/PX4/Firmware/pull/10037 and rebase.",
          "path": "src/modules/gnd_pos_control/GroundRoverPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-08-20T13:57:51Z",
          "body": "@dagar I have rebased. ",
          "path": "src/modules/gnd_pos_control/GroundRoverPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the conditions and acceptance radii used to update navigator triplets so missions don't get stuck when a waypoint is effectively past the current leg or when only the altitude acceptance fails. These are incorrect acceptance/state-transition checks (and handling of yaw acceptance) that produced unintended behavior, so the change addresses a logic error.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -56,4 +56,5 @@ px4_add_module(\n \tDEPENDS\n \t\tgit_ecl\n \t\tecl_geo\n+\t\tlanding_slope\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a89ec2b18781518f7c94e457d194b0435505b558/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -322,7 +322,7 @@ MissionBlock::is_mission_item_reached()\n \n \t\tif ((_navigator->get_vstatus()->is_rotary_wing\n \t\t     || (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT && _mission_item.force_heading))\n-\t\t    && PX4_ISFINITE(_mission_item.yaw)) {\n+\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))) {\n \n \t\t\t/* check course if defined only for rotary wing except takeoff */\n \t\t\tfloat cog = _navigator->get_vstatus()->is_rotary_wing ? _navigator->get_global_position()->yaw : atan2f(",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a89ec2b18781518f7c94e457d194b0435505b558/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "patch": "@@ -45,10 +45,12 @@\n #include \"navigator.h\"\n \n #include <drivers/drv_pwm_output.h>\n-#include <fw_pos_control_l1/Landingslope.hpp>\n #include <lib/ecl/geo/geo.h>\n-#include <mathlib/mathlib.h>\n+#include <lib/mathlib/mathlib.h>\n+#include <lib/landing_slope/Landingslope.hpp>\n #include <systemlib/mavlink_log.h>\n+#include <uORB/Subscription.hpp>\n+#include <uORB/topics/position_controller_landing_status.h>\n \n bool\n MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission,\n@@ -395,19 +397,22 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \n \t\t\t\tif (MissionBlock::item_contains_position(missionitem_previous)) {\n \n-\t\t\t\t\tconst bool fw_status_valid = (_navigator->get_fw_pos_ctrl_status()->timestamp > 0);\n+\t\t\t\t\tuORB::Subscription<position_controller_landing_status_s> landing_status{ORB_ID(position_controller_landing_status)};\n+\t\t\t\t\tlanding_status.forcedUpdate();\n+\n+\t\t\t\t\tconst bool landing_status_valid = (landing_status.get().timestamp > 0);\n \t\t\t\t\tconst float wp_distance = get_distance_to_next_waypoint(missionitem_previous.lat, missionitem_previous.lon,\n \t\t\t\t\t\t\t\t  missionitem.lat, missionitem.lon);\n \n-\t\t\t\t\tif (fw_status_valid && (wp_distance > _navigator->get_fw_pos_ctrl_status()->landing_flare_length)) {\n+\t\t\t\t\tif (landing_status_valid && (wp_distance > landing_status.get().flare_length)) {\n \t\t\t\t\t\t/* Last wp is before flare region */\n \n \t\t\t\t\t\tconst float delta_altitude = missionitem.altitude - missionitem_previous.altitude;\n \n \t\t\t\t\t\tif (delta_altitude < 0) {\n \n-\t\t\t\t\t\t\tconst float horizontal_slope_displacement = _navigator->get_fw_pos_ctrl_status()->landing_horizontal_slope_displacement;\n-\t\t\t\t\t\t\tconst float slope_angle_rad = _navigator->get_fw_pos_ctrl_status()->landing_slope_angle_rad;\n+\t\t\t\t\t\t\tconst float horizontal_slope_displacement = landing_status.get().horizontal_slope_displacement;\n+\t\t\t\t\t\t\tconst float slope_angle_rad = landing_status.get().slope_angle_rad;\n \t\t\t\t\t\t\tconst float slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude,\n \t\t\t\t\t\t\t\t\t\t    horizontal_slope_displacement, slope_angle_rad);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a89ec2b18781518f7c94e457d194b0435505b558/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -43,7 +43,6 @@\n \n #include <dataman/dataman.h>\n #include <uORB/topics/mission.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n \n class Geofence;\n class Navigator;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a89ec2b18781518f7c94e457d194b0435505b558/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 22,
        "deletions": 9,
        "changes": 31,
        "patch": "@@ -55,15 +55,17 @@\n #include \"rtl.h\"\n #include \"takeoff.h\"\n \n-#include <navigator/navigation.h>\n-#include <px4_module_params.h>\n+#include \"navigation.h\"\n+\n+#include <lib/perf/perf_counter.h>\n #include <px4_module.h>\n-#include <perf/perf_counter.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n+#include <px4_module_params.h>\n+#include <uORB/Subscription.hpp>\n #include <uORB/topics/geofence_result.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n #include <uORB/topics/parameter_update.h>\n+#include <uORB/topics/position_controller_status.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/vehicle_attitude_setpoint.h>\n #include <uORB/topics/vehicle_command.h>\n@@ -145,7 +147,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t/**\n \t * Getters\n \t */\n-\tstruct fw_pos_ctrl_status_s *get_fw_pos_ctrl_status() { return &_fw_pos_ctrl_status; }\n \tstruct home_position_s *get_home_position() { return &_home_pos; }\n \tstruct mission_result_s *get_mission_result() { return &_mission_result; }\n \tstruct position_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n@@ -240,6 +241,16 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tfloat\t\tget_acceptance_radius(float mission_item_radius);\n \n+\t/**\n+\t * Get the yaw acceptance given the current mission item\n+\t *\n+\t * @param mission_item_yaw the yaw to use in case the controller-derived radius is finite\n+\t *\n+\t * @return the yaw at which the next waypoint should be used or if the yaw at a waypoint\n+\t * should be ignored\n+\t */\n+\tfloat \t\tget_yaw_acceptance(float mission_item_yaw);\n+\n \torb_advert_t\t*get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n \tvoid\t\tincrement_mission_instance_count() { _mission_result.instance_count++; }\n@@ -271,14 +282,14 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool\t\tforce_vtol();\n \n private:\n-\tint\t\t_fw_pos_ctrl_status_sub{-1};\t/**< notification of vehicle capabilities updates */\n \tint\t\t_global_pos_sub{-1};\t\t/**< global position subscription */\n \tint\t\t_gps_pos_sub{-1};\t\t/**< gps position subscription */\n \tint\t\t_home_pos_sub{-1};\t\t/**< home position subscription */\n \tint\t\t_land_detected_sub{-1};\t\t/**< vehicle land detected subscription */\n \tint\t\t_local_pos_sub{-1};\t\t/**< local position subscription */\n \tint\t\t_offboard_mission_sub{-1};\t/**< offboard mission subscription */\n \tint\t\t_param_update_sub{-1};\t\t/**< param update subscription */\n+\tint\t\t_pos_ctrl_landing_status_sub{-1};\t/**< position controller landing status subscription */\n \tint\t\t_traffic_sub{-1};\t\t/**< traffic subscription */\n \tint\t\t_vehicle_command_sub{-1};\t/**< vehicle commands (onboard and offboard) */\n \tint\t\t_vstatus_sub{-1};\t\t/**< vehicle status subscription */\n@@ -292,15 +303,18 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \torb_advert_t\t_vehicle_roi_pub{nullptr};\n \n \t// Subscriptions\n-\tfw_pos_ctrl_status_s\t\t\t\t_fw_pos_ctrl_status{};\t/**< fixed wing navigation capabilities */\n \thome_position_s\t\t\t\t\t_home_pos{};\t\t/**< home position for RTL */\n \tmission_result_s\t\t\t\t_mission_result{};\n \tvehicle_global_position_s\t\t\t_global_pos{};\t\t/**< global vehicle position */\n \tvehicle_gps_position_s\t\t\t\t_gps_pos{};\t\t/**< gps position */\n \tvehicle_land_detected_s\t\t\t\t_land_detected{};\t/**< vehicle land_detected */\n \tvehicle_local_position_s\t\t\t_local_pos{};\t\t/**< local vehicle position */\n \tvehicle_status_s\t\t\t\t_vstatus{};\t\t/**< vehicle status */\n-\tuint8_t\t\t\t\t\t_previous_nav_state{}; /**< nav_state of the previous iteration*/\n+\n+\tuORB::Subscription<position_controller_status_s>\t_position_controller_status_sub{ORB_ID(position_controller_status)};\n+\n+\tuint8_t\t\t\t\t\t\t_previous_nav_state{}; /**< nav_state of the previous iteration*/\n+\n \t// Publications\n \tgeofence_result_s\t\t\t\t_geofence_result{};\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet{};\t/**< triplet of position setpoints */\n@@ -360,7 +374,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _mission_throttle{-1.0f};\n \n \t// update subscriptions\n-\tvoid\t\tfw_pos_ctrl_status_update(bool force = false);\n \tvoid\t\tglobal_position_update();\n \tvoid\t\tgps_position_update();\n \tvoid\t\thome_position_update(bool force = false);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a89ec2b18781518f7c94e457d194b0435505b558/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 38,
        "changes": 96,
        "patch": "@@ -46,26 +46,24 @@\n #include \"navigator.h\"\n \n #include <cfloat>\n-#include <sys/ioctl.h>\n #include <sys/stat.h>\n-#include <sys/types.h>\n \n #include <dataman/dataman.h>\n #include <drivers/drv_hrt.h>\n #include <lib/ecl/geo/geo.h>\n-#include <mathlib/mathlib.h>\n+#include <lib/mathlib/mathlib.h>\n #include <px4_config.h>\n #include <px4_defines.h>\n #include <px4_posix.h>\n #include <px4_tasks.h>\n #include <systemlib/mavlink_log.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n+#include <uORB/topics/position_controller_landing_status.h>\n+#include <uORB/topics/transponder_report.h>\n #include <uORB/topics/vehicle_command.h>\n #include <uORB/topics/vehicle_command_ack.h>\n #include <uORB/topics/vehicle_status.h>\n-#include <uORB/topics/transponder_report.h>\n #include <uORB/uORB.h>\n \n /**\n@@ -77,6 +75,8 @@ extern \"C\" __EXPORT int navigator_main(int argc, char *argv[]);\n \n #define GEOFENCE_CHECK_INTERVAL 200000\n \n+using namespace time_literals;\n+\n namespace navigator\n {\n Navigator\t*g_navigator;\n@@ -141,17 +141,6 @@ Navigator::home_position_update(bool force)\n \t}\n }\n \n-void\n-Navigator::fw_pos_ctrl_status_update(bool force)\n-{\n-\tbool updated = false;\n-\torb_check(_fw_pos_ctrl_status_sub, &updated);\n-\n-\tif (updated || force) {\n-\t\torb_copy(ORB_ID(fw_pos_ctrl_status), _fw_pos_ctrl_status_sub, &_fw_pos_ctrl_status);\n-\t}\n-}\n-\n void\n Navigator::vehicle_status_update()\n {\n@@ -193,7 +182,7 @@ Navigator::run()\n \t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n \t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n \t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n-\t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n+\t_pos_ctrl_landing_status_sub = orb_subscribe(ORB_ID(position_controller_landing_status));\n \t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n \t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n \t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n@@ -209,7 +198,6 @@ Navigator::run()\n \tlocal_position_update();\n \tgps_position_update();\n \thome_position_update(true);\n-\tfw_pos_ctrl_status_update(true);\n \tparams_update();\n \n \t/* wakeup source(s) */\n@@ -293,11 +281,7 @@ Navigator::run()\n \t\t}\n \n \t\t/* navigation capabilities updated */\n-\t\torb_check(_fw_pos_ctrl_status_sub, &updated);\n-\n-\t\tif (updated) {\n-\t\t\tfw_pos_ctrl_status_update();\n-\t\t}\n+\t\t_position_controller_status_sub.update();\n \n \t\t/* home position updated */\n \t\torb_check(_home_pos_sub, &updated);\n@@ -762,14 +746,11 @@ Navigator::run()\n \t\t}\n \n \t\tif (_pos_sp_triplet_updated) {\n-\t\t\t_pos_sp_triplet.timestamp = hrt_absolute_time();\n \t\t\tpublish_position_setpoint_triplet();\n-\t\t\t_pos_sp_triplet_updated = false;\n \t\t}\n \n \t\tif (_mission_result_updated) {\n \t\t\tpublish_mission_result();\n-\t\t\t_mission_result_updated = false;\n \t\t}\n \n \t\tperf_end(_loop_perf);\n@@ -778,7 +759,7 @@ Navigator::run()\n \torb_unsubscribe(_global_pos_sub);\n \torb_unsubscribe(_local_pos_sub);\n \torb_unsubscribe(_gps_pos_sub);\n-\torb_unsubscribe(_fw_pos_ctrl_status_sub);\n+\torb_unsubscribe(_pos_ctrl_landing_status_sub);\n \torb_unsubscribe(_vstatus_sub);\n \torb_unsubscribe(_land_detected_sub);\n \torb_unsubscribe(_home_pos_sub);\n@@ -827,18 +808,22 @@ Navigator::print_status()\n void\n Navigator::publish_position_setpoint_triplet()\n {\n-\t/* do not publish an empty triplet */\n+\t// do not publish an invalid setpoint\n \tif (!_pos_sp_triplet.current.valid) {\n \t\treturn;\n \t}\n \n+\t_pos_sp_triplet.timestamp = hrt_absolute_time();\n+\n \t/* lazily publish the position setpoint triplet only once available */\n \tif (_pos_sp_triplet_pub != nullptr) {\n \t\torb_publish(ORB_ID(position_setpoint_triplet), _pos_sp_triplet_pub, &_pos_sp_triplet);\n \n \t} else {\n \t\t_pos_sp_triplet_pub = orb_advertise(ORB_ID(position_setpoint_triplet), &_pos_sp_triplet);\n \t}\n+\n+\t_pos_sp_triplet_updated = false;\n }\n \n float\n@@ -860,7 +845,16 @@ Navigator::get_altitude_acceptance_radius()\n \t\treturn _param_fw_alt_acceptance_radius.get();\n \n \t} else {\n-\t\treturn _param_mc_alt_acceptance_radius.get();\n+\t\tfloat alt_acceptance_radius = _param_mc_alt_acceptance_radius.get();\n+\n+\t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\t\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)\n+\t\t    && pos_ctrl_status.altitude_acceptance_radius > alt_acceptance_radius) {\n+\t\t\talt_acceptance_radius = pos_ctrl_status.altitude_acceptance_radius;\n+\t\t}\n+\n+\t\treturn alt_acceptance_radius;\n \t}\n }\n \n@@ -934,15 +928,30 @@ Navigator::get_acceptance_radius(float mission_item_radius)\n \t// when in fixed wing mode\n \t// this might need locking against a commanded transition\n \t// so that a stale _vstatus doesn't trigger an accepted mission item.\n-\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n-\t\tif ((hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 5000000) && (_fw_pos_ctrl_status.turn_distance > radius)) {\n-\t\t\tradius = _fw_pos_ctrl_status.turn_distance;\n-\t\t}\n+\n+\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp) && pos_ctrl_status.acceptance_radius > radius) {\n+\t\tradius = pos_ctrl_status.acceptance_radius;\n \t}\n \n \treturn radius;\n }\n \n+float\n+Navigator::get_yaw_acceptance(float mission_item_yaw)\n+{\n+\tfloat yaw = mission_item_yaw;\n+\n+\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp) && !PX4_ISFINITE(pos_ctrl_status.yaw_acceptance)) {\n+\t\tyaw = pos_ctrl_status.yaw_acceptance;\n+\t}\n+\n+\treturn yaw;\n+}\n+\n void\n Navigator::load_fence_from_file(const char *filename)\n {\n@@ -1099,15 +1108,24 @@ void Navigator::check_traffic()\n bool\n Navigator::abort_landing()\n {\n+\t// only abort if currently landing and position controller status updated\n \tbool should_abort = false;\n \n-\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n-\t\tif (hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 1000000) {\n+\tif (_pos_sp_triplet.current.valid\n+\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n+\n+\t\tbool updated = false;\n \n-\t\t\tif (get_position_setpoint_triplet()->current.valid\n-\t\t\t    && get_position_setpoint_triplet()->current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n+\t\torb_check(_pos_ctrl_landing_status_sub, &updated);\n \n-\t\t\t\tshould_abort = _fw_pos_ctrl_status.abort_landing;\n+\t\tif (updated) {\n+\t\t\tposition_controller_landing_status_s landing_status = {};\n+\n+\t\t\t// landing status from position controller must be newer than navigator's last position setpoint\n+\t\t\tif (orb_copy(ORB_ID(position_controller_landing_status), _pos_ctrl_landing_status_sub, &landing_status)) {\n+\t\t\t\tif (landing_status.timestamp > _pos_sp_triplet.timestamp) {\n+\t\t\t\t\tshould_abort = landing_status.abort_landing;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -1199,6 +1217,8 @@ Navigator::publish_mission_result()\n \t_mission_result.item_do_jump_changed = false;\n \t_mission_result.item_changed_index = 0;\n \t_mission_result.item_do_jump_remaining = 0;\n+\n+\t_mission_result_updated = false;\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a89ec2b18781518f7c94e457d194b0435505b558/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::check_traffic",
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "Navigator::home_position_update",
        "MissionBlock::is_mission_item_reached",
        "Navigator::run",
        "Navigator::publish_mission_result",
        "Navigator::get_altitude_acceptance_radius",
        "Navigator::print_status",
        "fw_pos_ctrl_status_update",
        "PX4_ISFINITE",
        "Navigator::get_acceptance_radius"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "PX4_ISFINITE"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding"
        ],
        "src/modules/navigator/navigator.h": [
          "fw_pos_ctrl_status_update"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::check_traffic",
          "Navigator::home_position_update",
          "Navigator::run",
          "Navigator::publish_mission_result",
          "Navigator::get_altitude_acceptance_radius",
          "Navigator::print_status",
          "Navigator::get_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "Accept onboard computer heartbeats as telemetry",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10194",
    "number": 10194,
    "created_at": "2018-08-08T15:37:33Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "okalachev",
      "body": "This PR solves #10042 problem, that `STATUSTEXT` messages are not passed, when there is no GCS.\nAlso, this is a partial implementation of #7985.\n\nI pass `telemetry_status`, when OBC heartbeats received, but I changed the commander logic, for not considering OBC as a datalink.\n\nSo `NAV_DLL_ACT`, `COM_DL_LOSS_T`, `COM_DL_REG_T` are only about GCS link, not OBC (not renaming for backwards compatibility).\n\nThe OBC failsafe params, like `NAV_OBC_DLL_ACT`, `COM_OBC_DL_LOSS_T`, `COM_OBC_DL_REG_T` can be added later.\n\n@LorenzMeier , @TSC21 .",
      "issue_comments": [
        {
          "author": "TSC21",
          "created_at": "2018-08-08T15:42:07Z",
          "body": "This looks reasonable and can be extended for an OBC datalink failsafe after. Can you please rebase?",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-08-08T16:02:03Z",
          "body": "@okalachev: http://ci.px4.io:8080/blue/organizations/jenkins/PX4%2FFirmware/detail/PR-10194/2/pipeline#step-205-log-1111",
          "type": "issue_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-08T16:22:55Z",
          "body": "@TSC21 , thanks, I'll look.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-08T18:20:06Z",
          "body": "A few minor comments, but overall looks good.",
          "type": "issue_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-09T14:20:56Z",
          "body": "@TSC21 , I found the bug.\r\n\r\nThe problem starts, when multiple telemetry \"sources\" are on the same Mavlink instance, so this is the same `telemetry_status` topic instance, and the same \"telemetry\" in commander's `telemetry_data` array.\r\n\r\nSo, I don's see an easy solution yet, looks like a lot of telemetry logic should be changed.",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-08-09T14:24:24Z",
          "body": "@okalachev that probably means we need a different `telemetry_status` topic instance for each of the telemetry sources. Probably multitopic is required.",
          "type": "issue_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-09T14:36:01Z",
          "body": "I guess the maximum number of topic instances are `ORB_MULTI_MAX_INSTANCES`, which is 4. But the number of telemetry \"sources\" that way would be something like 255 (systems) * 255 (systems' components).\r\n\r\nSo, maybe not to use multitopic for that. Instead, to add system and component ids to `telemetry_status`? ",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-08-09T14:39:52Z",
          "body": "> I guess the maximum number of topic instances are `ORB_MULTI_MAX_INSTANCES`, which is 4. But the number of telemetry \"sources\" that way would be something like 255 (systems) * 255 (systems' components).\r\n\r\nWell I was thinking on limit the telemetry sources based on type and not on sys+comp id. But I guess that would make more sense yes. Can you propose that in a new issue as a RFC? Probably better to have a discussion about it first before one commits to it.",
          "type": "issue_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-09T14:58:37Z",
          "body": "You mean to write an RFC for adding sys and comp ids to `telemetry_status`?\r\n\r\nI'm not sure this is so large change to make an RFC.",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-08-09T15:00:39Z",
          "body": "> I'm not sure this is so large change to make an RFC.\r\n\r\nIt's a conceptual/structural change/feature that needs to be discussed.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-08-16T16:35:59Z",
          "body": "Could you please rebase? Thanks!",
          "type": "issue_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-16T16:45:27Z",
          "body": "Unfortunately, it doesn't make sense for now, because this change introduces a new bug, that I described in previous messages.\r\n\r\nI don't see an easy solution yet, without rewriting `telemetry_status` logic.",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-25T21:07:19Z",
          "body": "@okalachev what's the status of this? Have you thought of a way of bringing this into a state that does work?",
          "type": "issue_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-11-25T21:18:52Z",
          "body": "@TSC21, sorry, unfortunately I haven't worked at this yet. The easy workaround is to send fake GCS heartbeats from ROS code. The conversation can be continued at https://github.com/PX4/Firmware/issues/10042.\r\n\r\nThis PR can be closed I guess, as the implementation is incorrect.",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-25T21:25:52Z",
          "body": "The PR is not totally incorrect. It's rather incomplete. But I accept that we can bring a more complete solution in a new PR. Please fill free to close it or maybe we can iterate from here.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-28T14:53:20Z",
          "body": "Revisiting this idea - https://github.com/PX4/Firmware/pull/10933",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-02-26T15:27:57Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-03-12T16:13:01Z",
          "body": "Closing as stale.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-08-08T18:18:31Z",
          "body": "Is there any reason we can't drop this check entirely now?",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 8,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-08T18:19:25Z",
          "body": "How about ground control instead of GCS?",
          "path": "src/modules/commander/state_machine_helper.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-08T21:15:23Z",
          "body": "What if there is a heartbeat from another drone (in a swarm network), charging station, or any other device? Should it be considered as a telemetry link?\r\nI don't think so.",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 8,
          "type": "review_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-08-08T21:15:59Z",
          "body": "I don't see a huge difference, but I can change it.",
          "path": "src/modules/commander/state_machine_helper.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR attempts to address a telemetry logic problem but the author discovered it introduces a new incorrect behavior: multiple telemetry sources share the same telemetry_status/topic instance causing incorrect commander state. The implementation is incomplete/incorrect and was abandoned, so it does not successfully fix the underlying logic error.",
    "patches": {
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -98,7 +98,7 @@ PARAM_DEFINE_FLOAT(NAV_FW_ALT_RAD, 10.0f);\n PARAM_DEFINE_FLOAT(NAV_MC_ALT_RAD, 0.8f);\n \n /**\n- * Set data link loss failsafe mode\n+ * Set GCS data link loss failsafe mode\n  *\n  * The data link loss failsafe will only be entered after a timeout,\n  * set by COM_DL_LOSS_T in seconds. Once the timeout occurs the selected",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d0c29f1e9ccc5101f10f3f35efb583df725fd9c6/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Smooth auto desired vel",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10193",
    "number": 10193,
    "created_at": "2018-08-08T12:02:53Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "Stifael",
      "body": "Please use [PX4 Discuss](http://discuss.px4.io/) or [Slack](http://slack.px4.io/) to align on pull requests if necessary.\r\n\r\n**Test data / coverage**\r\nLogs uploaded to http://logs.px4.io or screenshots.\r\n\r\n**Describe problem solved by the proposed pull request**\r\nA clear and concise description of the problem, if any, this feature will solve. E.g. I'm always frustrated when ...\r\n\r\n**Describe your preferred solution**\r\nA clear and concise description of what you have implemented.\r\n\r\n**Describe possible alternatives**\r\nA clear and concise description of alternative solutions or features you've considered.\r\n\r\n**Additional context**\r\nAdd any other context or screenshots for the feature request here.\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR contains only a title ('Smooth auto desired vel') and an empty template body with no code changes, diffs, or discussion. There is no description of a bug, incorrect behavior, or the specific change made, so there's no evidence this addresses a logic error.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "patch": "@@ -112,7 +112,6 @@ Loiter::set_loiter_position()\n \tpos_sp_triplet->next.valid = false;\n \n \t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n-\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n@@ -139,26 +138,7 @@ Loiter::reposition()\n \t\tmemcpy(&pos_sp_triplet->current, &rep->current, sizeof(rep->current));\n \t\tpos_sp_triplet->next.valid = false;\n \n-\t\t// set yaw (depends on the value of parameter MIS_YAWMODE):\n-\t\t// MISSION_YAWMODE_NONE: do not change yaw setpoint\n-\t\t// MISSION_YAWMODE_FRONT_TO_WAYPOINT: point to next waypoint\n-\t\tif (_param_yawmode.get() != MISSION_YAWMODE_NONE) {\n-\t\t\tfloat travel_dist = get_distance_to_next_waypoint(_navigator->get_global_position()->lat,\n-\t\t\t\t\t    _navigator->get_global_position()->lon,\n-\t\t\t\t\t    pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n-\n-\t\t\tif (travel_dist > 1.0f) {\n-\t\t\t\t// calculate direction the vehicle should point to.\n-\t\t\t\tpos_sp_triplet->current.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t\t\t\t\t      _navigator->get_global_position()->lat,\n-\t\t\t\t\t\t\t\t      _navigator->get_global_position()->lon,\n-\t\t\t\t\t\t\t\t      pos_sp_triplet->current.lat,\n-\t\t\t\t\t\t\t\t      pos_sp_triplet->current.lon);\n-\t\t\t}\n-\t\t}\n-\n \t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n-\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \n \t\t// mark this as done",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24872af5808843b077f2b5ab67f04c1150179bec/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -76,9 +76,5 @@ class Loiter : public MissionBlock, public ModuleParams\n \t */\n \tvoid set_loiter_position();\n \n-\tDEFINE_PARAMETERS(\n-\t\t(ParamInt<px4::params::MIS_YAWMODE>) _param_yawmode\n-\t)\n-\n \tbool _loiter_pos_set{false};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24872af5808843b077f2b5ab67f04c1150179bec/src%2Fmodules%2Fnavigator%2Floiter.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 102,
        "changes": 166,
        "patch": "@@ -54,7 +54,6 @@\n #include <systemlib/mavlink_log.h>\n #include <systemlib/err.h>\n #include <lib/ecl/geo/geo.h>\n-#include <lib/mathlib/mathlib.h>\n #include <navigator/navigation.h>\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n@@ -246,15 +245,23 @@ Mission::on_active()\n \t}\n \n \t/* see if we need to update the current yaw heading */\n-\tif (_navigator->get_vroi().mode == vehicle_roi_s::ROI_LOCATION\n-\t    || (_param_yawmode.get() != MISSION_YAWMODE_NONE\n-\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n-\t\t&& _mission_type != MISSION_TYPE_NONE)\n-\t    || _navigator->get_vstatus()->is_vtol) {\n-\n+\tif (!_param_mnt_yaw_ctl.get() && (_navigator->get_vstatus()->is_rotary_wing)\n+\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n+\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n+\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n+\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n+\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n+\t\t || _work_item_type == WORK_ITEM_TYPE_ALIGN)) {\n+\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n+\t\t// needs to rotate such that ROI is in the field of view.\n+\t\t// ROI only makes sense for multicopters.\n \t\theading_sp_update();\n \t}\n \n+\t// TODO: Add vtol heading update method if required.\n+\t// Question: Why does vtol ever have to update heading?\n+\n \t/* check if landing needs to be aborted */\n \tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n \t    && (_navigator->abort_landing())) {\n@@ -1170,112 +1177,67 @@ Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n void\n Mission::heading_sp_update()\n {\n-\t/* we don't want to be yawing during takeoff, landing or aligning for a transition */\n-\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n-\t    || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n-\t    || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n-\t    || _mission_item.nav_cmd == NAV_CMD_LAND\n-\t    || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n-\t    || _work_item_type == WORK_ITEM_TYPE_ALIGN) {\n-\n-\t\treturn;\n-\t}\n-\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\t/* Don't change setpoint if last and current waypoint are not valid */\n-\tif (!pos_sp_triplet->current.valid) {\n-\t\treturn;\n-\t}\n-\n-\t/* Calculate direction the vehicle should point to. */\n-\n-\tdouble point_from_latlon[2];\n-\tdouble point_to_latlon[2];\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet =\n+\t\t_navigator->get_position_setpoint_triplet();\n+\n+\t// Only update if current triplet is valid\n+\tif (pos_sp_triplet->current.valid) {\n+\n+\t\tdouble point_from_latlon[2] = { _navigator->get_global_position()->lat,\n+\t\t\t\t\t\t_navigator->get_global_position()->lon\n+\t\t\t\t\t      };\n+\t\tdouble point_to_latlon[2] = { _navigator->get_global_position()->lat,\n+\t\t\t\t\t      _navigator->get_global_position()->lon\n+\t\t\t\t\t    };\n+\t\tfloat yaw_offset = 0.0f;\n+\n+\t\t// Depending on ROI-mode, update heading\n+\t\tswitch (_navigator->get_vroi().mode) {\n+\t\tcase vehicle_roi_s::ROI_LOCATION: {\n+\t\t\t\t// ROI is a fixed location. Vehicle needs to point towards that location\n+\t\t\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n+\t\t\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n+\t\t\t\t// No yaw offset required\n+\t\t\t\tyaw_offset = 0.0f;\n+\t\t\t\tbreak;\n+\t\t\t}\n \n-\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n-\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n+\t\tcase vehicle_roi_s::ROI_WPNEXT: {\n+\t\t\t\t// ROI is current waypoint. Vehcile needs to point towards current waypoint\n+\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n+\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n+\t\t\t\t// Add the gimbal's yaw offset\n+\t\t\t\tyaw_offset = _navigator->get_vroi().yaw_offset;\n+\t\t\t\tbreak;\n+\t\t\t}\n \n-\tif (_navigator->get_vroi().mode == vehicle_roi_s::ROI_LOCATION && !_param_mnt_yaw_ctl.get()) {\n-\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n-\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n+\t\tcase vehicle_roi_s::ROI_NONE:\n+\t\tcase vehicle_roi_s::ROI_WPINDEX:\n+\t\tcase vehicle_roi_s::ROI_TARGET:\n+\t\tcase vehicle_roi_s::ROI_ENUM_END:\n+\t\tdefault: {\n+\t\t\t}\n+\t\t}\n \n-\t\t/* stop if positions are close together to prevent excessive yawing */\n-\t\tfloat d_current = get_distance_to_next_waypoint(\n-\t\t\t\t\t  point_from_latlon[0], point_from_latlon[1],\n-\t\t\t\t\t  point_to_latlon[0], point_to_latlon[1]);\n+\t\t// Get desired heading and update it.\n+\t\t// However, only update if distance to desired heading is\n+\t\t// larger than acceptance radius to prevent excessive yawing\n+\t\tfloat d_current = get_distance_to_next_waypoint(point_from_latlon[0],\n+\t\t\t\t  point_from_latlon[1], point_to_latlon[0], point_to_latlon[1]);\n \n \t\tif (d_current > _navigator->get_acceptance_radius()) {\n-\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t\t    point_from_latlon[0], point_from_latlon[1],\n-\t\t\t\t\t    point_to_latlon[0], point_to_latlon[1]);\n+\t\t\tfloat yaw = wrap_pi(\n+\t\t\t\t\t    get_bearing_to_next_waypoint(point_from_latlon[0],\n+\t\t\t\t\t\t\t    point_from_latlon[1], point_to_latlon[0],\n+\t\t\t\t\t\t\t    point_to_latlon[1]) + yaw_offset);\n \n \t\t\t_mission_item.yaw = yaw;\n \t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n \t\t}\n \n-\t} else {\n-\t\t/* set yaw angle for the waypoint if a loiter time has been specified */\n-\t\tif (_waypoint_position_reached && get_time_inside(_mission_item) > FLT_EPSILON) {\n-\t\t\t// XXX: should actually be param4 from mission item\n-\t\t\t// at the moment it will just keep the heading it has\n-\t\t\t//_mission_item.yaw = _on_arrival_yaw;\n-\t\t\t//pos_sp_triplet->current.yaw = _mission_item.yaw;\n-\n-\t\t} else {\n-\t\t\t/* target location is home */\n-\t\t\tif ((_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME\n-\t\t\t     || _param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME)\n-\t\t\t    // need to be rotary wing for this but not in a transition\n-\t\t\t    // in VTOL mode this will prevent updating yaw during FW flight\n-\t\t\t    // (which would result in a wrong yaw setpoint spike during back transition)\n-\t\t\t    && _navigator->get_vstatus()->is_rotary_wing\n-\t\t\t    && !(_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION || _navigator->get_vstatus()->in_transition_mode)) {\n-\n-\t\t\t\tpoint_to_latlon[0] = _navigator->get_home_position()->lat;\n-\t\t\t\tpoint_to_latlon[1] = _navigator->get_home_position()->lon;\n-\n-\t\t\t} else {\n-\t\t\t\t/* target location is next (current) waypoint */\n-\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n-\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n-\t\t\t}\n-\n-\t\t\tfloat d_current = get_distance_to_next_waypoint(\n-\t\t\t\t\t\t  point_from_latlon[0], point_from_latlon[1],\n-\t\t\t\t\t\t  point_to_latlon[0], point_to_latlon[1]);\n-\n-\t\t\t/* stop if positions are close together to prevent excessive yawing */\n-\t\t\tif (d_current > _navigator->get_acceptance_radius()) {\n-\t\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t\t\t    point_from_latlon[0],\n-\t\t\t\t\t\t    point_from_latlon[1],\n-\t\t\t\t\t\t    point_to_latlon[0],\n-\t\t\t\t\t\t    point_to_latlon[1]);\n-\n-\t\t\t\t/* always keep the back of the rotary wing pointing towards home */\n-\t\t\t\tif (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n-\t\t\t\t\t_mission_item.yaw = wrap_pi(yaw + M_PI_F);\n-\t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\n-\t\t\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT\n-\t\t\t\t\t   && _navigator->get_vroi().mode == vehicle_roi_s::ROI_WPNEXT && !_param_mnt_yaw_ctl.get()) {\n-\t\t\t\t\t/* if yaw control for the mount is disabled and we have a valid ROI that points to the next\n-\t\t\t\t\t * waypoint, we add the gimbal's yaw offset to the vehicle's yaw */\n-\t\t\t\t\tyaw += _navigator->get_vroi().yaw_offset;\n-\t\t\t\t\t_mission_item.yaw = yaw;\n-\t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\n-\t\t\t\t} else {\n-\t\t\t\t\t_mission_item.yaw = yaw;\n-\t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t// we set yaw directly so we can run this in parallel to the FOH update\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n-\n-\t// we set yaw directly so we can run this in parallel to the FOH update\n-\t_navigator->set_position_setpoint_triplet_updated();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24872af5808843b077f2b5ab67f04c1150179bec/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -247,7 +247,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_dist_1wp,\n \t\t(ParamFloat<px4::params::MIS_DIST_WPS>) _param_dist_between_wps,\n \t\t(ParamInt<px4::params::MIS_ALTMODE>) _param_altmode,\n-\t\t(ParamInt<px4::params::MIS_YAWMODE>) _param_yawmode,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mnt_yaw_ctl\n \t)\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24872af5808843b077f2b5ab67f04c1150179bec/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "patch": "@@ -119,21 +119,6 @@ PARAM_DEFINE_FLOAT(MIS_DIST_WPS, 900);\n  */\n PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n \n-/**\n- * Multirotor only. Yaw setpoint mode.\n- *\n- * The values are defined in the enum mission_altitude_mode\n- *\n- * @min 0\n- * @max 3\n- * @value 0 Heading as set by waypoint\n- * @value 1 Heading towards waypoint\n- * @value 2 Heading towards home\n- * @value 3 Heading away from home\n- * @group Mission\n- */\n-PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n-\n /**\n * Enable yaw control of the mount. (Only affects multicopters and ROI mission items)\n *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24872af5808843b077f2b5ab67f04c1150179bec/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "Loiter::reposition",
        "Mission::calculate_takeoff_altitude",
        "Loiter::set_loiter_position",
        "Mission::on_active"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::reposition",
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::calculate_takeoff_altitude",
          "Mission::on_active"
        ]
      }
    }
  },
  {
    "title": "[WIP] Avoidance feedback",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10180",
    "number": 10180,
    "created_at": "2018-08-07T12:37:54Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "mrivi",
      "body": "Branch based on #10013 plus #10037 cherry-picked on top. \n- if the vehicle projected position on the line previous-current triplet is past the current triplet, the acceptance radius is enlarged such that navigator updates the triplets\n- if the vehicle is within the xy acceptance radius but not inside the z one, enlarge the altitude acceptance radius such that navigator updates the triplets\n- set the feedback yaw acceptance to NAN such that it is ignored by navigator\n\nMissions shouldn't get stuck anymore because a waypoint is not reachable or a waypoint is reached with a heading different from what navigator expects",
      "issue_comments": [
        {
          "author": "mrivi",
          "created_at": "2018-08-15T15:22:11Z",
          "body": "Closing this in favor of #10240 ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes the conditions used to decide when the navigator advances waypoints (triplet updates) by enlarging acceptance radii and ignoring yaw acceptance in certain cases. That addresses incorrect state-transition/acceptance logic that could leave missions stuck when a waypoint is unreachable or reached with an unexpected heading, so it is fixing a logic error.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -322,7 +322,7 @@ MissionBlock::is_mission_item_reached()\n \n \t\tif ((_navigator->get_vstatus()->is_rotary_wing\n \t\t     || (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT && _mission_item.force_heading))\n-\t\t    && PX4_ISFINITE(_mission_item.yaw)) {\n+\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))) {\n \n \t\t\t/* check course if defined only for rotary wing except takeoff */\n \t\t\tfloat cog = _navigator->get_vstatus()->is_rotary_wing ? _navigator->get_global_position()->yaw : atan2f(",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7cefcb3649cc6d3d2e6615e330c7483f073e7a7b/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "patch": "@@ -395,19 +395,21 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \n \t\t\t\tif (MissionBlock::item_contains_position(missionitem_previous)) {\n \n-\t\t\t\t\tconst bool fw_status_valid = (_navigator->get_fw_pos_ctrl_status()->timestamp > 0);\n+\t\t\t\t\tuORB::Subscription<fw_pos_ctrl_status_s> fw_pos_ctrl_status{ORB_ID(fw_pos_ctrl_status)};\n+\n+\t\t\t\t\tconst bool fw_status_valid = (fw_pos_ctrl_status.get().timestamp > 0);\n \t\t\t\t\tconst float wp_distance = get_distance_to_next_waypoint(missionitem_previous.lat, missionitem_previous.lon,\n \t\t\t\t\t\t\t\t  missionitem.lat, missionitem.lon);\n \n-\t\t\t\t\tif (fw_status_valid && (wp_distance > _navigator->get_fw_pos_ctrl_status()->landing_flare_length)) {\n+\t\t\t\t\tif (fw_status_valid && (wp_distance > fw_pos_ctrl_status.get().landing_flare_length)) {\n \t\t\t\t\t\t/* Last wp is before flare region */\n \n \t\t\t\t\t\tconst float delta_altitude = missionitem.altitude - missionitem_previous.altitude;\n \n \t\t\t\t\t\tif (delta_altitude < 0) {\n \n-\t\t\t\t\t\t\tconst float horizontal_slope_displacement = _navigator->get_fw_pos_ctrl_status()->landing_horizontal_slope_displacement;\n-\t\t\t\t\t\t\tconst float slope_angle_rad = _navigator->get_fw_pos_ctrl_status()->landing_slope_angle_rad;\n+\t\t\t\t\t\t\tconst float horizontal_slope_displacement = fw_pos_ctrl_status.get().landing_horizontal_slope_displacement;\n+\t\t\t\t\t\t\tconst float slope_angle_rad = fw_pos_ctrl_status.get().landing_slope_angle_rad;\n \t\t\t\t\t\t\tconst float slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude,\n \t\t\t\t\t\t\t\t\t\t    horizontal_slope_displacement, slope_angle_rad);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7cefcb3649cc6d3d2e6615e330c7483f073e7a7b/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "patch": "@@ -59,11 +59,11 @@\n #include <px4_module_params.h>\n #include <px4_module.h>\n #include <perf/perf_counter.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n #include <uORB/topics/geofence_result.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n #include <uORB/topics/parameter_update.h>\n+#include <uORB/topics/position_controller_status.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/vehicle_attitude_setpoint.h>\n #include <uORB/topics/vehicle_command.h>\n@@ -145,7 +145,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t/**\n \t * Getters\n \t */\n-\tstruct fw_pos_ctrl_status_s *get_fw_pos_ctrl_status() { return &_fw_pos_ctrl_status; }\n \tstruct home_position_s *get_home_position() { return &_home_pos; }\n \tstruct mission_result_s *get_mission_result() { return &_mission_result; }\n \tstruct position_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n@@ -240,6 +239,16 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tfloat\t\tget_acceptance_radius(float mission_item_radius);\n \n+\t/**\n+\t * Get the yaw acceptance given the current mission item\n+\t *\n+\t * @param mission_item_yaw the yaw to use in case the controller-derived radius is finite\n+\t *\n+\t * @return the yaw at which the next waypoint should be used or if the yaw at a waypoint\n+\t * should be ignored\n+\t */\n+\tfloat \t\tget_yaw_acceptance(float mission_item_yaw);\n+\n \torb_advert_t\t*get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n \tvoid\t\tincrement_mission_instance_count() { _mission_result.instance_count++; }\n@@ -271,7 +280,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool\t\tforce_vtol();\n \n private:\n-\tint\t\t_fw_pos_ctrl_status_sub{-1};\t/**< notification of vehicle capabilities updates */\n \tint\t\t_global_pos_sub{-1};\t\t/**< global position subscription */\n \tint\t\t_gps_pos_sub{-1};\t\t/**< gps position subscription */\n \tint\t\t_home_pos_sub{-1};\t\t/**< home position subscription */\n@@ -292,15 +300,17 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \torb_advert_t\t_vehicle_roi_pub{nullptr};\n \n \t// Subscriptions\n-\tfw_pos_ctrl_status_s\t\t\t\t_fw_pos_ctrl_status{};\t/**< fixed wing navigation capabilities */\n \thome_position_s\t\t\t\t\t_home_pos{};\t\t/**< home position for RTL */\n \tmission_result_s\t\t\t\t_mission_result{};\n \tvehicle_global_position_s\t\t\t_global_pos{};\t\t/**< global vehicle position */\n \tvehicle_gps_position_s\t\t\t\t_gps_pos{};\t\t/**< gps position */\n \tvehicle_land_detected_s\t\t\t\t_land_detected{};\t/**< vehicle land_detected */\n \tvehicle_local_position_s\t\t\t_local_pos{};\t\t/**< local vehicle position */\n \tvehicle_status_s\t\t\t\t_vstatus{};\t\t/**< vehicle status */\n+\tuORB::Subscription<position_controller_status_s>\t_position_controller_status_sub{ORB_ID(position_controller_status)};\n+\n \tuint8_t\t\t\t\t\t_previous_nav_state{}; /**< nav_state of the previous iteration*/\n+\n \t// Publications\n \tgeofence_result_s\t\t\t\t_geofence_result{};\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet{};\t/**< triplet of position setpoints */\n@@ -360,7 +370,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _mission_throttle{-1.0f};\n \n \t// update subscriptions\n-\tvoid\t\tfw_pos_ctrl_status_update(bool force = false);\n \tvoid\t\tglobal_position_update();\n \tvoid\t\tgps_position_update();\n \tvoid\t\thome_position_update(bool force = false);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7cefcb3649cc6d3d2e6615e330c7483f073e7a7b/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 27,
        "changes": 62,
        "patch": "@@ -59,9 +59,9 @@\n #include <px4_posix.h>\n #include <px4_tasks.h>\n #include <systemlib/mavlink_log.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n+#include <uORB/topics/position_controller_status.h>\n #include <uORB/topics/vehicle_command.h>\n #include <uORB/topics/vehicle_command_ack.h>\n #include <uORB/topics/vehicle_status.h>\n@@ -77,6 +77,8 @@ extern \"C\" __EXPORT int navigator_main(int argc, char *argv[]);\n \n #define GEOFENCE_CHECK_INTERVAL 200000\n \n+using namespace time_literals;\n+\n namespace navigator\n {\n Navigator\t*g_navigator;\n@@ -141,17 +143,6 @@ Navigator::home_position_update(bool force)\n \t}\n }\n \n-void\n-Navigator::fw_pos_ctrl_status_update(bool force)\n-{\n-\tbool updated = false;\n-\torb_check(_fw_pos_ctrl_status_sub, &updated);\n-\n-\tif (updated || force) {\n-\t\torb_copy(ORB_ID(fw_pos_ctrl_status), _fw_pos_ctrl_status_sub, &_fw_pos_ctrl_status);\n-\t}\n-}\n-\n void\n Navigator::vehicle_status_update()\n {\n@@ -193,7 +184,6 @@ Navigator::run()\n \t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n \t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n \t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n-\t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n \t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n \t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n \t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n@@ -209,7 +199,6 @@ Navigator::run()\n \tlocal_position_update();\n \tgps_position_update();\n \thome_position_update(true);\n-\tfw_pos_ctrl_status_update(true);\n \tparams_update();\n \n \t/* wakeup source(s) */\n@@ -293,11 +282,7 @@ Navigator::run()\n \t\t}\n \n \t\t/* navigation capabilities updated */\n-\t\torb_check(_fw_pos_ctrl_status_sub, &updated);\n-\n-\t\tif (updated) {\n-\t\t\tfw_pos_ctrl_status_update();\n-\t\t}\n+\t\t_position_controller_status_sub.update();\n \n \t\t/* home position updated */\n \t\torb_check(_home_pos_sub, &updated);\n@@ -778,7 +763,6 @@ Navigator::run()\n \torb_unsubscribe(_global_pos_sub);\n \torb_unsubscribe(_local_pos_sub);\n \torb_unsubscribe(_gps_pos_sub);\n-\torb_unsubscribe(_fw_pos_ctrl_status_sub);\n \torb_unsubscribe(_vstatus_sub);\n \torb_unsubscribe(_land_detected_sub);\n \torb_unsubscribe(_home_pos_sub);\n@@ -860,7 +844,16 @@ Navigator::get_altitude_acceptance_radius()\n \t\treturn _param_fw_alt_acceptance_radius.get();\n \n \t} else {\n-\t\treturn _param_mc_alt_acceptance_radius.get();\n+\t\tfloat alt_acceptance_radius = _param_mc_alt_acceptance_radius.get();\n+\n+\t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\t\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)\n+\t\t    && pos_ctrl_status.altitude_acceptance_radius > alt_acceptance_radius) {\n+\t\t\talt_acceptance_radius = pos_ctrl_status.altitude_acceptance_radius;\n+\t\t}\n+\n+\t\treturn alt_acceptance_radius;\n \t}\n }\n \n@@ -934,15 +927,30 @@ Navigator::get_acceptance_radius(float mission_item_radius)\n \t// when in fixed wing mode\n \t// this might need locking against a commanded transition\n \t// so that a stale _vstatus doesn't trigger an accepted mission item.\n-\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n-\t\tif ((hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 5000000) && (_fw_pos_ctrl_status.turn_distance > radius)) {\n-\t\t\tradius = _fw_pos_ctrl_status.turn_distance;\n-\t\t}\n+\n+\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp) && pos_ctrl_status.acceptance_radius > radius) {\n+\t\tradius = pos_ctrl_status.acceptance_radius;\n \t}\n \n \treturn radius;\n }\n \n+float\n+Navigator::get_yaw_acceptance(float mission_item_yaw)\n+{\n+\tfloat yaw = mission_item_yaw;\n+\n+\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp) && !PX4_ISFINITE(pos_ctrl_status.yaw_acceptance)) {\n+\t\tyaw = pos_ctrl_status.yaw_acceptance;\n+\t}\n+\n+\treturn yaw;\n+}\n+\n void\n Navigator::load_fence_from_file(const char *filename)\n {\n@@ -1102,12 +1110,12 @@ Navigator::abort_landing()\n \tbool should_abort = false;\n \n \tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n-\t\tif (hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 1000000) {\n+\t\tif (hrt_elapsed_time(&_position_controller_status_sub.get().timestamp) < 1_s) {\n \n \t\t\tif (get_position_setpoint_triplet()->current.valid\n \t\t\t    && get_position_setpoint_triplet()->current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n \n-\t\t\t\tshould_abort = _fw_pos_ctrl_status.abort_landing;\n+\t\t\t\tshould_abort = _position_controller_status_sub.get().abort_landing;\n \t\t\t}\n \t\t}\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7cefcb3649cc6d3d2e6615e330c7483f073e7a7b/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "Navigator::home_position_update",
        "MissionBlock::is_mission_item_reached",
        "Navigator::run",
        "Navigator::get_altitude_acceptance_radius",
        "Navigator::abort_landing",
        "fw_pos_ctrl_status_update",
        "PX4_ISFINITE",
        "Navigator::get_acceptance_radius"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached",
          "PX4_ISFINITE"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding"
        ],
        "src/modules/navigator/navigator.h": [
          "fw_pos_ctrl_status_update"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::home_position_update",
          "Navigator::run",
          "Navigator::get_altitude_acceptance_radius",
          "Navigator::abort_landing",
          "Navigator::get_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "uORB: update msgs fields from camelCase to snake_case",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10077",
    "number": 10077,
    "created_at": "2018-07-29T20:41:28Z",
    "merged": true,
    "merged_at": "2018-07-30T19:40:29Z",
    "state": "closed",
    "conversation": {
      "author": "TSC21",
      "body": "**Describe problem solved by the proposed pull request**\nIn the process of developing a ROS2 package that will be interfacing PX4 with ROS2 through fast-RTPS, I found out that while trying to building the package with the respective ROS msg generation, `rosidl_generate_interfaces()` does not process msg fields which have uppercase letters.\n\n**Describe your preferred solution**\nThis is an harmless PR which changes some message fields that have uppercase letters (or present a camelCase naming convention) so `rosidl_generate_interfaces()` is able to generate code for ROS IDL files. It basically replaces the uppercase with lowercase, and where required, change the naming convention to snake_case.\n\n**Describe possible alternatives**\nNot really much more we can do about it, unless one changes the copied file online during the build process, which is not really efficient.",
      "issue_comments": [
        {
          "author": "TSC21",
          "created_at": "2018-07-29T20:46:10Z",
          "body": "Also, after this gets merged, I think it will make sense to actually have something like a schema validator for uORB msgs, so that we can make sure every new fields that is added follows the same convention (does make much sense to have fields following different naming conventions). This validator would run on CI as a new job, parallel to the style check job for example.\r\n@dagar any thoughts?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-29T21:02:42Z",
          "body": "Anything from the ROS world that already solves this problem?",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-07-29T21:07:03Z",
          "body": "> Anything from the ROS world that already solves this problem?\r\n\r\nNo. This is actually a requirement for the message generation through ROS IDL generator python scripts.",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-07-29T21:16:55Z",
          "body": "Will be issuing a PR against Flight Review so to address these changes as well.",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-07-29T21:49:17Z",
          "body": "Changes on Flight Review addressed in https://github.com/PX4/flight_review/pull/123.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-07-29T21:50:33Z",
          "body": "@TSC21 Can you add a change that breaks the build if someone re-introduces this? Like a check in the Python generator for PX4 uORB messages?",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-07-29T21:53:24Z",
          "body": ">@TSC21 Can you add a change that breaks the build if someone re-introduces this? Like a check in the Python generator for PX4 uORB messages?\r\n\r\n@LorenzMeier that's what I was actually referencing here https://github.com/PX4/Firmware/pull/10077#issuecomment-408704710. @dagar believes that clang-tidy could possibly handle this if we actually generate the headers and then do the check against those. Would that be a better alternative to a check in the Python generator?",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-07-30T08:25:45Z",
          "body": "@TSC21 Let's keep it simple so we can merge this: Extend our message generator and throw an error please. I don't want this to start depending on something else and we drag it out weeks.\r\n\r\nThanks!",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-07-30T14:54:08Z",
          "body": "@LorenzMeier done",
          "type": "issue_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-07-30T20:25:34Z",
          "body": "@LorenzMeier thanks for merging. This does unblock the package development.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-07-29T21:10:41Z",
          "body": "@CarlOlsson did you have opinions about the naming of these fields? If so we might as well tackle that here quickly.",
          "path": "msg/tecs_status.msg",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-29T21:11:27Z",
          "body": "@bresch, @RomanBapst, @tstastny, @philipoe, @acfloria - anyone feel strongly about the naming of these fields?",
          "path": "msg/tecs_status.msg",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR corrects message field names to meet ROS IDL naming constraints (camelCase -> snake_case) so the ROS generator can build messages. That's a compatibility/naming fix to avoid build-generation failures, not a correction of program logic or algorithmic behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -967,7 +967,7 @@ void Navigator::fake_traffic(const char *callsign, float distance, float directi\n \n \ttransponder_report_s tr = {};\n \ttr.timestamp = hrt_absolute_time();\n-\ttr.ICAO_address = 1234;\n+\ttr.icao_address = 1234;\n \ttr.lat = lat; // Latitude, expressed as degrees\n \ttr.lon = lon; // Longitude, expressed as degrees\n \ttr.altitude_type = 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/213aa932b82cc0ceaeb84cb51c3827756c1f0560/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::fake_traffic"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::fake_traffic"
        ]
      }
    }
  },
  {
    "title": "Land: fix on_active() so mission finishes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10046",
    "number": 10046,
    "created_at": "2018-07-26T00:29:25Z",
    "merged": true,
    "merged_at": "2018-07-26T05:45:01Z",
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "**Test data / coverage**\nVerified that the mission can actually finish using a print statement and running a test in gazebo.\n\n**Describe problem solved by the proposed pull request**\nNot a problem per se, but it is indeed a bug with `land` from the perspective of a mission. \n\n**Describe your preferred solution**\nUse the function available to us `_navigator->get_land_detected()` to verify that we have indeed landed. The previous implementation was looking for  `is_mission_item_reached()`, which was unreachable because during land the mission item altitude set point was being set to absolute zero.",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error. The code previously used is_mission_item_reached() to decide mission completion during landing, but that condition was effectively unreachable because the landing item had an altitude setpoint of zero, preventing mission finish. Replacing it with a proper landed-state check (_navigator->get_land_detected()) corrects the improper state/termination logic.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -80,7 +80,7 @@ Land::on_active()\n \t}\n \n \n-\tif (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n+\tif (_navigator->get_land_detected()->landed) {\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n \t\tset_idle_item(&_mission_item);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4613366fa7ab1b508c2a57a57da6bd8577aac51c/src%2Fmodules%2Fnavigator%2Fland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_active"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ]
      }
    }
  },
  {
    "title": "RTL: If already landing, go straight to RTL_LAND",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10044",
    "number": 10044,
    "created_at": "2018-07-25T20:59:44Z",
    "merged": true,
    "merged_at": "2018-07-26T05:46:26Z",
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "**Test data / coverage**\nTested issuing a `land` command followed by an `rtl` command in gazebo. Vehicle continues to descend as expected.\n\n**Describe problem solved by the proposed pull request**\nRTL interrupts a land. This is an issue if an operator is trying to land the vehicle and a critically low battery triggers an RTL. We have seen many times the vehicle takeoff back into the air (RTL) when it is about to touch down for landing.\n\n**Describe your preferred solution**\nDo not allow RTL to `CLIMB` if already `position_setpoint_s::SETPOINT_TYPE_LAND`\n\n_I also cleaned up the comments, removed unnecessary includes, and got rid of namepacing_",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-07-25T22:07:54Z",
          "body": "We actually have to be a little careful here that the current position setpoint is still valid. The other option which might be safer overall is to go straight into RTL land if transitioning from the LAND navigation state.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-07-26T05:46:21Z",
          "body": "Thanks, perfect!",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-07-25T22:05:47Z",
          "body": "This should be okay if you also check `current.valid`.",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses an incorrect state transition in the navigation logic where an RTL command could interrupt an ongoing LAND and force a climb, producing unintended vehicle behavior. Preventing RTL from switching to CLIMB when the current setpoint is LAND corrects this flawed control flow/state-handling logic.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 36,
        "changes": 70,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2013-2017 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2013-2018 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -40,13 +40,6 @@\n #include \"rtl.h\"\n #include \"navigator.h\"\n \n-#include <cfloat>\n-\n-#include <mathlib/mathlib.h>\n-#include <systemlib/mavlink_log.h>\n-\n-using math::max;\n-using math::min;\n \n static constexpr float DELAY_SIGMA = 0.01f;\n \n@@ -59,7 +52,7 @@ RTL::RTL(Navigator *navigator) :\n void\n RTL::on_inactive()\n {\n-\t// reset RTL state\n+\t// Reset RTL state.\n \t_rtl_state = RTL_STATE_NONE;\n }\n \n@@ -73,21 +66,26 @@ void\n RTL::on_activation()\n {\n \tif (_navigator->get_land_detected()->landed) {\n-\t\t// for safety reasons don't go into RTL if landed\n+\t\t// For safety reasons don't go into RTL if landed.\n \t\t_rtl_state = RTL_STATE_LANDED;\n \n+\t} else if (_navigator->get_position_setpoint_triplet()->current.valid\n+\t\t   && _navigator->get_position_setpoint_triplet()->current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n+\t\t// Skip straight to land if already performing a land.\n+\t\t_rtl_state = RTL_STATE_LAND;\n+\n \t} else if ((rtl_type() == RTL_LAND) && _navigator->on_mission_landing()) {\n-\t\t// RTL straight to RETURN state, but mission will takeover for landing\n+\t\t// RTL straight to RETURN state, but mission will takeover for landing.\n \n \t} else if ((_navigator->get_global_position()->alt < _navigator->get_home_position()->alt + _param_return_alt.get())\n \t\t   || _rtl_alt_min) {\n \n-\t\t// if lower than return altitude, climb up first\n-\t\t// if rtl_alt_min is true then forcing altitude change even if above\n+\t\t// If lower than return altitude, climb up first.\n+\t\t// If rtl_alt_min is true then forcing altitude change even if above.\n \t\t_rtl_state = RTL_STATE_CLIMB;\n \n \t} else {\n-\t\t// otherwise go straight to return\n+\t\t// Otherwise go straight to return\n \t\t_rtl_state = RTL_STATE_RETURN;\n \t}\n \n@@ -112,17 +110,17 @@ RTL::set_return_alt_min(bool min)\n void\n RTL::set_rtl_item()\n {\n-\t// RTL_TYPE: mission landing\n-\t// landing using planned mission landing, fly to DO_LAND_START instead of returning HOME\n-\t// do nothing, let navigator takeover with mission landing\n+\t// RTL_TYPE: mission landing.\n+\t// Landing using planned mission landing, fly to DO_LAND_START instead of returning HOME.\n+\t// Do nothing, let navigator takeover with mission landing.\n \tif (rtl_type() == RTL_LAND) {\n \t\tif (_rtl_state > RTL_STATE_CLIMB) {\n \t\t\tif (_navigator->start_mission_landing()) {\n \t\t\t\tmavlink_and_console_log_info(_navigator->get_mavlink_log_pub(), \"RTL: using mission landing\");\n \t\t\t\treturn;\n \n \t\t\t} else {\n-\t\t\t\t// otherwise use regular RTL\n+\t\t\t\t// Otherwise use regular RTL.\n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RTL: unable to use mission landing\");\n \t\t\t}\n \t\t}\n@@ -135,19 +133,19 @@ RTL::set_rtl_item()\n \n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t// check if we are pretty close to home already\n+\t// Check if we are pretty close to home already.\n \tconst float home_dist = get_distance_to_next_waypoint(home.lat, home.lon, gpos.lat, gpos.lon);\n \n-\t// compute the return altitude\n-\tfloat return_alt = max(home.alt + _param_return_alt.get(), gpos.alt);\n+\t// Compute the return altitude.\n+\tfloat return_alt = math::max(home.alt + _param_return_alt.get(), gpos.alt);\n \n-\t// we are close to home, limit climb to min\n+\t// We are close to home, limit climb to min.\n \tif (home_dist < _param_rtl_min_dist.get()) {\n \t\treturn_alt = home.alt + _param_descend_alt.get();\n \t}\n \n-\t// compute the loiter altitude\n-\tconst float loiter_altitude = min(home.alt + _param_descend_alt.get(), gpos.alt);\n+\t// Compute the loiter altitude.\n+\tconst float loiter_altitude = math::min(home.alt + _param_descend_alt.get(), gpos.alt);\n \n \tswitch (_rtl_state) {\n \tcase RTL_STATE_CLIMB: {\n@@ -170,20 +168,20 @@ RTL::set_rtl_item()\n \n \tcase RTL_STATE_RETURN: {\n \n-\t\t\t// don't change altitude\n+\t\t\t// Don't change altitude.\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.lat = home.lat;\n \t\t\t_mission_item.lon = home.lon;\n \t\t\t_mission_item.altitude = return_alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n \n-\t\t\t// use home yaw if close to home\n-\t\t\t/* check if we are pretty close to home already */\n+\t\t\t// Use home yaw if close to home.\n+\t\t\t// Check if we are pretty close to home already.\n \t\t\tif (home_dist < _param_rtl_min_dist.get()) {\n \t\t\t\t_mission_item.yaw = home.yaw;\n \n \t\t\t} else {\n-\t\t\t\t// use current heading to home\n+\t\t\t\t// Use current heading to home.\n \t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, home.lat, home.lon);\n \t\t\t}\n \n@@ -210,7 +208,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.altitude = loiter_altitude;\n \t\t\t_mission_item.altitude_is_relative = false;\n \n-\t\t\t// except for vtol which might be still off here and should point towards this location\n+\t\t\t// Except for vtol which might be still off here and should point towards this location.\n \t\t\tconst float d_current = get_distance_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n \n \t\t\tif (_navigator->get_vstatus()->is_vtol && (d_current > _navigator->get_acceptance_radius())) {\n@@ -225,7 +223,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\t\t/* disable previous setpoint to prevent drift */\n+\t\t\t// Disable previous setpoint to prevent drift.\n \t\t\tpos_sp_triplet->previous.valid = false;\n \n \t\t\tmavlink_and_console_log_info(_navigator->get_mavlink_log_pub(), \"RTL: descend to %d m (%d m above home)\",\n@@ -236,15 +234,15 @@ RTL::set_rtl_item()\n \tcase RTL_STATE_LOITER: {\n \t\t\tconst bool autoland = (_param_land_delay.get() > FLT_EPSILON);\n \n-\t\t\t// don't change altitude\n+\t\t\t// Don't change altitude.\n \t\t\t_mission_item.lat = home.lat;\n \t\t\t_mission_item.lon = home.lon;\n \t\t\t_mission_item.altitude = loiter_altitude;\n \t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t_mission_item.yaw = home.yaw;\n \t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n \t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n-\t\t\t_mission_item.time_inside = max(_param_land_delay.get(), 0.0f);\n+\t\t\t_mission_item.time_inside = math::max(_param_land_delay.get(), 0.0f);\n \t\t\t_mission_item.autocontinue = autoland;\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n@@ -264,7 +262,7 @@ RTL::set_rtl_item()\n \t\t}\n \n \tcase RTL_STATE_LAND: {\n-\t\t\t// land at home position\n+\t\t\t// Land at home position.\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LAND;\n \t\t\t_mission_item.lat = home.lat;\n \t\t\t_mission_item.lon = home.lon;\n@@ -292,12 +290,12 @@ RTL::set_rtl_item()\n \n \treset_mission_item_reached();\n \n-\t/* execute command if set. This is required for commands like VTOL transition */\n+\t// Execute command if set. This is required for commands like VTOL transition.\n \tif (!item_contains_position(_mission_item)) {\n \t\tissue_command(_mission_item);\n \t}\n \n-\t/* convert mission item to current position setpoint and make it valid */\n+\t// Convert mission item to current position setpoint and make it valid.\n \tmission_apply_limitation(_mission_item);\n \n \tif (mission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current)) {\n@@ -328,7 +326,7 @@ RTL::advance_rtl()\n \n \tcase RTL_STATE_DESCEND:\n \n-\t\t/* only go to land if autoland is enabled */\n+\t\t// Only go to land if autoland is enabled.\n \t\tif (_param_land_delay.get() < -DELAY_SIGMA || _param_land_delay.get() > DELAY_SIGMA) {\n \t\t\t_rtl_state = RTL_STATE_LOITER;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d86b37fc0db5632008e9d99bb97b5e34dcd90221/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "RTL::set_return_alt_min",
        "RTL::on_activation",
        "RTL::RTL",
        "RTL::advance_rtl",
        "Copyright"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item",
          "RTL::set_return_alt_min",
          "RTL::advance_rtl",
          "RTL::RTL",
          "Copyright",
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Takeoff: Arm occasionally triggers `maybe_landed`",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10043",
    "number": 10043,
    "created_at": "2018-07-25T20:02:09Z",
    "merged": true,
    "merged_at": "2018-07-26T05:49:15Z",
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "**Test data / coverage**\nhttps://review.px4.io/plot_app?log=42ef1074-1762-4a6d-9861-bb0ec3a9ec38\n![takeoff](https://user-images.githubusercontent.com/37091262/43223873-b4b6c390-9011-11e8-9402-eb6985511e7b.png)\n\n\n**Describe problem solved by the proposed pull request**\nVery rarely (1 out of 20) an `arm` command will kick the **`land_detector`** into the  _`maybe_landed`_ state due to the torque from the props. This will cause the vehicle to fail to takeoff. I added the log statement (RESETTING TAKEOFF TO POSITION) at line 524 in `mission_block.cpp` which confirms that land detector thinks we are no longer `landed`.\n\n**Describe your preferred solution**\nCheck that  the vehicle is not  _`maybe_landed`_ as well as not _`landed`_ upon takeoff.",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-07-26T05:49:10Z",
          "body": "Thanks! I believe I have experienced these as well with vehicles with longer legs.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error where the takeoff logic did not properly handle the land_detector 'maybe_landed' state, allowing a transient torque on arming to trigger an incorrect landed/maybe_landed condition and prevent takeoff. The change tightens the pre-takeoff state checks to require the vehicle be neither 'landed' nor 'maybe_landed', correcting the improper state-based behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -520,7 +520,7 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \n \t\t// if already flying (armed and !landed) treat TAKEOFF like regular POSITION\n \t\tif ((_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED)\n-\t\t    && !_navigator->get_land_detected()->landed) {\n+\t\t    && !_navigator->get_land_detected()->landed && !_navigator->get_land_detected()->maybe_landed) {\n \n \t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5ab3f054096bded36fa31745bffde05cb94c6370/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "generic position controller status/feedback message",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10037",
    "number": 10037,
    "created_at": "2018-07-25T14:34:37Z",
    "merged": true,
    "merged_at": "2018-08-31T18:43:53Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "Not done, but should give you an idea.\n\nTODO\n - yaw acceptance (+ error threshold?)\n - z acceptance could come from the position controller\n - eliminate as much vehicle specific code from navigator as possible\n - consider vtol usage for back transition\n - stopping distance (loiter/rtl/geofence braking)",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-07-26T12:53:34Z",
          "body": "TODO: vtol implications (multi topic).",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-19T16:51:14Z",
          "body": "Ok I think this is everything we need right now. Needs testing and review.",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-08-23T18:15:41Z",
          "body": "@dagar can we get this PR tested?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-25T14:46:21Z",
          "body": "@PX4/testflights could you test this branch on FW or VTOL (must transition to FW)? The test should include at least a couple waypoints. ",
          "type": "issue_comment"
        },
        {
          "author": "dannyfpv",
          "created_at": "2018-08-28T23:00:38Z",
          "body": "pr tested on v3 fw\r\nhttps://review.px4.io/plot_app?log=851676a3-f71a-419f-b253-2d5aa822c350\r\nhttps://review.px4.io/plot_app?log=54f1fa1b-25c3-405d-b673-3ea058310f2a\r\nhttps://review.px4.io/plot_app?log=9586fcb4-e87a-4d51-860d-6ca7b709ef45\r\nhttps://review.px4.io/plot_app?log=aa094d9e-68d5-4c01-bf55-22f6a790d1a0",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-29T03:39:52Z",
          "body": "Thanks @dannyfpv \r\n\r\nI did a little more testing in SITL and everything looks good except for a small regression in FW landing abort behaviour that I'll have fixed shortly.",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-08-30T18:03:41Z",
          "body": "@dagar have you made any progress?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-30T19:39:53Z",
          "body": "@mrivi good to go.",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-08-31T08:53:39Z",
          "body": "@dagar do we need more tests or can we merge directly?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-31T13:24:22Z",
          "body": "We can merge, but let's wait for master to be unbroken (https://github.com/PX4/Firmware/pull/10379). ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "mrivi",
          "created_at": "2018-08-21T07:14:55Z",
          "body": "`yaw_acceptance` should be feedback into navigator, right? From #10240,  dc99bb088ad9c1a1b28a0db22e00a896bc9355d6",
          "path": "msg/position_controller_status.msg",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-08-25T14:43:37Z",
          "body": "Yes.",
          "path": "msg/position_controller_status.msg",
          "position": 14,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "Looks fine in general. I'd like comments what the items in the message mean and what their units are.",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR introduces a generic position controller status/feedback message and related refactoring/feature work rather than explicitly correcting an incorrect algorithm or state transition. Comments mention testing and a small regression that was fixed, but there is no clear indication the PR's primary purpose was to fix a logic bug causing incorrect program behavior â€” it appears to be feature/addition and cleanup work.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -56,4 +56,5 @@ px4_add_module(\n \tDEPENDS\n \t\tgit_ecl\n \t\tecl_geo\n+\t\tlanding_slope\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/33f0a3c2b6ac49fef183e4c51691edf31c786617/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "patch": "@@ -45,10 +45,12 @@\n #include \"navigator.h\"\n \n #include <drivers/drv_pwm_output.h>\n-#include <fw_pos_control_l1/Landingslope.hpp>\n #include <lib/ecl/geo/geo.h>\n-#include <mathlib/mathlib.h>\n+#include <lib/mathlib/mathlib.h>\n+#include <lib/landing_slope/Landingslope.hpp>\n #include <systemlib/mavlink_log.h>\n+#include <uORB/Subscription.hpp>\n+#include <uORB/topics/position_controller_landing_status.h>\n \n bool\n MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission,\n@@ -395,19 +397,22 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \n \t\t\t\tif (MissionBlock::item_contains_position(missionitem_previous)) {\n \n-\t\t\t\t\tconst bool fw_status_valid = (_navigator->get_fw_pos_ctrl_status()->timestamp > 0);\n+\t\t\t\t\tuORB::Subscription<position_controller_landing_status_s> landing_status{ORB_ID(position_controller_landing_status)};\n+\t\t\t\t\tlanding_status.forcedUpdate();\n+\n+\t\t\t\t\tconst bool landing_status_valid = (landing_status.get().timestamp > 0);\n \t\t\t\t\tconst float wp_distance = get_distance_to_next_waypoint(missionitem_previous.lat, missionitem_previous.lon,\n \t\t\t\t\t\t\t\t  missionitem.lat, missionitem.lon);\n \n-\t\t\t\t\tif (fw_status_valid && (wp_distance > _navigator->get_fw_pos_ctrl_status()->landing_flare_length)) {\n+\t\t\t\t\tif (landing_status_valid && (wp_distance > landing_status.get().flare_length)) {\n \t\t\t\t\t\t/* Last wp is before flare region */\n \n \t\t\t\t\t\tconst float delta_altitude = missionitem.altitude - missionitem_previous.altitude;\n \n \t\t\t\t\t\tif (delta_altitude < 0) {\n \n-\t\t\t\t\t\t\tconst float horizontal_slope_displacement = _navigator->get_fw_pos_ctrl_status()->landing_horizontal_slope_displacement;\n-\t\t\t\t\t\t\tconst float slope_angle_rad = _navigator->get_fw_pos_ctrl_status()->landing_slope_angle_rad;\n+\t\t\t\t\t\t\tconst float horizontal_slope_displacement = landing_status.get().horizontal_slope_displacement;\n+\t\t\t\t\t\t\tconst float slope_angle_rad = landing_status.get().slope_angle_rad;\n \t\t\t\t\t\t\tconst float slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude,\n \t\t\t\t\t\t\t\t\t\t    horizontal_slope_displacement, slope_angle_rad);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/33f0a3c2b6ac49fef183e4c51691edf31c786617/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -43,7 +43,6 @@\n \n #include <dataman/dataman.h>\n #include <uORB/topics/mission.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n \n class Geofence;\n class Navigator;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/33f0a3c2b6ac49fef183e4c51691edf31c786617/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "patch": "@@ -55,15 +55,17 @@\n #include \"rtl.h\"\n #include \"takeoff.h\"\n \n-#include <navigator/navigation.h>\n-#include <px4_module_params.h>\n+#include \"navigation.h\"\n+\n+#include <lib/perf/perf_counter.h>\n #include <px4_module.h>\n-#include <perf/perf_counter.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n+#include <px4_module_params.h>\n+#include <uORB/Subscription.hpp>\n #include <uORB/topics/geofence_result.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n #include <uORB/topics/parameter_update.h>\n+#include <uORB/topics/position_controller_status.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/vehicle_attitude_setpoint.h>\n #include <uORB/topics/vehicle_command.h>\n@@ -145,7 +147,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t/**\n \t * Getters\n \t */\n-\tstruct fw_pos_ctrl_status_s *get_fw_pos_ctrl_status() { return &_fw_pos_ctrl_status; }\n \tstruct home_position_s *get_home_position() { return &_home_pos; }\n \tstruct mission_result_s *get_mission_result() { return &_mission_result; }\n \tstruct position_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n@@ -278,14 +279,14 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool\t\tforce_vtol();\n \n private:\n-\tint\t\t_fw_pos_ctrl_status_sub{-1};\t/**< notification of vehicle capabilities updates */\n \tint\t\t_global_pos_sub{-1};\t\t/**< global position subscription */\n \tint\t\t_gps_pos_sub{-1};\t\t/**< gps position subscription */\n \tint\t\t_home_pos_sub{-1};\t\t/**< home position subscription */\n \tint\t\t_land_detected_sub{-1};\t\t/**< vehicle land detected subscription */\n \tint\t\t_local_pos_sub{-1};\t\t/**< local position subscription */\n \tint\t\t_offboard_mission_sub{-1};\t/**< offboard mission subscription */\n \tint\t\t_param_update_sub{-1};\t\t/**< param update subscription */\n+\tint\t\t_pos_ctrl_landing_status_sub{-1};\t/**< position controller landing status subscription */\n \tint\t\t_traffic_sub{-1};\t\t/**< traffic subscription */\n \tint\t\t_vehicle_command_sub{-1};\t/**< vehicle commands (onboard and offboard) */\n \tint\t\t_vstatus_sub{-1};\t\t/**< vehicle status subscription */\n@@ -299,15 +300,18 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \torb_advert_t\t_vehicle_roi_pub{nullptr};\n \n \t// Subscriptions\n-\tfw_pos_ctrl_status_s\t\t\t\t_fw_pos_ctrl_status{};\t/**< fixed wing navigation capabilities */\n \thome_position_s\t\t\t\t\t_home_pos{};\t\t/**< home position for RTL */\n \tmission_result_s\t\t\t\t_mission_result{};\n \tvehicle_global_position_s\t\t\t_global_pos{};\t\t/**< global vehicle position */\n \tvehicle_gps_position_s\t\t\t\t_gps_pos{};\t\t/**< gps position */\n \tvehicle_land_detected_s\t\t\t\t_land_detected{};\t/**< vehicle land_detected */\n \tvehicle_local_position_s\t\t\t_local_pos{};\t\t/**< local vehicle position */\n \tvehicle_status_s\t\t\t\t_vstatus{};\t\t/**< vehicle status */\n-\tuint8_t\t\t\t\t\t_previous_nav_state{}; /**< nav_state of the previous iteration*/\n+\n+\tuORB::Subscription<position_controller_status_s>\t_position_controller_status_sub{ORB_ID(position_controller_status)};\n+\n+\tuint8_t\t\t\t\t\t\t_previous_nav_state{}; /**< nav_state of the previous iteration*/\n+\n \t// Publications\n \tgeofence_result_s\t\t\t\t_geofence_result{};\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet{};\t/**< triplet of position setpoints */\n@@ -369,7 +373,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _mission_throttle{-1.0f};\n \n \t// update subscriptions\n-\tvoid\t\tfw_pos_ctrl_status_update(bool force = false);\n \tvoid\t\tglobal_position_update();\n \tvoid\t\tgps_position_update();\n \tvoid\t\thome_position_update(bool force = false);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/33f0a3c2b6ac49fef183e4c51691edf31c786617/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 37,
        "changes": 71,
        "patch": "@@ -46,26 +46,24 @@\n #include \"navigator.h\"\n \n #include <cfloat>\n-#include <sys/ioctl.h>\n #include <sys/stat.h>\n-#include <sys/types.h>\n \n #include <dataman/dataman.h>\n #include <drivers/drv_hrt.h>\n #include <lib/ecl/geo/geo.h>\n-#include <mathlib/mathlib.h>\n+#include <lib/mathlib/mathlib.h>\n #include <px4_config.h>\n #include <px4_defines.h>\n #include <px4_posix.h>\n #include <px4_tasks.h>\n #include <systemlib/mavlink_log.h>\n-#include <uORB/topics/fw_pos_ctrl_status.h>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n+#include <uORB/topics/position_controller_landing_status.h>\n+#include <uORB/topics/transponder_report.h>\n #include <uORB/topics/vehicle_command.h>\n #include <uORB/topics/vehicle_command_ack.h>\n #include <uORB/topics/vehicle_status.h>\n-#include <uORB/topics/transponder_report.h>\n #include <uORB/uORB.h>\n \n /**\n@@ -77,6 +75,8 @@ extern \"C\" __EXPORT int navigator_main(int argc, char *argv[]);\n \n #define GEOFENCE_CHECK_INTERVAL 200000\n \n+using namespace time_literals;\n+\n namespace navigator\n {\n Navigator\t*g_navigator;\n@@ -141,17 +141,6 @@ Navigator::home_position_update(bool force)\n \t}\n }\n \n-void\n-Navigator::fw_pos_ctrl_status_update(bool force)\n-{\n-\tbool updated = false;\n-\torb_check(_fw_pos_ctrl_status_sub, &updated);\n-\n-\tif (updated || force) {\n-\t\torb_copy(ORB_ID(fw_pos_ctrl_status), _fw_pos_ctrl_status_sub, &_fw_pos_ctrl_status);\n-\t}\n-}\n-\n void\n Navigator::vehicle_status_update()\n {\n@@ -193,7 +182,7 @@ Navigator::run()\n \t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n \t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n \t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n-\t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n+\t_pos_ctrl_landing_status_sub = orb_subscribe(ORB_ID(position_controller_landing_status));\n \t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n \t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n \t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n@@ -209,7 +198,6 @@ Navigator::run()\n \tlocal_position_update();\n \tgps_position_update();\n \thome_position_update(true);\n-\tfw_pos_ctrl_status_update(true);\n \tparams_update();\n \n \t/* wakeup source(s) */\n@@ -293,11 +281,7 @@ Navigator::run()\n \t\t}\n \n \t\t/* navigation capabilities updated */\n-\t\torb_check(_fw_pos_ctrl_status_sub, &updated);\n-\n-\t\tif (updated) {\n-\t\t\tfw_pos_ctrl_status_update();\n-\t\t}\n+\t\t_position_controller_status_sub.update();\n \n \t\t/* home position updated */\n \t\torb_check(_home_pos_sub, &updated);\n@@ -762,14 +746,11 @@ Navigator::run()\n \t\t}\n \n \t\tif (_pos_sp_triplet_updated) {\n-\t\t\t_pos_sp_triplet.timestamp = hrt_absolute_time();\n \t\t\tpublish_position_setpoint_triplet();\n-\t\t\t_pos_sp_triplet_updated = false;\n \t\t}\n \n \t\tif (_mission_result_updated) {\n \t\t\tpublish_mission_result();\n-\t\t\t_mission_result_updated = false;\n \t\t}\n \n \t\tperf_end(_loop_perf);\n@@ -778,7 +759,7 @@ Navigator::run()\n \torb_unsubscribe(_global_pos_sub);\n \torb_unsubscribe(_local_pos_sub);\n \torb_unsubscribe(_gps_pos_sub);\n-\torb_unsubscribe(_fw_pos_ctrl_status_sub);\n+\torb_unsubscribe(_pos_ctrl_landing_status_sub);\n \torb_unsubscribe(_vstatus_sub);\n \torb_unsubscribe(_land_detected_sub);\n \torb_unsubscribe(_home_pos_sub);\n@@ -827,18 +808,22 @@ Navigator::print_status()\n void\n Navigator::publish_position_setpoint_triplet()\n {\n-\t/* do not publish an empty triplet */\n+\t// do not publish an invalid setpoint\n \tif (!_pos_sp_triplet.current.valid) {\n \t\treturn;\n \t}\n \n+\t_pos_sp_triplet.timestamp = hrt_absolute_time();\n+\n \t/* lazily publish the position setpoint triplet only once available */\n \tif (_pos_sp_triplet_pub != nullptr) {\n \t\torb_publish(ORB_ID(position_setpoint_triplet), _pos_sp_triplet_pub, &_pos_sp_triplet);\n \n \t} else {\n \t\t_pos_sp_triplet_pub = orb_advertise(ORB_ID(position_setpoint_triplet), &_pos_sp_triplet);\n \t}\n+\n+\t_pos_sp_triplet_updated = false;\n }\n \n float\n@@ -949,10 +934,11 @@ Navigator::get_acceptance_radius(float mission_item_radius)\n \t// when in fixed wing mode\n \t// this might need locking against a commanded transition\n \t// so that a stale _vstatus doesn't trigger an accepted mission item.\n-\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n-\t\tif ((hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 5000000) && (_fw_pos_ctrl_status.turn_distance > radius)) {\n-\t\t\tradius = _fw_pos_ctrl_status.turn_distance;\n-\t\t}\n+\n+\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n+\n+\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp) && pos_ctrl_status.acceptance_radius > radius) {\n+\t\tradius = pos_ctrl_status.acceptance_radius;\n \t}\n \n \treturn radius;\n@@ -1114,15 +1100,24 @@ void Navigator::check_traffic()\n bool\n Navigator::abort_landing()\n {\n+\t// only abort if currently landing and position controller status updated\n \tbool should_abort = false;\n \n-\tif (!_vstatus.is_rotary_wing && !_vstatus.in_transition_mode) {\n-\t\tif (hrt_elapsed_time(&_fw_pos_ctrl_status.timestamp) < 1000000) {\n+\tif (_pos_sp_triplet.current.valid\n+\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n+\n+\t\tbool updated = false;\n+\n+\t\torb_check(_pos_ctrl_landing_status_sub, &updated);\n \n-\t\t\tif (get_position_setpoint_triplet()->current.valid\n-\t\t\t    && get_position_setpoint_triplet()->current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\n+\t\tif (updated) {\n+\t\t\tposition_controller_landing_status_s landing_status = {};\n \n-\t\t\t\tshould_abort = _fw_pos_ctrl_status.abort_landing;\n+\t\t\t// landing status from position controller must be newer than navigator's last position setpoint\n+\t\t\tif (orb_copy(ORB_ID(position_controller_landing_status), _pos_ctrl_landing_status_sub, &landing_status) == PX4_OK) {\n+\t\t\t\tif (landing_status.timestamp > _pos_sp_triplet.timestamp) {\n+\t\t\t\t\tshould_abort = landing_status.abort_landing;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -1214,6 +1209,8 @@ Navigator::publish_mission_result()\n \t_mission_result.item_do_jump_changed = false;\n \t_mission_result.item_changed_index = 0;\n \t_mission_result.item_do_jump_remaining = 0;\n+\n+\t_mission_result_updated = false;\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/33f0a3c2b6ac49fef183e4c51691edf31c786617/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::check_traffic",
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "Navigator::home_position_update",
        "Navigator::run",
        "Navigator::publish_mission_result",
        "Navigator::print_status",
        "fw_pos_ctrl_status_update",
        "Navigator::get_acceptance_radius"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding"
        ],
        "src/modules/navigator/navigator.h": [
          "fw_pos_ctrl_status_update"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::check_traffic",
          "Navigator::home_position_update",
          "Navigator::run",
          "Navigator::publish_mission_result",
          "Navigator::print_status",
          "Navigator::get_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "Yaw remove slewrate",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10003",
    "number": 10003,
    "created_at": "2018-07-23T13:37:17Z",
    "merged": true,
    "merged_at": "2018-08-03T06:24:35Z",
    "state": "closed",
    "conversation": {
      "author": "Stifael",
      "body": "Similar to this [PR](https://github.com/PX4/Firmware/pull/9146) but without manual changes. \nThis PR moves the heading computation from navigator to FlightTaskAuto, which will also remove\nthe continuous triplet update due to heading computation.",
      "issue_comments": [
        {
          "author": "Stifael",
          "created_at": "2018-07-23T13:48:18Z",
          "body": "it is to note that during any ROI mission without gimbal control/rotation, the heading will still continuously be updated by the navigator",
          "type": "issue_comment"
        },
        {
          "author": "ChristophTobler",
          "created_at": "2018-07-24T06:49:45Z",
          "body": "@Stifael Should we wait for https://github.com/PX4/Firmware/pull/10006 first?",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-07-24T06:52:45Z",
          "body": "> @Stifael Should we wait for #10006 first?\r\n\r\nyep, that makes sense. #10006 wasn't there when I created this PR",
          "type": "issue_comment"
        },
        {
          "author": "ChristophTobler",
          "created_at": "2018-08-02T09:11:19Z",
          "body": "@Stifael Do we need additional flight tests?",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-08-02T09:21:23Z",
          "body": "@PX4/testflights can you please test this PR with different heading settings? \r\nIt would be great to test this branch with a vtol / fixedwing as well.\r\n\r\nHeading settings are controller with: MPC_YAW_MODE",
          "type": "issue_comment"
        },
        {
          "author": "Tony3dr",
          "created_at": "2018-08-02T14:54:19Z",
          "body": "@Stifael did you mean MIS_YAWMODE to control heading during a mission?\r\n",
          "type": "issue_comment"
        },
        {
          "author": "santiago3dr",
          "created_at": "2018-08-02T15:01:09Z",
          "body": "flashed the pr, i see MPC_YAW_MODE appears in 'other' parameters\r\nwould the value be similar to MIS_YAWMODE?\r\nValues:\r\n0: Heading as set by waypoint\r\n1: Heading towards waypoint\r\n2: Heading towards home\r\n3: Heading away from home",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-08-02T15:21:58Z",
          "body": "similar: \r\n 0 towards waypoint\r\n 1 towards home\r\n 2 away from home\r\n 3 along trajectory\r\n\r\nSet by waypoint  got removed because if will take precedence over MPC_YAW_MODE. Basically if the mission sends a valid yaw waypoint, then the vehicle will obey that yaw waypoint independent of MPC_YAW_MODE/. ",
          "type": "issue_comment"
        },
        {
          "author": "santiago3dr",
          "created_at": "2018-08-02T15:26:40Z",
          "body": "thanks for the info, will test shortly",
          "type": "issue_comment"
        },
        {
          "author": "Avysuarez",
          "created_at": "2018-08-02T17:57:09Z",
          "body": "**Some flights with pixhawk 4 (V5). Good flights, heading towards waypoint**\r\n\r\nhttps://review.px4.io/plot_app?log=3b1aaa4c-e1df-4a54-811d-1ec7de1270d1\r\nhttps://review.px4.io/plot_app?log=3b1aaa4c-e1df-4a54-811d-1ec7de1270d1\r\nhttps://review.px4.io/plot_app?log=a448d8cb-8654-4596-9d0a-4dae924b78f1\r\n\r\n**Some flights with pixhawk 2.1 (V3). Good flights, heading towards waypoint**\r\nhttps://review.px4.io/plot_app?log=83616e27-9612-4a71-a2a1-f732edf072cb\r\nhttps://review.px4.io/plot_app?log=ea02ff15-43e9-4733-8ff9-f1c92b383257\r\nhttps://review.px4.io/plot_app?log=ea02ff15-43e9-4733-8ff9-f1c92b383257\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dannyfpv",
          "created_at": "2018-08-02T18:12:35Z",
          "body": "couple flights on a Pixhawk pro (v4):\r\nhttps://review.px4.io/plot_app?log=97f18520-5fd9-4b17-a425-1118e0e051f9\r\nhttps://review.px4.io/plot_app?log=b70f9c01-9a71-4098-943c-98b2862ac486\r\n\r\npixhawk mini:\r\nhttps://review.px4.io/plot_app?log=ef395dc6-785b-4295-97cf-423577d80b74\r\nhttps://review.px4.io/plot_app?log=bafc63ea-e1c2-4b5b-8aa2-e22b7272809b\r\n\r\npixhawk v2\r\nhttps://review.px4.io/plot_app?log=d73899c2-2087-4f62-98fe-0ced68ca7c38\r\nhttps://review.px4.io/plot_app?log=d73899c2-2087-4f62-98fe-0ced68ca7c38\r\nland and rtl working properly\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "santiago3dr",
          "created_at": "2018-08-02T19:48:02Z",
          "body": "Few flights on a pixracer (v4)\r\nmcp_yaw_mode set to 0,1,2,3 respectively per flight\r\n\r\nhttps://logs.px4.io/plot_app?log=aec9e42c-94e9-4b3d-ac34-53113de5a712\r\nhttps://logs.px4.io/plot_app?log=a062494e-114c-4024-b42e-0b006afabc1f\r\nhttps://logs.px4.io/plot_app?log=80fd9e14-0219-47ea-8f0d-ae9f97535b0a\r\nhttps://logs.px4.io/plot_app?log=d14d154f-22b3-442e-b06c-b1dbf8290c1f\r\n\r\neverything looks to be working as expected",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-08-03T06:24:30Z",
          "body": "great thanks",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "ChristophTobler",
          "created_at": "2018-08-02T09:08:12Z",
          "body": "typo: points",
          "path": "src/lib/FlightTasks/tasks/FlightTaskAuto.cpp",
          "position": 56,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "ChristophTobler",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes where heading is computed to stop the navigator from continuously updating mission triplets (and thus continuously changing heading). That corrects an incorrect state-update/behavioral flow (unintended continuous heading updates) and flight tests indicate the expected heading behavior is restored.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "patch": "@@ -112,7 +112,6 @@ Loiter::set_loiter_position()\n \tpos_sp_triplet->next.valid = false;\n \n \t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n-\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n@@ -139,26 +138,7 @@ Loiter::reposition()\n \t\tmemcpy(&pos_sp_triplet->current, &rep->current, sizeof(rep->current));\n \t\tpos_sp_triplet->next.valid = false;\n \n-\t\t// set yaw (depends on the value of parameter MIS_YAWMODE):\n-\t\t// MISSION_YAWMODE_NONE: do not change yaw setpoint\n-\t\t// MISSION_YAWMODE_FRONT_TO_WAYPOINT: point to next waypoint\n-\t\tif (_param_yawmode.get() != MISSION_YAWMODE_NONE) {\n-\t\t\tfloat travel_dist = get_distance_to_next_waypoint(_navigator->get_global_position()->lat,\n-\t\t\t\t\t    _navigator->get_global_position()->lon,\n-\t\t\t\t\t    pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n-\n-\t\t\tif (travel_dist > 1.0f) {\n-\t\t\t\t// calculate direction the vehicle should point to.\n-\t\t\t\tpos_sp_triplet->current.yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t\t\t\t\t      _navigator->get_global_position()->lat,\n-\t\t\t\t\t\t\t\t      _navigator->get_global_position()->lon,\n-\t\t\t\t\t\t\t\t      pos_sp_triplet->current.lat,\n-\t\t\t\t\t\t\t\t      pos_sp_triplet->current.lon);\n-\t\t\t}\n-\t\t}\n-\n \t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n-\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \n \t\t// mark this as done",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1e84d96e24ccf5fac4bdf73d851daea8097b7c3f/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -76,9 +76,5 @@ class Loiter : public MissionBlock, public ModuleParams\n \t */\n \tvoid set_loiter_position();\n \n-\tDEFINE_PARAMETERS(\n-\t\t(ParamInt<px4::params::MIS_YAWMODE>) _param_yawmode\n-\t)\n-\n \tbool _loiter_pos_set{false};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1e84d96e24ccf5fac4bdf73d851daea8097b7c3f/src%2Fmodules%2Fnavigator%2Floiter.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 102,
        "changes": 166,
        "patch": "@@ -54,7 +54,6 @@\n #include <systemlib/mavlink_log.h>\n #include <systemlib/err.h>\n #include <lib/ecl/geo/geo.h>\n-#include <lib/mathlib/mathlib.h>\n #include <navigator/navigation.h>\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n@@ -246,15 +245,23 @@ Mission::on_active()\n \t}\n \n \t/* see if we need to update the current yaw heading */\n-\tif (_navigator->get_vroi().mode == vehicle_roi_s::ROI_LOCATION\n-\t    || (_param_yawmode.get() != MISSION_YAWMODE_NONE\n-\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n-\t\t&& _mission_type != MISSION_TYPE_NONE)\n-\t    || _navigator->get_vstatus()->is_vtol) {\n-\n+\tif (!_param_mnt_yaw_ctl.get() && (_navigator->get_vstatus()->is_rotary_wing)\n+\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n+\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n+\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n+\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n+\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n+\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n+\t\t || _work_item_type == WORK_ITEM_TYPE_ALIGN)) {\n+\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n+\t\t// needs to rotate such that ROI is in the field of view.\n+\t\t// ROI only makes sense for multicopters.\n \t\theading_sp_update();\n \t}\n \n+\t// TODO: Add vtol heading update method if required.\n+\t// Question: Why does vtol ever have to update heading?\n+\n \t/* check if landing needs to be aborted */\n \tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n \t    && (_navigator->abort_landing())) {\n@@ -1170,112 +1177,67 @@ Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n void\n Mission::heading_sp_update()\n {\n-\t/* we don't want to be yawing during takeoff, landing or aligning for a transition */\n-\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n-\t    || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n-\t    || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n-\t    || _mission_item.nav_cmd == NAV_CMD_LAND\n-\t    || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n-\t    || _work_item_type == WORK_ITEM_TYPE_ALIGN) {\n-\n-\t\treturn;\n-\t}\n-\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\t/* Don't change setpoint if last and current waypoint are not valid */\n-\tif (!pos_sp_triplet->current.valid) {\n-\t\treturn;\n-\t}\n-\n-\t/* Calculate direction the vehicle should point to. */\n-\n-\tdouble point_from_latlon[2];\n-\tdouble point_to_latlon[2];\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet =\n+\t\t_navigator->get_position_setpoint_triplet();\n+\n+\t// Only update if current triplet is valid\n+\tif (pos_sp_triplet->current.valid) {\n+\n+\t\tdouble point_from_latlon[2] = { _navigator->get_global_position()->lat,\n+\t\t\t\t\t\t_navigator->get_global_position()->lon\n+\t\t\t\t\t      };\n+\t\tdouble point_to_latlon[2] = { _navigator->get_global_position()->lat,\n+\t\t\t\t\t      _navigator->get_global_position()->lon\n+\t\t\t\t\t    };\n+\t\tfloat yaw_offset = 0.0f;\n+\n+\t\t// Depending on ROI-mode, update heading\n+\t\tswitch (_navigator->get_vroi().mode) {\n+\t\tcase vehicle_roi_s::ROI_LOCATION: {\n+\t\t\t\t// ROI is a fixed location. Vehicle needs to point towards that location\n+\t\t\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n+\t\t\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n+\t\t\t\t// No yaw offset required\n+\t\t\t\tyaw_offset = 0.0f;\n+\t\t\t\tbreak;\n+\t\t\t}\n \n-\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n-\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n+\t\tcase vehicle_roi_s::ROI_WPNEXT: {\n+\t\t\t\t// ROI is current waypoint. Vehcile needs to point towards current waypoint\n+\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n+\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n+\t\t\t\t// Add the gimbal's yaw offset\n+\t\t\t\tyaw_offset = _navigator->get_vroi().yaw_offset;\n+\t\t\t\tbreak;\n+\t\t\t}\n \n-\tif (_navigator->get_vroi().mode == vehicle_roi_s::ROI_LOCATION && !_param_mnt_yaw_ctl.get()) {\n-\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n-\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n+\t\tcase vehicle_roi_s::ROI_NONE:\n+\t\tcase vehicle_roi_s::ROI_WPINDEX:\n+\t\tcase vehicle_roi_s::ROI_TARGET:\n+\t\tcase vehicle_roi_s::ROI_ENUM_END:\n+\t\tdefault: {\n+\t\t\t}\n+\t\t}\n \n-\t\t/* stop if positions are close together to prevent excessive yawing */\n-\t\tfloat d_current = get_distance_to_next_waypoint(\n-\t\t\t\t\t  point_from_latlon[0], point_from_latlon[1],\n-\t\t\t\t\t  point_to_latlon[0], point_to_latlon[1]);\n+\t\t// Get desired heading and update it.\n+\t\t// However, only update if distance to desired heading is\n+\t\t// larger than acceptance radius to prevent excessive yawing\n+\t\tfloat d_current = get_distance_to_next_waypoint(point_from_latlon[0],\n+\t\t\t\t  point_from_latlon[1], point_to_latlon[0], point_to_latlon[1]);\n \n \t\tif (d_current > _navigator->get_acceptance_radius()) {\n-\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t\t    point_from_latlon[0], point_from_latlon[1],\n-\t\t\t\t\t    point_to_latlon[0], point_to_latlon[1]);\n+\t\t\tfloat yaw = wrap_pi(\n+\t\t\t\t\t    get_bearing_to_next_waypoint(point_from_latlon[0],\n+\t\t\t\t\t\t\t    point_from_latlon[1], point_to_latlon[0],\n+\t\t\t\t\t\t\t    point_to_latlon[1]) + yaw_offset);\n \n \t\t\t_mission_item.yaw = yaw;\n \t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n \t\t}\n \n-\t} else {\n-\t\t/* set yaw angle for the waypoint if a loiter time has been specified */\n-\t\tif (_waypoint_position_reached && get_time_inside(_mission_item) > FLT_EPSILON) {\n-\t\t\t// XXX: should actually be param4 from mission item\n-\t\t\t// at the moment it will just keep the heading it has\n-\t\t\t//_mission_item.yaw = _on_arrival_yaw;\n-\t\t\t//pos_sp_triplet->current.yaw = _mission_item.yaw;\n-\n-\t\t} else {\n-\t\t\t/* target location is home */\n-\t\t\tif ((_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME\n-\t\t\t     || _param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME)\n-\t\t\t    // need to be rotary wing for this but not in a transition\n-\t\t\t    // in VTOL mode this will prevent updating yaw during FW flight\n-\t\t\t    // (which would result in a wrong yaw setpoint spike during back transition)\n-\t\t\t    && _navigator->get_vstatus()->is_rotary_wing\n-\t\t\t    && !(_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION || _navigator->get_vstatus()->in_transition_mode)) {\n-\n-\t\t\t\tpoint_to_latlon[0] = _navigator->get_home_position()->lat;\n-\t\t\t\tpoint_to_latlon[1] = _navigator->get_home_position()->lon;\n-\n-\t\t\t} else {\n-\t\t\t\t/* target location is next (current) waypoint */\n-\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n-\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n-\t\t\t}\n-\n-\t\t\tfloat d_current = get_distance_to_next_waypoint(\n-\t\t\t\t\t\t  point_from_latlon[0], point_from_latlon[1],\n-\t\t\t\t\t\t  point_to_latlon[0], point_to_latlon[1]);\n-\n-\t\t\t/* stop if positions are close together to prevent excessive yawing */\n-\t\t\tif (d_current > _navigator->get_acceptance_radius()) {\n-\t\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n-\t\t\t\t\t\t    point_from_latlon[0],\n-\t\t\t\t\t\t    point_from_latlon[1],\n-\t\t\t\t\t\t    point_to_latlon[0],\n-\t\t\t\t\t\t    point_to_latlon[1]);\n-\n-\t\t\t\t/* always keep the back of the rotary wing pointing towards home */\n-\t\t\t\tif (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n-\t\t\t\t\t_mission_item.yaw = wrap_pi(yaw + M_PI_F);\n-\t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\n-\t\t\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT\n-\t\t\t\t\t   && _navigator->get_vroi().mode == vehicle_roi_s::ROI_WPNEXT && !_param_mnt_yaw_ctl.get()) {\n-\t\t\t\t\t/* if yaw control for the mount is disabled and we have a valid ROI that points to the next\n-\t\t\t\t\t * waypoint, we add the gimbal's yaw offset to the vehicle's yaw */\n-\t\t\t\t\tyaw += _navigator->get_vroi().yaw_offset;\n-\t\t\t\t\t_mission_item.yaw = yaw;\n-\t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\n-\t\t\t\t} else {\n-\t\t\t\t\t_mission_item.yaw = yaw;\n-\t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t// we set yaw directly so we can run this in parallel to the FOH update\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n-\n-\t// we set yaw directly so we can run this in parallel to the FOH update\n-\t_navigator->set_position_setpoint_triplet_updated();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1e84d96e24ccf5fac4bdf73d851daea8097b7c3f/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -247,7 +247,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_dist_1wp,\n \t\t(ParamFloat<px4::params::MIS_DIST_WPS>) _param_dist_between_wps,\n \t\t(ParamInt<px4::params::MIS_ALTMODE>) _param_altmode,\n-\t\t(ParamInt<px4::params::MIS_YAWMODE>) _param_yawmode,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mnt_yaw_ctl\n \t)\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1e84d96e24ccf5fac4bdf73d851daea8097b7c3f/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "patch": "@@ -119,21 +119,6 @@ PARAM_DEFINE_FLOAT(MIS_DIST_WPS, 900);\n  */\n PARAM_DEFINE_INT32(MIS_ALTMODE, 1);\n \n-/**\n- * Multirotor only. Yaw setpoint mode.\n- *\n- * The values are defined in the enum mission_altitude_mode\n- *\n- * @min 0\n- * @max 3\n- * @value 0 Heading as set by waypoint\n- * @value 1 Heading towards waypoint\n- * @value 2 Heading towards home\n- * @value 3 Heading away from home\n- * @group Mission\n- */\n-PARAM_DEFINE_INT32(MIS_YAWMODE, 1);\n-\n /**\n * Enable yaw control of the mount. (Only affects multicopters and ROI mission items)\n *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1e84d96e24ccf5fac4bdf73d851daea8097b7c3f/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -155,7 +155,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.lon = gpos.lon;\n \t\t\t_mission_item.altitude = return_alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n-\t\t\t_mission_item.yaw = NAN;\n+\t\t\t_mission_item.yaw = _navigator->get_local_position()->yaw;\n \t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \t\t\t_mission_item.time_inside = 0.0f;\n \t\t\t_mission_item.autocontinue = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1e84d96e24ccf5fac4bdf73d851daea8097b7c3f/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "Mission::on_active",
        "Loiter::reposition",
        "Mission::calculate_takeoff_altitude",
        "Loiter::set_loiter_position"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::reposition",
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::calculate_takeoff_altitude",
          "Mission::on_active"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "Missions: ignore waypoint yaw when avoidance is active",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9880",
    "number": 9880,
    "created_at": "2018-07-11T17:12:51Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "mrivi",
      "body": "@dagar  @LorenzMeier @thomasgubler \n\nThis is a sketch of  what we discussed in the dev call. If the avoidance is active and healthy the flag `_waypoint_yaw_reached ` is always set to true.",
      "issue_comments": [
        {
          "author": "mhkabir",
          "created_at": "2018-07-12T03:56:07Z",
          "body": "General question - why should we disregard yaw when in avoidance mode? ",
          "type": "issue_comment"
        },
        {
          "author": "nicovanduijn",
          "created_at": "2018-07-12T05:54:56Z",
          "body": "@mhkabir The navigator usually checks whether the aircraft arrives in the direction from the previous mission item. When in avoidance mode, this is not necessarily true, because there may have been a detour that causes it to fly along a path other than the straight line connecting the two mission items",
          "type": "issue_comment"
        },
        {
          "author": "thomasgubler",
          "created_at": "2018-07-12T07:22:00Z",
          "body": "@nicovanduijn Can you test this? I think you were the one that could reproduce the error symptoms most consistently.",
          "type": "issue_comment"
        },
        {
          "author": "nicovanduijn",
          "created_at": "2018-07-12T08:07:22Z",
          "body": "I'll test this, but cherry-picked onto #9270, since anything else doesn't make sense (If you're not flying OA in mission mode, this has no effect)\r\n\r\nEdit: @thomasgubler I've been running it a few times and it looks good so far. Never seen the problem of mission items not getting checked off so far. This is by no means exhaustive testing though",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-07-12T08:25:54Z",
          "body": "I didn't put it on top of the avoidance PR because I thought that's going to be merged soon. So it doesn't makes sense to add things and void all the testing done so far.\r\nThe goal was to show what can be achieved easily and discuss the architecture more concretely. I am quite aware that this PR alone doesn't do anything (it doesn't even compile)",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-07-13T07:01:00Z",
          "body": "Since #9270 got merged, I have rebased this PR on top of master",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-07-24T11:41:13Z",
          "body": "I have added he proposal from last week dev call:\r\nIf the vehicle projected position on the vector previous-current triplet is past the current triplet or if no progress towards the goal is made for 10 seconds, `_waypoint_position_reached` is set to true which forces the triplet update.\r\n\r\nThis is a proposal to start the the discussion.",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-07-26T11:59:20Z",
          "body": "Closing this PR, because the final solution will be based on #10037 . The decision to update the triplet will be take in the position controller and feed it back to navigator thorough uORB. ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "thomasgubler",
          "created_at": "2018-07-12T07:20:34Z",
          "body": "is it a good pattern to return pointers to private members? I see the same on lines below and above so it might not be something that should be fixed in this PR",
          "path": "src/modules/navigator/navigator.h",
          "position": 13,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-12T15:49:16Z",
          "body": "I believe almost all of these can be changed to return const references fairly easily.",
          "path": "src/modules/navigator/navigator.h",
          "position": 13,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect mission behavior caused by a yaw-reached check that prevented waypoints from being marked reached when an avoidance detour changed the vehicle's heading. Ignoring the yaw requirement while avoidance is active corrects an improper conditional/state check that caused mission items to not get checked off (unintended behavior), and reviewers reported that testing reduced the symptom.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 18,
        "changes": 92,
        "patch": "@@ -122,19 +122,21 @@ MissionBlock::is_mission_item_reached()\n \t\tbreak;\n \t}\n \n-\thrt_abstime now = hrt_absolute_time();\n+\t_prev_t = _now;\n+\t_now = hrt_absolute_time();\n \n \tif (!_navigator->get_land_detected()->landed && !_waypoint_position_reached) {\n \n-\t\tfloat dist = -1.0f;\n+\t\t//float dist = -1.0f;\n \t\tfloat dist_xy = -1.0f;\n \t\tfloat dist_z = -1.0f;\n \n \t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n \t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n \t\t\t\t      : _mission_item.altitude;\n \n-\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n+\t\t_prev_dist = _dist;\n+\t\t_dist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n \t\t\t\t_navigator->get_global_position()->lat,\n \t\t\t\t_navigator->get_global_position()->lon,\n \t\t\t\t_navigator->get_global_position()->alt,\n@@ -147,7 +149,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n \n \t\t\t/* close to waypoint, but altitude error greater than twice acceptance */\n-\t\t\tif ((dist >= 0.0f)\n+\t\t\tif ((_dist >= 0.0f)\n \t\t\t    && (dist_z > 2 * _navigator->get_altitude_acceptance_radius())\n \t\t\t    && (dist_xy < 2 * _navigator->get_loiter_radius())) {\n \n@@ -163,7 +165,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t/* restore SETPOINT_TYPE_POSITION */\n \t\t\t\tif (curr_sp->type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n \t\t\t\t\t/* loiter acceptance criteria required to revert back to SETPOINT_TYPE_POSITION */\n-\t\t\t\t\tif ((dist >= 0.0f)\n+\t\t\t\t\tif ((_dist >= 0.0f)\n \t\t\t\t\t    && (dist_z < _navigator->get_loiter_radius())\n \t\t\t\t\t    && (dist_xy <= _navigator->get_loiter_radius() * 1.2f)) {\n \n@@ -200,7 +202,7 @@ MissionBlock::is_mission_item_reached()\n \n \t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n \t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n-\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()\n+\t\t\tif (_dist >= 0.0f && _dist <= _navigator->get_acceptance_radius()\n \t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n@@ -214,7 +216,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n \t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n \t\t\t */\n-\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\tif (_dist >= 0.0f && _dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n \t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \n \t\t\t\t_waypoint_position_reached = true;\n@@ -236,22 +238,22 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\tdist_xy = -1.0f;\n \t\t\t\tdist_z = -1.0f;\n \n-\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n+\t\t\t\t_dist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n \t\t\t\t\t\t_navigator->get_global_position()->lat,\n \t\t\t\t\t\t_navigator->get_global_position()->lon,\n \t\t\t\t\t\t_navigator->get_global_position()->alt,\n \t\t\t\t\t\t&dist_xy, &dist_z);\n \n-\t\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\t\tif (_dist >= 0.0f && _dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n \t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \n-\t\t\t\t\t// now set the loiter to the final altitude in the NAV_CMD_LOITER_TO_ALT mission item\n+\t\t\t\t\t// _now set the loiter to the final altitude in the NAV_CMD_LOITER_TO_ALT mission item\n \t\t\t\t\tcurr_sp->alt = altitude_amsl;\n \t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n \t\t\t\t}\n \n \t\t\t} else {\n-\t\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n+\t\t\t\tif (_dist >= 0.0f && _dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n \t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \n \t\t\t\t\t_waypoint_position_reached = true;\n@@ -277,7 +279,7 @@ MissionBlock::is_mission_item_reached()\n \t\t} else if (_mission_item.nav_cmd == NAV_CMD_DELAY) {\n \t\t\t_waypoint_position_reached = true;\n \t\t\t_waypoint_yaw_reached = true;\n-\t\t\t_time_wp_reached = now;\n+\t\t\t_time_wp_reached = _now;\n \n \t\t} else {\n \t\t\t/* for normal mission items used their acceptance radius */\n@@ -304,15 +306,69 @@ MissionBlock::is_mission_item_reached()\n \n \t\t\t}\n \n-\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius\n+\t\t\tif (_dist >= 0.0f && _dist <= mission_acceptance_radius\n \t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \t\t}\n \n \t\tif (_waypoint_position_reached) {\n-\t\t\t// reached just now\n-\t\t\t_time_wp_reached = now;\n+\t\t\t// reached just _now\n+\t\t\t_time_wp_reached = _now;\n+\t\t}\n+\t}\n+\n+\n+\tconst bool obstacle_avoidance_running = hrt_elapsed_time(&_navigator->get_trajectory_waypoint()->timestamp) < 1e6f;\n+\n+\t/* Obstacle Avoidance is running and it's healty */\n+\tif (_navigator->get_avoidance_active() && obstacle_avoidance_running) {\n+\n+\t\t/* project the vehicle position on the vector previous-current triplet and calculate how much\n+\t\t * distance has been travelled so far */\n+\n+\t\tmatrix::Vector2f u_prev_to_curr;\n+\t\tmatrix::Vector2f prev_to_pos(_navigator->get_global_position()->lat -\n+\t\t\t\t\t     _navigator->get_position_setpoint_triplet()->previous.lat,\n+\t\t\t\t\t     _navigator->get_global_position()->lon - _navigator->get_position_setpoint_triplet()->previous.lon);\n+\n+\t\tget_vector_to_next_waypoint(_navigator->get_position_setpoint_triplet()->previous.lat,\n+\t\t\t\t\t    _navigator->get_position_setpoint_triplet()->previous.lon,\n+\t\t\t\t\t    _navigator->get_position_setpoint_triplet()->current.lat,\n+\t\t\t\t\t    _navigator->get_position_setpoint_triplet()->current.lon, &u_prev_to_curr(0), &u_prev_to_curr(1));\n+\n+\t\tconst float dist_prev_curr = u_prev_to_curr.length();\n+\t\tu_prev_to_curr = u_prev_to_curr.normalized();\n+\n+\t\tmatrix::Vector2f pt_on_line = matrix::Vector2f(_navigator->get_position_setpoint_triplet()->previous.lat,\n+\t\t\t\t\t      _navigator->get_position_setpoint_triplet()->previous.lon) + u_prev_to_curr * (prev_to_pos * u_prev_to_curr);\n+\n+\t\tconst float prev_curr_travelled = get_distance_to_next_waypoint(\n+\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lat,\n+\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lon, pt_on_line(0), pt_on_line(1)) / dist_prev_curr;\n+\n+\t\t/* calculate the progress towards the goal (negative slope) and keep track of how much time\n+\t\t * has elapsed since the last time progress was made */\n+\t\tconst float slope = (_dist - _prev_dist) / (_now - _prev_t);\n+\n+\t\tif (slope > 0.0f) {\n+\t\t\t_time_positive_slope += (_now - _prev_t);\n+\n+\t\t} else {\n+\t\t\t_time_positive_slope = 0;\n+\t\t}\n+\n+\t\t/* always set the yaw as reached since it might never reach the requested\n+\t\t * yaw because avoidance is in charge of setting the vehicle heading */\n+\t\t_waypoint_yaw_reached = true;\n+\n+\t\t/* if the vehicle projetced position has passed the current triplet or\n+\t\t * the vehicle is not making progress towards the goal for more than 10\n+\t\t * seconds, set current triplet as reached so that navigator updates\n+\t\t * the triplets */\n+\t\tif (prev_curr_travelled > 1.0f || _time_positive_slope > 10 * 1000000) {\n+\t\t\t_waypoint_position_reached = true;\n+\t\t\t_time_wp_reached = _now;\n \t\t}\n \t}\n \n@@ -341,7 +397,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n \t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n \t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n-\t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n+\t\t\t    (_now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n \n \t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n \t\t\t}\n@@ -355,12 +411,12 @@ MissionBlock::is_mission_item_reached()\n \tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n \n \t\tif (_time_first_inside_orbit == 0) {\n-\t\t\t_time_first_inside_orbit = now;\n+\t\t\t_time_first_inside_orbit = _now;\n \t\t}\n \n \t\t/* check if the MAV was long enough inside the waypoint orbit */\n \t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n-\t\t    (now - _time_first_inside_orbit >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n+\t\t    (_now - _time_first_inside_orbit >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n \n \t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n \t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/edf96dcd28495e9d612dc0b465855c2f9bbf5b18/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -131,6 +131,13 @@ class MissionBlock : public NavigatorMode\n \thrt_abstime _time_first_inside_orbit{0};\n \thrt_abstime _action_start{0};\n \thrt_abstime _time_wp_reached{0};\n+\thrt_abstime _prev_t{0};\n+\thrt_abstime _now{0};\n+\n+\tfloat _prev_dist = -1.0f;\n+\tfloat _dist = -1.0f;\n+\thrt_abstime _time_positive_slope = 0;\n+\thrt_abstime  _first_time_positive_slope = 0;\n \n \torb_advert_t    _actuator_pub{nullptr};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/edf96dcd28495e9d612dc0b465855c2f9bbf5b18/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "patch": "@@ -71,6 +71,8 @@\n #include <uORB/topics/vehicle_gps_position.h>\n #include <uORB/topics/vehicle_land_detected.h>\n #include <uORB/topics/vehicle_local_position.h>\n+#include <uORB/topics/vehicle_trajectory_waypoint.h>\n+\n #include <uORB/uORB.h>\n \n /**\n@@ -157,6 +159,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tstruct vehicle_status_s *get_vstatus() { return &_vstatus; }\n \tPrecLand *get_precland() { return &_precland; } /**< allow others, e.g. Mission, to use the precision land block */\n \n+\tstruct vehicle_trajectory_waypoint_s *get_trajectory_waypoint() { return &_traj_wp_avoidance;}\n+\n \tconst vehicle_roi_s &get_vroi() { return _vroi; }\n \n \tbool home_alt_valid() { return (_home_pos.timestamp > 0 && _home_pos.valid_alt); }\n@@ -268,6 +272,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat\t\tget_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss.get(); }\n \tfloat\t\tget_vtol_reverse_delay() const { return _param_reverse_delay.get(); }\n \n+\tbool \t\tget_avoidance_active() const { return _param_avoidance_active.get(); }\n+\n \tbool\t\tforce_vtol();\n \n private:\n@@ -282,6 +288,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tint\t\t_traffic_sub{-1};\t\t/**< traffic subscription */\n \tint\t\t_vehicle_command_sub{-1};\t/**< vehicle commands (onboard and offboard) */\n \tint\t\t_vstatus_sub{-1};\t\t/**< vehicle status subscription */\n+\tint \t_traj_wp_avoidance_sub{-1}; /**< obstacle avoidance subscription */\n \n \torb_advert_t\t_geofence_result_pub{nullptr};\n \torb_advert_t\t_mavlink_log_pub{nullptr};\t/**< the uORB advert to send messages over mavlink */\n@@ -301,6 +308,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvehicle_local_position_s\t\t\t_local_pos{};\t\t/**< local vehicle position */\n \tvehicle_status_s\t\t\t\t_vstatus{};\t\t/**< vehicle status */\n \tuint8_t\t\t\t\t\t_previous_nav_state{}; /**< nav_state of the previous iteration*/\n+\tvehicle_trajectory_waypoint_s\t\t_traj_wp_avoidance{}; /** < obstacle avoidance >*/\n+\n \t// Publications\n \tgeofence_result_s\t\t\t\t_geofence_result{};\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet{};\t/**< triplet of position setpoints */\n@@ -352,7 +361,9 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \t\t// VTOL parameters TODO: get these out of navigator\n \t\t(ParamFloat<px4::params::VT_B_DEC_MSS>) _param_back_trans_dec_mss,\n-\t\t(ParamFloat<px4::params::VT_B_REV_DEL>) _param_reverse_delay\n+\t\t(ParamFloat<px4::params::VT_B_REV_DEL>) _param_reverse_delay,\n+\n+\t\t(ParamInt<px4::params::MPC_OBS_AVOID>) _param_avoidance_active\n \t)\n \n \tfloat _mission_cruising_speed_mc{-1.0f};\n@@ -368,6 +379,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvoid\t\tparams_update();\n \tvoid\t\tvehicle_land_detected_update();\n \tvoid\t\tvehicle_status_update();\n+\tvoid \t\ttrajectory_avoidance_update();\n \n \t/**\n \t * Publish a new position setpoint triplet for position controllers",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/edf96dcd28495e9d612dc0b465855c2f9bbf5b18/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "patch": "@@ -167,6 +167,12 @@ Navigator::vehicle_land_detected_update()\n \torb_copy(ORB_ID(vehicle_land_detected), _land_detected_sub, &_land_detected);\n }\n \n+void\n+Navigator::trajectory_avoidance_update()\n+{\n+\torb_copy(ORB_ID(vehicle_trajectory_waypoint), _traj_wp_avoidance_sub, &_traj_wp_avoidance);\n+}\n+\n void\n Navigator::params_update()\n {\n@@ -201,6 +207,8 @@ Navigator::run()\n \t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n \t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n \t_traffic_sub = orb_subscribe(ORB_ID(transponder_report));\n+\t_traj_wp_avoidance_sub = orb_subscribe(ORB_ID(vehicle_trajectory_waypoint));\n+\n \n \t/* copy all topics first time */\n \tvehicle_status_update();\n@@ -306,6 +314,13 @@ Navigator::run()\n \t\t\thome_position_update();\n \t\t}\n \n+\t\t/* obstacle avoidance update */\n+\t\torb_check(_traj_wp_avoidance_sub, &updated);\n+\n+\t\tif (updated) {\n+\t\t\ttrajectory_avoidance_update();\n+\t\t}\n+\n \t\t/* vehicle_command updated */\n \t\torb_check(_vehicle_command_sub, &updated);\n \n@@ -785,6 +800,7 @@ Navigator::run()\n \torb_unsubscribe(_offboard_mission_sub);\n \torb_unsubscribe(_param_update_sub);\n \torb_unsubscribe(_vehicle_command_sub);\n+\torb_unsubscribe(_traj_wp_avoidance_sub);\n }\n \n int Navigator::task_spawn(int argc, char *argv[])",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/edf96dcd28495e9d612dc0b465855c2f9bbf5b18/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::vehicle_land_detected_update",
        "Navigator::run",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run",
          "Navigator::vehicle_land_detected_update"
        ]
      }
    }
  },
  {
    "title": "Navigator: Fix fixed-wing first order altitude hold",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9850",
    "number": 9850,
    "created_at": "2018-07-06T15:52:20Z",
    "merged": true,
    "merged_at": "2018-07-16T03:54:09Z",
    "state": "closed",
    "conversation": {
      "author": "philipoe",
      "body": "**Issue**\r\nNavigator's fixed-wing first-order altitude hold (FOH) is currently causing altitude reference oscillations when in any LOITER mode. See screenshot below. Not only altitude, but also pitch and throttle can thus oscillate significantly. We observed this during a recent test flight.\r\n\r\n![image](https://user-images.githubusercontent.com/2565608/42387985-53c6343e-8144-11e8-86d2-a42aecc4c5c0.png)\r\n\r\n\r\nLog file from SITL where this can be seen: https://review.px4.io/plot_app?log=f18c45ab-622e-4b1d-9819-03cfb06af2b5 . Here, after t=3:20 the true altitude setpoint is still the same as before t=2:20 (i.e. 630m AMSL) but the FOH logic just wrongly sets it to 660m and adds slight oscillations on top. The exact amount of oscillations depends on waypoint distance, altitude difference etc, but i have seen altitude ref oscillations of up to 30m, resulting in full pitch up/down of the aircraft.\r\n\r\n**Analysis**\r\nSee the commit for the location of the code where this is happening. Essentially, every time that the loiter radius of any loiter WP is larger than the acceptance radius calculated from the L1 turn distance, then the Navigator FOH would _not_ consider the waypoint reached and would thus not stop modifying the current altitude setpoint. This leads to the oscillations or offsets in the altitude reference. \r\n\r\n**Solution**\r\nIf in any loiter mode, consider the loiter radius times a factor of 1.2 (same as for the waypoint_reached logic [here](https://github.com/PX4/Firmware/blob/master/src/modules/navigator/mission_block.cpp#L217) as the acceptance radius. Tested in SITL, which should be sufficient for this case.\r\n\r\n@acfloria @ryanjAA @antiheavy FYI\r\n@dagar Made this PR as a quick hotfix independently of your PR at https://github.com/PX4/Firmware/pull/8883/files which supposedly also fixes this but is much larger and where it is more uncertain when this would be merged.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-07-06T15:55:52Z",
          "body": "This actually needs a little thought to review. There are a few situations where the position setpoint type and mission_item type are not the same. ",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-07-06T16:12:36Z",
          "body": "I can of course also check for `(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\r\n\t\t\t    _mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT))` if you prefer that... just let me know.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-06T16:53:41Z",
          "body": "If you can do it entirely from the position setpoint (ignoring mission_item) it should effectively avoid the edge cases (LOITER_TO_ALT, mission work items, etc).",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-07-06T17:09:20Z",
          "body": "So you'd also want to use `acc_rad = _navigator->get_acceptance_radius(fabsf(pos_sp_triplet->current.loiter_radius) * 1.2f);` instead of using the mission item loiter radius?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-06T17:29:28Z",
          "body": "Yes, but drop the mission_item entirely and do a quick skim of the entire altitude_sp_foh_update() to make sure nothing is dependant on the mission item. This is one of the reasons I wanted to move it to the position controller. Multicopter skips this thing entirely.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-06T21:19:54Z",
          "body": "> Yes, but drop the mission_item entirely and do a quick skim of the entire altitude_sp_foh_update() to make sure nothing is dependant on the mission item. This is one of the reasons I wanted to move it to the position controller. Multicopter skips this thing entirely.\r\n\r\nI'll can do this tomorrow if you can't get to it.",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-07-06T21:58:12Z",
          "body": "> I'll can do this tomorrow if you can't get to it.\r\n\r\nSure, I guess you know exactly how you'd like to do it. Let me know if i should retest it afterwards then.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-16T01:29:51Z",
          "body": "> Sure, I guess you know exactly how you'd like to do it.\r\n\r\nNot really, I just see a number of subtle edge cases that make me uncomfortable.\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-07-16T03:52:19Z",
          "body": "I played around with this a bit, but there's still another (small) possible hole when the mission item nav_cmd is out of sync with the current position setpoint type.\r\n\r\nLet's merge this now, but work on moving it to the position controller soon. From there it's much easier to safely handle the altitude ramp or hand off between loiter <-> position without fighting to plug numerous holes.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "Possibly not 100% correct in all situations to mix _mission_item and position_setpoints here.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the FOH code was using an incorrect acceptance condition (comparing loiter radius against an L1-derived acceptance radius) which caused the waypoint to never be considered reached and the altitude setpoint to be continually modified, producing oscillations. The PR adjusts the acceptance radius for loiter (loiter_radius * 1.2) so the FOH stops updating the altitude once appropriate, fixing the erroneous behavior. Reviewers noted some edge cases around mission_item vs position_setpoint syncing, but the change addresses the core logic bug.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "patch": "@@ -1297,8 +1297,15 @@ Mission::altitude_sp_foh_update()\n \t\treturn;\n \t}\n \n+\t// Calculate acceptance radius, i.e. the radius within which we do not perform a first order hold anymore\n+\tfloat acc_rad = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n+\n+\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n+\t\tacc_rad = _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f);\n+\t}\n+\n \t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n-\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < FLT_EPSILON) {\n+\tif (_distance_current_previous - acc_rad < FLT_EPSILON) {\n \t\treturn;\n \t}\n \n@@ -1327,7 +1334,7 @@ Mission::altitude_sp_foh_update()\n \n \t/* if the minimal distance is smaller then the acceptance radius, we should be at waypoint alt\n \t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n-\tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n+\tif (_min_current_sp_distance_xy < acc_rad) {\n \t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n \n \t} else {\n@@ -1337,8 +1344,7 @@ Mission::altitude_sp_foh_update()\n \t\t * radius around the current waypoint\n \t\t **/\n \t\tfloat delta_alt = (get_absolute_altitude_for_item(_mission_item) - pos_sp_triplet->previous.alt);\n-\t\tfloat grad = -delta_alt / (_distance_current_previous - _navigator->get_acceptance_radius(\n-\t\t\t\t\t\t   _mission_item.acceptance_radius));\n+\t\tfloat grad = -delta_alt / (_distance_current_previous - acc_rad);\n \t\tfloat a = pos_sp_triplet->previous.alt - grad * _distance_current_previous;\n \t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6054aedbe9806b1e7b79fcfb8000aa31368f2b3b/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::altitude_sp_foh_update"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::altitude_sp_foh_update"
        ]
      }
    }
  },
  {
    "title": "ROI bugfix and improved precision",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9781",
    "number": 9781,
    "created_at": "2018-06-27T15:00:22Z",
    "merged": true,
    "merged_at": "2018-08-06T14:17:12Z",
    "state": "closed",
    "conversation": {
      "author": "potaito",
      "body": "## The ROI all-zeros bug\r\n\r\nWhen transmitting a mission with QGC, occasionally the ROI waypoints are broken in the sense that the ROI lat/lon is set to `(0.0, 0.0)`. Some digging showed that this only happens when the `MAV_CMD` used to send the mission is in INT mode. The reason is the conversion  from `mavlink_mission` to `mission_item`. In INT mode the latitude and longitude need scaling:\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/blob/bb8e653469e67afb43dbb9ecf3899cf50ef6162f/src/modules/mavlink/mavlink_mission.cpp#L1282-L1294\r\n\r\nHowever, further down when setting the ROI parameters for LAT/LONG/ALT, the conversion is missing and the values are simply copied (cast) regardless of `_int_mode`:\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/blob/bb8e653469e67afb43dbb9ecf3899cf50ef6162f/src/modules/mavlink/mavlink_mission.cpp#L1355-L1363\r\n\r\nA proposed fix is in the first commit.\r\n\r\n### Reproducing the issue:\r\nThe bug occurs only when the vehicle already has a mission loaded, with is removed in QGC, and then a new mission is sent containing the ROI. I am not sure why in one case INT mode is used, and in another case it's not...\r\n\r\n## ROI waypoint floating-point precision\r\nLooking at the situation with @MaEtUgR and @julianoes, we noticed that some precision is lost when using the parameter fields (float) of the vehicle message to store/access the ROI latitude and longitude (param 5 and param6):\r\nhttps://github.com/PX4/PX4-Autopilot/blob/bb8e653469e67afb43dbb9ecf3899cf50ef6162f/src/modules/navigator/mission_block.cpp#L445-L463\r\n\r\nInstead, we can just as well use the mission item's latitude and longitude, which are `double`s instead of `float`s:\r\nhttps://github.com/PX4/PX4-Autopilot/blob/bb8e653469e67afb43dbb9ecf3899cf50ef6162f/src/modules/navigator/navigation.h#L135-L153\r\n\r\nThe proposed fix is in the second commit, making the other commit redundant. \r\n\r\n------\r\n\r\n@julianoes Please take a look :)",
      "issue_comments": [
        {
          "author": "potaito",
          "created_at": "2018-07-26T07:32:29Z",
          "body": "@julianoes Could you review the changes? :)",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2018-07-26T16:06:18Z",
          "body": "Now there are conflicts :cry: \r\nI'll take care of it. ",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2018-08-06T09:28:29Z",
          "body": "@julianoes Conflicts resolved. They were caused by this commit: https://github.com/PX4/Firmware/commit/cf741668018f17cae47180064ebe2cfd2c9de214#diff-7a824e3d1e9a5420071c8c9bbe27b8e7R455\r\n\r\nWith the changes in this PR there is no conversion required, since the `lat` and `lon` fields are already `double` types:\r\nhttps://github.com/PX4/PX4-Autopilot/blob/e989c80205e22d11e5346bda3d11f90cdf294dfc/src/modules/navigator/navigation.h#L135-L137",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2018-08-06T09:54:06Z",
          "body": "```\r\n/usr/local/opt/ccache/libexec/c++  -DCONFIG_ARCH_BOARD_SITL -DMODULE_NAME=\\\"navigator\\\" -DPX4_MAIN=navigator_app_main -D__DF_DARWIN -D__PX4_DARWIN -D__PX4_POSIX -D__STDC_FORMAT_MACROS -Dnoreturn_function=\"__attribute__((noreturn))\" -I. -Isrc -Isrc/lib -Isrc/modules -I../../src -I../../src/drivers/boards/sitl -I../../src/include -I../../src/lib -I../../src/lib/DriverFramework/framework/include -I../../src/lib/matrix -I../../src/modules -I../../src/platforms -I../../platforms/posix/include -Iexternal/Install/include -I../../src/lib/ecl -g -fno-exceptions -fno-rtti -std=gnu++11 -fno-threadsafe-statics -DCONFIG_WCHAR_BUILTIN -D__CUSTOM_FILE_IO__ -Wall -Wextra -Werror -Warray-bounds -Wdisabled-optimization -Wdouble-promotion -Wfatal-errors -Wfloat-equal -Wformat-security -Winit-self -Wlogical-op -Wmissing-declarations -Wpointer-arith -Wshadow -Wuninitialized -Wunknown-pragmas -Wunused-variable -Wno-implicit-fallthrough -Wno-missing-field-initializers -Wno-missing-include-dirs -Wno-unused-parameter -Qunused-arguments -Wno-unused-const-variable -Wno-varargs -Wno-address-of-packed-member -Wno-unknown-warning-option -Wunused-but-set-variable -Wno-overloaded-virtual -Wreorder -fvisibility=hidden -include visibility.h -fno-strict-aliasing -fomit-frame-pointer -fno-math-errno -funsafe-math-optimizations -ffunction-sections -fdata-sections -fcolor-diagnostics -O2 -g -DNDEBUG   -fno-strict-aliasing -fomit-frame-pointer -fno-math-errno -funsafe-math-optimizations -ffunction-sections -fdata-sections -fcolor-diagnostics -std=gnu++11 -MD -MT src/modules/navigator/CMakeFiles/modules__navigator.dir/mission_block.cpp.o -MF src/modules/navigator/CMakeFiles/modules__navigator.dir/mission_block.cpp.o.d -o src/modules/navigator/CMakeFiles/modules__navigator.dir/mission_block.cpp.o -c ../../src/modules/navigator/mission_block.cpp\r\n\r\n../../src/modules/navigator/mission_block.cpp:462:18: fatal error: implicit conversion increases floating-point precision: 'const float' to 'double' [-Wdouble-promotion]\r\n\r\n                        vcmd.param5 = item.params[4];\r\n```",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2018-08-06T12:43:19Z",
          "body": "fixed",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "julianoes",
          "created_at": "2018-06-28T06:38:34Z",
          "body": "I thought here we lose the accuracy yet again but I was wrong.\r\nhttps://github.com/PX4/Firmware/blob/18abeb1118f3db8e4012d290e1b8dc5d0883333a/msg/vehicle_command.msg#L105-L106",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2018-06-28T06:41:34Z",
          "body": "So here we might as well use `item.alt` to be consistent, right?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "potaito",
          "created_at": "2018-06-28T06:51:54Z",
          "body": "True, didn't realize that thanks to the `union` the two fields actually occupy the same bytes. ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "potaito",
          "created_at": "2018-06-28T06:52:05Z",
          "body": "Right, those two params are the exception. Apparently they are meant for LAT/LON storage :)",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2018-06-28T07:51:37Z",
          "body": "Oh funny.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2018-06-28T07:51:46Z",
          "body": "Yep.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "potaito",
          "created_at": "2018-06-28T08:09:29Z",
          "body": ":heavy_check_mark: ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "julianoes",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "julianoes",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes incorrect behavior where INT-mode mission coordinates were not scaled when converting mavlink_mission to mission_item, causing ROI lat/lon to become (0.0, 0.0). It also addresses precision loss by using double latitude/longitude fields, both of which are logic-level bugs that produced wrong mission state/values.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "patch": "@@ -452,13 +452,15 @@ MissionBlock::issue_command(const mission_item_s &item)\n \t\tvcmd.param2 = item.params[1];\n \t\tvcmd.param3 = item.params[2];\n \t\tvcmd.param4 = item.params[3];\n-\t\tvcmd.param5 = (double)item.params[4];\n-\t\tvcmd.param6 = (double)item.params[5];\n \n \t\tif (item.nav_cmd == NAV_CMD_DO_SET_ROI_LOCATION && item.altitude_is_relative) {\n-\t\t\tvcmd.param7 = item.params[6] + _navigator->get_home_position()->alt;\n+\t\t\tvcmd.param5 = item.lat;\n+\t\t\tvcmd.param6 = item.lon;\n+\t\t\tvcmd.param7 = item.altitude + _navigator->get_home_position()->alt;\n \n \t\t} else {\n+\t\t\tvcmd.param5 = (double)item.params[4];\n+\t\t\tvcmd.param6 = (double)item.params[5];\n \t\t\tvcmd.param7 = item.params[6];\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/70155d02c8a43152bed8e7eed37abf8a52baff21/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::issue_command"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command"
        ]
      }
    }
  },
  {
    "title": "Land enhancement",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9772",
    "number": 9772,
    "created_at": "2018-06-26T19:07:03Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "This PR fixes two problems with _Land_. See #9691 & #9768\n\n**Problems**\n1. _Land_ can cause vehicle to flip upon land if the command was issued while the vehicle was moving quickly. \n\n2. _Land_ descent velocity was only **MPC_LAND_SPEED**. \n\n\n**Solutions**\n1. Vehicle will return to LAT/LON location where the _Land_ command was issued and begin descending from there. In the future, I want to implement a **_BRAKE_** setpoint type, but this is a good fix until that work is done.\n\n2. The vehicle now respects MPC_LAND_ALT1 and MPC_LAND_ALT2 to control descent velocities.\n\nI have simulation tested and physically flight tested this on our quadcopter and have seen no problems. I would love if someone could please test this with a fixed wing aircraft to verify. \n\nPlease let me know if you have any questions, thanks!\nJake",
      "issue_comments": [
        {
          "author": "Stifael",
          "created_at": "2018-06-27T15:27:06Z",
          "body": "Have you checked that `land` still works during failsafe and no local position available?",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-06-27T16:47:03Z",
          "body": "@Stifael Behavior in **_mc_pos_control_main.cpp_** remains the same if there is no local position.\r\n```\r\n\t\tif (abs(_local_pos.z) > _slow_land_alt1.get()) {\r\n\t\t\t_vel_sp(2) = _vel_max_down.get();\r\n\r\n\t\t} else if (abs(_local_pos.z) > _slow_land_alt2.get()) {\r\n\t\t\tfloat velocity_scaling = (abs(_local_pos.z) - _slow_land_alt2.get()) / (_slow_land_alt1.get() - _slow_land_alt2.get());\r\n\t\t\t_vel_sp(2) = _land_speed.get() + velocity_scaling * (_vel_max_down.get() - _land_speed.get());\r\n\r\n\t\t} else {\r\n\t\t\t_vel_sp(2) = _land_speed.get();\r\n\t\t}\r\n```\r\n\r\nDoes a failsafe event override navigator modes?",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-06-27T16:50:53Z",
          "body": "Actually, the way the code is _currently_ it seems like if local position was lost it would never make it into the first `if` statement for `land`\r\n\r\n```\r\n\tif (_pos_sp_triplet.current.valid\r\n\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LAND) {\r\n```",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-06-27T22:43:57Z",
          "body": "@dagar ",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-06-28T05:53:06Z",
          "body": "@dakejahl with your changes, the first stages are not of type `SETPOINT_TYPE_LAND`, they are of type `SETPOINT_TYPE_POSITION` (https://github.com/PX4/Firmware/pull/9772/files#diff-7a824e3d1e9a5420071c8c9bbe27b8e7R643). \r\nHave you tried in SITL to do fast forward flight and then turn of GPS?",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-06-28T17:26:43Z",
          "body": "@Stifael _\"Have you tried in SITL to do fast forward flight and then turn of GPS?\"_\r\n\r\nJust tested this, does not work. Thanks for the advice! Let me see what I can do. I am going to try to implement the braking feature in `mc_pos_control`. If I can't get this to work I will try to make it work from `navigator`. I'll report back once I have something. :grin:\r\n",
          "type": "issue_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-06-29T05:54:18Z",
          "body": "a break would also be helpful for this \"feature\" request: https://github.com/PX4/Firmware/issues/9741#issuecomment-399912835",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-06-29T18:10:29Z",
          "body": "Please see #9804",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2018-06-27T11:52:06Z",
          "body": "This whole block is duplicating the existing functionality: https://github.com/PX4/Firmware/blob/master/src/modules/mc_pos_control/mc_pos_control_main.cpp#L2439-L2443\r\nDid it not work correctly for you?",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-06-27T14:57:02Z",
          "body": "Look at the one liner that I removed.\r\n\r\n _vel_sp(2) = _land_speed.get();\r\n\r\nClearly this is overriding the current Z vel setpoint when the setpoint type is LAND.\r\n\r\nAlso, always limiting veritial velocity based upon height does not seem right. Those parameters are specified with the word 'LAND' and thus should only affect flight characteristics while in the LAND mode (this is my opinion).",
          "path": "src/modules/mc_pos_control/mc_pos_control_main.cpp",
          "position": 6,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "The position controller changes are in my eyes duplicate.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect runtime behavior (vehicles flipping when a Land command is issued while moving fast, and using a single fixed descent speed instead of alt-based speeds). Both fixes change control logic/state handling (returning to the command LAT/LON before descent and using MPC_LAND_ALT1/ALT2 to scale descent velocity), which corrects algorithmic/behavioral bugs rather than syntax or style issues.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 7,
        "changes": 45,
        "patch": "@@ -50,21 +50,22 @@ void\n Land::on_activation()\n {\n \t/* set current mission item to Land */\n-\tset_land_item(&_mission_item, true);\n+\tset_land_item(&_mission_item, LAND_STATE_RETURN);\n \t_navigator->get_mission_result()->finished = false;\n \t_navigator->set_mission_result_updated();\n-\treset_mission_item_reached();\n \n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tpos_sp_triplet->previous.valid = false;\n \tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\tpos_sp_triplet->previous.valid = false;\n \tpos_sp_triplet->next.valid = false;\n \n \t_navigator->set_can_loiter_at_sp(false);\n \n \t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t_land_state = LAND_STATE_RETURN;\n }\n \n void\n@@ -79,14 +80,44 @@ Land::on_active()\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n \n+\tif (_land_state != LAND_STATE_LANDED && is_mission_item_reached()) {\n+\t\tadvance_land();\n+\t\tset_land_item(&_mission_item, _land_state);\n+\n+\t\t/* Update the position setpoint  */\n+\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t}\n \n-\tif (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n+\tif (_land_state == LAND_STATE_LANDED) {\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n \t\tset_idle_item(&_mission_item);\n+\t}\n+}\n \n-\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n-\t\t_navigator->set_position_setpoint_triplet_updated();\n+void\n+Land::advance_land()\n+{\n+\tswitch (_land_state) {\n+\tcase LAND_STATE_RETURN_HOME:\n+\t\t_land_state = LAND_STATE_DESCEND;\n+\t\tbreak;\n+\n+\tcase LAND_STATE_RETURN:\n+\t\t_land_state = LAND_STATE_DESCEND;\n+\t\tbreak;\n+\n+\tcase LAND_STATE_DESCEND:\n+\t\t_land_state = LAND_STATE_LAND;\n+\t\tbreak;\n+\n+\tcase LAND_STATE_LAND:\n+\t\t_land_state = LAND_STATE_LANDED;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6fb2299bb08e1fc7d06378699aad9e79cdebae66/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/land.h": {
        "filename": "src/modules/navigator/land.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -51,4 +51,6 @@ class Land : public MissionBlock\n \n \tvoid on_activation() override;\n \tvoid on_active() override;\n+\tvoid advance_land();\n+\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6fb2299bb08e1fc7d06378699aad9e79cdebae66/src%2Fmodules%2Fnavigator%2Fland.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 21,
        "changes": 80,
        "patch": "@@ -628,40 +628,78 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float abs_altitude,\n }\n \n void\n-MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_location)\n+MissionBlock::set_land_item(struct mission_item_s *item, enum LandState land_state)\n {\n \t/* VTOL transition to RW before landing */\n \tif (_navigator->force_vtol()) {\n-\n \t\tvehicle_command_s vcmd = {};\n \t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n \t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n \t\t_navigator->publish_vehicle_cmd(&vcmd);\n \t}\n \n-\t/* set the land item */\n-\titem->nav_cmd = NAV_CMD_LAND;\n-\n-\t/* use current position */\n-\tif (at_current_location) {\n-\t\titem->lat = NAN; //descend at current position\n-\t\titem->lon = NAN; //descend at current position\n-\t\titem->yaw = _navigator->get_local_position()->yaw;\n+\tswitch (land_state) {\n+\tcase LAND_STATE_RETURN_HOME:\n+\t\titem->nav_cmd = NAV_CMD_WAYPOINT;\n \n-\t} else {\n \t\t/* use home position */\n-\t\titem->lat = _navigator->get_home_position()->lat;\n-\t\titem->lon = _navigator->get_home_position()->lon;\n-\t\titem->yaw = _navigator->get_home_position()->yaw;\n+\t\tif (_navigator->get_vstatus()->failsafe) {\n+\t\t\titem->lat = NAN; //descend at current position\n+\t\t\titem->lon = NAN; //descend at current position\n+\t\t\titem->yaw = _navigator->get_local_position()->yaw;\n+\t\t\titem->altitude = 0;\n+\n+\t\t} else {\n+\t\t\titem->lat = _navigator->get_home_position()->lat;\n+\t\t\titem->lon = _navigator->get_home_position()->lon;\n+\t\t\titem->yaw = _navigator->get_home_position()->yaw;\n+\t\t\titem->altitude = _navigator->get_global_position()->alt;\n+\t\t}\n+\n+\t\titem->acceptance_radius = _navigator->get_acceptance_radius(0.5);\n+\t\titem->time_inside = 1.0f;\n+\t\titem->autocontinue = true;\n+\t\titem->origin = ORIGIN_ONBOARD;\n+\t\tbreak;\n+\n+\tcase LAND_STATE_RETURN:\n+\t\titem->nav_cmd = NAV_CMD_WAYPOINT;\n+\n+\t\t/* use current position */\n+\t\tif (_navigator->get_vstatus()->failsafe) {\n+\t\t\titem->lat = NAN; //descend at current position\n+\t\t\titem->lon = NAN; //descend at current position\n+\t\t\titem->yaw = _navigator->get_local_position()->yaw;\n+\t\t\titem->altitude = 0;\n+\n+\t\t} else {\n+\t\t\titem->lat = _navigator->get_global_position()->lat;\n+\t\t\titem->lon = _navigator->get_global_position()->lon;\n+\t\t\titem->yaw = _navigator->get_global_position()->yaw;\n+\t\t\titem->altitude = _navigator->get_global_position()->alt;\n+\t\t}\n+\n+\t\titem->acceptance_radius = _navigator->get_acceptance_radius(0.5);\n+\t\titem->time_inside = 1.0f;\n+\t\titem->autocontinue = true;\n+\t\titem->origin = ORIGIN_ONBOARD;\n+\t\tbreak;\n+\n+\tcase LAND_STATE_DESCEND:\n+\t\titem->nav_cmd = NAV_CMD_LAND;\n+\t\titem->altitude = 0;\n+\t\tbreak;\n+\n+\tcase LAND_STATE_LANDED:\n+\t\titem->nav_cmd = NAV_CMD_IDLE;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n+\n \t}\n \n-\titem->altitude = 0;\n-\titem->altitude_is_relative = false;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n-\titem->acceptance_radius = _navigator->get_acceptance_radius();\n-\titem->time_inside = 0.0f;\n-\titem->autocontinue = true;\n-\titem->origin = ORIGIN_ONBOARD;\n+\treset_mission_item_reached();\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6fb2299bb08e1fc7d06378699aad9e79cdebae66/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "patch": "@@ -68,6 +68,16 @@ class MissionBlock : public NavigatorMode\n \tstatic bool item_contains_position(const mission_item_s &item);\n \n protected:\n+\n+\tenum LandState {\n+\t\tLAND_STATE_NONE = 0,\n+\t\tLAND_STATE_RETURN_HOME,\n+\t\tLAND_STATE_RETURN,\n+\t\tLAND_STATE_DESCEND,\n+\t\tLAND_STATE_LAND,\n+\t\tLAND_STATE_LANDED,\n+\t} _land_state{LAND_STATE_NONE};\n+\n \t/**\n \t * Check if mission item has been reached\n \t * @return true if successfully reached\n@@ -100,7 +110,7 @@ class MissionBlock : public NavigatorMode\n \t/**\n \t * Set a land mission item\n \t */\n-\tvoid set_land_item(struct mission_item_s *item, bool at_current_location);\n+\tvoid set_land_item(struct mission_item_s *item, enum LandState land_state);\n \n \t/**\n \t * Set idle mission item",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6fb2299bb08e1fc7d06378699aad9e79cdebae66/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_activation",
        "Land::on_active",
        "set_land_item",
        "MissionBlock::set_takeoff_item"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation",
          "Land::on_active"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_takeoff_item"
        ],
        "src/modules/navigator/mission_block.h": [
          "set_land_item"
        ]
      }
    }
  },
  {
    "title": "mission feasibility: add small tolerance to fw landing slope alt",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9753",
    "number": 9753,
    "created_at": "2018-06-24T09:14:25Z",
    "merged": true,
    "merged_at": "2018-06-29T12:10:54Z",
    "state": "closed",
    "conversation": {
      "author": "tstastny",
      "body": "Once sent from QGC to pixhawk, the fixed-wing landing pattern coordinates are again converted to local distances for feasibility checks, where small floating point errors can cause a rejection -- and the need to modify and resend the waypoints (somewhat tedious on the field). This PR simply adds a small tolerance to the check condition to avoid this.\n\n(also open to recommendations on the value of this tolerance, I just put 1m for now)\n\nPartially addresses #9472.",
      "issue_comments": [
        {
          "author": "tstastny",
          "created_at": "2018-06-26T07:20:48Z",
          "body": "@dagar @LorenzMeier ok to merge? or any other thoughts?",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-29T10:50:40Z",
          "body": "@dagar @LorenzMeier LGTM given that all checks have passed?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” this PR fixes a logic error: a feasibility check was too strict and could incorrectly reject valid fixed-wing landing patterns due to floating-point/ boundary rounding errors. Adding a small tolerance corrects the boundary condition and prevents unintended rejections without changing program flow.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -411,8 +411,8 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n \t\t\t\t\t\t\tconst float slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude,\n \t\t\t\t\t\t\t\t\t\t    horizontal_slope_displacement, slope_angle_rad);\n \n-\t\t\t\t\t\t\tif (missionitem_previous.altitude > slope_alt_req) {\n-\t\t\t\t\t\t\t\t/* Landing waypoint is above altitude of slope at the given waypoint distance */\n+\t\t\t\t\t\t\tif (missionitem_previous.altitude > slope_alt_req + 1.0f) {\n+\t\t\t\t\t\t\t\t/* Landing waypoint is above altitude of slope at the given waypoint distance (with small tolerance for floating point discrepancies) */\n \t\t\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: adjust landing approach.\");\n \n \t\t\t\t\t\t\t\tconst float wp_distance_req = Landingslope::getLandingSlopeWPDistance(missionitem_previous.altitude,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7994dbceb54a87db9f397e51df23205dfe37a6da/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkFixedWingLanding"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding"
        ]
      }
    }
  },
  {
    "title": "[WIP] mission_result split into mission_status and navigator_status",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9747",
    "number": 9747,
    "created_at": "2018-06-23T03:03:24Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "The navigator message `mission_result` has become overloaded to contain both general navigator status, mission feasibility, and mission status. This has resulted in some confusion in both logs and usage from commander.\n\nThis PR splits mission_result into a general navigator_status message, and a mission_status that's specific to the planned dataman stored mission.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-06-23T12:51:56Z",
          "body": " - fixes https://github.com/PX4/Firmware/issues/9746\r\n - possibly fixes https://github.com/PX4/Firmware/issues/9515 (TBD)",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-01-20T04:33:43Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2019-01-20T15:29:39Z",
          "body": "this PR is still valid, or at least the part the tries to fix this current bug:  https://github.com/PX4/Firmware/issues/9746",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2019-02-05T21:08:38Z",
          "body": "Needs to be rebased badly.",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-10-13T17:18:05Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-10T17:51:22Z",
          "body": "Closing as stale.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses an overloaded navigator message that conflated general navigator state, mission feasibility, and mission-specific status. That mixing of concerns produces incorrect/ambiguous state reporting and data flow (improper state representation), so splitting into navigator_status and mission_status corrects a logic/design error causing unintended behavior and confusion.",
    "patches": {
      "src/modules/navigator/datalinkloss.cpp": {
        "filename": "src/modules/navigator/datalinkloss.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -132,8 +132,8 @@ DataLinkLoss::set_dll_item()\n \n \tcase DLL_STATE_TERMINATE: {\n \t\t\t/* Request flight termination from the commander */\n-\t\t\t_navigator->get_mission_result()->flight_termination = true;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->get_navigator_status()->flight_termination = true;\n+\t\t\t_navigator->set_navigator_status_updated();\n \t\t\treset_mission_item_reached();\n \t\t\twarnx(\"not switched to manual: request flight termination\");\n \t\t\tpos_sp_triplet->previous.valid = false;\n@@ -167,8 +167,8 @@ DataLinkLoss::advance_dll()\n \t\t\twarnx(\"%d data link losses, limit is %d, fly to airfield home\",\n \t\t\t      _navigator->get_vstatus()->data_link_lost_counter, _param_numberdatalinklosses.get());\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"too many DL losses, fly to airfield home\");\n-\t\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->get_navigator_status()->stay_in_failsafe = true;\n+\t\t\t_navigator->set_navigator_status_updated();\n \t\t\treset_mission_item_reached();\n \t\t\t_dll_state = DLL_STATE_FLYTOAIRFIELDHOMEWP;\n \n@@ -192,17 +192,17 @@ DataLinkLoss::advance_dll()\n \t\twarnx(\"fly to airfield home\");\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"fly to airfield home\");\n \t\t_dll_state = DLL_STATE_FLYTOAIRFIELDHOMEWP;\n-\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t\t_navigator->get_navigator_status()->stay_in_failsafe = true;\n+\t\t_navigator->set_navigator_status_updated();\n \t\treset_mission_item_reached();\n \t\tbreak;\n \n \tcase DLL_STATE_FLYTOAIRFIELDHOMEWP:\n \t\t_dll_state = DLL_STATE_TERMINATE;\n \t\twarnx(\"time is up, state should have been changed manually by now\");\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"no manual control, terminating\");\n-\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t\t_navigator->get_navigator_status()->stay_in_failsafe = true;\n+\t\t_navigator->set_navigator_status_updated();\n \t\treset_mission_item_reached();\n \t\tbreak;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fdatalinkloss.cpp"
      },
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -135,8 +135,8 @@ GpsFailure::set_gpsf_item()\n \tswitch (_gpsf_state) {\n \tcase GPSF_STATE_TERMINATE: {\n \t\t\t/* Request flight termination from commander */\n-\t\t\t_navigator->get_mission_result()->flight_termination = true;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->get_navigator_status()->flight_termination = true;\n+\t\t\t_navigator->set_navigator_status_updated();\n \t\t\tPX4_WARN(\"GPS failure: request flight termination\");\n \t\t}\n \t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      },
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "patch": "@@ -51,8 +51,7 @@ Land::on_activation()\n {\n \t/* set current mission item to Land */\n \tset_land_item(&_mission_item, true);\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->set_mission_result_updated();\n+\t_navigator->set_navigator_status_updated();\n \treset_mission_item_reached();\n \n \t/* convert mission item to current setpoint */\n@@ -80,9 +79,9 @@ Land::on_active()\n \t}\n \n \n-\tif (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n+\tif (is_mission_item_reached() && !_navigator->get_navigator_status()->finished) {\n+\t\t_navigator->get_navigator_status()->finished = true;\n+\t\t_navigator->set_navigator_status_updated();\n \t\tset_idle_item(&_mission_item);\n \n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 53,
        "changes": 125,
        "patch": "@@ -58,7 +58,6 @@\n #include <navigator/navigation.h>\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n-#include <uORB/topics/mission_result.h>\n \n using matrix::wrap_pi;\n \n@@ -136,7 +135,7 @@ Mission::on_inactive()\n \t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n \n \t/* reset so MISSION_ITEM_REACHED isn't published */\n-\t_navigator->get_mission_result()->seq_reached = -1;\n+\tmission_status().seq_reached = -1;\n }\n \n void\n@@ -156,7 +155,7 @@ Mission::on_activation()\n {\n \tif (_mission_waypoints_changed) {\n \t\t// do not set the closest mission item in the normal mission mode\n-\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n+\t\tif (_mission_execution_mode != mission_status_s::MISSION_EXECUTION_MODE_NORMAL) {\n \t\t\t_current_offboard_mission_index = index_closest_mission_item();\n \t\t}\n \n@@ -175,6 +174,9 @@ Mission::on_activation()\n \tcmd.param1 = -1.0f;\n \tcmd.param3 = 0.0f;\n \t_navigator->publish_vehicle_cmd(&cmd);\n+\n+\t_navigator->get_navigator_status()->finished = true;\n+\t_navigator->set_navigator_status_updated();\n }\n \n void\n@@ -204,7 +206,7 @@ Mission::on_active()\n \tif (offboard_updated || _mission_waypoints_changed || _execution_mode_changed) {\n \t\tif (_mission_waypoints_changed) {\n \t\t\t// do not set the closest mission item in the normal mission mode\n-\t\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n+\t\t\tif (_mission_execution_mode != mission_status_s::MISSION_EXECUTION_MODE_NORMAL) {\n \t\t\t\t_current_offboard_mission_index = index_closest_mission_item();\n \t\t\t}\n \n@@ -272,12 +274,24 @@ Mission::on_active()\n \t\t\t_navigator->get_precland()->on_active();\n \t\t}\n \t}\n+\n+\t// set mission failure if navigator has failed during mission\n+\tif (_navigator->get_navigator_status()->failure && !mission_status().failure) {\n+\t\tmission_status().failure = true;\n+\t\tmission_status_update();\n+\t}\n+\n+\t// sync mission status with navigator status\n+\tif (mission_status().finished != _navigator->get_navigator_status()->finished) {\n+\t\t_navigator->get_navigator_status()->finished = mission_status().finished;\n+\t\t_navigator->set_navigator_status_updated();\n+\t}\n }\n \n bool\n Mission::set_current_offboard_mission_index(uint16_t index)\n {\n-\tif (_navigator->get_mission_result()->valid &&\n+\tif (mission_status().valid &&\n \t    (index != _current_offboard_mission_index) && (index < _offboard_mission.count)) {\n \n \t\t_current_offboard_mission_index = index;\n@@ -312,13 +326,13 @@ Mission::set_execution_mode(const uint8_t mode)\n {\n \tif (_mission_execution_mode != mode) {\n \t\t_execution_mode_changed = true;\n-\t\t_navigator->get_mission_result()->execution_mode = mode;\n+\t\tmission_status().execution_mode = mode;\n \n \n \t\tswitch (_mission_execution_mode) {\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD:\n-\t\t\tif (mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_NORMAL:\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD:\n+\t\t\tif (mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE) {\n \t\t\t\t// command a transition if in vtol mc mode\n \t\t\t\tif (_navigator->get_vstatus()->is_rotary_wing &&\n \t\t\t\t    _navigator->get_vstatus()->is_vtol &&\n@@ -349,9 +363,9 @@ Mission::set_execution_mode(const uint8_t mode)\n \n \t\t\tbreak;\n \n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE:\n-\t\t\tif ((mode == mission_result_s::MISSION_EXECUTION_MODE_NORMAL) ||\n-\t\t\t    (mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD)) {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_REVERSE:\n+\t\t\tif ((mode == mission_status_s::MISSION_EXECUTION_MODE_NORMAL) ||\n+\t\t\t    (mode == mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD)) {\n \t\t\t\t// handle switch from reverse to forward mission\n \t\t\t\tif (_current_offboard_mission_index < 0) {\n \t\t\t\t\t_current_offboard_mission_index = 0;\n@@ -428,7 +442,7 @@ Mission::landing()\n \t// vehicle is currently landing if\n \t//  mission valid, still flying, and in the landing portion of mission\n \n-\tconst bool mission_valid = _navigator->get_mission_result()->valid;\n+\tconst bool mission_valid = mission_status().valid;\n \tconst bool on_landing_stage = _land_start_available && (_current_offboard_mission_index >= get_land_start_index());\n \n \treturn mission_valid && on_landing_stage;\n@@ -437,7 +451,6 @@ Mission::landing()\n void\n Mission::update_offboard_mission()\n {\n-\n \tbool failed = true;\n \n \t/* reset triplets */\n@@ -465,15 +478,15 @@ Mission::update_offboard_mission()\n \n \t\tcheck_mission_valid(true);\n \n-\t\tfailed = !_navigator->get_mission_result()->valid;\n+\t\tfailed = !mission_status().valid;\n \n \t\tif (!failed) {\n \t\t\t/* reset mission failure if we have an updated valid mission */\n-\t\t\t_navigator->get_mission_result()->failure = false;\n+\t\t\tmission_status().failure = false;\n \n \t\t\t/* reset sequence info as well */\n-\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n-\t\t\t_navigator->get_mission_result()->seq_total = _offboard_mission.count;\n+\t\t\tmission_status().seq_reached = -1;\n+\t\t\tmission_status().seq_total = _offboard_mission.count;\n \n \t\t\t/* reset work item if new mission has been accepted */\n \t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n@@ -518,13 +531,13 @@ Mission::advance_mission()\n \tswitch (_mission_type) {\n \tcase MISSION_TYPE_OFFBOARD:\n \t\tswitch (_mission_execution_mode) {\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_NORMAL:\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n \t\t\t\t_current_offboard_mission_index++;\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_REVERSE: {\n \t\t\t\t// find next position item in reverse order\n \t\t\t\tdm_item_t dm_current = (dm_item_t)(_offboard_mission.dataman_id);\n \n@@ -580,7 +593,7 @@ Mission::set_mission_items()\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n \t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n-\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Executing Reverse Mission\" :\n+\t\t\t\t\t _mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE ? \"Executing Reverse Mission\" :\n \t\t\t\t\t \"Executing Mission\");\n \t\t\tuser_feedback_done = true;\n \t\t}\n@@ -593,13 +606,13 @@ Mission::set_mission_items()\n \n \t\t\tif (_navigator->get_land_detected()->landed) {\n \t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n-\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, landed\" :\n+\t\t\t\t\t\t _mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, landed\" :\n \t\t\t\t\t\t \"Mission finished, landed.\");\n \n \t\t\t} else {\n \t\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n \t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n-\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, loitering\" :\n+\t\t\t\t\t\t _mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, loitering\" :\n \t\t\t\t\t\t \"Mission finished, loitering.\");\n \n \t\t\t\t/* use last setpoint for loiter */\n@@ -625,8 +638,8 @@ Mission::set_mission_items()\n \t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n \n \t\t// set mission finished\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t\tmission_status().finished = true;\n+\t\tmission_status_update();\n \n \t\tif (!user_feedback_done) {\n \t\t\t/* only tell users that we got no mission if there has not been any\n@@ -657,8 +670,8 @@ Mission::set_mission_items()\n \n \tif (item_contains_position(_mission_item)) {\n \t\tswitch (_mission_execution_mode) {\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_NORMAL:\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n \t\t\t\t/* force vtol land */\n \t\t\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n \t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n@@ -886,7 +899,7 @@ Mission::set_mission_items()\n \n \t\t\t\t// for fast forward convert certain types to simple waypoint\n \t\t\t\t// XXX: add other types which should be ignored in fast forward\n-\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD &&\n+\t\t\t\tif (_mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD &&\n \t\t\t\t    ((_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED) ||\n \t\t\t\t     (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT))) {\n \t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n@@ -897,7 +910,7 @@ Mission::set_mission_items()\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_REVERSE: {\n \t\t\t\tif (item_contains_position(_mission_item)) {\n \t\t\t\t\t// convert mission item to a simple waypoint\n \t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n@@ -915,8 +928,8 @@ Mission::set_mission_items()\n \t} else {\n \t\t/* handle non-position mission items such as commands */\n \t\tswitch (_mission_execution_mode) {\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_NORMAL:\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n \t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t\t\t\t/* turn towards next waypoint before MC to FW transition */\n@@ -972,7 +985,7 @@ Mission::set_mission_items()\n \t\t\t\t}\n \n \t\t\t\t// ignore certain commands in mission fast forward\n-\t\t\t\tif ((_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD) &&\n+\t\t\t\tif ((_mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD) &&\n \t\t\t\t    (_mission_item.nav_cmd == NAV_CMD_DELAY)) {\n \t\t\t\t\t_mission_item.autocontinue = true;\n \t\t\t\t\t_mission_item.time_inside = 0.0f;\n@@ -981,7 +994,7 @@ Mission::set_mission_items()\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n+\t\tcase mission_status_s::MISSION_EXECUTION_MODE_REVERSE: {\n \t\t\t\t// nothing to do, all commands are ignored\n \t\t\t\tbreak;\n \t\t\t}\n@@ -1427,7 +1440,7 @@ Mission::prepare_mission_items(mission_item_s *mission_item,\n \tbool first_res = false;\n \tint offset = 1;\n \n-\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n+\tif (_mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE) {\n \t\toffset = -1;\n \t}\n \n@@ -1443,7 +1456,7 @@ Mission::prepare_mission_items(mission_item_s *mission_item,\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n+\t\t\tif (_mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE) {\n \t\t\t\toffset--;\n \n \t\t\t} else {\n@@ -1498,7 +1511,7 @@ Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n \n \t\t/* check for DO_JUMP item, and whether it hasn't not already been repeated enough times */\n \t\tif (mission_item_tmp.nav_cmd == NAV_CMD_DO_JUMP) {\n-\t\t\tconst bool execute_jumps = _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_NORMAL;\n+\t\t\tconst bool execute_jumps = _mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_NORMAL;\n \n \t\t\t/* do DO_JUMP as many times as requested if not in reverse mode */\n \t\t\tif ((mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) && execute_jumps) {\n@@ -1528,7 +1541,7 @@ Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n \t\t\t\t}\n \n \t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */\n-\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n+\t\t\t\tif (_mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE) {\n \t\t\t\t\t(*mission_index_ptr)--;\n \n \t\t\t\t} else {\n@@ -1605,29 +1618,33 @@ void\n Mission::report_do_jump_mission_changed(int index, int do_jumps_remaining)\n {\n \t/* inform about the change */\n-\t_navigator->get_mission_result()->item_do_jump_changed = true;\n-\t_navigator->get_mission_result()->item_changed_index = index;\n-\t_navigator->get_mission_result()->item_do_jump_remaining = do_jumps_remaining;\n+\tmission_status().item_do_jump_changed = true;\n+\tmission_status().item_changed_index = index;\n+\tmission_status().item_do_jump_remaining = do_jumps_remaining;\n \n-\t_navigator->set_mission_result_updated();\n+\t_mission_status_pub.update();\n+\n+\tmission_status().item_do_jump_changed = false;\n+\tmission_status().item_do_jump_changed = 0;\n+\tmission_status().item_do_jump_remaining = 0;\n }\n \n void\n Mission::set_mission_item_reached()\n {\n-\t_navigator->get_mission_result()->seq_reached = _current_offboard_mission_index;\n-\t_navigator->set_mission_result_updated();\n+\tmission_status().seq_reached = _current_offboard_mission_index;\n+\tmission_status_update();\n \n \treset_mission_item_reached();\n }\n \n void\n Mission::set_current_offboard_mission_item()\n {\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->get_mission_result()->seq_current = _current_offboard_mission_index;\n+\tmission_status().finished = false;\n+\tmission_status().seq_current = _current_offboard_mission_index;\n \n-\t_navigator->set_mission_result_updated();\n+\tmission_status_update();\n \n \tsave_offboard_mission_state();\n }\n@@ -1639,15 +1656,17 @@ Mission::check_mission_valid(bool force)\n \n \t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator);\n \n-\t\t_navigator->get_mission_result()->valid =\n+\t\tmission_status().valid =\n \t\t\t_missionFeasibilityChecker.checkMissionFeasible(_offboard_mission,\n \t\t\t\t\t_param_dist_1wp.get(),\n \t\t\t\t\t_param_dist_between_wps.get(),\n-\t\t\t\t\t_navigator->mission_landing_required());\n+\t\t\t\t\t_navigator->mission_landing_required(),\n+\t\t\t\t\tmission_status().warning);\n+\n+\t\tmission_status().seq_total = _offboard_mission.count;\n+\t\tmission_status().instance_count++;\n+\t\tmission_status_update();\n \n-\t\t_navigator->get_mission_result()->seq_total = _offboard_mission.count;\n-\t\t_navigator->increment_mission_instance_count();\n-\t\t_navigator->set_mission_result_updated();\n \t\t_home_inited = _navigator->home_position_valid();\n \n \t\t// find and store landing start marker (if available)\n@@ -1771,7 +1790,7 @@ Mission::index_closest_mission_item() const\n \t}\n \n \t// for mission reverse also consider the home position\n-\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n+\tif (_mission_execution_mode == mission_status_s::MISSION_EXECUTION_MODE_REVERSE) {\n \t\tfloat dist = get_distance_to_point_global_wgs84(\n \t\t\t\t     _navigator->get_home_position()->lat,\n \t\t\t\t     _navigator->get_home_position()->lon,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 17,
        "deletions": 3,
        "changes": 20,
        "patch": "@@ -53,9 +53,10 @@\n #include <dataman/dataman.h>\n #include <drivers/drv_hrt.h>\n #include <px4_module_params.h>\n+#include <uORB/Publication.hpp>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n-#include <uORB/topics/mission_result.h>\n+#include <uORB/topics/mission_status.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/vehicle_status.h>\n@@ -99,14 +100,21 @@ class Mission : public MissionBlock, public ModuleParams\n \tbool get_mission_changed() const { return _mission_changed ; }\n \tbool get_mission_waypoints_changed() const { return _mission_waypoints_changed ; }\n \n+\tconst mission_status_s &get_mission_status() { return _mission_status_pub.get(); }\n+\n \tvoid set_closest_item_as_current();\n \n \t/**\n \t * Set a new mission mode and handle the switching between the different modes\n \t *\n-\t * For a list of the different modes refer to mission_result.msg\n+\t * For a list of the different modes refer to mission_status.msg\n \t */\n \tvoid set_execution_mode(const uint8_t mode);\n+\n+\tvoid set_execution_mode_normal() { set_execution_mode(mission_status_s::MISSION_EXECUTION_MODE_NORMAL); }\n+\tvoid set_execution_mode_reverse() { set_execution_mode(mission_status_s::MISSION_EXECUTION_MODE_REVERSE); }\n+\tvoid set_execution_mode_fast_forward() { set_execution_mode(mission_status_s::MISSION_EXECUTION_MODE_FAST_FORWARD); }\n+\n private:\n \n \t/**\n@@ -241,6 +249,10 @@ class Mission : public MissionBlock, public ModuleParams\n \t */\n \tint32_t index_closest_mission_item() const;\n \n+\tmission_status_s &mission_status() { return _mission_status_pub.get(); }\n+\n+\tvoid mission_status_update() { _mission_status_pub.get().timestamp = hrt_absolute_time(); _mission_status_pub.update(); }\n+\n \tbool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;\n \n \tDEFINE_PARAMETERS(\n@@ -251,6 +263,8 @@ class Mission : public MissionBlock, public ModuleParams\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mnt_yaw_ctl\n \t)\n \n+\tuORB::Publication<mission_status_s> _mission_status_pub{ORB_ID(mission_status)};\n+\n \tstruct mission_s _offboard_mission {};\n \n \tint32_t _current_offboard_mission_index{-1};\n@@ -288,6 +302,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t\tWORK_ITEM_TYPE_PRECISION_LAND\n \t} _work_item_type{WORK_ITEM_TYPE_DEFAULT};\t/**< current type of work to do (sub mission item) */\n \n-\tuint8_t _mission_execution_mode{mission_result_s::MISSION_EXECUTION_MODE_NORMAL};\t/**< the current mode of how the mission is executed,look at mission_result.msg for the definition */\n+\tuint8_t _mission_execution_mode{mission_status_s::MISSION_EXECUTION_MODE_NORMAL};\t/**< the current mode of how the mission is executed,look at mission_status.msg for the definition */\n \tbool _execution_mode_changed{false};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -343,7 +343,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n \t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n \n-\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n+\t\t\t\t_navigator->set_navigator_failure(\"unable to reach heading within timeout\");\n \t\t\t}\n \n \t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 12,
        "changes": 27,
        "patch": "@@ -53,11 +53,14 @@\n bool\n MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission,\n \t\tfloat max_distance_to_1st_waypoint, float max_distance_between_waypoints,\n-\t\tbool land_start_req)\n+\t\tbool land_start_req, bool &warning)\n {\n \tbool failed = false;\n \tbool warned = false;\n \n+\t// reset previous warnings\n+\twarning = false;\n+\n \t// first check if we have a valid position\n \tconst bool home_valid = _navigator->home_position_valid();\n \tconst bool home_alt_valid = _navigator->home_alt_valid();\n@@ -68,16 +71,16 @@ MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission,\n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Not yet ready for mission, no position lock.\");\n \n \t} else {\n-\t\tfailed = failed || !checkDistanceToFirstWaypoint(mission, max_distance_to_1st_waypoint);\n+\t\tfailed = failed || !checkDistanceToFirstWaypoint(mission, max_distance_to_1st_waypoint, warning);\n \t}\n \n \tconst float home_alt = _navigator->get_home_position()->alt;\n \n \t// check if all mission item commands are supported\n \tfailed = failed || !checkMissionItemValidity(mission);\n-\tfailed = failed || !checkDistancesBetweenWaypoints(mission, max_distance_between_waypoints);\n+\tfailed = failed || !checkDistancesBetweenWaypoints(mission, max_distance_between_waypoints, warning);\n \tfailed = failed || !checkGeofence(mission, home_alt, home_valid);\n-\tfailed = failed || !checkHomePositionAltitude(mission, home_alt, home_alt_valid, warned);\n+\tfailed = failed || !checkHomePositionAltitude(mission, home_alt, home_alt_valid, warned, warning);\n \n \t// VTOL always respects rotary wing feasibility\n \tif (_navigator->get_vstatus()->is_rotary_wing || _navigator->get_vstatus()->is_vtol) {\n@@ -179,23 +182,23 @@ MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_al\n \n bool\n MissionFeasibilityChecker::checkHomePositionAltitude(const mission_s &mission, float home_alt, bool home_alt_valid,\n-\t\tbool throw_error)\n+\t\tbool throw_error, bool &warning)\n {\n \t/* Check if all waypoints are above the home altitude */\n \tfor (size_t i = 0; i < mission.count; i++) {\n \t\tstruct mission_item_s missionitem = {};\n \t\tconst ssize_t len = sizeof(struct mission_item_s);\n \n \t\tif (dm_read((dm_item_t)mission.dataman_id, i, &missionitem, len) != len) {\n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\twarning = true;\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\treturn false;\n \t\t}\n \n \t\t/* reject relative alt without home set */\n \t\tif (missionitem.altitude_is_relative && !home_alt_valid && MissionBlock::item_contains_position(missionitem)) {\n \n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\twarning = true;\n \n \t\t\tif (throw_error) {\n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: No home pos, WP %d uses rel alt\", i + 1);\n@@ -212,7 +215,7 @@ MissionFeasibilityChecker::checkHomePositionAltitude(const mission_s &mission, f\n \n \t\tif ((home_alt > wp_alt) && MissionBlock::item_contains_position(missionitem)) {\n \n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\twarning = true;\n \n \t\t\tif (throw_error) {\n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: Waypoint %d below home\", i + 1);\n@@ -467,7 +470,7 @@ MissionFeasibilityChecker::checkFixedWingLanding(const mission_s &mission, bool\n }\n \n bool\n-MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission, float max_distance)\n+MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission, float max_distance, bool &warning)\n {\n \tif (max_distance <= 0.0f) {\n \t\t/* param not set, check is ok */\n@@ -505,7 +508,7 @@ MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission\n \t\t\t\t\t     \"First waypoint too far away: %d meters, %d max.\",\n \t\t\t\t\t     (int)dist_to_1wp, (int)max_distance);\n \n-\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\twarning = true;\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -515,7 +518,7 @@ MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission\n }\n \n bool\n-MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &mission, float max_distance)\n+MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &mission, float max_distance, bool &warning)\n {\n \tif (max_distance <= 0.0f) {\n \t\t/* param not set, check is ok */\n@@ -555,7 +558,7 @@ MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &missi\n \t\t\t\t\t\t     \"Distance between waypoints too far: %d meters, %d max.\",\n \t\t\t\t\t\t     (int)dist_between_waypoints, (int)max_distance);\n \n-\t\t\t\t_navigator->get_mission_result()->warning = true;\n+\t\t\t\twarning = true;\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.h": {
        "filename": "src/modules/navigator/mission_feasibility_checker.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "patch": "@@ -56,12 +56,13 @@ class MissionFeasibilityChecker\n \t/* Checks for all airframes */\n \tbool checkGeofence(const mission_s &mission, float home_alt, bool home_valid);\n \n-\tbool checkHomePositionAltitude(const mission_s &mission, float home_alt, bool home_alt_valid, bool throw_error);\n+\tbool checkHomePositionAltitude(const mission_s &mission, float home_alt, bool home_alt_valid, bool throw_error,\n+\t\t\t\t       bool &warning);\n \n \tbool checkMissionItemValidity(const mission_s &mission);\n \n-\tbool checkDistanceToFirstWaypoint(const mission_s &mission, float max_distance);\n-\tbool checkDistancesBetweenWaypoints(const mission_s &mission, float max_distance);\n+\tbool checkDistanceToFirstWaypoint(const mission_s &mission, float max_distance, bool &warning);\n+\tbool checkDistancesBetweenWaypoints(const mission_s &mission, float max_distance, bool &warning);\n \n \t/* Checks specific to fixedwing airframes */\n \tbool checkFixedwing(const mission_s &mission, float home_alt, bool home_alt_valid, bool land_start_req);\n@@ -83,7 +84,7 @@ class MissionFeasibilityChecker\n \t */\n \tbool checkMissionFeasible(const mission_s &mission,\n \t\t\t\t  float max_distance_to_1st_waypoint, float max_distance_between_waypoints,\n-\t\t\t\t  bool land_start_req);\n+\t\t\t\t  bool land_start_req, bool &warning);\n \n };\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "patch": "@@ -62,7 +62,7 @@\n #include <uORB/topics/fw_pos_ctrl_status.h>\n #include <uORB/topics/geofence_result.h>\n #include <uORB/topics/mission.h>\n-#include <uORB/topics/mission_result.h>\n+#include <uORB/topics/navigator_status.h>\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n #include <uORB/topics/vehicle_attitude_setpoint.h>\n@@ -140,14 +140,14 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid\t\tset_can_loiter_at_sp(bool can_loiter) { _can_loiter_at_sp = can_loiter; }\n \tvoid\t\tset_position_setpoint_triplet_updated() { _pos_sp_triplet_updated = true; }\n-\tvoid\t\tset_mission_result_updated() { _mission_result_updated = true; }\n+\tvoid\t\tset_navigator_status_updated() { _navigator_status_updated = true; }\n \n \t/**\n \t * Getters\n \t */\n \tstruct fw_pos_ctrl_status_s *get_fw_pos_ctrl_status() { return &_fw_pos_ctrl_status; }\n \tstruct home_position_s *get_home_position() { return &_home_pos; }\n-\tstruct mission_result_s *get_mission_result() { return &_mission_result; }\n+\tstruct navigator_status_s *get_navigator_status() { return &_navigator_status; }\n \tstruct position_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n \tstruct position_setpoint_triplet_s *get_reposition_triplet() { return &_reposition_triplet; }\n \tstruct position_setpoint_triplet_s *get_takeoff_triplet() { return &_takeoff_triplet; }\n@@ -242,9 +242,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \torb_advert_t\t*get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n-\tvoid\t\tincrement_mission_instance_count() { _mission_result.instance_count++; }\n-\n-\tvoid \t\tset_mission_failure(const char *reason);\n+\tvoid \t\tset_navigator_failure(const char *reason);\n \n \t// MISSION\n \tbool\t\tis_planned_mission() const { return _navigation_mode == &_mission; }\n@@ -285,7 +283,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \torb_advert_t\t_geofence_result_pub{nullptr};\n \torb_advert_t\t_mavlink_log_pub{nullptr};\t/**< the uORB advert to send messages over mavlink */\n-\torb_advert_t\t_mission_result_pub{nullptr};\n+\torb_advert_t\t_navigator_status_pub{nullptr};\n \torb_advert_t\t_pos_sp_triplet_pub{nullptr};\n \torb_advert_t\t_vehicle_cmd_ack_pub{nullptr};\n \torb_advert_t\t_vehicle_cmd_pub{nullptr};\n@@ -294,7 +292,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t// Subscriptions\n \tfw_pos_ctrl_status_s\t\t\t\t_fw_pos_ctrl_status{};\t/**< fixed wing navigation capabilities */\n \thome_position_s\t\t\t\t\t_home_pos{};\t\t/**< home position for RTL */\n-\tmission_result_s\t\t\t\t_mission_result{};\n+\tnavigator_status_s\t\t\t\t_navigator_status{};\n \tvehicle_global_position_s\t\t\t_global_pos{};\t\t/**< global vehicle position */\n \tvehicle_gps_position_s\t\t\t\t_gps_pos{};\t\t/**< gps position */\n \tvehicle_land_detected_s\t\t\t\t_land_detected{};\t/**< vehicle land_detected */\n@@ -316,7 +314,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tbool\t\t_can_loiter_at_sp{false};\t\t\t/**< flags if current position SP can be used to loiter */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t/**< flags if position SP triplet needs to be published */\n \tbool \t\t_pos_sp_triplet_published_invalid_once{false};\t/**< flags if position SP triplet has been published once to UORB */\n-\tbool\t\t_mission_result_updated{false};\t\t/**< flags if mission result has seen an update */\n+\tbool\t\t_navigator_status_updated{false};\t\t/**< flags if mission result has seen an update */\n \n \tNavigatorMode\t*_navigation_mode{nullptr};\t\t/**< abstract pointer to current navigation mode class */\n \tMission\t\t_mission;\t\t\t/**< class that handles the missions */\n@@ -377,7 +375,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t/**\n \t * Publish the mission result so commander and mavlink know what is going on\n \t */\n-\tvoid\t\tpublish_mission_result();\n+\tvoid\t\tpublish_navigator_status();\n \n \tvoid\t\tpublish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_t result);\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "patch": "@@ -436,7 +436,7 @@ Navigator::run()\n \t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_s::VEHICLE_CMD_RESULT_ACCEPTED);\n \n \t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n-\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n+\t\t\t\tif (_mission.get_mission_status().valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n \t\t\t\t\tif (!_mission.set_current_offboard_mission_index(cmd.param1)) {\n \t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n \t\t\t\t\t}\n@@ -558,7 +558,7 @@ Navigator::run()\n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n \t\t\t_pos_sp_triplet_published_invalid_once = false;\n \n-\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n+\t\t\t_mission.set_execution_mode_normal();\n \t\t\tnavigation_mode_new = &_mission;\n \n \t\t\tbreak;\n@@ -586,7 +586,7 @@ Navigator::run()\n \n \t\t\t\t\t// if RTL is set to use a mission landing and mission has a planned landing, then use MISSION to fly there directly\n \t\t\t\t\tif (on_mission_landing() && !get_land_detected()->landed) {\n-\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n+\t\t\t\t\t\t_mission.set_execution_mode_fast_forward();\n \t\t\t\t\t\tnavigation_mode_new = &_mission;\n \n \t\t\t\t\t} else {\n@@ -598,7 +598,7 @@ Navigator::run()\n \t\t\t\tcase RTL::RTL_MISSION:\n \t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n \t\t\t\t\t\t// the mission contains a landing spot\n-\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n+\t\t\t\t\t\t_mission.set_execution_mode_fast_forward();\n \n \t\t\t\t\t\tif (_navigation_mode != &_mission) {\n \t\t\t\t\t\t\tif (_navigation_mode == nullptr) {\n@@ -621,10 +621,10 @@ Navigator::run()\n \n \t\t\t\t\t} else {\n \t\t\t\t\t\t// fly the mission in reverse if switching from a non-manual mode\n-\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_REVERSE);\n+\t\t\t\t\t\t_mission.set_execution_mode_reverse();\n \n \t\t\t\t\t\tif ((_navigation_mode != nullptr && (_navigation_mode != &_rtl || _mission.get_mission_changed())) &&\n-\t\t\t\t\t\t    (! _mission.get_mission_finished()) &&\n+\t\t\t\t\t\t    (!_mission.get_mission_finished()) &&\n \t\t\t\t\t\t    (!get_land_detected()->landed)) {\n \t\t\t\t\t\t\t// determine the closest mission item if switching from a non-mission mode, and we are either not already\n \t\t\t\t\t\t\t// mission mode or the mission waypoints changed.\n@@ -730,10 +730,15 @@ Navigator::run()\n \t\t\t//\n \t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n \t\t\t//        this general reset here.\n-\t\t\tif (!(_navigation_mode == &_takeoff &&\n-\t\t\t      navigation_mode_new == &_loiter)) {\n+\t\t\tif (!(_navigation_mode == &_takeoff && navigation_mode_new == &_loiter)) {\n+\n \t\t\t\treset_triplets();\n \t\t\t}\n+\n+\t\t\t_navigator_status.failure = false;\n+\t\t\t_navigator_status.finished = false;\n+\n+\t\t\t_navigator_status_updated = true;\n \t\t}\n \n \t\t_navigation_mode = navigation_mode_new;\n@@ -767,9 +772,9 @@ Navigator::run()\n \t\t\t_pos_sp_triplet_updated = false;\n \t\t}\n \n-\t\tif (_mission_result_updated) {\n-\t\t\tpublish_mission_result();\n-\t\t\t_mission_result_updated = false;\n+\t\tif (_navigator_status_updated) {\n+\t\t\tpublish_navigator_status();\n+\t\t\t_navigator_status_updated = false;\n \t\t}\n \n \t\tperf_end(_loop_perf);\n@@ -1181,24 +1186,19 @@ int navigator_main(int argc, char *argv[])\n }\n \n void\n-Navigator::publish_mission_result()\n+Navigator::publish_navigator_status()\n {\n-\t_mission_result.timestamp = hrt_absolute_time();\n+\t_navigator_status.timestamp = hrt_absolute_time();\n \n \t/* lazily publish the mission result only once available */\n-\tif (_mission_result_pub != nullptr) {\n+\tif (_navigator_status_pub != nullptr) {\n \t\t/* publish mission result */\n-\t\torb_publish(ORB_ID(mission_result), _mission_result_pub, &_mission_result);\n+\t\torb_publish(ORB_ID(navigator_status), _navigator_status_pub, &_navigator_status);\n \n \t} else {\n \t\t/* advertise and publish */\n-\t\t_mission_result_pub = orb_advertise(ORB_ID(mission_result), &_mission_result);\n+\t\t_navigator_status_pub = orb_advertise(ORB_ID(navigator_status), &_navigator_status);\n \t}\n-\n-\t/* reset some of the flags */\n-\t_mission_result.item_do_jump_changed = false;\n-\t_mission_result.item_changed_index = 0;\n-\t_mission_result.item_do_jump_remaining = 0;\n }\n \n void\n@@ -1216,11 +1216,11 @@ Navigator::publish_geofence_result()\n }\n \n void\n-Navigator::set_mission_failure(const char *reason)\n+Navigator::set_navigator_failure(const char *reason)\n {\n-\tif (!_mission_result.failure) {\n-\t\t_mission_result.failure = true;\n-\t\tset_mission_result_updated();\n+\tif (!_navigator_status.failure) {\n+\t\t_navigator_status.failure = true;\n+\t\tset_navigator_status_updated();\n \t\tmavlink_log_critical(&_mavlink_log_pub, \"%s\", reason);\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_mode.cpp": {
        "filename": "src/modules/navigator/navigator_mode.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -57,8 +57,8 @@ NavigatorMode::run(bool active)\n \tif (active) {\n \t\tif (!_active) {\n \t\t\t/* first run, reset stay in failsafe flag */\n-\t\t\t_navigator->get_mission_result()->stay_in_failsafe = false;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->get_navigator_status()->stay_in_failsafe = false;\n+\t\t\t_navigator->set_navigator_status_updated();\n \t\t\ton_activation();\n \n \t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Fnavigator_mode.cpp"
      },
      "src/modules/navigator/rcloss.cpp": {
        "filename": "src/modules/navigator/rcloss.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -114,8 +114,8 @@ RCLoss::set_rcl_item()\n \n \tcase RCL_STATE_TERMINATE: {\n \t\t\t/* Request flight termination from the commander */\n-\t\t\t_navigator->get_mission_result()->flight_termination = true;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->get_navigator_status()->flight_termination = true;\n+\t\t\t_navigator->set_navigator_status_updated();\n \t\t\twarnx(\"rc not recovered: request flight termination\");\n \t\t\tpos_sp_triplet->previous.valid = false;\n \t\t\tpos_sp_triplet->current.valid = false;\n@@ -151,8 +151,8 @@ RCLoss::advance_rcl()\n \t\t\twarnx(\"RC loss, OBC mode, slip loiter, terminate\");\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"rc loss, terminating\");\n \t\t\t_rcl_state = RCL_STATE_TERMINATE;\n-\t\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n-\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->get_navigator_status()->stay_in_failsafe = true;\n+\t\t\t_navigator->set_navigator_status_updated();\n \t\t\treset_mission_item_reached();\n \t\t}\n \n@@ -162,8 +162,8 @@ RCLoss::advance_rcl()\n \t\t_rcl_state = RCL_STATE_TERMINATE;\n \t\twarnx(\"time is up, no RC regain, terminating\");\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RC not regained, terminating\");\n-\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t\t_navigator->get_navigator_status()->stay_in_failsafe = true;\n+\t\t_navigator->set_navigator_status_updated();\n \t\treset_mission_item_reached();\n \t\tbreak;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Frcloss.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -258,6 +258,9 @@ RTL::set_rtl_item()\n \t\t\t} else {\n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n \t\t\t\tmavlink_and_console_log_info(_navigator->get_mavlink_log_pub(), \"RTL: completed, loitering\");\n+\n+\t\t\t\t_navigator->get_navigator_status()->finished = true;\n+\t\t\t\t_navigator->set_navigator_status_updated();\n \t\t\t}\n \n \t\t\tbreak;\n@@ -283,6 +286,10 @@ RTL::set_rtl_item()\n \tcase RTL_STATE_LANDED: {\n \t\t\tset_idle_item(&_mission_item);\n \t\t\tset_return_alt_min(false);\n+\n+\t\t\t_navigator->get_navigator_status()->finished = true;\n+\t\t\t_navigator->set_navigator_status_updated();\n+\n \t\t\tbreak;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "patch": "@@ -61,9 +61,9 @@ Takeoff::on_active()\n \t\t// reset the position\n \t\tset_takeoff_position();\n \n-\t} else if (is_mission_item_reached() && !_navigator->get_mission_result()->finished) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n+\t} else if (is_mission_item_reached() && !_navigator->get_navigator_status()->finished) {\n+\t\t_navigator->get_navigator_status()->finished = true;\n+\t\t_navigator->set_navigator_status_updated();\n \n \t\t// set loiter item so position controllers stop doing takeoff logic\n \t\tset_loiter_item(&_mission_item);\n@@ -120,8 +120,7 @@ Takeoff::set_takeoff_position()\n \n \t// set current mission item to takeoff\n \tset_takeoff_item(&_mission_item, abs_altitude);\n-\t_navigator->get_mission_result()->finished = false;\n-\t_navigator->set_mission_result_updated();\n+\t_navigator->set_navigator_status_updated();\n \treset_mission_item_reached();\n \n \t// convert mission item to current setpoint",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2afce0aa8591724b0f41e1d174875c2c0f68f4ef/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "GpsFailure::set_gpsf_item",
        "Mission::index_closest_mission_item",
        "Land::on_active",
        "RCLoss::advance_rcl",
        "Mission::landing",
        "set_mission_result_updated",
        "NavigatorMode::run",
        "Mission::on_active",
        "Mission::read_mission_item",
        "Mission::on_inactive",
        "Mission::on_activation",
        "MissionFeasibilityChecker::checkMissionFeasible",
        "Land::on_activation",
        "set_mission_failure",
        "checkDistancesBetweenWaypoints",
        "MissionFeasibilityChecker::checkDistancesBetweenWaypoints",
        "MissionFeasibilityChecker::checkDistanceToFirstWaypoint",
        "RCLoss::set_rcl_item",
        "checkHomePositionAltitude",
        "Navigator::publish_geofence_result",
        "RTL::set_rtl_item",
        "MissionBlock::is_mission_item_reached",
        "Mission::advance_mission",
        "publish_mission_result",
        "checkDistanceToFirstWaypoint",
        "Takeoff::set_takeoff_position",
        "Mission::prepare_mission_items",
        "Mission::set_execution_mode",
        "Mission::check_mission_valid",
        "MissionFeasibilityChecker::checkGeofence",
        "MissionFeasibilityChecker::checkHomePositionAltitude",
        "Navigator::run",
        "increment_mission_instance_count",
        "Mission::report_do_jump_mission_changed",
        "Takeoff::on_active",
        "DataLinkLoss::set_dll_item",
        "Mission::update_offboard_mission",
        "DataLinkLoss::advance_dll",
        "Mission::set_mission_items"
      ],
      "by_file": {
        "src/modules/navigator/datalinkloss.cpp": [
          "DataLinkLoss::advance_dll",
          "DataLinkLoss::set_dll_item"
        ],
        "src/modules/navigator/gpsfailure.cpp": [
          "GpsFailure::set_gpsf_item"
        ],
        "src/modules/navigator/land.cpp": [
          "Land::on_activation",
          "Land::on_active"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::on_active",
          "Mission::read_mission_item",
          "Mission::index_closest_mission_item",
          "Mission::on_inactive",
          "Mission::advance_mission",
          "Mission::on_activation",
          "Mission::report_do_jump_mission_changed",
          "Mission::prepare_mission_items",
          "Mission::landing",
          "Mission::set_execution_mode",
          "Mission::update_offboard_mission",
          "Mission::check_mission_valid",
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding",
          "MissionFeasibilityChecker::checkHomePositionAltitude",
          "MissionFeasibilityChecker::checkMissionFeasible",
          "MissionFeasibilityChecker::checkDistancesBetweenWaypoints",
          "MissionFeasibilityChecker::checkGeofence",
          "MissionFeasibilityChecker::checkDistanceToFirstWaypoint"
        ],
        "src/modules/navigator/mission_feasibility_checker.h": [
          "checkDistanceToFirstWaypoint",
          "checkHomePositionAltitude",
          "checkDistancesBetweenWaypoints"
        ],
        "src/modules/navigator/navigator.h": [
          "publish_mission_result",
          "set_mission_result_updated",
          "increment_mission_instance_count",
          "set_mission_failure"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_geofence_result",
          "Navigator::run"
        ],
        "src/modules/navigator/navigator_mode.cpp": [
          "NavigatorMode::run"
        ],
        "src/modules/navigator/rcloss.cpp": [
          "RCLoss::advance_rcl",
          "RCLoss::set_rcl_item"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active",
          "Takeoff::set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "Mission feasibility checker remove 2/3rds distance warnings that don't reject a mission",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9743",
    "number": 9743,
    "created_at": "2018-06-22T15:04:55Z",
    "merged": true,
    "merged_at": "2018-06-23T14:39:23Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "Could we review the need for these mission feasibility distance warnings? In practice they can be problematic.\n\n![image](https://user-images.githubusercontent.com/84712/41783807-cf8db7c0-760b-11e8-9718-e162f3b479e1.png)\n\nDo we even need these warnings PX4 side? I think of the mission feasibility checker as the last line of defence for loading something bogus. If we also want it to return helpful warnings it needs a better interface.",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-06-23T13:12:35Z",
          "body": "Yes, we need them. Mostly because people are stupid and produce fly-aways by â€œfat finger planningâ€.\r\n\r\nTime again for the events interface discussion.\r\n\r\nIn the meantime I would just increase the distance considerably. Most of the times people hit a completely wrong location many miles away, not something close. That is what we want to prevent.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-23T13:39:34Z",
          "body": "Actually I'm only talking specifically about the warnings that are 2/3rds of the error. I don't have a problem with the feasibility checker rejecting a mission that actually exceeds the parameter value. What I don't see is the value in a mavlink critical warning when the mission is still going to be accepted.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-06-23T14:21:26Z",
          "body": "Fair!",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-23T14:39:29Z",
          "body": "Thanks for the review.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR removes/moves warning notifications (2/3 distance warnings) that do not change mission acceptance. This is a UX/notification policy change rather than a bug in the mission-feasibility algorithm or state transition â€” the core logic that rejects invalid missions remains intact. It addresses confusing/undesired messages but not an incorrect computation or program state, so it is not a classic logic error fix.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 19,
        "changes": 20,
        "patch": "@@ -497,14 +497,6 @@ MissionFeasibilityChecker::checkDistanceToFirstWaypoint(const mission_s &mission\n \n \t\tif (dist_to_1wp < max_distance) {\n \n-\t\t\tif (dist_to_1wp > ((max_distance * 2) / 3)) {\n-\t\t\t\t/* allow at 2/3 distance, but warn */\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n-\t\t\t\t\t\t     \"First waypoint far away: %d meters.\", (int)dist_to_1wp);\n-\n-\t\t\t\t_navigator->get_mission_result()->warning = true;\n-\t\t\t}\n-\n \t\t\treturn true;\n \n \t\t} else {\n@@ -557,17 +549,7 @@ MissionFeasibilityChecker::checkDistancesBetweenWaypoints(const mission_s &missi\n \t\t\t\t\tmission_item.lat, mission_item.lon,\n \t\t\t\t\tlast_lat, last_lon);\n \n-\t\t\tif (dist_between_waypoints < max_distance) {\n-\n-\t\t\t\tif (dist_between_waypoints > ((max_distance * 2) / 3)) {\n-\t\t\t\t\t/* allow at 2/3 distance, but warn */\n-\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n-\t\t\t\t\t\t\t     \"Distance between waypoints very far: %d meters.\", (int)dist_between_waypoints);\n-\n-\t\t\t\t\t_navigator->get_mission_result()->warning = true;\n-\t\t\t\t}\n-\n-\t\t\t} else {\n+\t\t\tif (dist_between_waypoints > max_distance) {\n \t\t\t\t/* item is too far from home */\n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n \t\t\t\t\t\t     \"Distance between waypoints too far: %d meters, %d max.\",",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ae33e6b9d578251085d4b9e50fc70e372dd137e6/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkDistanceToFirstWaypoint",
        "MissionFeasibilityChecker::checkDistancesBetweenWaypoints"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkDistanceToFirstWaypoint",
          "MissionFeasibilityChecker::checkDistancesBetweenWaypoints"
        ]
      }
    }
  },
  {
    "title": "Fixed-wing autoland improvements",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9698",
    "number": 9698,
    "created_at": "2018-06-16T11:02:49Z",
    "merged": true,
    "merged_at": "2018-08-24T14:13:08Z",
    "state": "closed",
    "conversation": {
      "author": "philipoe",
      "body": "Fixed-wing autoland seems quite suboptimal at the moment. We have had very mixed results during flight tests so far, i.e. while on small foamy-like platforms or when landing on huge runways you may not have any issues, on short-field landings with larger and more complex (e.g. different flap configurations, wide airspeed range) platforms in challenging environments you will definitely see the shortcomings of the current autoland. This PR therefore introduces some improvements:\n\n### Improvements\n\n1. **Airplane landing configuration activated during loiter down (commit 2448863)**\n_Issue_: The landing configuration (i.e. setting the flaps and changing the airspeed from nominal to landing speed) was previously performed only when entering the final approach, i.e. at relatively low altitude above ground (15m is a good rule). In our flight tests, the flap and airspeed changes caused huge altitude errors (+5m), and the aircraft corrected by pitching down significantly and nearly slamming into the ground (alos because the integrators can wind up). This is extremely unsafe. _Solution_: The mode change (flaps, airspeed) is now performed when approaching the loiter-down WP, i.e. usually at much higher altitude of 50m+. The discontinuity is of course still there, but it happens at an altitude where it is safe and the controller (especially the integrators) still have plenty of time to adapt to this new configuration.\n\n2. **Separate and tigther gains for landing (commit 2448863)**\n_Issue_: To avoid motor wear and to allow a good flight efficiency, one usually wants to somewhat relax the TECS throttle time constant (FW_T_THRO_CONST). However, the alt/airspeed control may then not accurate enough for landings anymore. _Solution_: Introduced a throttle time constant scaling factor which is ONLY activated during landings (and loiter-down-to-landing) and is 100% by default such that it doesnt make a difference by default. Note that I am still debating a bit whether we should introduce even more landing-specific parameters (for example, the pitch setpoint offset FW_PSP_OFF changes quite a lot with flaps on our platform), but tried to reduce the amount of additional parameters in this PR. Any thoughts on that?\n\n3. **Tighter altitude acceptance radius for landings (commit https://github.com/PX4/Firmware/commit/d8cc40c67c521ef35cf74d41ee28b7adb8fe0c11)**\n_Issue_: Currently, the final decision on whether to enter the landing approch or not uses the standard altitude acceptance radius parameter for fixed wings (see [here](https://github.com/PX4/Firmware/blob/master/src/modules/navigator/mission_block.cpp#L255). This parameter is 10m by default, and we often set it to 20m because at higher altitudes it just does not matter. This is however not accurate enough for autolandings: Imagine you want to enter the landing approach at hAGL=15m, then the plane would still initiate the autoland at hAGL=5m...25m. Very unsafe and potentially not even feasible for the plane due to sink/climb rate constraints! _Solution_: A \"relative\" altitude acceptance radius, i.e. we assume a 30% error w.r.t. the remaining altitude difference to the landing waypoint can still be handled by the plane. Assuming hLandingApproach=15m, this means 4.5m of altitude acceptance radius. We of course constrain the altitude acceptance radius (see code).\n\n4. **ALWAYS flare when close to the ground (commit https://github.com/PX4/Firmware/commit/02e380af538ea8ef80a433da8fa63f63ed7601fb)**\n_Issue_: During previous flight testing, we were surprised to _sometimes_ see nice flares from the aircraft and sometimes not (i.e. the aircraft just impacted the ground with nominal sink speed of 0.5-0.8m/s). We always thought it is a tuning issue, but turns out it is also because the airplane _only_ flares when it is horizontally close enough to the landing waypoint. This can a) mean that the aircraft (e.g. simply due to errors in the altitude control) never really flares or b) that it will always flare at different altitudes AGL, so the impact velocity is always different. _Solution_: ALWAYS flare when close to the ground, thus guaranteeing a smooth landing in all cases. Note that the motor still _only_ shuts off when we are close to the land WP such that, e.g. if a downdraft pushed the aircraft too close to the ground, the aircraft still continues to fight that downdraft using the motor.\n\n### Notes\n - These are simple effective fixes that make autoland better without changing its overall structure. I know it can be improved a lot, but I think implementing these improvements as a first-shot solution is very important.\n - This was discussed with @dagar already. @priseborough @tstastny @LorenzMeier I am looking for feedback on why the changes I propose would NOT be suitable/better than the current implementation (or what could be improved quickly and effectively without changing the overall code too much)\n - Tested extensively in HIL already, i.e. that all mode changes and parameter changes work. The final tests (both HIL + flight testing) will be performed after feedback from you guys and the respective code changes.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-06-16T14:52:38Z",
          "body": "@antiheavy FYI",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-16T15:14:49Z",
          "body": "Some great ideas here.  We do a lot of fixed wing landings with our 2kg class flying wing and would be excited to test some of this.  Here are some initial comments:\r\n\r\n\r\n\r\n> Airplane landing configuration activated during loiter down\r\n\r\nI couldn't tell how this works from your code link.  My concern is how are you handling generic landing pattern use cases beyond the QGC built in landing pattern?  For example, people often manually plan a box-type landing pattern with traditional downwind, base, and final approach segments, they might place additional waypoints along the way to control the altitude, and place a DoLandStart command and the front of this to define it as the landing pattern in the mission. \r\n\r\nAlternate approaches to the \"integrators fighting flaps problem\" might include:\r\n- a slew rate parameter to slow down flap deployment allowing time for the integrators to adjust, this has the added benefit of allowing the roll integrator time to adjust to inadvertent differential flap deployment rates too.\r\n- a feed-forward type parameter for the pitch offset similar to what you mentioned.\r\n\r\n\r\n\r\n> Separate and tigther gains for landing\r\n\r\nYes!  I think something along these lines would be of great benefit to manage landing energy.  Might also consider some soft of pitch gain and maybe roll gain scaling. \r\n\r\n\r\n\r\n\r\n> Tighter altitude acceptance radius for landings\r\n\r\nI like the goal here, but I have concerns on the implementation.\r\n\r\nDo I correctly understand that the hard coded 30% value will be constrained to not exceed NAV_FW_ALT_RAD?  I think it is important that the hard coded 30% value doesn't inadvertently exceed the normal waypoint acceptance distances.\r\n\r\nMy bigger concern here is what is the behavior if the altitude is missed?  does the vehicle do a turn-around to try to get back to the waypoint? This could be very bad in the case where someone has placed a waypoint to start the final descent at low altitude very close to the Land waypoint (below trees, etc).  I see that you hard coded a 3m minimum, but even that is very difficult for most fixed wings to actually achieve.  I'm not sure the right answer here, but maybe instead of hard coding 30% there should be a separate parameter for landing approach WP vertical error, different from NAV_FW_ALT_RAD?\r\n\r\n\r\n\r\n> ALWAYS flare when close to the ground\r\n\r\nI agree we should get rid of the distance from land waypoint thing for Flare.  However, I'm unsure about the throttle piece you've added.  There is already a FW_LND_TLALT parameter which I feel should be respected no matter what (e.g. we don't want throttle kicking in when very close to the ground in case of propeller strike, etc).",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-17T00:06:45Z",
          "body": "@dagar @antiheavy thanks for your feedback! I adapted the code, see the comments. Answers to some remaining questions below.\r\n\r\n>>Airplane landing configuration activated during loiter down\r\n\r\n>I couldn't tell how this works from your code link. My concern is how are you handling generic landing pattern use cases beyond the QGC built in landing pattern? For example, people often manually plan a box-type landing pattern with traditional downwind, base, and final approach segments, they might place additional waypoints along the way to control the altitude, and place a DoLandStart command and the front of this to define it as the landing pattern in the mission.\r\n\r\nGeneric landing patterns which do NOT involve a LOITER_TO_ALT waypoint before the final approach are handled exactly as before. So they still work, but do not profit from improvement 1 (like activating flaps + different airspeed earlier) in this PR. Two potential solutions:\r\n\r\n1. Just check whether the next_wp is a NAV_LAND WP independently of whether the curr_wp is a LOITER_TO_ALT WP. I am a bit concerned about cases like curr_wp=takeoff and next_wp=land however. So one would need to really carefully look for potentially dangerous corner cases.\r\n2. Alternatively, one could use the DO_LAND_START mission item to trigger the landing configuration. However, this is a mission item that is only known to NAVIGATOR (as far as i know), so we cannot handle this in the FixedWingPositionControl. And even _if_ we had the DO_LAND_START information where we need it, the question is still: What happens if a user forgets to set a DO_LAND_START mission item -> The same as if he does not use the LOITER_TO_ALT waypoint, i.e. the landing is still going to work but is not going to benefit from the improvements above.\r\n\r\n_General note:_ I really feel like a loiter-to-alt is _the_ waypoint type to use before an approach because it guarantees that _both_ your altitude _and_ heading are perfectly (within the acceptance tolerances of course) aligned with the landing approach. We also used the \"downwind, base...\" approaches before but always placed a loiter-to-alt (just a semi-circle, which does not even need to involve altitude changes btw.) directly before the landing approach because of the advantages mentioned above. \r\n\r\n>Alternate approaches to the \"integrators fighting flaps problem\" might include: a slew rate parameter to slow down flap deployment allowing time for the integrators to adjust, this has the added benefit of allowing the roll integrator time to adjust to inadvertent differential flap deployment rates too.\r\n\r\nDepends. If you start flap deployment at the same time as before (i.e. when entering the landing approach) but just deploy the flaps slower, then this is actually worse because you are shifting the time when the flaps are fully deployed even closer to the ground. So doing these configuration changes as early as possible is the way to go (unless you have a model-predictive controller or similar feed forwards).\r\n\r\n\r\n>>Tighter altitude acceptance radius for landings\r\n\r\n>I like the goal here, but I have concerns on the implementation. Do I correctly understand that the hard coded 30% value will be constrained to not exceed NAV_FW_ALT_RAD? I think it is important that the hard coded 30% value doesn't inadvertently exceed the normal waypoint acceptance distances.\r\n\r\nCorrect.\r\n\r\n> My bigger concern here is what is the behavior if the altitude is missed? does the vehicle do a turn-around to try to get back to the waypoint? This could be very bad in the case where someone has placed a waypoint to start the final descent at low altitude very close to the Land waypoint (below trees, etc). I see that you hard coded a 3m minimum, but even that is very difficult for most fixed wings to actually achieve. I'm not sure the right answer here, but maybe instead of hard coding 30% there should be a separate parameter for landing approach WP vertical error, different from NAV_FW_ALT_RAD?\r\n\r\nWith the QGC fixed-wing landing pattern (or a manually-set loiter-to-alt WP) the vehicle just does one other turn in the loiter circle. This is perfectly safe. For a standard waypoint, the airplane may turn back to track that WP, yes. But again, standard WPs don't seem optimal for me there: If you don't hit the altitude acceptance, then the airplane will do crazy stuff, so you have to set a large NAV_FW_ALT_RAD to avoid this -> This then however means that the landing approach altitude is potentially very inaccurate, which is again unsafe. So it's _only_ a tradeoff between two potentially dangerous situations! The much cleaner way is to use loiter-to-alt WPs. Still, i could of course also live with using an additional landing-altitude-acceptance-radius parameter (the disadvantage there concerns the _scale_ of your problem: So say for a landing approach from 15m AGL a 5m altitude acceptance radius might be fine, but if you then land from 100m AGL then 5m altitude acceptance radius is overly tight because your vehicle could easily compensate for say up to 30m altitude error during the landing approach -> This is exactly the reason for using the 30% relative acceptance altitude). Maybe @dagar can comment on what general Pixhawk fixed-wing users would prefer?\r\n\r\n>>ALWAYS flare when close to the ground\r\n\r\n> I agree we should get rid of the distance from land waypoint thing for Flare. However, I'm unsure about the throttle piece you've added. There is already a FW_LND_TLALT parameter which I feel should be respected no matter what (e.g. we don't want throttle kicking in when very close to the ground in case of propeller strike, etc).\r\n\r\nI did not change the throttle behavior at all! The limitation that throttle is NOT being cut off by the autoland logic when we are too far way from the waypoint was already there before, and i somewhat understand the reason for having it there: Of course, there is a certain risk of a propeller strike close to the ground, but if you deactivate that throttle too early you might not only loose your propeller but your whole plane. There is the tradeoff again ;) Note that the land-detector will shut down the throttle _after_ landing, so at least that is somewhat safe.",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-18T17:37:45Z",
          "body": "@philipoe A couple more questions:\r\n\r\n1) what happens if the vehicle flies very high/long past the Land waypoint, but has not yet begun to flare?  Will the flare still happen?  How will throttle behave in this scenario?\r\n\r\n2) Do I understand the following statement correctly? \r\n - \"A tighter exit criteria tolerance of 30% of the landing height applies only in the case when there is a Loiter-to-Alt waypoint followed by a Land waypoint?  This is limited between 3 meters and NAV_FW_ALT_RAD\"\r\nIf so, I think that is okay as long as that special case gets documented appropriately.",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-18T19:51:22Z",
          "body": "> what happens if the vehicle flies very high/long past the Land waypoint, but has not yet begun to flare? Will the flare still happen? How will throttle behave in this scenario?\r\n\r\nIf you pass the landing waypoint at an altitude that is much higher than FW_LND_FLALT, then, just as before, it is not going flare above the landing WP but only later should it descend to FW_LND_FLALT. Of course externally there might be some go-around logic that triggers, i'd need to check that later.\r\n\r\n> \"A tighter exit criteria tolerance of 30% of the landing height applies only in the case when there is a Loiter-to-Alt waypoint followed by a Land waypoint? This is limited between 3 meters and NAV_FW_ALT_RAD\"\r\nIf so, I think that is okay as long as that special case gets documented appropriately.\r\n\r\nNo, as it is implemented right now this tighter acceptance radius applies for _every_ waypoint type which is followed by a NAV_LAND waypoint type. This can of course be changed. But where do you see the advantage of using standard WPs instead of loiter-to-alt WPs (or: The QGC standard fixed-wing landing pattern)? I guess the question we had before, i.e. whether to use either the relative \"30% of the remaining descent altitude\" rule or introducing a separate parameter is another question for @dagar .",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-18T20:56:23Z",
          "body": "> as it is implemented right now this tighter acceptance radius applies for every waypoint type which is followed by a NAV_LAND waypoint\r\n\r\nAh, well my concern here is exactly what you said previously: \"...If you don't hit the altitude acceptance, then the airplane will do crazy stuff...\".   I like your tighter criteria when using loiter-to-alt waypoints prior to NAV_LAND because, as you pointed out, it we behave predictably and safely.  I'm concerned about the use case when a normal waypoint is used prior to NAV_LAND and the vehicle may not behave predictably and safely.\r\n\r\n\r\n\r\n> where do you see the advantage of using standard WPs instead of loiter-to-alt WPs\r\n\r\nWhen landing in areas that have rows of trees, power lines, or other challenges that do not allow good use of the standard QGC Landing Pattern.  We use the standard QGC landing pattern 95% of the time, but we also need safe and predictable landing behavior for the cases when we need to use Box patterns or custom patterns to avoid trees, etc.",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-18T21:01:25Z",
          "body": "> When landing in areas that have rows of trees, power lines, or other challenges that do not allow good use of the standard QGC Landing Pattern. We use the standard QGC landing pattern 95% of the time, but we also need safe and predictable landing behavior for the cases when we need to use Box patterns or custom patterns to avoid trees, etc.\r\n\r\nWhich means that you define safe as \"do not do crazy maneuvers in the horizontal direction\", but you do not care as much (or have a platform that has a lot of robustness) about the vertical direction, right?",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-18T21:05:25Z",
          "body": "> Which means that you define safe as \"do not do crazy maneuvers in the horizontal direction\", but you do not care as much (or have a platform that has a lot of robustness) about the vertical direction, right?\r\n\r\ncorrect.  I mean, of course I would want both, but horizontal/lateral variability is worse than vertical/longitudinal variability.",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-18T21:26:06Z",
          "body": "> correct. I mean, of course I would want both, but horizontal/lateral variability is worse than vertical/longitudinal variability.\r\n\r\nOK, i feel like handling all waypoint types before a NAV_LAND wp the same is more important than saving one parameter and having this \"dynamic\" calculation ... so if @dagar has nothing against that I will introduce a separate land altitude acceptance parameter that is then going to apply to every single landing approach. ",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-19T00:50:24Z",
          "body": "@philipoe is there a thought that maybe loiter-to-alt waypoints could have a tighter altitude acceptance than normal waypoints in general?  I mean they are special in the way that their altitude is a specific part of what they are.\r\n\r\nAlternately, what if you kept the dynamic calculation and improved the fixed wing behavior if the vehicle missed a normal waypoint?  e.g. auto-abort the landing?  I generally dislike auto-aborted landings, but that would be better than \"do crazy things\" in this case.\r\n\r\nI really like your goal here, and I would totally use a dynamic tighter acceptance criteria for our loiter-to-alt landings if the safe behavior problem with other waypoints could be solved.\r\n\r\nEven if you make a separate vertical tolerance parameter for the waypoint before the NAV_LAND, we will need to set that tolerance large because the behavior will still be bad if a normal waypoint is used and it misses.",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-19T04:23:04Z",
          "body": "What happens in instances where the setup is for flaps trigger airbrakes (ailerons)? Thatâ€™s how we have it set up and my concern would be if you are not able segregate only the flaps (which I believe is currently the case), youâ€™d inadvertently end up with crow being deployed which would be a problem at any altitude given the added drag. Ran into this on full wing flaps (which also could be something great for landing very slowly [or heavy]). \r\n\r\nReally like what youâ€™ve done here. We have planes flying autoland flights daily and while it works well as is, more granularity to tune further or even more so having something more robust is great. Weâ€™ll get testing on this soon and we definitely see the pitch up when flaps are deployed. ",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-20T17:50:52Z",
          "body": "> Alternately, what if you kept the dynamic calculation and improved the fixed wing behavior if the vehicle missed a normal waypoint? e.g. auto-abort the landing? I generally dislike auto-aborted landings, but that would be better than \"do crazy things\" in this case. I really like your goal here, and I would totally use a dynamic tighter acceptance criteria for our loiter-to-alt landings if the safe behavior problem with other waypoints could be solved.\r\n\r\nOptimizing the behavior after the waypoint was reached can be quite involved. I therefore disabled the dynamic acceptance radius calculation again and introduced a separate altitude-acceptance-before-landing parameter (NAV_FW_ALTL_RAD). This should solve your issues as it gives you full configurability for your autolands.\r\n\r\n>What happens in instances where the setup is for flaps trigger airbrakes (ailerons)? Thatâ€™s how we have it set up and my concern would be if you are not able segregate only the flaps (which I believe is currently the case), youâ€™d inadvertently end up with crow being deployed which would be a problem at any altitude given the added drag. Ran into this on full wing flaps (which also could be something great for landing very slowly [or heavy]).\r\n\r\nThe flaps (and thus your drag-producing airbrakes) will _only_ trigger earlier with this PR _if_ you use a loiter-to-alt WP before the landing. Given that loiter-to-alt is effectively used to burn your excess altitude the additional drag should not matter. Standard WPs before a landing will not trigger your airbrakes, so you won't have a problem.\r\n\r\n@Antiheavy @ryanjAA @dagar Is this OK with the last fixes/commits that I made or is there any concerns left on your side? If so, then i will do extensive testing tomorrow, you guys could then also test if you like and we can then merge afterwards.",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-20T18:17:10Z",
          "body": "@philipoe just so i'm clear, loiter to alt would also include (or basically also is) fixed wing landing pattern? We have to enable airbrakes and keep them quite highly engaged (lots of drag) to simply slow down so we cant fly with them on, full throttle I suppose might keep it there in calm conditions but it really is like throwing a drag chute out the back when they activate. Maybe we are an edge case scenario but any high aspect ratio wing that inherently will tip stall makes me worry about inducing that much drag while banking. I am worried about either that or having tecs have to near full throttle it to keep it in the air to then shut it back down quickly (ramp up and down). Again, might work in calm conditions but we'd essentially be eliminating the available power overhead budget for windy situations if near full throttle due to airbrakes out. Yesterday comes to mind, we were flying in 12-15 m/s winds and on the landing pattern, there was plenty of overhead to speed up in a hurry during pattern land but remove that ability and now we're close to the ground and going to have a much higher probability of not being able to avoid a stall.\r\n\r\nDon't get me wrong, i really like this since we spend the vast majority of the time setting and testing autolanding up under different scenarios, I'm just trying to highlight some issues I can see. I think we need to simply segregate the _att_sp.apply_flaps = true flag from putting on the airbrakes which will also take some thought on the mixer side of things but overall, if people are always stuck with flaps and airbrakes then more creative things like you're doing are going to have potential unforeseen flaws.\r\n\r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-20T19:43:56Z",
          "body": "> @philipoe just so i'm clear, loiter to alt would also include (or basically also is) fixed wing landing pattern? \r\n\r\nWhen we talk about QGC, then fixed-wing landing pattern = 1) loiter-to-alt + 2)landing waypoint.\r\n\r\n> We have to enable airbrakes and keep them quite highly engaged (lots of drag) to simply slow down so we cant fly with them on, full throttle I suppose might keep it there in calm conditions but it really is like throwing a drag chute out the back when they activate. Maybe we are an edge case scenario but any high aspect ratio wing that inherently will tip stall makes me worry about inducing that much drag while banking.\r\n\r\nI am not sure i completely understand what the problem is: You are saying that in straight level flight (i.e. during the landing approach) you are not afraid of stalling, right? But then you are saying that you are afraid to bank. You are aware that the fixed-wing controller automatically increases the airspeed reference depending on your bank angle, see [this code](https://github.com/PX4/Firmware/blob/master/src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp#L853) ? You are also saying you would need throttle to keep your airspeed when the airbrakes are out due to the drag, but the great thing in the loiter-to-alt (=down) mode is that you don't even need throttle but will keep your airspeed because you are descending anyways (and the sink rate can be configured of course). With all that said, maybe a video from your exact landing sequence would better help me to understand your approach/issues?\r\n\r\n> Don't get me wrong, i really like this since we spend the vast majority of the time setting and testing autolanding up under different scenarios, I'm just trying to highlight some issues I can see. I think we need to simply segregate the _att_sp.apply_flaps = true flag from putting on the airbrakes which will also take some thought on the mixer side of things but overall, if people are always stuck with flaps and airbrakes then more creative things like you're doing are going to have potential unforeseen flaws.\r\n\r\nOf course we can talk about separating flaps and airbrakes, but i personally wouldnt do this in this PR. Still, i dont fully understand _why_ you'd like to separate them right now, given that until now (i.e. during the landing approach) you have also always used them together, right? And as mentioned, flaps+airbrakes would then _only_ deploy in a loiter-to-alt waypoint, but in no other type of waypoint (apart from NAV_LAND as before).\r\n\r\nIf it helps, feel free to write me on slack...",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-20T20:16:31Z",
          "body": "I can write you on slack but essentially we have a high aspect ratio wing and the characteristics of any high aspect ratio wing are that they are prone to tip stalling (as you probably know) so during bank at reduced speeds (near stall/landing speed) that concern or even issue becomes very pronounced, ie less room for error. Slowing down in a straight line with even the hint of a stall is easily managed by tecs and pitch but the concern is not the code to increase speed, that works great, it's that when you're creating so much more drag, the true ability to quickly increase speed is diminished and you are close to the ground. Recovering is potentially not an option at that point. As for why to separate the flaps, because anything that forces on flaps and in many cases airbrakes as well is not ideal. I wouldn't deploy airbrakes ever until I have exited my loiter tangent to the landing waypoint. \r\n\r\nLanding sequence is pretty standard, fixed wing pattern then once exited flaps and airbrakes come on and we see nose up for a moment if pitch correction isnt set and then glide down. This is more about forcing one action actually forces two (flaps and airbrakes) and anything to hinder the ability to stay in the air is a concern and when that limit is power overhead which we are reduced due to increased drag essentially just limits what can be flown in safely or in edge cases if can even be used at all. The more I think about it the more it makes me think that the power system needs to be able to easily overcome drag forces but also raises the questions of what do having airbrakes out do aerodynamically when trying to bank which would be a concern since ailerons will already be deployed. Airbrakes really shouldn't come on until we are in a straight line.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-06-20T20:22:27Z",
          "body": "Gentlemen, to make this more efficient and fun how about you all join the next PX4 dev call and we will schedule time for this - yes?",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-20T20:23:53Z",
          "body": "Sounds good!",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-20T20:25:44Z",
          "body": "> Gentlemen, to make this more efficient and fun how about you all join the next PX4 dev call and we will schedule time for this - yes?\r\n\r\nI honestly think this is too much of a corner case to be of concern for the PX4 dev call. Also, this is in one week, right? I think we should solve this faster than that. Or am i misunderstanding anything? Skype or slack would be an alternative...",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-20T20:38:29Z",
          "body": "I think maybe my comment regarding high aspect ratio wings limits the scope and pushes things more specific to wings of that type but realistically even in the case of non high aspect ratio wings I wouldnt deploy airbrakes until lined up with the landing waypoint which I believe is the same in most full size planes (not all). I suppose the best fix is to either to be able to turn off the functionality or separate the flaps and airbrake call.",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-21T14:09:31Z",
          "body": "> Gentlemen, to make this more efficient and fun how about you all join the next PX4 dev call and we will schedule time for this - yes?\r\n\r\nRyan and myself discussed on slack yesterday, and we concluded that fixed-wing landings are so heavily aircraft configuration dependend that we basically need parameters to let the (pro-)user configure the landing process. \r\n\r\n@ryanjAA @Antiheavy I have included the parameter FW_LND_EARLYCFG which enables/disables the early use of the landing configuration (flaps+airspeed change) during the loiter down. Does anyone of you want to test this? Another testing feedback i'd be extremely interested in is whether choosing a different FW_PSP_OFF increases altitude tracking accuracy for your platforms during landing! Could you try to test this too? Of course the FW_INTEG_GAIN needs to be zero such that one can see the differences. For me, in our HIL model, having a different FW_PSP_OFF helps a lot during loiter down and landing (reduction of steady-state altitude tracking error by >50%, i.e. from 6m to <2m). I will also test this on our planes in the next days.",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-22T16:41:18Z",
          "body": "Yep - sounds great. Cool feature, will definitely try it out. We keep FW_PSP_OFF at 1 as knowing the true offset does help quite a lot (we could probably calculate for people/airframes that don't know it if set to 0, fly level and see if we are pitching up/down at cruise). FW_T_INTEG_GAIN is at 0.1 but will try at 0 and see.  ",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-27T13:30:01Z",
          "body": "Tested in flight, no issues. Also tested in HIL. GTM from my side.\r\n\r\n@ryanjAA @Antiheavy Tested on your side too and/or are you OK with merging this?",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2018-06-28T03:37:08Z",
          "body": "Good to know no issues on your end. I havenâ€™t tested yet. Enabled crow the other day and couldnâ€™t climb with full power so still a bit reluctant to rely on TECS stall code with our crow setting deployed. I know we wouldnâ€™t be ascending but still concerned some. Iâ€™ll try as soon as possible though. Will do it when we have some lower winds. ",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-28T08:18:01Z",
          "body": "Iâ€™m interested in testing either in SITL or flight test or both. Unfortunately I probably cannot get to it until after the 4th of July holiday as Iâ€™m out of the office until then.   The flare always and setting a slightly tighter altitude tolerance for the landing pattern are both of interest to us.  I also want to verify no change to landings speeds or other vehicle settings since we donâ€™t use flaps.  ",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-28T08:18:53Z",
          "body": "FYI @kjkinney",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-07-08T20:45:06Z",
          "body": "@Antiheavy Tested? We should merge relatively quickly if this is OK because other PRs relating to flap configuration are coming up (e.g. https://github.com/PX4/Firmware/pull/9858/files).",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-07-09T15:40:20Z",
          "body": "@philipoe I just returned from vacation today.  I will see if we can make a firmware build with this pulled in to flight test tomorrow.",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-07-11T13:38:55Z",
          "body": "@philipoe We test flew a build with this PR on our fixed wing (elevons+rudder) and didn't notice any negative effects.  I'll post logs later today once we've had a chance to review them in detail.",
          "type": "issue_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-07-11T19:32:40Z",
          "body": "Here is our flight testing log.  It is a short flight with two landing approaches with an abort in-between.  Everything looks nominal as far as I can tell.  We didn't excercise any of the new parameters.  Mostly just wanted to ensure the default settings didn't negatively impact our use case.  Take a look at let me know what you think.  Thanks!\r\n\r\nhttps://review.px4.io/plot_app?log=cb831133-4e76-4be7-806f-facac345cdb9",
          "type": "issue_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-07-11T22:28:36Z",
          "body": "Looks good/nominal! Thanks for testing! Seems like your airspeed sensor is still a bit off, and i also did not see any \"[Landing] Flaring\" and \"[Landing]: Killing throttle\" messages in your logged messages, but it might be that this is fine (did you see a flare+truttle cut off?) and these are only transmitted via telemetry... So overall good to merge @dagar  ?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-06-16T14:46:30Z",
          "body": "Maybe we should be doing this within TECS entirely? TECS internally already has modes which could be expanded as needed for LANDING. We shouldn't have to be continuously setting TECS parameters outside of normal parameter changes.",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-16T14:51:26Z",
          "body": "Keep in mind that you might be outside of an actual loiter while still in the SETPOINT_TYPE_LOITER handling. \r\n\r\nWhat do you think about waiting to enter the actual loiter (requiring `_l1_control.circle_mode()` here).",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-16T14:54:21Z",
          "body": "Fine for debugging, but can you drop these messages before merge? PX4_INFO isn't even logged.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-16T14:58:24Z",
          "body": "This is a copy (extra work), use a const reference instead. In c++ you also don't need the \"struct\".\r\n`struct position_setpoint_s next_sp` -> `const position_setpoint_s& next_sp`",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-16T15:05:26Z",
          "body": "Looking at how navigator overall works it would be cleaner to move this into a new `MissionBlock::get_altitude_acceptance()` that checks the vehicle type and setpoint triplet. All callers except for one (feasibility) are MissionBlocks.\r\n\r\n`Navigator::get_altitude_acceptance_radius()` could become `Navigator::get_default_altitude_acceptance_radius()` for grabbing the param values.\r\n\r\nThat would also give us a good mechanism for tightening the altitude acceptance during takeoff.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-16T15:15:41Z",
          "body": "> Maybe we should be doing this within TECS entirely?\r\n\r\nThat was my thought as well.",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Antiheavy",
          "created_at": "2018-06-16T15:18:06Z",
          "body": "I don't think it is valid to assume that all FW landings are preceded by a loiter.",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-16T23:18:43Z",
          "body": "With \"modes\" you mean these guys https://github.com/PX4/ecl/blob/1a1106878d6ab1cc48565bef9b25b07d626c5d0b/tecs/tecs.h#L94 ? Yes, this does not contain any LANDING state yet, so that would need to be extended, and i did not want to change @priseborough 's TECS too much here. I agree that if one changes multiple parameters for the landing then TECS should handle this, but i think for a single parameter the current solution would work. ",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-16T23:18:56Z",
          "body": "Changed.",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-16T23:19:09Z",
          "body": "Changed, must have slipped through somehow...",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-16T23:19:14Z",
          "body": "Changed.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-16T23:19:43Z",
          "body": "Changed, but a bit differently than you proposed: I put everything into the respective `Navigator::get_altitude_acceptance_radius()` and `Navigator::get_default_altitude_acceptance_radius()` functions because the \"sister\" functions (`get_acceptance_radius()` and `get_default_acceptance_radius()` ) are also located in Navigator, and i don't think we should have one of them in MissionBlock and one in Navigator. But you could now easily integrate all take-off altitude acceptance radius related checks into `Navigator::get_altitude_acceptance_radius()`.\r\n\r\nBtw: This current implementation means that for _every_ waypoint type (not only loiter-to-alt) we enter the function that checks whether the next WP is a land WP. I quickly looked through the whole code and think this is fine however. ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "philipoe",
          "created_at": "2018-06-18T09:02:52Z",
          "body": "See reply in my big comment.",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes address incorrect/unsafe behavioral logic (timing of landing config changes, landing-specific control gains, waypoint altitude acceptance logic, and flare/throttle decision conditions). These are state-transition and boundary/acceptance-condition fixes that correct unintended aircraft responses (e.g. integrator windup and aggressive pitch-down on flap deployment, overly large altitude acceptance, and inconsistent flaring), which match the definition of logic errors.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -243,7 +243,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\t\t\t\t&dist_xy, &dist_z);\n \n \t\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f)\n-\t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n+\t\t\t\t    && dist_z <= _navigator->get_default_altitude_acceptance_radius()) {\n \n \t\t\t\t\t// now set the loiter to the final altitude in the NAV_CMD_LOITER_TO_ALT mission item\n \t\t\t\t\tcurr_sp->alt = altitude_amsl;\n@@ -258,7 +258,7 @@ MissionBlock::is_mission_item_reached()\n \n \t\t\t\t\t// set required yaw from bearing to the next mission item\n \t\t\t\t\tif (_mission_item.force_heading) {\n-\t\t\t\t\t\tstruct position_setpoint_s next_sp = _navigator->get_position_setpoint_triplet()->next;\n+\t\t\t\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n \n \t\t\t\t\t\tif (next_sp.valid) {\n \t\t\t\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(_navigator->get_global_position()->lat,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0f5b201fdf39fe472a233e49b792d685c2ff6b/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "patch": "@@ -181,6 +181,13 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tfloat\t\tget_acceptance_radius();\n \n+\t/**\n+\t * Get the default altitude acceptance radius (i.e. from parameters)\n+\t *\n+\t * @return the distance from the target altitude before considering the waypoint reached\n+\t */\n+\tfloat\t\tget_default_altitude_acceptance_radius();\n+\n \t/**\n \t * Get the altitude acceptance radius\n \t *\n@@ -338,6 +345,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamFloat<px4::params::NAV_ACC_RAD>) _param_acceptance_radius,\t/**< acceptance for takeoff */\n \t\t(ParamFloat<px4::params::NAV_FW_ALT_RAD>)\n \t\t_param_fw_alt_acceptance_radius,\t/**< acceptance radius for fixedwing altitude */\n+\t\t(ParamFloat<px4::params::NAV_FW_ALTL_RAD>)\n+\t\t_param_fw_alt_lnd_acceptance_radius,\t/**< acceptance radius for fixedwing altitude before landing*/\n \t\t(ParamFloat<px4::params::NAV_MC_ALT_RAD>)\n \t\t_param_mc_alt_acceptance_radius,\t/**< acceptance radius for multicopter altitude */\n \t\t(ParamInt<px4::params::NAV_FORCE_VT>) _param_force_vtol,\t/**< acceptance radius for multicopter altitude */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0f5b201fdf39fe472a233e49b792d685c2ff6b/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "patch": "@@ -854,7 +854,7 @@ Navigator::get_acceptance_radius()\n }\n \n float\n-Navigator::get_altitude_acceptance_radius()\n+Navigator::get_default_altitude_acceptance_radius()\n {\n \tif (!get_vstatus()->is_rotary_wing) {\n \t\treturn _param_fw_alt_acceptance_radius.get();\n@@ -864,6 +864,21 @@ Navigator::get_altitude_acceptance_radius()\n \t}\n }\n \n+float\n+Navigator::get_altitude_acceptance_radius()\n+{\n+\tif (!get_vstatus()->is_rotary_wing) {\n+\t\tconst position_setpoint_s &next_sp = get_position_setpoint_triplet()->next;\n+\n+\t\tif (next_sp.type == position_setpoint_s::SETPOINT_TYPE_LAND && next_sp.valid) {\n+\t\t\t// Use separate (tighter) altitude acceptance for clean altitude starting point before landing\n+\t\t\treturn _param_fw_alt_lnd_acceptance_radius.get();\n+\t\t}\n+\t}\n+\n+\treturn get_default_altitude_acceptance_radius();\n+}\n+\n float\n Navigator::get_cruising_speed()\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0f5b201fdf39fe472a233e49b792d685c2ff6b/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "patch": "@@ -83,6 +83,20 @@ PARAM_DEFINE_FLOAT(NAV_ACC_RAD, 10.0f);\n  */\n PARAM_DEFINE_FLOAT(NAV_FW_ALT_RAD, 10.0f);\n \n+/**\n+ * FW Altitude Acceptance Radius before a landing\n+ *\n+ * Altitude acceptance used for the last waypoint before a fixed-wing landing. This is usually smaller\n+ * than the standard vertical acceptance because close to the ground higher accuracy is required.\n+ *\n+ * @unit m\n+ * @min 0.05\n+ * @max 200.0\n+ * @decimal 1\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(NAV_FW_ALTL_RAD, 5.0f);\n+\n /**\n  * MC Altitude Acceptance Radius\n  *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fc0f5b201fdf39fe472a233e49b792d685c2ff6b/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::get_altitude_acceptance_radius",
        "Navigator::get_acceptance_radius",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_altitude_acceptance_radius",
          "Navigator::get_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "ecl: update submodule",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9685",
    "number": 9685,
    "created_at": "2018-06-15T09:24:54Z",
    "merged": true,
    "merged_at": "2018-06-15T13:53:29Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "contains:\n- https://github.com/PX4/ecl/pull/460\n- https://github.com/PX4/ecl/pull/462\n\nAlso changes a critical RTL message that does not need to be critical to an info.\n\nFixes  #9527",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR updates the ecl submodule and references two ecl PRs plus 'Fixes #9527', which suggests it includes bug fixes in the estimator/control code (likely logic fixes). However, the PR description itself provides no details of the code changes; the only explicit change mentioned (downgrading an RTL log message) is not a logic error, so certainty is limited.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -276,7 +276,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.autocontinue = true;\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RTL: land at home\");\n+\t\t\tmavlink_and_console_log_info(_navigator->get_mavlink_log_pub(), \"RTL: land at home\");\n \t\t\tbreak;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5e903fcbcafb843326e745d60b49eb93e5d57a5f/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "Precland fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9668",
    "number": 9668,
    "created_at": "2018-06-13T21:36:33Z",
    "merged": true,
    "merged_at": "2018-06-14T03:32:52Z",
    "state": "closed",
    "conversation": {
      "author": "okalachev",
      "body": "This PR addresses two precland-related isses:\n\n1. When the copter switches to the horizontal approach state, the check of landing target pose validity is not fully correct: an old message (when the landing target is seen the last time) can switch the state.\n\n2. When downloading mission with a precision landing waypoint from the copter, the precision land parameter is lost.\n\n@ndepal",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "ndepal",
          "created_at": "2018-06-14T07:53:01Z",
          "body": "Why is this necessary? `_target_pose_updated` is only true if we got a new message in this `on_active()` call. In this case, the timestamp of the message is recent, so `_target_pose_valid` is always true if `_target_pose_updated` is true.\r\n\r\nIt's only possible for `_target_pose_valid` to be true and `_target_pose_updated` false (due to `_param_timeout`), but not the other way around.",
          "path": "src/modules/navigator/precland.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "okalachev",
          "created_at": "2018-06-14T12:01:29Z",
          "body": "Unfortunately, no. When testing we have met situations, when the copter sees the landing marker, when not in Precland mode (so Precland's `on_active` is not called). Then, for example, the copter flies from another point to the landing point. And then, \"sees\" the marker (actually just gets and old message).",
          "path": "src/modules/navigator/precland.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "ndepal",
          "created_at": "2018-06-14T12:08:31Z",
          "body": "Ah I see. Thanks for the fix!",
          "path": "src/modules/navigator/precland.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "mhkabir",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "patches": {
      "src/modules/navigator/precland.cpp": {
        "filename": "src/modules/navigator/precland.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -477,7 +477,7 @@ bool PrecLand::check_state_conditions(PrecLandState state)\n \t\t}\n \n \t\t// If we're trying to switch to this state, the target needs to be visible\n-\t\treturn _target_pose_updated && _target_pose.abs_pos_valid;\n+\t\treturn _target_pose_updated && _target_pose_valid && _target_pose.abs_pos_valid;\n \n \tcase PrecLandState::DescendAboveTarget:\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b9eec7fd552a618fbe6d24f6ef2dd04f34c8ae7c/src%2Fmodules%2Fnavigator%2Fprecland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "PrecLand::check_state_conditions"
      ],
      "by_file": {
        "src/modules/navigator/precland.cpp": [
          "PrecLand::check_state_conditions"
        ]
      }
    }
  },
  {
    "title": "Do not set the closest mission item in normal mission mode",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9646",
    "number": 9646,
    "created_at": "2018-06-12T08:34:45Z",
    "merged": true,
    "merged_at": "2018-06-12T16:11:14Z",
    "state": "closed",
    "conversation": {
      "author": "acfloria",
      "body": "As requested in [#9606](https://github.com/PX4/Firmware/issues/9606).\n\nTested in SITL for normal mission flight and RTL.\n\n@potaito can you confirm that now it works as you expect?",
      "issue_comments": [
        {
          "author": "potaito",
          "created_at": "2018-06-12T09:33:54Z",
          "body": "Tested in HITL and it works as expected:\r\n\r\n![1](https://user-images.githubusercontent.com/3762382/41282367-2ec80694-6e34-11e8-8ed0-8c1ea1e87f1c.png)\r\nTakeoff performed and then created mission.\r\n\r\n----\r\n\r\n![2](https://user-images.githubusercontent.com/3762382/41282359-266e6af6-6e34-11e8-85d3-ea1f04a04698.png)\r\nStarted the mission, flying towards the first waypoint.\r\n\r\n----\r\n\r\n![3](https://user-images.githubusercontent.com/3762382/41282374-30f090a8-6e34-11e8-9d45-73d275d789be.png)\r\nAll waypoints passed in correct order :+1: ",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-12T14:55:30Z",
          "body": " - fixes https://github.com/PX4/Firmware/issues/9606",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-12T16:11:20Z",
          "body": "Thanks!",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "potaito",
          "created_at": "",
          "body": "LGTM, thanks @acfloria ",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR prevents the flight stack from switching the active mission index to the 'closest' mission item in normal mission mode, which previously caused incorrect mission execution order (an incorrect state/flow). The linked issue, reviewer notes, and SITL/HITL tests showing waypoints passed in correct order indicate this fixes a logic bug in mission handling.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "patch": "@@ -155,7 +155,11 @@ void\n Mission::on_activation()\n {\n \tif (_mission_waypoints_changed) {\n-\t\t_current_offboard_mission_index = index_closest_mission_item();\n+\t\t// do not set the closest mission item in the normal mission mode\n+\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n+\t\t\t_current_offboard_mission_index = index_closest_mission_item();\n+\t\t}\n+\n \t\t_mission_waypoints_changed = false;\n \t}\n \n@@ -199,7 +203,11 @@ Mission::on_active()\n \t/* reset mission items if needed */\n \tif (offboard_updated || _mission_waypoints_changed || _execution_mode_changed) {\n \t\tif (_mission_waypoints_changed) {\n-\t\t\t_current_offboard_mission_index = index_closest_mission_item();\n+\t\t\t// do not set the closest mission item in the normal mission mode\n+\t\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n+\t\t\t\t_current_offboard_mission_index = index_closest_mission_item();\n+\t\t\t}\n+\n \t\t\t_mission_waypoints_changed = false;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a1ca862263180c2bec8ad613c70e611467423ba3/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::on_activation",
        "Mission::on_active"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_activation",
          "Mission::on_active"
        ]
      }
    }
  },
  {
    "title": "replace geo _wrap_pi with matrix::wrap_pi",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/9630",
    "number": 9630,
    "created_at": "2018-06-09T21:24:21Z",
    "merged": true,
    "merged_at": "2018-06-12T07:00:54Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "Requires https://github.com/PX4/Matrix/pull/68 and https://github.com/PX4/ecl/pull/456 to be merged first.",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-06-10T21:12:37Z",
          "body": "This looks wrong.",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-06-11T00:52:14Z",
          "body": "Good catch, fixed.",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "Looked good except for the one line. Given how critical these are I would like to have another review pass tomorrow.",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR title and description indicate a replacement of a local geo _wrap_pi with matrix::wrap_pi (a refactor to use a shared implementation) but contain no mention of incorrect behavior, a bug, or failing cases. Review comments note a minor issue and request another pass due to criticality, but there's no explicit evidence the change corrects a logic error rather than consolidating code. Without details showing the previous behavior was wrong, this appears to be a refactor, not a confirmed logic bug fix.",
    "patches": {
      "src/modules/navigator/follow_target.cpp": {
        "filename": "src/modules/navigator/follow_target.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -56,6 +56,8 @@\n \n #include \"navigator.h\"\n \n+using matrix::wrap_pi;\n+\n constexpr float FollowTarget::_follow_position_matricies[4][9];\n \n FollowTarget::FollowTarget(Navigator *navigator) :\n@@ -200,7 +202,7 @@ void FollowTarget::on_active()\n \t\t\t\t\t\t_current_target_motion.lat,\n \t\t\t\t\t\t_current_target_motion.lon);\n \n-\t\t\t\t_yaw_rate = _wrap_pi((_yaw_angle - _navigator->get_global_position()->yaw) / (dt_ms / 1000.0f));\n+\t\t\t\t_yaw_rate = wrap_pi((_yaw_angle - _navigator->get_global_position()->yaw) / (dt_ms / 1000.0f));\n \n \t\t\t} else {\n \t\t\t\t_yaw_angle = _yaw_rate = NAN;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2a2a0940d4bd9497b11474a43f673a0dec84f005/src%2Fmodules%2Fnavigator%2Ffollow_target.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -60,6 +60,8 @@\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n \n+using matrix::wrap_pi;\n+\n Mission::Mission(Navigator *navigator) :\n \tMissionBlock(navigator),\n \tModuleParams(navigator)\n@@ -1245,7 +1247,7 @@ Mission::heading_sp_update()\n \n \t\t\t\t/* always keep the back of the rotary wing pointing towards home */\n \t\t\t\tif (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n-\t\t\t\t\t_mission_item.yaw = _wrap_pi(yaw + M_PI_F);\n+\t\t\t\t\t_mission_item.yaw = wrap_pi(yaw + M_PI_F);\n \t\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n \n \t\t\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2a2a0940d4bd9497b11474a43f673a0dec84f005/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -54,6 +54,8 @@\n #include <uORB/topics/vehicle_command.h>\n #include <uORB/topics/vtol_vehicle_status.h>\n \n+using matrix::wrap_pi;\n+\n MissionBlock::MissionBlock(Navigator *navigator) :\n \tNavigatorMode(navigator)\n {\n@@ -326,7 +328,8 @@ MissionBlock::is_mission_item_reached()\n \t\t\tfloat cog = _navigator->get_vstatus()->is_rotary_wing ? _navigator->get_global_position()->yaw : atan2f(\n \t\t\t\t\t    _navigator->get_global_position()->vel_e,\n \t\t\t\t\t    _navigator->get_global_position()->vel_n);\n-\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - cog);\n+\n+\t\t\tfloat yaw_err = wrap_pi(_mission_item.yaw - cog);\n \n \t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n \t\t\tif (fabsf(yaw_err) < math::radians(_navigator->get_yaw_threshold())",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2a2a0940d4bd9497b11474a43f673a0dec84f005/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::heading_sp_update",
        "FollowTarget::on_active",
        "MissionBlock::is_mission_item_reached"
      ],
      "by_file": {
        "src/modules/navigator/follow_target.cpp": [
          "FollowTarget::on_active"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::heading_sp_update"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ]
      }
    }
  },
  {
    "title": "WIP: HEARTBEAT and commander failsafe handling cleanup",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10933",
    "number": 10933,
    "created_at": "2018-11-28T14:51:09Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "For discussion of expanded failsafe handling WRT mavlink HEARTBEAT (https://github.com/PX4/Firmware/pull/10841).\n\n - mavlink update telemetry_status with all HEARTBEAT timestamps\n - let commander decide which HEARTBEATs to use\n - optimizations to avoid unnecessary state and subscribing to all telemetry_status and iridiumsbd instances (saves ~1.5kB of RAM)\n - simplifies convoluted commander data link handling\n\n Related\n - https://github.com/PX4/Firmware/pull/10841\n - https://github.com/PX4/Firmware/pull/10194\n - https://github.com/PX4/Firmware/pull/9473\n - https://github.com/PX4/Firmware/pull/7985",
      "issue_comments": [
        {
          "author": "TSC21",
          "created_at": "2018-11-29T13:02:22Z",
          "body": "@baumanta your commit looks really good. But it's failing for a specific target: http://ci.px4.io:8080/blue/organizations/jenkins/PX4_misc%2FFirmware-compile/detail/pr-heartbeat_failsafes/5/pipeline#step-533-log-407",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-12-04T10:52:02Z",
          "body": "@dagar I quickly checked, so far no conflict with #10907 ðŸ˜… ",
          "type": "issue_comment"
        },
        {
          "author": "baumanta",
          "created_at": "2018-12-05T12:51:45Z",
          "body": "@dagar are there any updates on this?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-12-17T05:30:13Z",
          "body": "TODO: double check the iridium behavior  ",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2019-02-13T14:40:10Z",
          "body": "I'll try to resurrect this and get it in incrementally. \r\nPart 1 - https://github.com/PX4/Firmware/pull/11454",
          "type": "issue_comment"
        },
        {
          "author": "jkflying",
          "created_at": "2019-06-04T11:50:07Z",
          "body": "I guess this is all in now and can be closed?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2019-06-04T14:16:18Z",
          "body": "Yes, thanks everyone!",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "TSC21",
          "created_at": "2018-11-28T15:06:24Z",
          "body": "If this came to the commander param list, why not change the suffix to `COM`?",
          "path": "src/modules/commander/Commander.hpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-28T15:06:33Z",
          "body": "Same thing here",
          "path": "src/modules/commander/Commander.hpp",
          "position": 12,
          "type": "review_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-28T15:08:57Z",
          "body": "so for an `_obc_datalink_loss`, we need to add new params right?",
          "path": "src/modules/commander/Commander.hpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-28T15:12:14Z",
          "body": "@baumanta ",
          "path": "src/modules/commander/Commander.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-28T15:12:25Z",
          "body": "They've already effectively been commander params for several releases. The only reason I didn't do the rename is that users will lose existing settings. This is the type of thing we can do for a release with proper migration documentation.",
          "path": "src/modules/commander/Commander.hpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-28T15:12:31Z",
          "body": "See previous comment.",
          "path": "src/modules/commander/Commander.hpp",
          "position": 12,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-28T15:16:40Z",
          "body": "One more time for clarity, how would you like it to work?",
          "path": "src/modules/commander/Commander.hpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-28T15:20:54Z",
          "body": "For example: I have a GCS link and a OBC link. I want the OBC link, if failing, to trigger a failsafe, but if the GCS link fails, I just want it to send a mavlink_log warning me, but not triggering a failsafe. Or, I may want them to both trigger a failsafe, or want that none trigger a failsafe but at least warn me this also applies to the high latency case.\r\n\r\nImagine we have 3 links. I would like to state which ones do trigger failsafes in the case of failure, but want to all of them to tell at least warn me in the case of a failsafe.",
          "path": "src/modules/commander/Commander.hpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "TSC21",
          "created_at": "2018-11-28T15:30:01Z",
          "body": "It can make sense to be more atomic and say: OBC triggers a RTL failsafe, while GCS triggers a land failsafe",
          "path": "src/modules/commander/Commander.hpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-28T15:39:08Z",
          "body": "TODO: we need to be careful for the scenario where a single mavlink connection will have multiple HEARTBEATs (eg companion also routing to GCS). I'll make sure that each received HEARTBEAT results in a telemetry_status publication.",
          "path": "src/modules/commander/Commander.hpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-30T15:51:57Z",
          "body": "I'm wondering if we can drop the sysid check entirely now.",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 13,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-12-17T05:27:29Z",
          "body": "We need to preserve the ability to build px4 without the multicopter controllers. \r\n\r\nOne option is to use the older c param api for MPC_OBS_AVOID, but now that I'm looking at this again I'm wondering if it's needed at all. You could either have an independent set of commander parameters analogous to datalink loss, but specifically for avoidance loss (COM_OBS_LOSS_T), or perhaps have the position controller put something in `position_controller_status` (https://github.com/PX4/Firmware/blob/master/msg/position_controller_status.msg) indicating that an avoidance system is required.",
          "path": "src/modules/commander/Commander.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-12-17T05:32:53Z",
          "body": "```suggestion\r\n\r\n```",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 13,
          "type": "review_comment"
        },
        {
          "author": "baumanta",
          "created_at": "2018-12-19T12:29:54Z",
          "body": "@dagar I just switched the definition of the parameter from position controller to commander. Now the parameter is called COM_OBS_AVOID. As commander is build anyway for all the boards this should solve our problem. Anyway I think this is the better location for this parameter as the decision on whether to use obstacle avoidance is rather a commander matter then a position controller choice. What do you think, would that be ok for you?",
          "path": "src/modules/commander/Commander.hpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes how MAVLink HEARTBEAT timestamps are reported and moves the decision logic for using those heartbeats into the commander (i.e. which link to trust for failsafe). That is a change to program decision/state logic (failsafe handling and data-link selection), which fixes incorrect or fragile behavior in failsafe determination â€” a classic logic error (improper state/decision handling).",
    "patches": {
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 0,
        "deletions": 42,
        "changes": 42,
        "patch": "@@ -111,48 +111,6 @@ PARAM_DEFINE_FLOAT(NAV_FW_ALTL_RAD, 5.0f);\n  */\n PARAM_DEFINE_FLOAT(NAV_MC_ALT_RAD, 0.8f);\n \n-/**\n- * Set data link loss failsafe mode\n- *\n- * The data link loss failsafe will only be entered after a timeout,\n- * set by COM_DL_LOSS_T in seconds. Once the timeout occurs the selected\n- * action will be executed. Setting this parameter to 4 will enable CASA\n- * Outback Challenge rules, which are only recommended to participants\n- * of that competition.\n- *\n- * @value 0 Disabled\n- * @value 1 Hold mode\n- * @value 2 Return mode\n- * @value 3 Land mode\n- * @value 4 Data Link Auto Recovery (CASA Outback Challenge rules)\n- * @value 5 Terminate\n- * @value 6 Lockdown\n- *\n- * @group Mission\n- */\n-PARAM_DEFINE_INT32(NAV_DLL_ACT, 0);\n-\n-/**\n- * Set RC loss failsafe mode\n- *\n- * The RC loss failsafe will only be entered after a timeout,\n- * set by COM_RC_LOSS_T in seconds. If RC input checks have been disabled\n- * by setting the COM_RC_IN_MODE param it will not be triggered.\n- * Setting this parameter to 4 will enable CASA Outback Challenge rules,\n- * which are only recommended to participants of that competition.\n- *\n- * @value 0 Disabled\n- * @value 1 Hold mode\n- * @value 2 Return mode\n- * @value 3 Land mode\n- * @value 4 RC Auto Recovery (CASA Outback Challenge rules)\n- * @value 5 Terminate\n- * @value 6 Lockdown\n- *\n- * @group Mission\n- */\n-PARAM_DEFINE_INT32(NAV_RCL_ACT, 2);\n-\n /**\n  * Set traffic avoidance mode\n  *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/99f8e38de02805723ce725c4299e35f5ee8cc4fa/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "[WIP] DO_CHANGE_SPEED work across LOITER, MISSION, RTL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10912",
    "number": 10912,
    "created_at": "2018-11-25T19:04:26Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "Opening for further discussion and testing, please do not merge.\n\nTODO:\n - review behaviour wrt VTOL transitions\n - define mission behaviour\n   - debatably, the speed should be set as a property of the current mission\n   - example: setting mission speed, temporarily leaving leaving mission mode, then resuming",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-11-25T19:08:19Z",
          "body": "@sanderux do you have any input here? This might be a good time to review and document your requirements (current and desired).",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-25T19:16:08Z",
          "body": "@superware",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-11-25T22:50:26Z",
          "body": "A quick pass looks good to me.",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2018-11-26T16:44:12Z",
          "body": "does this work for setting cruise throttle? (disabled airspeed sensors)",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2018-11-26T16:47:33Z",
          "body": "our use case for changing speed would be \r\n- from an onboard computer monitoring vehicle behavior and detecting a requirement for more speed\r\n- custom behavior: change flight setting from efficient to performance and back\r\n- custom behavior: Quick RTL / Bird strike avoidance\r\n\r\nSo for us it is not so much a mission setting but a way for external systems (or perhaps in the future through QGC) of defining the vehicles speed.",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-07-10T17:37:03Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-10-23T09:12:29Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "superware",
          "created_at": "2019-10-23T10:44:16Z",
          "body": "Hi @julianoes, can you please reopen?",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2019-10-25T11:57:22Z",
          "body": "> Hi @julianoes, can you please reopen?\r\n\r\nIt's still open.",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2020-01-24T03:36:30Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2021-01-10T17:49:45Z",
          "body": "Closing as stale.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR appears to be adding/adjusting behavior so the DO_CHANGE_SPEED command works across LOITER, MISSION and RTL rather than correcting a clearly documented incorrect behavior. The discussion focuses on desired semantics, edge cases (VTOL transitions, mission-resume), and use cases rather than fixing a concrete logic bug, so this reads as a feature/enhancement rather than a targeted logic error fix.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -57,6 +57,8 @@ Loiter::on_inactive()\n void\n Loiter::on_activation()\n {\n+\t_navigator->reset_cruising_speed();\n+\n \tif (_navigator->get_reposition_triplet()->current.valid) {\n \t\treposition();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/227d9fc19dd3e6cb0c6da7961f71a1b7f6fa8f16/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 29,
        "changes": 29,
        "patch": "@@ -70,11 +70,6 @@ Mission::Mission(Navigator *navigator) :\n void\n Mission::on_inactive()\n {\n-\t/* We need to reset the mission cruising speed, otherwise the\n-\t * mission velocity which might have been set using mission items\n-\t * is used for missions such as RTL. */\n-\t_navigator->set_cruising_speed();\n-\n \t/* Without home a mission can't be valid yet anyway, let's wait. */\n \tif (!_navigator->home_position_valid()) {\n \t\treturn;\n@@ -96,7 +91,6 @@ Mission::on_inactive()\n \t\tif (need_to_reset_mission(false)) {\n \t\t\treset_offboard_mission(_offboard_mission);\n \t\t\tupdate_offboard_mission();\n-\t\t\t_navigator->reset_cruising_speed();\n \t\t}\n \n \t} else {\n@@ -239,11 +233,6 @@ Mission::on_active()\n \t\t}\n \t}\n \n-\t/* check if a cruise speed change has been commanded */\n-\tif (_mission_type != MISSION_TYPE_NONE) {\n-\t\tcruising_speed_sp_update();\n-\t}\n-\n \t/* see if we need to update the current yaw heading */\n \tif (!_param_mnt_yaw_ctl.get() && (_navigator->get_vstatus()->is_rotary_wing)\n \t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n@@ -1315,24 +1304,6 @@ Mission::altitude_sp_foh_update()\n \t_navigator->set_position_setpoint_triplet_updated();\n }\n \n-void\n-Mission::cruising_speed_sp_update()\n-{\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\tconst float cruising_speed = _navigator->get_cruising_speed();\n-\n-\t/* Don't change setpoint if the current waypoint is not valid */\n-\tif (!pos_sp_triplet->current.valid ||\n-\t    fabsf(pos_sp_triplet->current.cruising_speed - cruising_speed) < FLT_EPSILON) {\n-\t\treturn;\n-\t}\n-\n-\tpos_sp_triplet->current.cruising_speed = cruising_speed;\n-\n-\t_navigator->set_position_setpoint_triplet_updated();\n-}\n-\n void\n Mission::do_abort_landing()\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/227d9fc19dd3e6cb0c6da7961f71a1b7f6fa8f16/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "patch": "@@ -164,11 +164,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t */\n \tvoid altitude_sp_foh_update();\n \n-\t/**\n-\t * Update the cruising speed setpoint.\n-\t */\n-\tvoid cruising_speed_sp_update();\n-\n \t/**\n \t * Abort landing\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/227d9fc19dd3e6cb0c6da7961f71a1b7f6fa8f16/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "patch": "@@ -517,9 +517,6 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \t\tsp->acceptance_radius = _navigator->get_default_acceptance_radius();\n \t}\n \n-\tsp->cruising_speed = _navigator->get_cruising_speed();\n-\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n-\n \tswitch (item.nav_cmd) {\n \tcase NAV_CMD_IDLE:\n \t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/227d9fc19dd3e6cb0c6da7961f71a1b7f6fa8f16/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 1,
        "changes": 27,
        "patch": "@@ -722,6 +722,9 @@ Navigator::run()\n \n \t\t/* we have a new navigation mode: reset triplet */\n \t\tif (_navigation_mode != navigation_mode_new) {\n+\n+\t\t\treset_cruising_speed();\n+\n \t\t\t// We don't reset the triplet if we just did an auto-takeoff and are now\n \t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n \t\t\t// than where we wanted to go.\n@@ -918,6 +921,18 @@ Navigator::set_cruising_speed(float speed)\n \t} else {\n \t\t_mission_cruising_speed_fw = speed;\n \t}\n+\n+\tif (_navigation_mode != nullptr) {\n+\t\t/* Don't change setpoint if the current waypoint is not valid */\n+\t\tif (!_pos_sp_triplet.current.valid ||\n+\t\t    fabsf(_pos_sp_triplet.current.cruising_speed - speed) < FLT_EPSILON) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t_pos_sp_triplet.current.cruising_speed = speed;\n+\n+\t\tset_position_setpoint_triplet_updated();\n+\t}\n }\n \n void\n@@ -930,9 +945,19 @@ Navigator::reset_cruising_speed()\n void\n Navigator::reset_triplets()\n {\n-\t_pos_sp_triplet.current.valid = false;\n \t_pos_sp_triplet.previous.valid = false;\n+\t_pos_sp_triplet.current.cruising_speed = -1.0f;\n+\t_pos_sp_triplet.current.cruising_throttle = -1.0f;\n+\n+\t_pos_sp_triplet.current.valid = false;\n+\t_pos_sp_triplet.current.cruising_speed = -1.0f;\n+\t_pos_sp_triplet.current.cruising_throttle = -1.0f;\n+\n+\n \t_pos_sp_triplet.next.valid = false;\n+\t_pos_sp_triplet.current.cruising_speed = -1.0f;\n+\t_pos_sp_triplet.current.cruising_throttle = -1.0f;\n+\n \t_pos_sp_triplet_updated = true;\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/227d9fc19dd3e6cb0c6da7961f71a1b7f6fa8f16/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -65,6 +65,8 @@ RTL::rtl_type() const\n void\n RTL::on_activation()\n {\n+\t_navigator->reset_cruising_speed();\n+\n \tif (_navigator->get_land_detected()->landed) {\n \t\t// For safety reasons don't go into RTL if landed.\n \t\t_rtl_state = RTL_STATE_LANDED;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/227d9fc19dd3e6cb0c6da7961f71a1b7f6fa8f16/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::Mission",
        "Mission::altitude_sp_foh_update",
        "RTL::rtl_type",
        "Mission::on_active",
        "Mission::on_inactive",
        "Navigator::run",
        "cruising_speed_sp_update",
        "Navigator::set_cruising_speed",
        "Navigator::reset_cruising_speed",
        "Loiter::on_inactive",
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_inactive"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::Mission",
          "Mission::on_inactive",
          "Mission::altitude_sp_foh_update",
          "Mission::on_active"
        ],
        "src/modules/navigator/mission.h": [
          "cruising_speed_sp_update"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::set_cruising_speed",
          "Navigator::run",
          "Navigator::reset_cruising_speed"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::rtl_type"
        ]
      }
    }
  },
  {
    "title": "Landing gear improvement",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10842",
    "number": 10842,
    "created_at": "2018-11-14T11:09:17Z",
    "merged": true,
    "merged_at": "2018-12-10T15:17:24Z",
    "state": "closed",
    "conversation": {
      "author": "MaEtUgR",
      "body": "**Test data / coverage**\nSITL/HITL and field tested ~20 flights in H520 Firmware before cherry-picking.\n\n**Describe problem solved by the proposed pull request**\nControlling the landing gear is tied to the attitude setpoint message which is just misusing an existing message that lead to a lot of problems when implementing landing gear behaviour according to product requirements.\n\n**Describe your preferred solution**\nWe took the time to solve these problems and make it more flexible and want to contribute this architecture.\n\n**Additional context**\nThere were conflicts with #10805. (FYI @bkueng)\n\n---\n\n**State:** I'm still porting commits.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-11-14T17:10:53Z",
          "body": "What do you think about getting landing gear out of control group 0?\r\n\r\n![image](https://user-images.githubusercontent.com/84712/48499335-33204200-e806-11e8-84a4-18b9ac9f231e.png)\r\n\r\nLater that could facilitate handling landing gear entirely outside of the position and attitude controllers.\r\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-11-14T22:41:51Z",
          "body": "I recall having discussed that and I think that is necessary.",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-11-15T10:25:05Z",
          "body": "Sure, this is just a **first step** of detaching the landing gear out of the attitude setpoint because it really has nothing to do with the attitude and its controller. These changes were necessary to **solve our nasty dependency issues** because of product customization that lead to a severe maintenance effort to keep **up to date with PX4** and that's why we wanted to contribute. Any further work in this direction is appreciated. The only obstacle I see with removing it from the control group is messing with the IO which usually takes more time but that should not hinder us after all.",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-12-06T14:26:21Z",
          "body": "I rebased because there were conflicts in the position controller because of my own pr https://github.com/PX4/Firmware/pull/10831",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-12-10T14:02:07Z",
          "body": "Rebased without conflicts, any reason this is waiting?",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-12-10T14:17:17Z",
          "body": "No, good to go.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "Stifael",
          "created_at": "2018-12-04T14:41:32Z",
          "body": "`_gear_switch_old = landing_gear_s::GEAR_KEEP `?",
          "path": "src/lib/FlightTasks/tasks/Manual/FlightTaskManual.hpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "Stifael",
          "created_at": "2018-12-04T14:44:03Z",
          "body": "Am I correct with the assumption that the publication of landing-gear is only required for logging?",
          "path": "src/modules/mc_att_control/mc_att_control.hpp",
          "position": 28,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-12-06T13:18:51Z",
          "body": "No, to detect the transition of the RC **switch** controlling the landing gear (if there is any) like the word `switch` suggests.\r\nIt's states are defined according to: https://github.com/PX4/Firmware/blob/0c60fff6bd0e09db9b4fc716472849978a60516f/msg/manual_control_setpoint.msg#L3-L6",
          "path": "src/lib/FlightTasks/tasks/Manual/FlightTaskManual.hpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-12-06T13:24:13Z",
          "body": "~Your curiousity saves lives, good catch ðŸ‘ I'll fix this malicious publication.~",
          "path": "src/modules/mc_att_control/mc_att_control.hpp",
          "position": 28,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-12-06T14:21:52Z",
          "body": "I recalled my changes which were done during the rebase because the attitude controller had conflicts caused by https://github.com/PX4/Firmware/pull/10805. The landing gear field is not in the attitude setpoint anymore and @bkueng 's pattern here https://github.com/PX4/Firmware/pull/10805/files#diff-6e842349b82ef0b37ba6161a6d0f85c3R167 is to publish the attitude setpoint out of the same loop that polls on it (I find that confusing and improvable as well). So to enable landing gear operation in stabilized mode I had to follow the same pattern.\r\n\r\nFor the landing gear this might actually make a lot of sense because in the future the execution of the landing gear message should not be in the attitude controller anymore. And for the attitude I discussed with @Stifael it would make sense that the position controller sends thrust and yaw while the attitude controller converts either the input from the position controller or from the sticks to an attitude setpoint (quaterion) executes and publishes it for logging.",
          "path": "src/modules/mc_att_control/mc_att_control.hpp",
          "position": 28,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "Stifael",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logical/architectural bug: landing-gear control was incorrectly tied to the attitude setpoint/message and controller, which misused the message and caused incorrect behavior and painful dependency/state issues. Decoupling landing gear from the attitude control group corrects the control-flow/state responsibilities and resolves the unintended behavior.",
    "patches": {
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -46,6 +46,7 @@\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/home_position.h>\n+#include <uORB/topics/vehicle_attitude_setpoint.h>\n #include <mathlib/mathlib.h>\n \n using matrix::Eulerf;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/612874458cd5e6ae5bd76bcab991c2774752e328/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -67,7 +67,6 @@\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/position_controller_status.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n-#include <uORB/topics/vehicle_attitude_setpoint.h>\n #include <uORB/topics/vehicle_command.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/vehicle_gps_position.h>",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/612874458cd5e6ae5bd76bcab991c2774752e328/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "[DO NOT MERGE] introduce vehicle_thrust_setpoint",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10832",
    "number": 10832,
    "created_at": "2018-11-12T20:46:39Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "For discussion only at this point (not complete or tested).\n\nIf this is viable we might be able to drop the virtual attitude setpoints entirely. Then we can lean on thrust setpoints for coordination between position controllers. This should also lead to it being possible to drop virtual actuator controls.",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-11-12T23:17:34Z",
          "body": "Nice! This is going in the right direction. We might want to do this in stages though (with the original PR going in first, then this on top of it).",
          "type": "issue_comment"
        },
        {
          "author": "bresch",
          "created_at": "2018-11-13T13:17:57Z",
          "body": "@dagar We won't be able to drop the virtual attitude setpoints because during the transition of a standard VTOL, since we want pitch and thrust_x from TECS, roll from L1 and thrust_z from the multicopter position controller. Besides that, splitting the thrust setpoints from the attitudes ones is the right way to go :)",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-13T14:32:06Z",
          "body": "@bresch yes, we'd still need a mechanism to combine orthogonal thrust setpoints (MPC altitude controller). This is one of the reasons I asked about the control allocation idea.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2019-02-05T21:06:48Z",
          "body": "Revisit for v1.10.0",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR is an architectural/feature proposal to introduce a separate vehicle_thrust_setpoint and reorganize control signaling, not a targeted fix for a specific incorrect behavior. The description and comments discuss design trade-offs and coordination between controllers rather than correcting an existing logic bug or unintended output.",
    "patches": {
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "patch": "@@ -46,6 +46,8 @@\n #include <uORB/uORB.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/home_position.h>\n+#include <uORB/topics/vehicle_attitude_setpoint.h>\n+#include <uORB/topics/vehicle_thrust_setpoint.h>\n #include <mathlib/mathlib.h>\n \n using matrix::Eulerf;\n@@ -86,7 +88,10 @@ GpsFailure::on_active()\n \t\t\tatt_sp.timestamp = hrt_absolute_time();\n \t\t\tatt_sp.roll_body = math::radians(_param_openlooploiter_roll.get());\n \t\t\tatt_sp.pitch_body = math::radians(_param_openlooploiter_pitch.get());\n-\t\t\tatt_sp.thrust = _param_openlooploiter_thrust.get();\n+\n+\t\t\tvehicle_thrust_setpoint_s thrust_sp = {};\n+\t\t\tthrust_sp.timestamp = att_sp.timestamp;\n+\t\t\tthrust_sp.thrust_body[0] = _param_openlooploiter_thrust.get();\n \n \t\t\tQuatf q(Eulerf(att_sp.roll_body, att_sp.pitch_body, 0.0f));\n \t\t\tq.copyTo(att_sp.q_d);\n@@ -101,6 +106,15 @@ GpsFailure::on_active()\n \t\t\t\t_att_sp_pub = orb_advertise(ORB_ID(vehicle_attitude_setpoint), &att_sp);\n \t\t\t}\n \n+\t\t\tif (_thrust_sp_pub != nullptr) {\n+\t\t\t\t/* publish att sp*/\n+\t\t\t\torb_publish(ORB_ID(vehicle_thrust_setpoint), _thrust_sp_pub, &thrust_sp);\n+\n+\t\t\t} else {\n+\t\t\t\t/* advertise and publish */\n+\t\t\t\t_thrust_sp_pub = orb_advertise(ORB_ID(vehicle_thrust_setpoint), &thrust_sp);\n+\t\t\t}\n+\n \t\t\t/* Measure time */\n \t\t\tif ((_param_loitertime.get() > FLT_EPSILON) &&\n \t\t\t    (hrt_elapsed_time(&_timestamp_activation) > _param_loitertime.get() * 1e6f)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2c8988f04faf190353a5c19f106c4fb5b8bbb2f/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      },
      "src/modules/navigator/gpsfailure.h": {
        "filename": "src/modules/navigator/gpsfailure.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -73,6 +73,7 @@ class GpsFailure : public MissionBlock, public ModuleParams\n \thrt_abstime _timestamp_activation{0}; //*< timestamp when this mode was activated */\n \n \torb_advert_t\t_att_sp_pub{nullptr};\n+\torb_advert_t\t_thrust_sp_pub{nullptr};\n \n \t/**\n \t * Set the GPSF item",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2c8988f04faf190353a5c19f106c4fb5b8bbb2f/src%2Fmodules%2Fnavigator%2Fgpsfailure.h"
      }
    },
    "modified_functions": {
      "all": [
        "GpsFailure::on_active"
      ],
      "by_file": {
        "src/modules/navigator/gpsfailure.cpp": [
          "GpsFailure::on_active"
        ]
      }
    }
  },
  {
    "title": "VTOL rate control improvements",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10819",
    "number": 10819,
    "created_at": "2018-11-08T09:59:50Z",
    "merged": true,
    "merged_at": "2018-11-22T01:32:41Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "Replaces #9190",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-11-08T10:06:17Z",
          "body": "Not merging just yet!",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-11-08T10:43:46Z",
          "body": "@LorenzMeier yes, please don't! It breaks Flight Review :)",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:50:23Z",
          "body": "Once this is good to go I'll squash the commits.",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T14:09:09Z",
          "body": "@PX4/testflights Any chance you can test fly this. It touches multirotor, vtol and fixed wing.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-14T16:34:49Z",
          "body": "@PX4/testflights please try this on all VTOLs, as well as regression testing on MC and FW platforms.",
          "type": "issue_comment"
        },
        {
          "author": "Avysuarez",
          "created_at": "2018-11-15T20:06:50Z",
          "body": "I tested this PR on convergence Vtol, it took off well in the mission but did not do the transition, when I aborted the mission the VTOL it fell and crashed. And did not save the log.\r\n\r\n![vtol1](https://user-images.githubusercontent.com/12182176/48578779-6f6ba500-e8cf-11e8-9cfb-3eb29464a8e2.jpg)\r\n![vtol4](https://user-images.githubusercontent.com/12182176/48578781-6f6ba500-e8cf-11e8-8957-ba55a8bcb41b.jpg)\r\n\r\n\r\n\r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dannyfpv",
          "created_at": "2018-11-15T20:17:36Z",
          "body": "test on pixhawk 1 and crash on stabilize mode\r\nhttps://review.px4.io/plot_app?log=8f5cbf75-cb1f-4fd3-88ed-d18d425c7cfb\r\n\r\non pixhawk v4 pro crash on stabilize mode\r\nhttps://review.px4.io/plot_app?log=014173eb-4156-4828-a97d-492c417f3577",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-15T20:30:14Z",
          "body": "@dannyfpv Hi! Thanks for testing and sorry for the crash. I checked the log and I already found the bug. Unfortunately, there was sign error in throttle in stabilized mode that was introduced during the lasted rebase on master. SITL did not catch that bug because it does not use test stabilized mode.\r\nHowever, in future I suggest to bench test PRs which introduce massive changes like this one does before actually flying the vehicle. In this case you would have had no throttle in stabilized mode.\r\nAnyway, I hope the convergence is not broken too badly...",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2018-11-15T20:40:09Z",
          "body": "Thanks for the feedback @RomanBapst, don't worry about the convergence it fulfilled its duty! Now let's make sure we have tests for stabilized mode, should I open an issue for tracking @dagar or is this covered somewhere already?",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-15T20:42:53Z",
          "body": "@mrpollo I was already thinking about this. I think it would not be too hard to use the dronecode SDK in the CI and actually 'simulate' a human flying with a radio controller. That would just be a sluggish controller outputting RC commands. ",
          "type": "issue_comment"
        },
        {
          "author": "dannyfpv",
          "created_at": "2018-11-21T22:19:01Z",
          "body": "tested on pixhawk v4 pro, good flights no noticeable issues.\r\nhttps://review.px4.io/plot_app?log=482daec6-d8b5-416f-bb3c-e57782fec3bd\r\nhttps://review.px4.io/plot_app?log=4fc131d3-e215-4188-895c-d59a7161747d",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-22T01:30:28Z",
          "body": "I took another pass and this looks good. Let's merge and keep going.",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2018-11-22T16:33:50Z",
          "body": "Great team work everyone ðŸŽ‰ ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bkueng",
          "created_at": "2018-11-08T12:22:06Z",
          "body": "```suggestion\r\n\t\tif (orb_copy(ORB_ID(vehicle_attitude_setpoint), _att_sp_sub, &_att_sp) == 0) {\r\n```",
          "path": "src/modules/fw_att_control/FixedwingAttitudeControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-11-08T12:25:57Z",
          "body": "```suggestion\r\n\treturn _parameters.airspeed_trim / math::max(airspeed,  _parameters.airspeed_min);\r\n```",
          "path": "src/modules/fw_att_control/FixedwingAttitudeControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-11-08T12:32:28Z",
          "body": "Why is this removed?",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-11-08T12:37:38Z",
          "body": "Can you add a `using namespace matrix` on top? Should become more readable w/o `matrix::` everywhere.",
          "path": "src/modules/vtol_att_control/tailsitter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-11-08T12:43:06Z",
          "body": "Is x here correct? Further down it's using z.",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T12:46:12Z",
          "body": "Note to myself: change to _thrust_sp",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:08:58Z",
          "body": "@bkueng Mistake during rebase",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:10:25Z",
          "body": "@bkueng Sure, good idea as it's not a header file.",
          "path": "src/modules/vtol_att_control/tailsitter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:44:51Z",
          "body": "Fixed",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:44:59Z",
          "body": "Done",
          "path": "src/modules/vtol_att_control/tailsitter.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:45:25Z",
          "body": "Fixed, for now use thrust_z as offboard is used for multicopters",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-08T13:45:33Z",
          "body": "Fixed",
          "path": "src/modules/mc_att_control/mc_att_control_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-11-08T16:01:21Z",
          "body": "It seems obvious that this is only done in fixed wing mode but where is that decision?",
          "path": "src/modules/navigator/gpsfailure.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-11-08T16:11:59Z",
          "body": "I strongly suggest that we use arrays to store vecotrs inside uORB messages like here:\r\nhttps://github.com/PX4/Firmware/blob/master/msg/vehicle_local_position_setpoint.msg#L20",
          "path": "msg/vehicle_attitude_setpoint.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-10T15:53:04Z",
          "body": "@MaEtUgR The gpsfailure class is only used for fixed wing. It's executed if the navigation state is set to NAVIGATION_STATE_AUTO_LANDGPSFAIL. If you go look into the commander you'll see that it's only used for fixed wing.",
          "path": "src/modules/navigator/gpsfailure.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-11-10T16:16:02Z",
          "body": "@MaEtUgR Done!",
          "path": "msg/vehicle_attitude_setpoint.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-10T18:21:22Z",
          "body": "@RomanBapst I believe this is the issue. Clang doesn't let you use static constexpr with these template functions.",
          "path": "src/modules/fw_att_control/FixedwingAttitudeControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-13T01:32:30Z",
          "body": "@RomanBapst I believe this change was done intentionally ~~for flaps deployment~~ to fix rudder stuttering in manual mode with FW_RLL_TO_YAW_FF. I'll track down the original so we can make sure the intended fix is preserved.",
          "path": "src/modules/fw_att_control/FixedwingAttitudeControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-11-13T01:33:25Z",
          "body": "https://github.com/PX4/Firmware/pull/9607",
          "path": "src/modules/fw_att_control/FixedwingAttitudeControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2018-11-20T16:40:40Z",
          "body": "Perfect thanks!",
          "path": "msg/vehicle_attitude_setpoint.msg",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "",
          "body": "Looks good generally. Flight Review is fine too, it's using the thrust from actuator_controls.\r\n\r\nIs the uavcan submodule update on purpose?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "",
          "body": "The multicopter part looks good, the fw, vtol as well for the part that I can still follow.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "This reverts https://github.com/PX4/Firmware/pull/9607",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic bug: a sign error in the throttle handling for stabilized mode introduced during a rebase, which produced incorrect control output (no/negative throttle) and caused unsafe behavior/crashes. Test logs and author comments confirm the incorrect control logic was identified and corrected, and subsequent test flights passed.",
    "patches": {
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -86,7 +86,7 @@ GpsFailure::on_active()\n \t\t\tatt_sp.timestamp = hrt_absolute_time();\n \t\t\tatt_sp.roll_body = math::radians(_param_openlooploiter_roll.get());\n \t\t\tatt_sp.pitch_body = math::radians(_param_openlooploiter_pitch.get());\n-\t\t\tatt_sp.thrust = _param_openlooploiter_thrust.get();\n+\t\t\tatt_sp.thrust_body[0] = _param_openlooploiter_thrust.get();\n \n \t\t\tQuatf q(Eulerf(att_sp.roll_body, att_sp.pitch_body, 0.0f));\n \t\t\tq.copyTo(att_sp.q_d);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/981eb9b4724a5196e0a350525cb6adf9f123d173/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "GpsFailure::on_active"
      ],
      "by_file": {
        "src/modules/navigator/gpsfailure.cpp": [
          "GpsFailure::on_active"
        ]
      }
    }
  },
  {
    "title": "Format strings",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10773",
    "number": 10773,
    "created_at": "2018-10-27T09:00:27Z",
    "merged": true,
    "merged_at": "2018-10-27T10:44:52Z",
    "state": "closed",
    "conversation": {
      "author": "m-ou-se",
      "body": "In #10766, I forgot a `%s` in a format string. Surprisingly to me, the compiler didn't warn me.\n\nThis PR enables GCC's `__attribute__((format))` which will make it validate the format strings, to prevent this kind of bugs.\n\nBy enabling it, I found (and fixed) many simliar bugs already in the code:\n\n- A `%d` for a pointer (replaced it by `%p`)\n- 2 cases of `%d` for a `ssize_t` (replaced it by `%zi`)\n- 18 cases of `%d`, `%u` or `%i` for a `size_t` (replaced it by `%zu`)\n- An unused formatting argument (removed it)\n- A missing `%d` (added it)\n- 2 cases of `%llu` for a `uint64_t` (replaced it by `\"%\" PRIu64`)\n- 6 cases of giving a string directly as format string, which would break if the string would contain any `%` signs. (replaced it by `(\"%s\", string)`)",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-10-27T09:11:24Z",
          "body": "One more required (uncovered by this PR): ```\r\nsrc/modules/uORB/CMakeFiles/modules__uORB.dir/uORBDeviceMaster.cpp.obj -c ../../src/modules/uORB/uORBDeviceMaster.cpp\r\nIn file included from ../../src/platforms/px4_defines.h:42:0,\r\n                 from ../../src/drivers/drv_orb_dev.h:43,\r\n                 from ../../src/modules/uORB/uORBCommon.hpp:37,\r\n                 from ../../src/modules/uORB/uORBDeviceMaster.hpp:38,\r\n                 from ../../src/modules/uORB/uORBDeviceMaster.cpp:34:\r\n../../src/modules/uORB/uORBDeviceMaster.cpp: In member function 'void uORB::DeviceMaster::showTop(char**, int)':\r\n../../src/platforms/px4_log.h:282:40: error: unknown conversion type character '-' in format [-Werror=format=]\r\n   px4_log_raw(level, fmt, ##__VA_ARGS__); \\\r\n                                        ^\r\n../../src/platforms/px4_log.h:429:33: note: in expansion of macro '__px4_log_raw'\r\n #define PX4_INFO_RAW(FMT, ...)  __px4_log_raw(_PX4_LOG_LEVEL_INFO, FMT, ##__VA_ARGS__)\r\n                                 ^~~~~~~~~~~~~\r\n../../src/modules/uORB/uORBDeviceMaster.cpp:371:4: note: in expansion of macro 'PX4_INFO_RAW'\r\n    PX4_INFO_RAW(CLEAR_LINE \"%*-s INST #SUB #MSG #LOST #QSIZE\\n\", (int)max_topic_name_length - 2, \"TOPIC NAME\");\r\n    ^~~~~~~~~~~~\r\ncompilation terminated due to -Wfatal-errors.\r\n```\r\n\r\nSee CI output for more. Thanks!",
          "type": "issue_comment"
        },
        {
          "author": "m-ou-se",
          "created_at": "2018-10-27T09:15:38Z",
          "body": "Interesting. That file uses `%*-s`, but `#ifdef`ed to only do that on NuttX. On other platforms, it uses `%*s`.\r\n\r\n`%*-s`, however, is invalid. I guess `%-*s` was meant? My best guess is that NuttX accepts this invalid specifier too, but other platforms don't, and that's why the `#ifdef` is there to begin with. If this is the case, we can just remove the `#ifdef`s completely, and use `%-*s`. I'm now trying to find the history of when those `#ifdef`s were added to check if there's another reason i'm missing.",
          "type": "issue_comment"
        },
        {
          "author": "m-ou-se",
          "created_at": "2018-10-27T09:20:09Z",
          "body": "Found the commit: f601428e821bcc781e1ae3a858035fc804e2027a adds those `#ifdef __PX4_NUTTX`'s, but the commit is rather large, and the message doesn't say anything specific about the format specifier:\r\n\r\n> add ifdef's where necessary to mitigate diffs between nuttx & posix\r\n\r\nI'll just assume `%-*s` was meant, and remove the `#ifdef __PX4_NUTTX` there.",
          "type": "issue_comment"
        },
        {
          "author": "m-ou-se",
          "created_at": "2018-10-27T09:28:17Z",
          "body": "Looks like there are many more of them, which are not found by a simple build on/for Linux.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-10-27T09:35:10Z",
          "body": "```make px4fmu-v5_default``` will likely uncover many of them. But I don't want to put that burden on you - we can distribute the effort. If you want to continue using that build command feel free to patch all of them.",
          "type": "issue_comment"
        },
        {
          "author": "m-ou-se",
          "created_at": "2018-10-27T09:55:50Z",
          "body": "That target doesn't build on my computer right now, so I'll just stay on the Posix target. Do you want to fix it for all other platforms before merging this? Or should we merge the fixes, but not the `__attribute__` yet? Or should we only enable the attribute, or enable/disable the `-Wformat` warning, on some specific targets?",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-10-27T10:30:03Z",
          "body": "The fmuv5 target is building successfully on my machine with your latest commit - I haven't checked out the attributes you set in detail, but you haven't disabled the checks, have you?",
          "type": "issue_comment"
        },
        {
          "author": "m-ou-se",
          "created_at": "2018-10-27T10:31:49Z",
          "body": "Nothing disabled. Just fixed a few more of them. Maybe those were the last?",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2018-10-27T10:35:38Z",
          "body": "This is looking pretty good now.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "Awesome, thanks for these fixes!",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes multiple incorrect format-string usages (missing %s, wrong conversion specifiers for pointers/size_t/uint64_t, passing strings as format templates, and an invalid \"%*-s\"), which cause incorrect output and can produce undefined or unexpected behavior. Enabling and using GCC's format attribute and correcting the specifiers addresses these logic bugs and prevents similar future errors.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "patch": "@@ -170,7 +170,7 @@ MissionFeasibilityChecker::checkGeofence(const mission_s &mission, float home_al\n \n \t\t\tif (MissionBlock::item_contains_position(missionitem) && !_navigator->get_geofence().check(missionitem)) {\n \n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %d\", i + 1);\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %zu\", i + 1);\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n@@ -200,11 +200,11 @@ MissionFeasibilityChecker::checkHomePositionAltitude(const mission_s &mission, f\n \t\t\t_navigator->get_mission_result()->warning = true;\n \n \t\t\tif (throw_error) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: No home pos, WP %d uses rel alt\", i + 1);\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: No home pos, WP %zu uses rel alt\", i + 1);\n \t\t\t\treturn false;\n \n \t\t\t} else\t{\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Warning: No home pos, WP %d uses rel alt\", i + 1);\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Warning: No home pos, WP %zu uses rel alt\", i + 1);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n@@ -217,11 +217,11 @@ MissionFeasibilityChecker::checkHomePositionAltitude(const mission_s &mission, f\n \t\t\t_navigator->get_mission_result()->warning = true;\n \n \t\t\tif (throw_error) {\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: Waypoint %d below home\", i + 1);\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: Waypoint %zu below home\", i + 1);\n \t\t\t\treturn false;\n \n \t\t\t} else\t{\n-\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Warning: Waypoint %d below home\", i + 1);\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Warning: Waypoint %zu below home\", i + 1);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/78287fd4561a34b798dad2c327e2b1b2ab9d995b/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkHomePositionAltitude",
        "MissionFeasibilityChecker::checkGeofence"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkHomePositionAltitude",
          "MissionFeasibilityChecker::checkGeofence"
        ]
      }
    }
  },
  {
    "title": "fix reposition: set acceptance radius",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10760",
    "number": 10760,
    "created_at": "2018-10-25T15:02:47Z",
    "merged": true,
    "merged_at": "2018-10-25T15:05:28Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "Previously the acceptance radius was 0, so the FlightTaskAutoLine was\r\nrandomly changing yaw and sometimes going into a random direction (see  #10757).\r\n\r\nThere is still something else wrong in there, but this patch avoids the reposition bug. I see 2 problems:\r\n- The FlightTaskAuto contains states and resets certain attributes when switching (https://github.com/PX4/Firmware/blob/master/src/lib/FlightTasks/tasks/Auto/FlightTaskAuto.cpp#L468). In case of the reposition, the switches were random due to numerical inaccuracies. If possible we should avoid these states.\r\n- FlightTaskAutoLine uses _target and _prev_wp to determine the velocity direction (https://github.com/PX4/Firmware/blob/master/src/lib/FlightTasks/tasks/AutoLine/FlightTaskAutoLine.cpp#L79). However this might not reflect where the vehicle currently is (I guess the states are meant to prevent this, but it doesn't seem to work).\r\n\r\nThe combination of all these led to the unexpected behavior.\r\n\r\nFixes #10757\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect runtime behavior caused by an acceptance radius of zero which led to random state switches and wrong velocity/yaw decisions in FlightTaskAutoLine; this is a logic bug (improper state transitions and boundary condition handling). The change to set a nonzero acceptance radius prevents the unintended direction/yaw changes, addressing the reported incorrect behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -319,6 +319,7 @@ Navigator::run()\n \t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\trep->current.cruising_speed = get_cruising_speed();\n \t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n+\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n \n \t\t\t\t// Go on and check which changes had been requested\n \t\t\t\tif (PX4_ISFINITE(cmd.param4)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/92b9c747a0f4892a482ed947e3877c100c519737/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Mission Log",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10738",
    "number": 10738,
    "created_at": "2018-10-22T11:09:20Z",
    "merged": true,
    "merged_at": "2018-10-26T06:02:43Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "This adds a new log file to the SD card configurable via `SDLOG_MISSION` parameter.\n\n### Use-cases\nIt's also a ULog file, but only contains minimal information for the following use-cases:\n- geotagging/survey (more generally: extract data collected by the pixhawk during a mission and needed for post-processing)\n- cloud upload & statistics: keeping track of where and how long a vehicle has flown, and if there were problems.\n- regulation: keeping a small log to show where a drone was flown, what failures happened etc.\n\nIt is stored in another directory (`mission_log`) to keep the logs separate from the normal flight logs.\n\n@dogmaphobic This will need an interface update on the QGC side, and maybe changes/extensions to the log download. I have not looked into that yet.\n\n### Implementation\n- the general structure of the logger is the same, but the mission logs use a separate independent write buffer.\n- optimization to reduce the header size: now only the message formats are written for messages that are actually logged. Reduces the header size by about 13KB for a normal log.\n- due to other optimizations, RAM usage does not increase if the mission log is disabled.\n  If enabled, only the additional buffer of 300 bytes is required.\n\n### Testing\nI ran a stress-test on a low-quality SD card for 1h:30min with 90KB/s normal logging rate and enabled mission log with 5Hz camera capture publication. There were no drops for the mission log, and the maximum used buffer was 200 bytes, so 300 bytes buffer size will be enough.\nCPU load minimally increased from 5.6% + 1.7% to 5.7% + 1.8% for the main and writer threads.\n\nFixes https://github.com/PX4/Firmware/issues/10189.\n\nI enabled the mission log by default so that we get it field-tested. But it does not have to be enabled later on.",
      "issue_comments": [
        {
          "author": "hamishwillee",
          "created_at": "2018-10-23T01:19:35Z",
          "body": "Looks cool. I commented on the parameter doc.\r\n\r\nCan we also update the user guide with this and also cover the other SDLOG_ params? Proposal is that this should be added in user guide https://docs.px4.io/en/getting_started/flight_reporting.html\r\n- Add a section on \"Configuring logging\" covering all the params\r\n- Explain which logs can be used for what - for example, is Mission Log useful in Flight Reporting?\r\n\r\nI thought it would be good to add a link to the geotagging log in geotagging docs, but we don't have any. Do we need a page that covers what we offer in this area? If so, what would such a page offer?\r\n\r\nLast of all, I looked at the devguide logging topic https://dev.px4.io/en/log/logging.html\r\nMy guess is that the logger is set up with all the rates information etc when the board is set up - and the user guide people don't need to know about this?\r\nShould we perhaps just add a note in that logging topic about the SDLOG parameters. ",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-10-23T10:12:13Z",
          "body": "> Can we also update the user guide with this and also cover the other SDLOG_ params? Proposal is that this should be added in user guide https://docs.px4.io/en/getting_started/flight_reporting.html\r\n\r\nOk.\r\n\r\n> Explain which logs can be used for what - for example, is Mission Log useful in Flight Reporting?\r\n\r\nNo.\r\n\r\n> I thought it would be good to add a link to the geotagging log in geotagging docs, but we don't have any. Do we need a page that covers what we offer in this area? If so, what would such a page offer?\r\n\r\nYes we should have that. But I don't know of anything that exists already either.\r\n\r\n> My guess is that the logger is set up with all the rates information etc when the board is set up - and the user guide people don't need to know about this?\r\n\r\nYou generally don't have to change anything, since the defaults are good for general log analysis. Special use-cases that differ from that include:\r\n- ekf2 replay\r\n- enabling the high-rate logging profile for PID & filter tuning\r\n- if you want your own set of logged topics.\r\n- thermal temperature calibration",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2018-10-24T01:44:58Z",
          "body": "Thanks @bkueng . I'll look into updates to those docs once this is merged.",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-10-24T07:42:21Z",
          "body": "CI fails:\r\n> remote file operation failed: /tmp/jenkins/workspace/irmware-compile_mission_log-VMOKXZB2XWPNUMKC2VMXOFD4RIUCZ46BF3YVCQJRPP6QGICMO3JA@tmp/durable-cb023d6c at hudson.remoting.Channel@61b65624:ec2_docker_slave (i-0001bbab6136cffbf): java.nio.file.FileSystemException: /tmp/jenkins/workspace/irmware-compile_mission_log-VMOKXZB2XWPNUMKC2VMXOFD4RIUCZ46BF3YVCQJRPP6QGICMO3JA@tmp/durable-cb023d6c: No space left on device\r\n\r\n@dagar can you look into it?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-24T14:30:12Z",
          "body": "@bkueng we had a zombie ec2 slave. I'll restart these jobs now.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-24T16:36:02Z",
          "body": "~~Some may want vehicle_attitude as well. Pix4d can optionally use roll, pitch, yaw.~~\r\n\r\nNevermind, just reviewed the contents of camera_capture.",
          "type": "issue_comment"
        },
        {
          "author": "Avysuarez",
          "created_at": "2018-10-25T20:12:19Z",
          "body": "I tested in pixhawk 4 and pixhawk 4 mini in both created a folder with the name of mission_log.\r\npixhawk 4 log\r\nhttps://review.px4.io/plot_app?log=eaed8008-87c9-40a3-b209-d23c50208f5f\r\npixhawk 4 mini log\r\nhttps://review.px4.io/plot_app?log=f074290a-4f59-4cff-9a05-23adf99b21ef",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2018-10-26T03:53:16Z",
          "body": "@bkueng OK, docs for this waiting in https://github.com/PX4/px4_user_guide/pull/372 . Note that they are only peripherally about the mission log - without a topic about something that uses it (e.g. geofencing) there isn't much to say about it yet. So consider this \"a start\".",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "hamishwillee",
          "created_at": "2018-10-23T01:00:59Z",
          "body": "HOw about:\r\n\r\n```\r\n/**\r\n * Mission Log\r\n *\r\n * If enabled, a small additional \"mission\" log file will be written to the SD card.\r\n * The log contains just those messages that are useful for tasks like \r\n * generating flight statistics and geotagging.\r\n *\r\n * The different modes can be used to further reduce the logged data\r\n * (and thus the log file size). For example, choose geotagging mode to\r\n * only log data required for geotagging.\r\n\r\n * Note that the normal/full log is still created, and contains all\r\n * the data in the mission log (and more).\r\n */\r\n```\r\n\r\nThe `@value 1 Complete` was also a little confusing to me when I first saw it, because I thought maybe this meant \"full log\", rather than just \"Complete mission log\".\r\nMaybe it is ok. Alternative: \r\n```\r\n * @value 0 Disabled\r\n * @value 1 All mission messages\r\n * @value 2 Geotagging mission messages\r\n```",
          "path": "src/modules/logger/params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-10-23T10:11:44Z",
          "body": "Thanks, updated accordingly.",
          "path": "src/modules/logger/params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-24T16:27:09Z",
          "body": "Picky minor side note - we should have some basic float literal guidelines. Inconsistent use of `0.f`, `0.0f`, `0.0F` throughout the codebase should be an easy eyesore to avoid.",
          "path": "src/modules/navigator/navigator.h",
          "position": 25,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-24T16:31:50Z",
          "body": "vehicle_status is published at 1Hz or when something changes.",
          "path": "src/modules/logger/logger.cpp",
          "position": 167,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-10-25T07:26:41Z",
          "body": "I saw that, but I wanted to be explicit/conservative here in case something changes in commander.",
          "path": "src/modules/logger/logger.cpp",
          "position": 167,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2018-10-25T07:26:43Z",
          "body": "Yeah. I have no problem overlooking those though.",
          "path": "src/modules/navigator/navigator.h",
          "position": 25,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR adds a new mission log feature and optimizations (separate write buffer, reduced header size) rather than correcting incorrect program logic. The changes introduce new behavior and functionality, not a fix for an unintended or incorrect algorithm/state transition, so it does not address a logic error.",
    "patches": {
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "patch": "@@ -283,8 +283,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat\t\tget_yaw_timeout() const { return _param_yaw_timeout.get(); }\n \tfloat\t\tget_yaw_threshold() const { return _param_yaw_err.get(); }\n \n-\tfloat\t\tget_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss.get(); }\n-\tfloat\t\tget_vtol_reverse_delay() const { return _param_reverse_delay.get(); }\n+\tfloat\t\tget_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss; }\n+\tfloat\t\tget_vtol_reverse_delay() const { return _param_reverse_delay; }\n \n \tbool\t\tforce_vtol();\n \n@@ -371,13 +371,14 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamFloat<px4::params::MIS_LTRMIN_ALT>) _param_loiter_min_alt,\n \t\t(ParamFloat<px4::params::MIS_TAKEOFF_ALT>) _param_takeoff_min_alt,\n \t\t(ParamFloat<px4::params::MIS_YAW_TMT>) _param_yaw_timeout,\n-\t\t(ParamFloat<px4::params::MIS_YAW_ERR>) _param_yaw_err,\n-\n-\t\t// VTOL parameters TODO: get these out of navigator\n-\t\t(ParamFloat<px4::params::VT_B_DEC_MSS>) _param_back_trans_dec_mss,\n-\t\t(ParamFloat<px4::params::VT_B_REV_DEL>) _param_reverse_delay\n+\t\t(ParamFloat<px4::params::MIS_YAW_ERR>) _param_yaw_err\n \t)\n \n+\tparam_t _handle_back_trans_dec_mss{PARAM_INVALID};\n+\tparam_t _handle_reverse_delay{PARAM_INVALID};\n+\tfloat _param_back_trans_dec_mss{0.f};\n+\tfloat _param_reverse_delay{0.f};\n+\n \tfloat _mission_cruising_speed_mc{-1.0f};\n \tfloat _mission_cruising_speed_fw{-1.0f};\n \tfloat _mission_throttle{-1.0f};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/214c433b4da91ec10837f39edca13348084d5926/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -110,6 +110,9 @@ Navigator::Navigator() :\n \t_navigation_mode_array[8] = &_land;\n \t_navigation_mode_array[9] = &_precland;\n \t_navigation_mode_array[10] = &_follow_target;\n+\n+\t_handle_back_trans_dec_mss = param_find(\"VT_B_DEC_MSS\");\n+\t_handle_reverse_delay = param_find(\"VT_B_REV_DEL\");\n }\n \n void\n@@ -162,6 +165,14 @@ Navigator::params_update()\n \tparameter_update_s param_update;\n \torb_copy(ORB_ID(parameter_update), _param_update_sub, &param_update);\n \tupdateParams();\n+\n+\tif (_handle_back_trans_dec_mss != PARAM_INVALID) {\n+\t\tparam_get(_handle_back_trans_dec_mss, &_param_back_trans_dec_mss);\n+\t}\n+\n+\tif (_handle_reverse_delay != PARAM_INVALID) {\n+\t\tparam_get(_handle_reverse_delay, &_param_reverse_delay);\n+\t}\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/214c433b4da91ec10837f39edca13348084d5926/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::params_update",
        "get_vtol_back_trans_deceleration",
        "get_vtol_reverse_delay",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/navigator.h": [
          "get_vtol_back_trans_deceleration",
          "get_vtol_reverse_delay"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::params_update",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "fixes cherry-picked to stable",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10726",
    "number": 10726,
    "created_at": "2018-10-19T14:21:59Z",
    "merged": true,
    "merged_at": "2018-10-20T00:11:15Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "https://github.com/PX4/Firmware/issues/10064\n\n@PX4/testflights please test this pull request, it will become the v1.8.1 release.",
      "issue_comments": [
        {
          "author": "Avysuarez",
          "created_at": "2018-10-19T18:45:08Z",
          "body": "**> Some flights with pixhawk 4 mini (v5)** \r\n\r\nGood flight, but in altitude mode their was a delay in the throttle to rise.\r\nhttps://review.px4.io/plot_app?log=d511ed58-1d33-4177-bfe1-76acb8686c44\r\nhttps://review.px4.io/plot_app?log=8902f3b5-a550-46ce-89a2-77d4d082a12b\r\nhttps://review.px4.io/plot_app?log=61bfd603-50d1-4e8e-af2b-3c42d9116e21\r\n\r\n**> Some flights with pixhawk 4 (v5)**\r\n\r\nGood flight, no issues.\r\nhttps://review.px4.io/plot_app?log=49b0015c-92f3-4998-b606-b3acd1f7c277\r\nhttps://review.px4.io/plot_app?log=ae2fa213-b0ad-4ff8-acd6-a2c040fb187e\r\nhttps://review.px4.io/plot_app?log=05643504-de97-47ae-86ac-42f148358866\r\n\r\n### **Some flights with pixhawk 2.1 (v3)**\r\nGood flight, no issues\r\nhttps://review.px4.io/plot_app?log=7c160989-2153-44ea-a333-e168a1fbe9eb\r\nhttps://review.px4.io/plot_app?log=2d2d2700-104f-46e4-9591-1891b83fd5e7\r\n\r\n**Some flights with Pixracer (v4)**\r\nGood flight, no issues.\r\nhttps://review.px4.io/plot_app?log=0325ff4e-4176-4a2e-a536-f1a5d7a8f5bc\r\nhttps://review.px4.io/plot_app?log=0ad44079-a441-40be-bce5-76b473bb248b\r\nhttps://review.px4.io/plot_app?log=961df6e1-7354-423b-8a88-f5af71c6c4d0",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-20T00:11:05Z",
          "body": "Thanks for the summary @Avysuarez. These look consistent with v1.8.0 stable, which still needs a few more commits for full pixhawk 4 mini support.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR is a release/cherry-pick PR with no description of a specific code change addressing the reported throttle-delay behavior. The comments describe an unintended runtime behavior (which would be a logic issue), but the maintainer notes the behavior is consistent with the current stable and that additional commits are required for full hardware support â€” there is no evidence this PR actually contains a logic fix.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "patch": "@@ -1297,8 +1297,15 @@ Mission::altitude_sp_foh_update()\n \t\treturn;\n \t}\n \n+\t// Calculate acceptance radius, i.e. the radius within which we do not perform a first order hold anymore\n+\tfloat acc_rad = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n+\n+\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n+\t\tacc_rad = _navigator->get_acceptance_radius(fabsf(_mission_item.loiter_radius) * 1.2f);\n+\t}\n+\n \t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n-\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < FLT_EPSILON) {\n+\tif (_distance_current_previous - acc_rad < FLT_EPSILON) {\n \t\treturn;\n \t}\n \n@@ -1327,7 +1334,7 @@ Mission::altitude_sp_foh_update()\n \n \t/* if the minimal distance is smaller then the acceptance radius, we should be at waypoint alt\n \t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n-\tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n+\tif (_min_current_sp_distance_xy < acc_rad) {\n \t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n \n \t} else {\n@@ -1337,8 +1344,7 @@ Mission::altitude_sp_foh_update()\n \t\t * radius around the current waypoint\n \t\t **/\n \t\tfloat delta_alt = (get_absolute_altitude_for_item(_mission_item) - pos_sp_triplet->previous.alt);\n-\t\tfloat grad = -delta_alt / (_distance_current_previous - _navigator->get_acceptance_radius(\n-\t\t\t\t\t\t   _mission_item.acceptance_radius));\n+\t\tfloat grad = -delta_alt / (_distance_current_previous - acc_rad);\n \t\tfloat a = pos_sp_triplet->previous.alt - grad * _distance_current_previous;\n \t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2c30a803c6ad477e6cdbc0a597da671523b4a130/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::altitude_sp_foh_update"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::altitude_sp_foh_update"
        ]
      }
    }
  },
  {
    "title": "ekf2: increase min value of MAG_YAWLIM",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10721",
    "number": 10721,
    "created_at": "2018-10-18T15:42:35Z",
    "merged": true,
    "merged_at": "2018-10-22T13:26:07Z",
    "state": "closed",
    "conversation": {
      "author": "CarlOlsson",
      "body": "- Some fixed wing platforms require a higher value of EKF2_MAG_YAWLIM in order not to constantly switch mag fusion mode during straight lines in gusty weather. [Relevant commit](https://github.com/PX4/Firmware/commit/1cdfaaf2e19d1a8fb988679d968c68ae0b0d1742)\n- Also fixed some typos",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-10-18T16:53:40Z",
          "body": "Just a personal preference? I've added some other perf counters with spaces in the name, but don't really care either way.",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "CarlOlsson",
          "created_at": "2018-10-18T18:26:12Z",
          "body": "I was doing some tests and noticed that all others had underscores so thought it was inconsistent. But if that is not the case, yes I would prefer underscores ",
          "path": "src/modules/fw_pos_control_l1/FixedwingPositionControl.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The change raises the minimum allowed MAG_YAWLIM to prevent frequent, unintended mag-fusion mode switches on fixed-wing platforms in gusty conditions â€” an incorrect state transition/behavior caused by an overly small threshold. This is a behavioral/logic fix (tuning of control logic threshold) rather than a syntax/style change.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -554,7 +554,7 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tcase NAV_CMD_LOITER_TO_ALT:\n \n \t\t// initially use current altitude, and switch to mission item altitude once in loiter position\n-\t\tif (_navigator->get_loiter_min_alt() > 0.0f) { // ignore _param_loiter_min_alt if smaller then 0 (-1)\n+\t\tif (_navigator->get_loiter_min_alt() > 0.0f) { // ignore _param_loiter_min_alt if smaller than 0 (-1)\n \t\t\tsp->alt = math::max(_navigator->get_global_position()->alt,\n \t\t\t\t\t    _navigator->get_home_position()->alt + _navigator->get_loiter_min_alt());\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a663b9fd87c0362f198e18972e76923b8687a443/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -126,7 +126,7 @@ enum NAV_FRAME {\n /**\n  * Global position setpoint in WGS84 coordinates.\n  *\n- * This is the position the MAV is heading towards. If it of type loiter,\n+ * This is the position the MAV is heading towards. If it is of type loiter,\n  * the MAV is circling around it with the given loiter radius in meters.\n  *\n  * Corresponds to one of the DM_KEY_WAYPOINTS_OFFBOARD_* dataman items",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a663b9fd87c0362f198e18972e76923b8687a443/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "DeltaTag: enhanced geo-referencing survey images",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10715",
    "number": 10715,
    "created_at": "2018-10-17T22:02:25Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "DeltaTag provides an alternate method to geo-referencing images from survey missions.\r\nIt uses the delta in seconds between the images and the delta between the triggers to \r\nmatch geo information with pictures, allowing for mission images.\r\n\r\nIt uses the last image and last trigger event as a calibration point as errors are\r\nmore likely to arrise in the first images (test triggers, booting cameras, etc)\r\n\r\nNote: DeltaTag does not make copies, it writes the Exif information directly to the images\r\n\r\nInstall: sudo pip install pyulog piexif Pillow\r\nRun: python deltatag.py [logfile] [image dir] (optional offset)\r\neg: python deltatag.py mylog.ulg ./images\r\n\r\nParameters\r\nlogfile: a ulog formatted logfile containing camera_capture events (survey missions)\r\nimage_dir: the directory where the images are located\r\noffset (optional): skip [offset] triggers to reference the last image\r\n                   0 means the last trigger event equals last image (default)\r\n                   1 means the second last trigger event equals last image\r\n                   ...etc",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR introduces a new feature (DeltaTag) to geo-reference images by matching time deltas and using the last trigger as a calibration point. The description and comments present it as additional functionality rather than a correction of incorrect program logic; there is no mention of a previously incorrect behavior or a bug being fixed.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "patch": "@@ -812,6 +812,12 @@ Mission::set_mission_items()\n \n \t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n \n+\t\t\t\t\t/*\n+\t\t\t\t\t * This will make the vehicle proceed directly to the land waypoint in the next stage\n+\t\t\t\t\t * and not attempt to line up with the plotted path first\n+\t\t\t\t\t */\n+\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.valid = false;\n+\n \t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n \t\t\t\t}\n \n@@ -1106,7 +1112,8 @@ Mission::do_need_move_to_land()\n \t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n \t\t\t\t  _navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n \n-\t\treturn d_current > _navigator->get_acceptance_radius();\n+\t\t/* using default acceptance radius as a back transition item can result in a FW acceptance radius being returned */\n+\t\treturn d_current > _navigator->get_default_acceptance_radius();\n \t}\n \n \treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bac541f84d39e783ad659d373f66926dc90e49e9/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::set_mission_items",
        "Mission::do_need_move_to_land"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items",
          "Mission::do_need_move_to_land"
        ]
      }
    }
  },
  {
    "title": "Triplets  acceptance radius",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10632",
    "number": 10632,
    "created_at": "2018-10-03T14:09:28Z",
    "merged": true,
    "merged_at": "2018-10-09T16:01:46Z",
    "state": "closed",
    "conversation": {
      "author": "mrivi",
      "body": "**Describe problem solved by the proposed pull request**\nThe `acceptance_radius` field of a triplet is set only when explicitly setting param2 in the mission item (see https://github.com/PX4/Firmware/pull/10413#discussion_r218913242). When using the default `NAV_ACC_RAD`, the field in the triplet is always `0.0`.\nThis PR sets the triplet  `acceptance_radius` to the default `NAV_ACC_RAD` unless the mission item has a param2 different from zero. The triplet field is checked in the Auto FlightTasks instead of the parameter. \n\n**Test data / coverage**\nOnly tested on SITL.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2018-10-03T14:46:27Z",
          "body": "It's not clear to me how acceptance radius not set is supposed to be expressed. This is the type of thing that's unclear in the mavlink spec. At the moment I'm guessing 0 or NAN could both be used.\r\n\r\n![image](https://user-images.githubusercontent.com/84712/46418202-4b764a80-c6f9-11e8-9841-e26b0f2e9b52.png)\r\n\r\nhttps://mavlink.io/en/messages/common.html#MAV_CMD\r\n\r\n@DonLakeFlyer could you provide any insight here?",
          "type": "issue_comment"
        },
        {
          "author": "DonLakeFlyer",
          "created_at": "2018-10-03T16:04:45Z",
          "body": "QGC sets to 0 to mean not set.",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-10-03T16:04:55Z",
          "body": "@dagar Right now, param2 is zero when not set",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2018-10-08T09:16:30Z",
          "body": "careful: VTOL_LAND sets a dynamic acceptance radius on the setpoint.",
          "type": "issue_comment"
        },
        {
          "author": "mrivi",
          "created_at": "2018-10-08T09:35:19Z",
          "body": "@sanderux could you please point me to where the acceptance radius is dynamically changed?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-09T16:01:41Z",
          "body": "@sanderux we need to fix and review that for VTOL regardless.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-10-03T19:57:17Z",
          "body": "To be paranoid (until it's documented) could you check ISFINITE as well? Setting the default in else would also be slightly better (only touching sp->acceptance_radius once).",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error where triplet.acceptance_radius stayed 0.0 when param2 was unset, causing Auto FlightTasks to use an unintended zero acceptance radius instead of the default NAV_ACC_RAD. This is an incorrect state/conditional handling bug (improper propagation of a default parameter into the triplet) and the PR corrects it by populating the triplet with the default unless param2 is explicitly set. Note: VM/VTOL-specific dynamic acceptance-radius behavior noted in comments should still be reviewed, but that doesn't change that the original behavior was a logic bug.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "patch": "@@ -508,7 +508,14 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n \t\t\t    _navigator->get_loiter_radius();\n \tsp->loiter_direction = (item.loiter_radius > 0) ? 1 : -1;\n-\tsp->acceptance_radius = item.acceptance_radius;\n+\n+\tif (item.acceptance_radius > 0.0f && PX4_ISFINITE(item.acceptance_radius)) {\n+\t\t// if the mission item has a specified acceptance radius, overwrite the default one from parameters\n+\t\tsp->acceptance_radius = item.acceptance_radius;\n+\n+\t} else {\n+\t\tsp->acceptance_radius = _navigator->get_default_acceptance_radius();\n+\t}\n \n \tsp->cruising_speed = _navigator->get_cruising_speed();\n \tsp->cruising_throttle = _navigator->get_cruising_throttle();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3f36f5fb96091afbd9c359ac83e4263e4a1ebadf/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "VTOL fix back transition navigation path for final MC stretch",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10628",
    "number": 10628,
    "created_at": "2018-10-02T21:26:30Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "Fixes https://github.com/PX4/Firmware/issues/10539\n\nInvalidates the previous setpoint (back transition itself).\n\nAlso skips the do_need_move_to_land as this step is always required and the variable acceptance radius could make it skip the final meters and make it start descent directly if the vtol_land waypoint is too close",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2018-10-03T07:56:14Z",
          "body": "@bresch Could you please review?",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-03T14:16:45Z",
          "body": "Dropped do_need_move_to_land() is likely breaking FW.\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-03T14:19:06Z",
          "body": " * fixes https://github.com/PX4/Firmware/issues/10590",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-03T14:24:02Z",
          "body": "Could we please clarify the actual (intended) requirements with all of this mission logic? It's quite convoluted.\r\n\r\n### Intended Behaviour\r\n\r\n * When executing a landing mission item a multicopter should first move to the landing position at the current altitude. If already within the acceptance radius then start executing the landing immediately. \r\n",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2018-10-07T18:26:16Z",
          "body": "@dagar better?",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2018-10-16T09:09:42Z",
          "body": "@dagar Can we bring this in now? From what I understand changes to the navigator logic in this [PR](https://github.com/PX4/Firmware/pull/8749) have changed the behavior for VTOL doing back-transitions.\r\n At the moment I could not think of a better fix and even if I wanted to try it would involve a lot of time going through the navigator logic which has reached quite some level of complexity.\r\nSo unless you have a better idea I think we should merge this.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-16T12:18:46Z",
          "body": "Why does it make sense to mark the current position setpoint invalid, but not publish the updated triplet? ",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2018-10-17T15:18:28Z",
          "body": "Waiting for @RomanBapst for a better method",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2018-10-03T14:17:10Z",
          "body": "Comment explaining why?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 8,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2018-10-03T14:18:01Z",
          "body": "Regular FW implications?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2018-10-03T21:24:54Z",
          "body": "The acceptance radius on a vtol_land is assigned dynamically based on ground speed. It does this to estimate the distance where it should start the back transition.\r\n\r\nFor a fixed wing the default acceptance radius is used. The do_need_move_to_land would result in skipping the workitem that sets the intermediate waypoint to navigate towards the land site before commencing landing. It would only be skipped if the fixed wing was already withing the acceptance radius of the land waypoint when it got to that waypoint. Even if this would happen (which would be very odd) and we remove this condition it would only result in setting the nav item and directly accepting it as done.\r\n\r\nI do not see how this could affect a fixed wing mission in reality. Let me know if you think it can.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect mission/navigation behavior (state/waypoint handling) for VTOL back-transition and landing: the acceptance-radius check could cause the vehicle to skip the final multicopter approach and start descent prematurely, and the previous setpoint/state needed invalidation. Review comments note potential regressions, but the change targets an unintended state transition and conditional logic bug in the navigator, so this is a logic error fix.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "patch": "@@ -812,6 +812,12 @@ Mission::set_mission_items()\n \n \t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n \n+\t\t\t\t\t/*\n+\t\t\t\t\t * This will make the vehicle proceed directly to the land waypoint in the next stage\n+\t\t\t\t\t * and not attempt to line up with the plotted path first\n+\t\t\t\t\t */\n+\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.valid = false;\n+\n \t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n \t\t\t\t}\n \n@@ -1106,7 +1112,8 @@ Mission::do_need_move_to_land()\n \t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n \t\t\t\t  _navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n \n-\t\treturn d_current > _navigator->get_acceptance_radius();\n+\t\t/* using default acceptance radius as a back transition item can result in a FW acceptance radius being returned */\n+\t\treturn d_current > _navigator->get_default_acceptance_radius();\n \t}\n \n \treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/afa2ed1b5554418715693dde273ceb0446d6d47d/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::set_mission_items",
        "Mission::do_need_move_to_land"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items",
          "Mission::do_need_move_to_land"
        ]
      }
    }
  },
  {
    "title": "[WIP] navigator initialization and mode change improvements",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/10611",
    "number": 10611,
    "created_at": "2018-09-30T18:52:58Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": " - safely initialize every MissionBlock's _mission_item\n - allow position setpoint triplets with no valid position setpoint to be published\n   - this ensures that the position controllers don't accidentally use an old position setpoint \n - move loiter and takeoff reposition handling into each class (full position setpoint triplet isn't needed)\n - delete dead code\n\n\n**Needs testing**\n\n### Test\n - [ ] takeoff -> hold\n - [ ] reposition usage\n - [ ] switching modes",
      "issue_comments": [
        {
          "author": "dakejahl",
          "created_at": "2018-10-05T17:38:05Z",
          "body": "SITL test's worked fine, real world test not so much....\r\nhttps://review.px4.io/plot_app?log=f464696e-00bb-48a8-b82f-00e089d2fa98\r\n\r\n1. Issued a `takeoff`\r\n2. After successful takeoff then transition into loiter, changed to `position`\r\n3. Flew it forward a bit, no issues\r\n4. Issued `return` \r\n5. Quad begin to roll to reposition...kept rolling and then went inverted and smashed into the ground\r\n\r\nThis is flying todays `master` with `pr-navigator-robust` pulled on top of that.",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2018-10-09T21:05:39Z",
          "body": "FYI @dagar I flew this again but this time using an RC setup.... Definitely not safe to fly! haha\r\n\r\nhttps://review.px4.io/plot_app?log=0d5f3f53-d3cc-4946-b125-cfeb4881ac8a\r\n\r\nedit: hardfaults as it starts to roll to move towards home...\r\n\r\n![selection_001](https://user-images.githubusercontent.com/37091262/46699087-ff824480-cbd5-11e8-97ec-47c6a420236c.png)\r\n\r\nSanity check.... SITL works fines, no local changes in navigator",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-07-10T17:37:08Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-07-24T18:56:34Z",
          "body": "Closing as stale.\n",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2019-10-23T09:12:32Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "stale[bot]",
          "created_at": "2020-01-22T18:30:46Z",
          "body": "This issue has been automatically marked as stale because it has not had recent activity. Thank you for your contributions.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2020-01-22T20:15:53Z",
          "body": "The majority of the changes here eventually ended up in master.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "",
          "body": ":hankey: ",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR targets improper state/data-flow (uninitialized MissionBlock _mission_item and publishing of position setpoint triplets without a valid position), which can cause controllers to use stale/incorrect setpoints and produce unsafe behavior. These are classic logic errors (incorrect state handling and boundary/initialization conditions) rather than syntax/style fixes.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "patch": "@@ -56,7 +56,7 @@ Land::on_activation()\n \treset_mission_item_reached();\n \n \t/* convert mission item to current setpoint */\n-\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \tpos_sp_triplet->previous.valid = false;\n \tmission_apply_limitation(_mission_item);\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n@@ -73,19 +73,22 @@ Land::on_active()\n \t/* for VTOL update landing location during back transition */\n \tif (_navigator->get_vstatus()->is_vtol &&\n \t    _navigator->get_vstatus()->in_transition_mode) {\n-\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \t\tpos_sp_triplet->current.lat = _navigator->get_global_position()->lat;\n \t\tpos_sp_triplet->current.lon = _navigator->get_global_position()->lon;\n+\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n \n \n \tif (_navigator->get_land_detected()->landed) {\n+\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n \t\tset_idle_item(&_mission_item);\n \n-\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 14,
        "changes": 32,
        "patch": "@@ -57,7 +57,7 @@ Loiter::on_inactive()\n void\n Loiter::on_activation()\n {\n-\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\tif (_reposition.valid) {\n \t\treposition();\n \n \t} else {\n@@ -68,7 +68,7 @@ Loiter::on_activation()\n void\n Loiter::on_active()\n {\n-\tif (_navigator->get_reposition_triplet()->current.valid) {\n+\tif (_reposition.valid) {\n \t\treposition();\n \t}\n \n@@ -98,8 +98,6 @@ Loiter::set_loiter_position()\n \t\treturn;\n \t}\n \n-\t_loiter_pos_set = true;\n-\n \t// set current mission item to loiter\n \tset_loiter_item(&_mission_item, _navigator->get_loiter_min_alt());\n \n@@ -113,6 +111,8 @@ Loiter::set_loiter_position()\n \n \t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n \t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t_loiter_pos_set = true;\n }\n \n void\n@@ -123,25 +123,29 @@ Loiter::reposition()\n \t\treturn;\n \t}\n \n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_reposition_triplet();\n-\n-\tif (rep->current.valid) {\n+\tif (_reposition.valid) {\n \t\t// set loiter position based on reposition command\n \n-\t\t// convert mission item to current setpoint\n-\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\t\tpos_sp_triplet->current.velocity_valid = false;\n-\t\tpos_sp_triplet->previous.yaw = _navigator->get_global_position()->yaw;\n+\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t\t// previous: current position\n \t\tpos_sp_triplet->previous.lat = _navigator->get_global_position()->lat;\n \t\tpos_sp_triplet->previous.lon = _navigator->get_global_position()->lon;\n \t\tpos_sp_triplet->previous.alt = _navigator->get_global_position()->alt;\n-\t\tmemcpy(&pos_sp_triplet->current, &rep->current, sizeof(rep->current));\n+\t\tpos_sp_triplet->previous.yaw = _navigator->get_global_position()->yaw;\n+\t\tpos_sp_triplet->previous.valid = true;\n+\n+\t\t// current: use reposition\n+\t\tpos_sp_triplet->current = _reposition;\n+\t\tpos_sp_triplet->current.velocity_valid = false;\n+\n+\t\t// next: invalid\n \t\tpos_sp_triplet->next.valid = false;\n \n \t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \n-\t\t// mark this as done\n-\t\tmemset(rep, 0, sizeof(*rep));\n+\t\t// clear the reposition to mark as done\n+\t\t_reposition = position_setpoint_s{};\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "patch": "@@ -55,14 +55,7 @@ class Loiter : public MissionBlock, public ModuleParams\n \tvoid on_activation() override;\n \tvoid on_active() override;\n \n-\t// TODO: share this with mission\n-\tenum mission_yaw_mode {\n-\t\tMISSION_YAWMODE_NONE = 0,\n-\t\tMISSION_YAWMODE_FRONT_TO_WAYPOINT = 1,\n-\t\tMISSION_YAWMODE_FRONT_TO_HOME = 2,\n-\t\tMISSION_YAWMODE_BACK_TO_HOME = 3,\n-\t\tMISSION_YAWMODE_MAX = 4\n-\t};\n+\tposition_setpoint_s &get_reposition() { return _reposition; }\n \n private:\n \t/**\n@@ -76,5 +69,7 @@ class Loiter : public MissionBlock, public ModuleParams\n \t */\n \tvoid set_loiter_position();\n \n+\tposition_setpoint_s\t\t\t_reposition{};\t/**< position setpoint for non-mission direct position command */\n+\n \tbool _loiter_pos_set{false};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Floiter.h"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "patch": "@@ -80,14 +80,6 @@ class Mission : public MissionBlock, public ModuleParams\n \t\tMISSION_ALTMODE_FOH = 1\n \t};\n \n-\tenum mission_yaw_mode {\n-\t\tMISSION_YAWMODE_NONE = 0,\n-\t\tMISSION_YAWMODE_FRONT_TO_WAYPOINT = 1,\n-\t\tMISSION_YAWMODE_FRONT_TO_HOME = 2,\n-\t\tMISSION_YAWMODE_BACK_TO_HOME = 3,\n-\t\tMISSION_YAWMODE_MAX = 4\n-\t};\n-\n \tbool set_current_offboard_mission_index(uint16_t index);\n \n \tbool land_start();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 5,
        "changes": 22,
        "patch": "@@ -59,6 +59,14 @@ using matrix::wrap_pi;\n MissionBlock::MissionBlock(Navigator *navigator) :\n \tNavigatorMode(navigator)\n {\n+\t_mission_item.lat = (double)NAN;\n+\t_mission_item.lon = (double)NAN;\n+\t_mission_item.yaw = NAN;\n+\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n+\t_mission_item.time_inside = 0.0f;\n+\t_mission_item.autocontinue = true;\n+\t_mission_item.origin = ORIGIN_ONBOARD;\n }\n \n bool\n@@ -469,10 +477,14 @@ MissionBlock::issue_command(const mission_item_s &item)\n }\n \n float\n-MissionBlock::get_time_inside(const struct mission_item_s &item)\n+MissionBlock::get_time_inside(const mission_item_s &item) const\n {\n-\tif (item.nav_cmd != NAV_CMD_TAKEOFF) {\n-\t\treturn item.time_inside;\n+\tif ((item.nav_cmd == NAV_CMD_WAYPOINT && _navigator->get_vstatus()->is_rotary_wing) ||\n+\t    item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n+\t    item.nav_cmd == NAV_CMD_DELAY) {\n+\n+\t\t// TODO: set appropriate upper limit\n+\t\treturn math::constrain(item.time_inside, 0.0f, 3600.0f);\n \t}\n \n \treturn 0.0f;\n@@ -502,7 +514,7 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \n \tsp->lat = item.lat;\n \tsp->lon = item.lon;\n-\tsp->alt = item.altitude_is_relative ? item.altitude + _navigator->get_home_position()->alt : item.altitude;\n+\tsp->alt = get_absolute_altitude_for_item(item);\n \tsp->yaw = item.yaw;\n \tsp->yaw_valid = PX4_ISFINITE(item.yaw);\n \tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n@@ -728,7 +740,7 @@ MissionBlock::mission_apply_limitation(mission_item_s &item)\n }\n \n float\n-MissionBlock::get_absolute_altitude_for_item(struct mission_item_s &mission_item) const\n+MissionBlock::get_absolute_altitude_for_item(const mission_item_s &mission_item) const\n {\n \tif (mission_item.altitude_is_relative) {\n \t\treturn mission_item.altitude + _navigator->get_home_position()->alt;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -115,13 +115,13 @@ class MissionBlock : public NavigatorMode\n \t/**\n \t * General function used to adjust the mission item based on vehicle specific limitations\n \t */\n-\tvoid\tmission_apply_limitation(mission_item_s &item);\n+\tvoid mission_apply_limitation(mission_item_s &item);\n \n \tvoid issue_command(const mission_item_s &item);\n \n-\tfloat get_time_inside(const struct mission_item_s &item);\n+\tfloat get_time_inside(const mission_item_s &item) const ;\n \n-\tfloat get_absolute_altitude_for_item(struct mission_item_s &mission_item) const;\n+\tfloat get_absolute_altitude_for_item(const mission_item_s &mission_item) const;\n \n \tmission_item_s _mission_item{};\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "patch": "@@ -84,7 +84,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n {\n public:\n \tNavigator();\n-\tvirtual ~Navigator() = default;\n+\t~Navigator() override;\n+\n \tNavigator(const Navigator &) = delete;\n \tNavigator operator=(const Navigator &) = delete;\n \n@@ -149,8 +150,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tstruct home_position_s *get_home_position() { return &_home_pos; }\n \tstruct mission_result_s *get_mission_result() { return &_mission_result; }\n \tstruct position_setpoint_triplet_s *get_position_setpoint_triplet() { return &_pos_sp_triplet; }\n-\tstruct position_setpoint_triplet_s *get_reposition_triplet() { return &_reposition_triplet; }\n-\tstruct position_setpoint_triplet_s *get_takeoff_triplet() { return &_takeoff_triplet; }\n \tstruct vehicle_global_position_s *get_global_position() { return &_global_pos; }\n \tstruct vehicle_land_detected_s *get_land_detected() { return &_land_detected; }\n \tstruct vehicle_local_position_s *get_local_position() { return &_local_pos; }\n@@ -324,8 +323,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t// Publications\n \tgeofence_result_s\t\t\t\t_geofence_result{};\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet{};\t/**< triplet of position setpoints */\n-\tposition_setpoint_triplet_s\t\t\t_reposition_triplet{};\t/**< triplet for non-mission direct position command */\n-\tposition_setpoint_triplet_s\t\t\t_takeoff_triplet{};\t/**< triplet for non-mission direct takeoff command */\n \tvehicle_roi_s\t\t\t\t\t_vroi{};\t\t/**< vehicle ROI */\n \n \tperf_counter_t\t_loop_perf;\t\t\t/**< loop performance counter */\n@@ -335,7 +332,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool\t\t_can_loiter_at_sp{false};\t\t\t/**< flags if current position SP can be used to loiter */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t/**< flags if position SP triplet needs to be published */\n-\tbool \t\t_pos_sp_triplet_published_invalid_once{false};\t/**< flags if position SP triplet has been published once to UORB */\n \tbool\t\t_mission_result_updated{false};\t\t/**< flags if mission result has seen an update */\n \n \tNavigatorMode\t*_navigation_mode{nullptr};\t\t/**< abstract pointer to current navigation mode class */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 118,
        "changes": 198,
        "patch": "@@ -113,6 +113,35 @@ Navigator::Navigator() :\n \n \t_handle_back_trans_dec_mss = param_find(\"VT_B_DEC_MSS\");\n \t_handle_reverse_delay = param_find(\"VT_B_REV_DEL\");\n+\n+\t// subscriptions\n+\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n+\t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n+\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n+\t_pos_ctrl_landing_status_sub = orb_subscribe(ORB_ID(position_controller_landing_status));\n+\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n+\t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n+\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n+\t_offboard_mission_sub = orb_subscribe(ORB_ID(mission));\n+\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n+\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n+\t_traffic_sub = orb_subscribe(ORB_ID(transponder_report));\n+\n+\treset_triplets();\n+}\n+\n+Navigator::~Navigator()\n+{\n+\torb_unsubscribe(_global_pos_sub);\n+\torb_unsubscribe(_local_pos_sub);\n+\torb_unsubscribe(_gps_pos_sub);\n+\torb_unsubscribe(_pos_ctrl_landing_status_sub);\n+\torb_unsubscribe(_vstatus_sub);\n+\torb_unsubscribe(_land_detected_sub);\n+\torb_unsubscribe(_home_pos_sub);\n+\torb_unsubscribe(_offboard_mission_sub);\n+\torb_unsubscribe(_param_update_sub);\n+\torb_unsubscribe(_vehicle_command_sub);\n }\n \n void\n@@ -189,19 +218,6 @@ Navigator::run()\n \t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n \t}\n \n-\t/* do subscriptions */\n-\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n-\t_local_pos_sub = orb_subscribe(ORB_ID(vehicle_local_position));\n-\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n-\t_pos_ctrl_landing_status_sub = orb_subscribe(ORB_ID(position_controller_landing_status));\n-\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n-\t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n-\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n-\t_offboard_mission_sub = orb_subscribe(ORB_ID(mission));\n-\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n-\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n-\t_traffic_sub = orb_subscribe(ORB_ID(transponder_report));\n-\n \t/* copy all topics first time */\n \tvehicle_status_update();\n \tvehicle_land_detected_update();\n@@ -316,111 +332,85 @@ Navigator::run()\n \n \t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n \n-\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n+\t\t\t\tposition_setpoint_s &rep = _loiter.get_reposition();\n \t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n \n-\t\t\t\t// store current position as previous position and goal as next\n-\t\t\t\trep->previous.yaw = get_global_position()->yaw;\n-\t\t\t\trep->previous.lat = get_global_position()->lat;\n-\t\t\t\trep->previous.lon = get_global_position()->lon;\n-\t\t\t\trep->previous.alt = get_global_position()->alt;\n-\n-\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\trep->current.loiter_direction = 1;\n-\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\n-\t\t\t\t// If no argument for ground speed, use default value.\n-\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n-\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n-\n-\t\t\t\t} else {\n-\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n-\t\t\t\t}\n-\n-\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n-\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n+\t\t\t\trep.loiter_radius = get_loiter_radius();\n+\t\t\t\trep.loiter_direction = 1;\n+\t\t\t\trep.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\trep.cruising_speed = get_cruising_speed();\n+\t\t\t\trep.cruising_throttle = get_cruising_throttle();\n \n \t\t\t\t// Go on and check which changes had been requested\n \t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n-\t\t\t\t\trep->current.yaw = cmd.param4;\n-\t\t\t\t\trep->current.yaw_valid = true;\n+\t\t\t\t\trep.yaw = cmd.param4;\n+\t\t\t\t\trep.yaw_valid = true;\n \n \t\t\t\t} else {\n-\t\t\t\t\trep->current.yaw = NAN;\n-\t\t\t\t\trep->current.yaw_valid = false;\n+\t\t\t\t\trep.yaw = NAN;\n+\t\t\t\t\trep.yaw_valid = false;\n \t\t\t\t}\n \n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n \n \t\t\t\t\t// Position change with optional altitude change\n-\t\t\t\t\trep->current.lat = (cmd.param5 < 1000) ? cmd.param5 : cmd.param5 / (double)1e7;\n-\t\t\t\t\trep->current.lon = (cmd.param6 < 1000) ? cmd.param6 : cmd.param6 / (double)1e7;\n+\t\t\t\t\trep.lat = (cmd.param5 < 1000) ? cmd.param5 : cmd.param5 / (double)1e7;\n+\t\t\t\t\trep.lon = (cmd.param6 < 1000) ? cmd.param6 : cmd.param6 / (double)1e7;\n \n \t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n-\t\t\t\t\t\trep->current.alt = cmd.param7;\n+\t\t\t\t\t\trep.alt = cmd.param7;\n \n \t\t\t\t\t} else {\n-\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n+\t\t\t\t\t\trep.alt = get_global_position()->alt;\n \t\t\t\t\t}\n \n \t\t\t\t} else if (PX4_ISFINITE(cmd.param7) && curr->current.valid\n \t\t\t\t\t   && PX4_ISFINITE(curr->current.lat)\n \t\t\t\t\t   && PX4_ISFINITE(curr->current.lon)) {\n \n \t\t\t\t\t// Altitude without position change\n-\t\t\t\t\trep->current.lat = curr->current.lat;\n-\t\t\t\t\trep->current.lon = curr->current.lon;\n-\t\t\t\t\trep->current.alt = cmd.param7;\n+\t\t\t\t\trep.lat = curr->current.lat;\n+\t\t\t\t\trep.lon = curr->current.lon;\n+\t\t\t\t\trep.alt = cmd.param7;\n \n \t\t\t\t} else {\n \t\t\t\t\t// All three set to NaN - hold in current position\n-\t\t\t\t\trep->current.lat = get_global_position()->lat;\n-\t\t\t\t\trep->current.lon = get_global_position()->lon;\n-\t\t\t\t\trep->current.alt = get_global_position()->alt;\n+\t\t\t\t\trep.lat = get_global_position()->lat;\n+\t\t\t\t\trep.lon = get_global_position()->lon;\n+\t\t\t\t\trep.alt = get_global_position()->alt;\n \t\t\t\t}\n \n-\t\t\t\trep->previous.valid = true;\n-\t\t\t\trep->current.valid = true;\n-\t\t\t\trep->next.valid = false;\n+\t\t\t\trep.valid = true;\n \n \t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n \n \t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n-\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n-\n-\t\t\t\t// store current position as previous position and goal as next\n-\t\t\t\trep->previous.yaw = get_global_position()->yaw;\n-\t\t\t\trep->previous.lat = get_global_position()->lat;\n-\t\t\t\trep->previous.lon = get_global_position()->lon;\n-\t\t\t\trep->previous.alt = get_global_position()->alt;\n+\t\t\t\tposition_setpoint_s &rep = _takeoff.get_reposition();\n \n-\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\trep->current.loiter_direction = 1;\n-\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n+\t\t\t\trep.loiter_radius = get_loiter_radius();\n+\t\t\t\trep.loiter_direction = 1;\n+\t\t\t\trep.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n \n \t\t\t\tif (home_position_valid()) {\n-\t\t\t\t\trep->current.yaw = cmd.param4;\n-\t\t\t\t\trep->previous.valid = true;\n+\t\t\t\t\trep.yaw = cmd.param4;\n \n \t\t\t\t} else {\n-\t\t\t\t\trep->current.yaw = get_local_position()->yaw;\n-\t\t\t\t\trep->previous.valid = false;\n+\t\t\t\t\trep.yaw = get_local_position()->yaw;\n \t\t\t\t}\n \n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n-\t\t\t\t\trep->current.lat = (cmd.param5 < 1000) ? cmd.param5 : cmd.param5 / (double)1e7;\n-\t\t\t\t\trep->current.lon = (cmd.param6 < 1000) ? cmd.param6 : cmd.param6 / (double)1e7;\n+\t\t\t\t\trep.lat = (cmd.param5 < 1000) ? cmd.param5 : cmd.param5 / (double)1e7;\n+\t\t\t\t\trep.lon = (cmd.param6 < 1000) ? cmd.param6 : cmd.param6 / (double)1e7;\n \n \t\t\t\t} else {\n \t\t\t\t\t// If one of them is non-finite, reset both\n-\t\t\t\t\trep->current.lat = (double)NAN;\n-\t\t\t\t\trep->current.lon = (double)NAN;\n+\t\t\t\t\trep.lat = (double)NAN;\n+\t\t\t\t\trep.lon = (double)NAN;\n \t\t\t\t}\n \n-\t\t\t\trep->current.alt = cmd.param7;\n+\t\t\t\trep.alt = cmd.param7;\n \n-\t\t\t\trep->current.valid = true;\n-\t\t\t\trep->next.valid = false;\n+\t\t\t\trep.valid = true;\n \n \t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n \n@@ -475,7 +465,8 @@ Navigator::run()\n \t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n \t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n \t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n-\t\t\t\t_vroi = {};\n+\n+\t\t\t\t_vroi = vehicle_roi_s{};\n \n \t\t\t\tswitch (cmd.command) {\n \t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n@@ -562,25 +553,20 @@ Navigator::run()\n \n \t\tswitch (_vstatus.nav_state) {\n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n-\n \t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n \t\t\tnavigation_mode_new = &_mission;\n \n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_loiter;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_rcLoss;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL: {\n-\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \n \t\t\t\tconst bool rtl_activated = _previous_nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL;\n \n@@ -671,43 +657,35 @@ Navigator::run()\n \t\t\t}\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_takeoff;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_land;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_precland;\n \t\t\t_precland.set_mode(PrecLandMode::Required);\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_land;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_dataLinkLoss;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_engineFailure;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_gpsFailure;\n \t\t\tbreak;\n \n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_follow_target;\n \t\t\tbreak;\n \n@@ -719,7 +697,6 @@ Navigator::run()\n \t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n \t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n \t\tdefault:\n-\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = nullptr;\n \t\t\t_can_loiter_at_sp = false;\n \t\t\tbreak;\n@@ -730,16 +707,18 @@ Navigator::run()\n \n \t\t/* we have a new navigation mode: reset triplet */\n \t\tif (_navigation_mode != navigation_mode_new) {\n-\t\t\t// We don't reset the triplet if we just did an auto-takeoff and are now\n-\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n-\t\t\t// than where we wanted to go.\n-\t\t\t//\n-\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n-\t\t\t//        this general reset here.\n-\t\t\tif (!(_navigation_mode == &_takeoff &&\n-\t\t\t      navigation_mode_new == &_loiter)) {\n-\t\t\t\treset_triplets();\n+\n+\t\t\t// if switching to loiter after an auto-takeoff use the same position\n+\t\t\tif ((_navigation_mode == &_takeoff) && (navigation_mode_new == &_loiter)) {\n+\n+\t\t\t\tif (_pos_sp_triplet.current.valid && (_pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n+\n+\t\t\t\t\t_loiter.get_reposition() = _pos_sp_triplet.current;\n+\t\t\t\t\t_loiter.get_reposition().type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\t}\n \t\t\t}\n+\n+\t\t\treset_triplets();\n \t\t}\n \n \t\t_navigation_mode = navigation_mode_new;\n@@ -754,17 +733,16 @@ Navigator::run()\n \t\t    !((_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF)\n \t\t      || (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION))) {\n \n+\t\t\tconst uint8_t type_prev = _pos_sp_triplet.current.type;\n+\n \t\t\t_pos_sp_triplet.current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n \t\t\t_pos_sp_triplet.current.valid = true;\n \t\t\t_pos_sp_triplet.previous.valid = false;\n \t\t\t_pos_sp_triplet.next.valid = false;\n \n-\t\t}\n-\n-\t\t/* if nothing is running, set position setpoint triplet invalid once */\n-\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n-\t\t\t_pos_sp_triplet_published_invalid_once = true;\n-\t\t\treset_triplets();\n+\t\t\tif (_pos_sp_triplet.current.type != type_prev) {\n+\t\t\t\t_pos_sp_triplet_updated = true;\n+\t\t\t}\n \t\t}\n \n \t\tif (_pos_sp_triplet_updated) {\n@@ -777,17 +755,6 @@ Navigator::run()\n \n \t\tperf_end(_loop_perf);\n \t}\n-\n-\torb_unsubscribe(_global_pos_sub);\n-\torb_unsubscribe(_local_pos_sub);\n-\torb_unsubscribe(_gps_pos_sub);\n-\torb_unsubscribe(_pos_ctrl_landing_status_sub);\n-\torb_unsubscribe(_vstatus_sub);\n-\torb_unsubscribe(_land_detected_sub);\n-\torb_unsubscribe(_home_pos_sub);\n-\torb_unsubscribe(_offboard_mission_sub);\n-\torb_unsubscribe(_param_update_sub);\n-\torb_unsubscribe(_vehicle_command_sub);\n }\n \n int Navigator::task_spawn(int argc, char *argv[])\n@@ -830,11 +797,6 @@ Navigator::print_status()\n void\n Navigator::publish_position_setpoint_triplet()\n {\n-\t// do not publish an invalid setpoint\n-\tif (!_pos_sp_triplet.current.valid) {\n-\t\treturn;\n-\t}\n-\n \t_pos_sp_triplet.timestamp = hrt_absolute_time();\n \n \t/* lazily publish the position setpoint triplet only once available */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 14,
        "changes": 24,
        "patch": "@@ -55,9 +55,7 @@ Takeoff::on_activation()\n void\n Takeoff::on_active()\n {\n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n-\n-\tif (rep->current.valid) {\n+\tif (_reposition.valid) {\n \t\t// reset the position\n \t\tset_takeoff_position();\n \n@@ -77,8 +75,6 @@ Takeoff::on_active()\n void\n Takeoff::set_takeoff_position()\n {\n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n-\n \tfloat abs_altitude = 0.0f;\n \n \tfloat min_abs_altitude;\n@@ -91,8 +87,8 @@ Takeoff::set_takeoff_position()\n \t}\n \n \t// Use altitude if it has been set. If home position is invalid use min_abs_altitude\n-\tif (rep->current.valid && PX4_ISFINITE(rep->current.alt) && _navigator->home_position_valid()) {\n-\t\tabs_altitude = rep->current.alt;\n+\tif (_reposition.valid && PX4_ISFINITE(_reposition.alt) && _navigator->home_position_valid()) {\n+\t\tabs_altitude = _reposition.alt;\n \n \t\t// If the altitude suggestion is lower than home + minimum clearance, raise it and complain.\n \t\tif (abs_altitude < min_abs_altitude) {\n@@ -132,20 +128,20 @@ Takeoff::set_takeoff_position()\n \tpos_sp_triplet->current.yaw_valid = true;\n \tpos_sp_triplet->next.valid = false;\n \n-\tif (rep->current.valid) {\n+\tif (_reposition.valid) {\n \n \t\t// Go on and check which changes had been requested\n-\t\tif (PX4_ISFINITE(rep->current.yaw)) {\n-\t\t\tpos_sp_triplet->current.yaw = rep->current.yaw;\n+\t\tif (PX4_ISFINITE(_reposition.yaw)) {\n+\t\t\tpos_sp_triplet->current.yaw = _reposition.yaw;\n \t\t}\n \n-\t\tif (PX4_ISFINITE(rep->current.lat) && PX4_ISFINITE(rep->current.lon)) {\n-\t\t\tpos_sp_triplet->current.lat = rep->current.lat;\n-\t\t\tpos_sp_triplet->current.lon = rep->current.lon;\n+\t\tif (PX4_ISFINITE(_reposition.lat) && PX4_ISFINITE(_reposition.lon)) {\n+\t\t\tpos_sp_triplet->current.lat = _reposition.lat;\n+\t\t\tpos_sp_triplet->current.lon = _reposition.lon;\n \t\t}\n \n \t\t// mark this as done\n-\t\tmemset(rep, 0, sizeof(*rep));\n+\t\t_reposition = position_setpoint_s{};\n \t}\n \n \t_navigator->set_can_loiter_at_sp(true);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/takeoff.h": {
        "filename": "src/modules/navigator/takeoff.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -52,7 +52,11 @@ class Takeoff : public MissionBlock\n \tvoid on_activation() override;\n \tvoid on_active() override;\n \n+\tposition_setpoint_s &get_reposition() { return _reposition; }\n+\n private:\n \n \tvoid set_takeoff_position();\n+\n+\tposition_setpoint_s\t\t\t_reposition{};\t/**< position setpoint for non-mission direct position command */\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ee517b2f9233a99c1205504cbcab6a608d939887/src%2Fmodules%2Fnavigator%2Ftakeoff.h"
      }
    },
    "modified_functions": {
      "all": [
        "mission_apply_limitation",
        "Loiter::reposition",
        "Navigator::run",
        "Loiter::on_activation",
        "Land::on_activation",
        "Land::on_active",
        "MissionBlock::issue_command",
        "get_absolute_altitude_for_item",
        "Navigator::print_status",
        "Navigator::Navigator",
        "Takeoff::on_active",
        "MissionBlock::mission_apply_limitation",
        "Takeoff::on_activation",
        "get_time_inside",
        "Takeoff::set_takeoff_position",
        "Loiter::on_inactive",
        "MissionBlock::mission_item_to_position_setpoint",
        "Loiter::set_loiter_position"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation",
          "Land::on_active"
        ],
        "src/modules/navigator/loiter.cpp": [
          "Loiter::set_loiter_position",
          "Loiter::on_inactive",
          "Loiter::reposition",
          "Loiter::on_activation"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::mission_apply_limitation"
        ],
        "src/modules/navigator/mission_block.h": [
          "mission_apply_limitation",
          "get_time_inside",
          "get_absolute_altitude_for_item"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::print_status",
          "Navigator::run",
          "Navigator::Navigator"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active",
          "Takeoff::on_activation",
          "Takeoff::set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "Use RTL when offboard is lost",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/3404",
    "number": 3404,
    "created_at": "2015-12-30T23:42:13Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AndreasAntener",
      "body": "This contains 2 updates:\n- option to go to RTL when offboard is lost. Parameter allows to set a timeout to wait in LOITER before entering RTL\n- jump to the proper RTL phase when engaged inside acceptance radius of home (instead of climbing up first)\n",
      "issue_comments": [
        {
          "author": "AndreasAntener",
          "created_at": "2015-12-31T11:14:57Z",
          "body": "Updated and SITL tested\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T13:36:32Z",
          "body": "@julianoes thanks, updated\nSITL tested. I think an outdoor test to verify RTL would be good. The offboard timeout to RTL is extensively simulation tested.\n",
          "type": "issue_comment"
        },
        {
          "author": "mhkabir",
          "created_at": "2016-03-05T14:03:09Z",
          "body": "@AndreasAntener, can we have an option to just land if offboard is lost? I think it would be fairly easy to add it to this PR. \n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T14:11:10Z",
          "body": "@mhkabir that's the default if you have no RC connected. It will only RTL if you set this new param\n",
          "type": "issue_comment"
        },
        {
          "author": "mhkabir",
          "created_at": "2016-03-05T14:12:40Z",
          "body": "What if RC is connected? I think it drops back into the previous mode then? \n\nI just wanted it to land instead of that. \n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-03-05T14:14:06Z",
          "body": "In that case it goes to POSCTL: https://github.com/PX4/Firmware/pull/3404/files#diff-20f2c9d76df9330422532b87ab964f86R812\nDo you want to make a PR against this with a param to choose between the two?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2016-05-12T06:37:04Z",
          "body": "@AndreasAntener Because of the inherent dangers I'd prefer if this would support switching between HOLD (loiter), LAND and RTL.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-05-12T13:04:44Z",
          "body": "Ok, I can do that. Same style as for DL and RC loss I guess.\nActually we're currently also using a 4th option: MANUAL. Especially useful for testing takeoff/landing stuff where you want to it to stop controlling 10cm above ground.\n",
          "type": "issue_comment"
        },
        {
          "author": "AndreasAntener",
          "created_at": "2016-05-27T13:25:12Z",
          "body": "New one incoming, split RTL and offboard lost functionality\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "julianoes",
          "created_at": "2016-02-15T13:03:55Z",
          "body": "Personally, I'd prefer a param name like `COM_OFFB_RTL` but up to you.\n",
          "path": "src/modules/commander/commander_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-15T13:05:18Z",
          "body": "nitpick: You could just use `1e6f` instead of `(float)1e6`, right?\n",
          "path": "src/modules/commander/commander.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-15T13:10:37Z",
          "body": "These changes lake correct, I'm only a little confused that they are part of this PR.\n",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 24,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2016-02-15T13:12:21Z",
          "body": "Scary change but it seems right from what I see.\n",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 38,
          "type": "review_comment"
        }
      ],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes state-transition behavior when offboard control is lost (adds a configurable timeout to enter RTL and fixes the RTL phase selection when already within home acceptance radius). Those are incorrect/imprecise control-mode transitions and unexpected vehicle behavior, i.e. logic errors, so the changes address program logic rather than syntax or style.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "patch": "@@ -92,9 +92,30 @@ RTL::on_activation()\n \t\t\t_rtl_state = RTL_STATE_LANDED;\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no RTL when landed\");\n \n+\t\t/* for multicopters:\n+\t\t * if we're already inside the acceptance radius at home position, don't climb again\n+\t\t */\n+\t\t} else if (_navigator->get_vstatus()->is_rotary_wing &&\n+\t\t\t\tget_distance_to_next_waypoint(_navigator->get_global_position()->lat,\n+\t\t\t\t_navigator->get_global_position()->lon, _navigator->get_home_position()->lat,\n+\t\t\t\t_navigator->get_home_position()->lon) < _navigator->get_acceptance_radius()) {\n+\n+\t\t\t/* if still above descend altitude, go to descend, otherwise go to loiter directly */\n+\t\t\tif (_navigator->get_global_position()->alt > _navigator->get_home_position()->alt\n+\t\t\t\t\t+ _param_descend_alt.get()) {\n+\t\t\t\t_rtl_state = RTL_STATE_DESCEND;\n+\n+\t\t\t} else {\n+\t\t\t\t/* set altitude setpoint to current altitude */\n+\t\t\t\t_rtl_state = RTL_STATE_LOITER;\n+\t\t\t\t_mission_item.altitude_is_relative = false;\n+\t\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n+\t\t\t\t_rtl_start_lock = false;\n+\t\t\t}\n+\n \t\t/* if lower than return altitude, climb up first */\n \t\t} else if (_navigator->get_global_position()->alt < _navigator->get_home_position()->alt\n-\t\t\t   + _param_return_alt.get()) {\n+\t\t\t\t+ _param_return_alt.get()) {\n \t\t\t_rtl_state = RTL_STATE_CLIMB;\n \t\t\t_rtl_start_lock = false;\n \n@@ -219,8 +240,7 @@ RTL::set_rtl_item()\n \n \t\t_mission_item.lat = _navigator->get_home_position()->lat;\n \t\t_mission_item.lon = _navigator->get_home_position()->lon;\n-\t\t_mission_item.altitude_is_relative = false;\n-\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_descend_alt.get();\n+\t\t// don't change altitude\n \t\t_mission_item.yaw = _navigator->get_home_position()->yaw;\n \t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n \t\t_mission_item.loiter_direction = 1;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/75ae8bc07123ca6bf7f20ed57a3e435d74b903fa/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::set_rtl_item",
        "RTL::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item",
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Fmuv1 space",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/2080",
    "number": 2080,
    "created_at": "2015-04-24T23:35:50Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "@kd0aij could you test this? Particularly interested in the log - it should work the same as in master (so could have this 8 byte error I haven't traced back yet), but should work with 2 MAVLink instances.\n\nBench-tested on FMUv1 hardware.\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-25T05:10:23Z",
          "body": "This change set brings FMUv1 from:\n\n```\n             total       used       free    largest\n\nMem:        181456     158384      23072      22672\n```\n\nto\n\n```\n             total       used       free    largest\n\nMem:        181456     153968      27488      27136\n```\n\nwithout any loss of functionality.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-25T06:17:24Z",
          "body": "Passes testing on FMUv1 and FMUv2.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-25T06:18:20Z",
          "body": "Output of top:\n\n```\nProcesses: 20 total, 2 running, 18 sleeping\nCPU usage: 41.69% tasks, 0.48% sched, 57.83% idle\nUptime: 61.275s total, 36.269s idle\n\n PID COMMAND                   CPU(ms) CPU(%)  USED/STACK PRIO(BASE) STATE \n   0 Idle Task                   36269 57.827     0/    0   0 (  0)  READY \n   1 hpwork                       1446  2.476   748/ 1792 192 (192)  w:sig \n   2 lpwork                        165  0.239   356/ 1792  50 ( 50)  READY \n   3 init                         1445  0.000  1324/ 2992 100 (100)  w:sem \n   6 nshterm                         0  0.000   560/ 1496  70 ( 70)  w:sem \n 142 top                           365  2.236  1156/ 1696 100 (100)  RUN   \n  63 dataman                        22  0.000   668/ 1792 100 (100)  w:sem \n  85 sensors_task                 1680  2.795  1292/ 1992 250 (250)  w:sem \n  87 commander                     333  0.399  2756/ 3392 215 (215)  w:sig \n  88 commander_low_prio            156  0.000   692/ 1992  50 ( 50)  w:sem \n  90 px4io                        1014  1.757   852/ 1792 240 (240)  w:sem \n 100 mavlink_if0                   472  0.718  1844/ 2392 100 (100)  w:sig \n 101 mavlink_rcv_if0                 4  0.000   780/ 1792 175 (175)  w:sem \n 109 sdlog2                       3273  5.591  1852/ 2992  70 ( 70)  w:sig \n 111 gps                           149  0.479   700/ 1496 220 (220)  w:sem \n 124 ekf_att_pos_estimator       12823 22.444  3476/ 7496 215 (215)  w:sem \n 126 mc_att_control                625  1.038  1060/ 1496 250 (250)  w:sem \n 136 mc_pos_control                416  0.718  1012/ 1496 250 (250)  w:sem \n 138 land_detector                 108  0.159   484/  992 100 (100)  w:sig \n 140 navigator                     460  0.641   860/ 1696 120 (120)  w:sem          \n```\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2015-04-25T14:02:18Z",
          "body": "with 2 mavlink instances:\n\n```\nProcesses: 21 total, 3 running, 18 sleeping\nCPU usage: 37.68% tasks, 0.54% sched, 61.78% idle\nUptime: 2058.952s total, 1325.763s idle\n\n PID COMMAND                   CPU(ms) CPU(%)  USED/STACK PRIO(BASE) STATE \n   0 Idle Task                 1325763 61.780     0/    0   0 (  0)  READY \n   1 hpwork                      43956  2.072   676/ 1792 240 (192)  w:sem \n   2 lpwork                       6610  0.306   364/ 1792  50 ( 50)  w:sig \n   3 init                          249  0.000  1460/ 2992 100 (100)  w:sem \n 198 top                            64  2.225  1164/ 1696 100 (100)  RUN   \n  75 dataman                       279  0.000   612/ 1792 100 (100)  w:sem \n  89 sensors_task                43186  2.072  1260/ 1992 250 (250)  w:sem \n  91 commander                    7329  0.306  2836/ 3392 215 (215)  w:sig \n  92 commander_low_prio            131  0.000   876/ 1992  50 ( 50)  w:sem \n  94 px4io                       32757  1.611   876/ 1792 240 (240)  w:sem \n 147 mavlink_if0                 27572  1.304  1844/ 2392 100 (100)  w:sig \n 148 mavlink_rcv_if0               134  0.000   780/ 1792 175 (175)  w:sem \n 111 sdlog2                      26906  1.304  1844/ 2992  70 ( 70)  w:sig \n 113 gps                          3497  0.153   740/ 1496 220 (220)  w:sig \n 125 ekf_att_pos_estimator      392557 19.186  3700/ 7496 215 (215)  w:sem \n 132 mc_att_control              18925  0.920   996/ 1496 250 (250)  w:sem \n 135 mc_pos_control              12791  0.537  1116/ 1496 250 (250)  w:sem \n 140 land_detector                3487  0.153   468/  992 100 (100)  w:sig \n 142 navigator                   22313  1.074   900/ 1696 120 (120)  w:sem \n 150 mavlink_if1                 88663  4.451  1908/ 2392 100 (100)  w:sig \n 151 mavlink_rcv_if1               267  0.000   944/ 1792 175 (175)  w:sem \n```\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2015-04-25T14:50:23Z",
          "body": "flight performance nominal in manual mode, but no log file generated. contents of msgs_2015_04_25_14_35_31.txt:\n\n```\nsettings autosaved\n[ekf] ref: LA 39.7501,LO -105.0975,ALT 1692.43\nhome: 39.7501216, -105.0975292, 1694.87\nARMED by RC\nhome: 39.7501293, -105.0975340, 1691.70\n[cmd] arming state: ARMED\nIN AIR MODE\nLANDED MODE\nIN AIR MODE\nDISARMED by RC\n[cmd] arming state: STANDBY\nLANDED MODE\n```\n",
          "type": "issue_comment"
        },
        {
          "author": "davids5",
          "created_at": "2015-04-25T15:45:58Z",
          "body": "I think the stack penetrations of the interrupt stack is 480 bytes (top on nuttx_next has the interrupt stack stats listed for idle)  and the allocations is 1500.  Since we do not nest there is another K that can be recover. \n\nBecause the configuration uses a separate interrupt stack. You really only need about 8 bytes of margin beyond the fully loaded system used values. So there are some gains that could reaped there.\n\nIf call time stack checking is enabled then this increases to an overly conservative 264 bytes. \nThe reason for the 264 byte margin is: It wants to see 64 bytes of head room plus 136 for the FP context and sets the limit at 64. But in reality because the separate interrupt stack we will never stack the full CPU and FP context on the user stack AND there is a and 64 bytes in where limit it set (R10 is 64 bytes from the bottom of the stack)  it is overly conservative.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-25T17:36:41Z",
          "body": "@kd0aij Would you mind re-testing? I checked that sdlog2 works now. Please also make sure to run make distclean and make archives to get the full benefit.\n",
          "type": "issue_comment"
        },
        {
          "author": "kd0aij",
          "created_at": "2015-04-25T19:21:47Z",
          "body": "sdlog2 now working, log: http://dash.oznet.ch/view/gvn9ZVSM4PtYZSSStXD4sJ\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-26T12:34:39Z",
          "body": "Applied on master.\n",
          "type": "issue_comment"
        },
        {
          "author": "coveralls",
          "created_at": "2016-12-20T02:24:43Z",
          "body": "\n[![Coverage Status](https://coveralls.io/builds/9352764/badge)](https://coveralls.io/builds/9352764)\n\nChanges Unknown when pulling **573bfe85a6e0069a35aa6df12b0cf648942bca95 on fmuv1_space** into ** on master**.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR adjusts FMUv1 memory/stack layout so the system can run two MAVLink instances and restore sdlog2 logging; previously the runtime behaved incorrectly (no log file) despite not crashing. This is a logic-level bug in resource allocation/stack configuration that produced unintended behavior and the changes correct that incorrect runtime behavior.",
    "patches": {
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -134,7 +134,7 @@ bool MissionFeasibilityChecker::checkHomePositionAltitude(dm_item_t dm_current,\n {\n \t/* Check if all all waypoints are above the home altitude, only return false if bool throw_error = true */\n \tfor (size_t i = 0; i < nMissionItems; i++) {\n-\t\tstatic struct mission_item_s missionitem;\n+\t\tstruct mission_item_s missionitem;\n \t\tconst ssize_t len = sizeof(struct mission_item_s);\n \n \t\tif (dm_read(dm_current, i, &missionitem, len) != len) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/573bfe85a6e0069a35aa6df12b0cf648942bca95/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -518,7 +518,7 @@ Navigator::start()\n \t_navigator_task = task_spawn_cmd(\"navigator\",\n \t\t\t\t\t SCHED_DEFAULT,\n \t\t\t\t\t SCHED_PRIORITY_DEFAULT + 20,\n-\t\t\t\t\t 1800,\n+\t\t\t\t\t 1700,\n \t\t\t\t\t (main_t)&Navigator::task_main_trampoline,\n \t\t\t\t\t nullptr);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/573bfe85a6e0069a35aa6df12b0cf648942bca95/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkHomePositionAltitude",
        "Navigator::start"
      ],
      "by_file": {
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkHomePositionAltitude"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::start"
        ]
      }
    }
  },
  {
    "title": "Parameter meta data fixes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/2035",
    "number": 2035,
    "created_at": "2015-04-15T18:31:17Z",
    "merged": true,
    "merged_at": "2015-04-15T19:12:44Z",
    "state": "closed",
    "conversation": {
      "author": "DonLakeFlyer",
      "body": "We now have decent group names for everything. Fixed parser for missing defines. I'm going to call it good from my side.\n\nStill need lots of work with units and short description. But I'll leave that up to the firmware folks to clean up.\n",
      "issue_comments": [
        {
          "author": "DonLakeFlyer",
          "created_at": "2015-04-15T18:31:59Z",
          "body": "@LorenzMeier The QGC parameter xml parser is still kind of fragile. Can you ping me if you see pulls go by with param changes in them so I can review the meta data?\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-15T18:36:26Z",
          "body": "Yes, will ping you. Thanks for the cleanup!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes the parameter metadata handling and specifically 'fixed parser for missing defines', which addresses incorrect behavior in the parameter parsing logic (a parser bug). This is a logic error because it causes incorrect program behavior (mis-parsed/missing parameter metadata) rather than a syntax/crash issue.",
    "patches": {
      "src/modules/navigator/datalinkloss_params.c": {
        "filename": "src/modules/navigator/datalinkloss_params.c",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "patch": "@@ -54,7 +54,7 @@\n  *\n  * @unit seconds\n  * @min 0.0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_DLL_CH_T, 120.0f);\n \n@@ -65,7 +65,7 @@ PARAM_DEFINE_FLOAT(NAV_DLL_CH_T, 120.0f);\n  *\n  * @unit degrees * 1e7\n  * @min 0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CH_LAT, -266072120);\n \n@@ -76,7 +76,7 @@ PARAM_DEFINE_INT32(NAV_DLL_CH_LAT, -266072120);\n  *\n  * @unit degrees * 1e7\n  * @min 0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CH_LON, 1518453890);\n \n@@ -87,7 +87,7 @@ PARAM_DEFINE_INT32(NAV_DLL_CH_LON, 1518453890);\n  *\n  * @unit m\n  * @min 0.0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_DLL_CH_ALT, 600.0f);\n \n@@ -98,7 +98,7 @@ PARAM_DEFINE_FLOAT(NAV_DLL_CH_ALT, 600.0f);\n  *\n  * @unit seconds\n  * @min 0.0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_DLL_AH_T, 120.0f);\n \n@@ -107,7 +107,7 @@ PARAM_DEFINE_FLOAT(NAV_DLL_AH_T, 120.0f);\n  *\n  * After more than this number of data link timeouts the aircraft returns home directly\n  *\n- * @group DLL\n+ * @group Data Link Loss\n  * @min 0\n  * @max 1000\n  */\n@@ -119,7 +119,7 @@ PARAM_DEFINE_INT32(NAV_DLL_N, 2);\n  * If set to 1 the system will skip the comms hold wp on data link loss and will directly fly to\n  * airfield home\n  *\n- * @group DLL\n+ * @group Data Link Loss\n  * @min 0\n  * @max 1\n  */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/05c351183f0425f1c4feba60bf68b28d73eee51f/src%2Fmodules%2Fnavigator%2Fdatalinkloss_params.c"
      },
      "src/modules/navigator/gpsfailure_params.c": {
        "filename": "src/modules/navigator/gpsfailure_params.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -55,7 +55,7 @@\n  *\n  * @unit seconds\n  * @min 0.0\n- * @group GPSF\n+ * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_LT, 30.0f);\n \n@@ -67,7 +67,7 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_LT, 30.0f);\n  * @unit deg\n  * @min 0.0\n  * @max 30.0\n- * @group GPSF\n+ * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_R, 15.0f);\n \n@@ -79,7 +79,7 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_R, 15.0f);\n  * @unit deg\n  * @min -30.0\n  * @max 30.0\n- * @group GPSF\n+ * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_P, 0.0f);\n \n@@ -90,7 +90,7 @@ PARAM_DEFINE_FLOAT(NAV_GPSF_P, 0.0f);\n  *\n  * @min 0.0\n  * @max 1.0\n- * @group GPSF\n+ * @group GPS Failure Navigation\n  */\n PARAM_DEFINE_FLOAT(NAV_GPSF_TR, 0.7f);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/05c351183f0425f1c4feba60bf68b28d73eee51f/src%2Fmodules%2Fnavigator%2Fgpsfailure_params.c"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -95,7 +95,7 @@ PARAM_DEFINE_INT32(NAV_RCL_OBC, 0);\n  *\n  * @unit degrees * 1e7\n  * @min 0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_INT32(NAV_AH_LAT, -265847810);\n \n@@ -106,7 +106,7 @@ PARAM_DEFINE_INT32(NAV_AH_LAT, -265847810);\n  *\n  * @unit degrees * 1e7\n  * @min 0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_INT32(NAV_AH_LON, 1518423250);\n \n@@ -117,6 +117,6 @@ PARAM_DEFINE_INT32(NAV_AH_LON, 1518423250);\n  *\n  * @unit m\n  * @min 0.0\n- * @group DLL\n+ * @group Data Link Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_AH_ALT, 600.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/05c351183f0425f1c4feba60bf68b28d73eee51f/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rcloss_params.c": {
        "filename": "src/modules/navigator/rcloss_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -55,6 +55,6 @@\n  *\n  * @unit seconds\n  * @min -1.0\n- * @group RCL\n+ * @group Radio Signal Loss\n  */\n PARAM_DEFINE_FLOAT(NAV_RCL_LT, 120.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/05c351183f0425f1c4feba60bf68b28d73eee51f/src%2Fmodules%2Fnavigator%2Frcloss_params.c"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -55,7 +55,7 @@\n  * @unit meters\n  * @min 20\n  * @max 200\n- * @group RTL\n+ * @group Return To Land\n  */\n PARAM_DEFINE_FLOAT(RTL_LOITER_RAD, 50.0f);\n \n@@ -67,7 +67,7 @@ PARAM_DEFINE_FLOAT(RTL_LOITER_RAD, 50.0f);\n  * @unit meters\n  * @min 0\n  * @max 150\n- * @group RTL\n+ * @group Return To Land\n  */\n PARAM_DEFINE_FLOAT(RTL_RETURN_ALT, 60);\n \n@@ -81,7 +81,7 @@ PARAM_DEFINE_FLOAT(RTL_RETURN_ALT, 60);\n  * @unit meters\n  * @min 2\n  * @max 100\n- * @group RTL\n+ * @group Return To Land\n  */\n PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n \n@@ -94,6 +94,6 @@ PARAM_DEFINE_FLOAT(RTL_DESCEND_ALT, 30);\n  * @unit seconds\n  * @min -1\n  * @max 300\n- * @group RTL\n+ * @group Return To Land\n  */\n PARAM_DEFINE_FLOAT(RTL_LAND_DELAY, -1.0f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/05c351183f0425f1c4feba60bf68b28d73eee51f/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Store parameter xml size in .px4 file",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/2029",
    "number": 2029,
    "created_at": "2015-04-15T02:18:04Z",
    "merged": true,
    "merged_at": "2015-04-15T07:35:29Z",
    "state": "closed",
    "conversation": {
      "author": "DonLakeFlyer",
      "body": "This is needed in order to decompress in QGroundControl\n",
      "issue_comments": [
        {
          "author": "DonLakeFlyer",
          "created_at": "2015-04-15T06:08:18Z",
          "body": "Hold off on merging this. I have some parameter meta data fixes to go in here as well.\n",
          "type": "issue_comment"
        },
        {
          "author": "DonLakeFlyer",
          "created_at": "2015-04-15T06:28:31Z",
          "body": "Ok. I've cleaned up the parameter meta data that QGC is complaining about. Specific problems:\n- If the param is float or int then the default/min/max values must be float or int. No \"1.0\" value for an int.\n- Float values don't end in \"f'. Floats are just 0.0 not 0.0f. This breaks string conversion.\n\nEventually this will all get better when I switch the firmware to generate param c++ code from xml. This way the parser will validate the xml.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-15T07:35:27Z",
          "body": "Thanks!\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior rather than syntax: it adds storing the parameter XML size to enable proper decompression in QGroundControl and corrects parameter metadata/type handling (ensuring int vs float defaults and proper float string forms). These changes address parsing/validation and data-format issues that would cause incorrect runtime behavior. ",
    "patches": {
      "src/modules/navigator/datalinkloss_params.c": {
        "filename": "src/modules/navigator/datalinkloss_params.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -64,7 +64,7 @@ PARAM_DEFINE_FLOAT(NAV_DLL_CH_T, 120.0f);\n  * Latitude of comms hold waypoint\n  *\n  * @unit degrees * 1e7\n- * @min 0.0\n+ * @min 0\n  * @group DLL\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CH_LAT, -266072120);\n@@ -75,7 +75,7 @@ PARAM_DEFINE_INT32(NAV_DLL_CH_LAT, -266072120);\n  * Longitude of comms hold waypoint\n  *\n  * @unit degrees * 1e7\n- * @min 0.0\n+ * @min 0\n  * @group DLL\n  */\n PARAM_DEFINE_INT32(NAV_DLL_CH_LON, 1518453890);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3dc8cf87691d8376f380f7739a6fb43c1f529a1b/src%2Fmodules%2Fnavigator%2Fdatalinkloss_params.c"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -94,7 +94,7 @@ PARAM_DEFINE_INT32(NAV_RCL_OBC, 0);\n  * Latitude of airfield home waypoint\n  *\n  * @unit degrees * 1e7\n- * @min 0.0\n+ * @min 0\n  * @group DLL\n  */\n PARAM_DEFINE_INT32(NAV_AH_LAT, -265847810);\n@@ -105,7 +105,7 @@ PARAM_DEFINE_INT32(NAV_AH_LAT, -265847810);\n  * Longitude of airfield home waypoint\n  *\n  * @unit degrees * 1e7\n- * @min 0.0\n+ * @min 0\n  * @group DLL\n  */\n PARAM_DEFINE_INT32(NAV_AH_LON, 1518423250);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3dc8cf87691d8376f380f7739a6fb43c1f529a1b/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "GF range warning limit mavlink critical messages",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/2028",
    "number": 2028,
    "created_at": "2015-04-14T22:46:26Z",
    "merged": true,
    "merged_at": "2015-04-18T07:53:48Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "This changes the geofence range warning to only send a mavlink critical message when your distance outside the max horizontal/vertical has increased instead of every time it's checked (quite annoying).\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2015-04-15T00:20:16Z",
          "body": "On second thought, maybe this is still too much? Maybe it should be any change in distance and a couple seconds.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-15T07:34:32Z",
          "body": "@dagar An additional throttling based on time might make sense, but is only required if you can't set the distance to a higher value. If you make it 30-50m then it should sound only every few seconds, even for fast vehicles. And given that an increase is a pretty significant issue, it being annoying probably makes sense.\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2015-04-17T23:13:16Z",
          "body": "@LorenzMeier Now I'm thinking just a time based delay would best cover all scenarios. I chose 3 seconds.\n\nI flew this and it worked well for me slowing flying a hex in a small area.\n",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2015-04-18T07:53:42Z",
          "body": "cool, thanks! Looking forward to the RTL part next ;-).\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the notification condition from sending a mavlink critical message on every check while outside the geofence to only when the out-of-bounds distance increases (and later to a time-throttled approach). This fixes incorrect notification logic (unnecessary repeated alerts) by correcting the condition/state used to trigger messages and adding sensible throttling.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 4,
        "changes": 21,
        "patch": "@@ -51,12 +51,15 @@\n #include <unistd.h>\n #include <mavlink/mavlink_log.h>\n #include <geo/geo.h>\n+#include <drivers/drv_hrt.h>\n \n #define GEOFENCE_OFF 0\n #define GEOFENCE_FILE_ONLY 1\n #define GEOFENCE_MAX_DISTANCES_ONLY 2\n #define GEOFENCE_FILE_AND_MAX_DISTANCES 3\n \n+#define GEOFENCE_RANGE_WARNING_LIMIT 3000000\n+\n \n /* Oddly, ERROR is not defined for C++ */\n #ifdef ERROR\n@@ -69,6 +72,8 @@ Geofence::Geofence() :\n \t_fence_pub(-1),\n \t_home_pos{},\n \t_home_pos_set(false),\n+\t_last_horizontal_range_warning(0),\n+\t_last_vertical_range_warning(0),\n \t_altitude_min(0),\n \t_altitude_max(0),\n \t_verticesCount(0),\n@@ -146,14 +151,22 @@ bool Geofence::inside(double lat, double lon, float altitude)\n \t\t\t\t\t\t\t\t   &dist_xy, &dist_z);\n \n \t\t\t\tif (max_vertical_distance > 0 && (dist_z > max_vertical_distance)) {\n-\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"Geofence exceeded max vertical distance by %.0f m\",\n-\t\t\t\t\t\t\t     (double)(dist_z - max_vertical_distance));\n+\t\t\t\t\tif (hrt_elapsed_time(&_last_vertical_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n+\t\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"Geofence exceeded max vertical distance by %.1f m\",\n+\t\t\t\t\t\t\t\t     (double)(dist_z - max_vertical_distance));\n+\t\t\t\t\t\t_last_vertical_range_warning = hrt_absolute_time();\n+\t\t\t\t\t}\n+\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \n \t\t\t\tif (max_horizontal_distance > 0 && (dist_xy > max_horizontal_distance)) {\n-\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"Geofence exceeded max horizontal distance by %.0f m\",\n-\t\t\t\t\t\t\t     (double)(dist_xy - max_horizontal_distance));\n+\t\t\t\t\tif (hrt_elapsed_time(&_last_horizontal_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n+\t\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"Geofence exceeded max horizontal distance by %.1f m\",\n+\t\t\t\t\t\t\t\t     (double)(dist_xy - max_horizontal_distance));\n+\t\t\t\t\t\t_last_horizontal_range_warning = hrt_absolute_time();\n+\t\t\t\t\t}\n+\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/230c0b95e32b84f72cd8a9cc6dbff15026eefa14/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -48,6 +48,7 @@\n #include <uORB/topics/home_position.h>\n #include <controllib/blocks.hpp>\n #include <controllib/block/BlockParam.hpp>\n+#include <drivers/drv_hrt.h>\n \n #define GEOFENCE_FILENAME \"/fs/microsd/etc/geofence.txt\"\n \n@@ -109,6 +110,9 @@ class Geofence : public control::SuperBlock\n \thome_position_s _home_pos;\n \tbool _home_pos_set;\n \n+\thrt_abstime _last_horizontal_range_warning;\n+\thrt_abstime _last_vertical_range_warning;\n+\n \tfloat\t\t\t_altitude_min;\n \tfloat\t\t\t_altitude_max;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/230c0b95e32b84f72cd8a9cc6dbff15026eefa14/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::inside",
        "Geofence::Geofence"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::inside",
          "Geofence::Geofence"
        ]
      }
    }
  },
  {
    "title": "navigator: Get rid of audio tag in strings and use appropriate priority ...",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/2023",
    "number": 2023,
    "created_at": "2015-04-14T11:25:41Z",
    "merged": true,
    "merged_at": "2015-04-14T13:44:45Z",
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "...to get audio out when needed in the GCS.\n\n@tumbili Please review and let me know what you think.\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR title and description indicate a change from embedding an \"audio\" tag inside strings to using an explicit priority mechanism so the GCS will play audio when required. That addresses incorrect behaviour/data-flow (using message text to trigger audio) and likely fixes when audio is emitted, which is a logic-level bug rather than a syntax/style issue. Confidence is medium because no code or review details were provided to confirm the exact implementation.",
    "patches": {
      "src/modules/navigator/datalinkloss.cpp": {
        "filename": "src/modules/navigator/datalinkloss.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "patch": "@@ -186,27 +186,27 @@ DataLinkLoss::advance_dll()\n \t\tif (_navigator->get_vstatus()->data_link_lost_counter > _param_numberdatalinklosses.get()) {\n \t\t\twarnx(\"%d data link losses, limit is %d, fly to airfield home\",\n \t\t\t\t\t_navigator->get_vstatus()->data_link_lost_counter, _param_numberdatalinklosses.get());\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: too many DL losses, fly to airfield home\");\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"too many DL losses, fly to airfield home\");\n \t\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n \t\t\t_navigator->set_mission_result_updated();\n \t\t\treset_mission_item_reached();\n \t\t\t_dll_state = DLL_STATE_FLYTOAIRFIELDHOMEWP;\n \t\t} else {\n \t\t\tif (!_param_skipcommshold.get()) {\n \t\t\t\twarnx(\"fly to comms hold, datalink loss counter: %d\", _navigator->get_vstatus()->data_link_lost_counter);\n-\t\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: fly to comms hold\");\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"fly to comms hold\");\n \t\t\t\t_dll_state = DLL_STATE_FLYTOCOMMSHOLDWP;\n \t\t\t} else {\n \t\t\t\t/* comms hold wp not active, fly to airfield home directly */\n \t\t\t\twarnx(\"Skipping comms hold wp. Flying directly to airfield home\");\n-\t\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: fly to airfield home, comms hold skipped\");\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"fly to airfield home, comms hold skipped\");\n \t\t\t\t_dll_state = DLL_STATE_FLYTOAIRFIELDHOMEWP;\n \t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DLL_STATE_FLYTOCOMMSHOLDWP:\n \t\twarnx(\"fly to airfield home\");\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: fly to airfield home\");\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"fly to airfield home\");\n \t\t_dll_state = DLL_STATE_FLYTOAIRFIELDHOMEWP;\n \t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n \t\t_navigator->set_mission_result_updated();\n@@ -215,7 +215,7 @@ DataLinkLoss::advance_dll()\n \tcase DLL_STATE_FLYTOAIRFIELDHOMEWP:\n \t\t_dll_state = DLL_STATE_TERMINATE;\n \t\twarnx(\"time is up, state should have been changed manually by now\");\n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: no manual control, terminating\");\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no manual control, terminating\");\n \t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n \t\t_navigator->set_mission_result_updated();\n \t\treset_mission_item_reached();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fdatalinkloss.cpp"
      },
      "src/modules/navigator/enginefailure.cpp": {
        "filename": "src/modules/navigator/enginefailure.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -140,7 +140,7 @@ EngineFailure::advance_ef()\n {\n \tswitch (_ef_state) {\n \tcase EF_STATE_NONE:\n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: Engine failure. Loitering down\");\n+\t\tmavlink_log_emergency(_navigator->get_mavlink_fd(), \"Engine failure. Loitering down\");\n \t\t_ef_state = EF_STATE_LOITERDOWN;\n \t\tbreak;\n \tdefault:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fenginefailure.cpp"
      },
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -146,13 +146,13 @@ bool Geofence::inside(double lat, double lon, float altitude)\n \t\t\t\t\t\t\t\t   &dist_xy, &dist_z);\n \n \t\t\t\tif (max_vertical_distance > 0 && (dist_z > max_vertical_distance)) {\n-\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"#audio: Geofence exceeded max vertical distance by %.0f m\",\n+\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"Geofence exceeded max vertical distance by %.0f m\",\n \t\t\t\t\t\t\t     (double)(dist_z - max_vertical_distance));\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \n \t\t\t\tif (max_horizontal_distance > 0 && (dist_xy > max_horizontal_distance)) {\n-\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"#audio: Geofence exceeded max horizontal distance by %.0f m\",\n+\t\t\t\t\tmavlink_log_critical(_mavlinkFd, \"Geofence exceeded max horizontal distance by %.0f m\",\n \t\t\t\t\t\t\t     (double)(dist_xy - max_horizontal_distance));\n \t\t\t\t\treturn false;\n \t\t\t\t}\n@@ -409,7 +409,7 @@ Geofence::loadFromFile(const char *filename)\n \n \t} else {\n \t\twarnx(\"Geofence: import error\");\n-\t\tmavlink_log_critical(_mavlinkFd, \"#audio: Geofence import error\");\n+\t\tmavlink_log_critical(_mavlinkFd, \"Geofence import error\");\n \t}\n \n error:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/gpsfailure.cpp": {
        "filename": "src/modules/navigator/gpsfailure.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -161,12 +161,12 @@ GpsFailure::advance_gpsf()\n \tcase GPSF_STATE_NONE:\n \t\t_gpsf_state = GPSF_STATE_LOITER;\n \t\twarnx(\"gpsf loiter\");\n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: open loop loiter\");\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"GPS failed: open loop loiter\");\n \t\tbreak;\n \tcase GPSF_STATE_LOITER:\n \t\t_gpsf_state = GPSF_STATE_TERMINATE;\n \t\twarnx(\"gpsf terminate\");\n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: no gps recovery, termination\");\n+\t\tmavlink_log_emergency(_navigator->get_mavlink_fd(), \"no gps recovery, termination\");\n \t\twarnx(\"mavlink sent\");\n \t\tbreak;\n \tcase GPSF_STATE_TERMINATE:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fgpsfailure.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -159,7 +159,7 @@ MissionBlock::is_mission_item_reached()\n \t\t\t_time_first_inside_orbit = now;\n \n \t\t\t// if (_mission_item.time_inside > 0.01f) {\n-\t\t\t// \tmavlink_log_info(_mavlink_fd, \"#audio: waypoint reached, wait for %.1fs\",\n+\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n \t\t\t// \t\t(double)_mission_item.time_inside);\n \t\t\t// }\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -121,7 +121,7 @@ bool MissionFeasibilityChecker::checkGeofence(dm_item_t dm_current, size_t nMiss\n \t\t\t}\n \n \t\t\tif (!geofence.inside_polygon(missionitem.lat, missionitem.lon, missionitem.altitude)) {\n-\t\t\t\tmavlink_log_info(_mavlink_fd, \"#audio: Geofence violation waypoint %d\", i);\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation waypoint %d\", i);\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n@@ -203,25 +203,25 @@ bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size\n \t\t\t\t\t\t\treturn true;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t/* Landing waypoint is above altitude of slope at the given waypoint distance */\n-\t\t\t\t\t\t\tmavlink_log_info(_mavlink_fd, \"#audio: Landing: last waypoint too high/too close\");\n-\t\t\t\t\t\t\tmavlink_log_info(_mavlink_fd, \"Move down to %.1fm or move further away by %.1fm\",\n+\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Landing: last waypoint too high/too close\");\n+\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Move down to %.1fm or move further away by %.1fm\",\n \t\t\t\t\t\t\t\t\t(double)(slope_alt_req),\n \t\t\t\t\t\t\t\t\t(double)(wp_distance_req - wp_distance));\n \t\t\t\t\t\t\treturn false;\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t/* Landing waypoint is above last waypoint */\n-\t\t\t\t\t\tmavlink_log_info(_mavlink_fd, \"#audio: Landing waypoint above last nav waypoint\");\n+\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Landing waypoint above last nav waypoint\");\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t/* Last wp is in flare region */\n \t\t\t\t\t//xxx give recommendations\n-\t\t\t\t\tmavlink_log_info(_mavlink_fd, \"#audio: Warning: Landing: last waypoint in flare region\");\n+\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Landing: last waypoint in flare region\");\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tmavlink_log_info(_mavlink_fd, \"#audio: Warning: starting with land waypoint\");\n+\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: starting with land waypoint\");\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -409,7 +409,7 @@ Navigator::task_main()\n \n \t\t\t\t/* Issue a warning about the geofence violation once */\n \t\t\t\tif (!_geofence_violation_warning_sent) {\n-\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"#audio: Geofence violation\");\n+\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation\");\n \t\t\t\t\t_geofence_violation_warning_sent = true;\n \t\t\t\t}\n \t\t\t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rcloss.cpp": {
        "filename": "src/modules/navigator/rcloss.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -155,11 +155,11 @@ RCLoss::advance_rcl()\n \tcase RCL_STATE_NONE:\n \t\tif (_param_loitertime.get() > 0.0f) {\n \t\t\twarnx(\"RC loss, OBC mode, loiter\");\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: rc loss, loitering\");\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"rc loss, loitering\");\n \t\t\t_rcl_state = RCL_STATE_LOITER;\n \t\t} else {\n \t\t\twarnx(\"RC loss, OBC mode, slip loiter, terminate\");\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: rc loss, terminating\");\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"rc loss, terminating\");\n \t\t\t_rcl_state = RCL_STATE_TERMINATE;\n \t\t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n \t\t\t_navigator->set_mission_result_updated();\n@@ -169,7 +169,7 @@ RCLoss::advance_rcl()\n \tcase RCL_STATE_LOITER:\n \t\t_rcl_state = RCL_STATE_TERMINATE;\n \t\twarnx(\"time is up, no RC regain, terminating\");\n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RC not regained, terminating\");\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RC not regained, terminating\");\n \t\t_navigator->get_mission_result()->stay_in_failsafe = true;\n \t\t_navigator->set_mission_result_updated();\n \t\treset_mission_item_reached();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Frcloss.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -89,7 +89,7 @@ RTL::on_activation()\n \t\t/* for safety reasons don't go into RTL if landed */\n \t\tif (_navigator->get_vstatus()->condition_landed) {\n \t\t\t_rtl_state = RTL_STATE_LANDED;\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: no RTL when landed\");\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no RTL when landed\");\n \n \t\t/* if lower than return altitude, climb up first */\n \t\t} else if (_navigator->get_global_position()->alt < _navigator->get_home_position()->alt\n@@ -146,7 +146,7 @@ RTL::set_rtl_item()\n \t\t_mission_item.autocontinue = true;\n \t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: climb to %d meters above home\",\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: climb to %d meters above home\",\n \t\t\t(int)(climb_alt - _navigator->get_home_position()->alt));\n \t\tbreak;\n \t}\n@@ -177,7 +177,7 @@ RTL::set_rtl_item()\n \t\t_mission_item.autocontinue = true;\n \t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: return at %d meters above home\",\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: return at %d meters above home\",\n \t\t\t(int)(_mission_item.altitude - _navigator->get_home_position()->alt));\n \t\tbreak;\n \t}\n@@ -197,7 +197,7 @@ RTL::set_rtl_item()\n \t\t_mission_item.autocontinue = false;\n \t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: descend to %d meters above home\",\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: descend to %d meters above home\",\n \t\t\t(int)(_mission_item.altitude - _navigator->get_home_position()->alt));\n \t\tbreak;\n \t}\n@@ -222,10 +222,10 @@ RTL::set_rtl_item()\n \t\t_navigator->set_can_loiter_at_sp(true);\n \n \t\tif (autoland) {\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: loiter %.1fs\", (double)_mission_item.time_inside);\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: loiter %.1fs\", (double)_mission_item.time_inside);\n \n \t\t} else {\n-\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: completed, loiter\");\n+\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: completed, loiter\");\n \t\t}\n \t\tbreak;\n \t}\n@@ -245,7 +245,7 @@ RTL::set_rtl_item()\n \t\t_mission_item.autocontinue = true;\n \t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: land at home\");\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: land at home\");\n \t\tbreak;\n \t}\n \n@@ -264,7 +264,7 @@ RTL::set_rtl_item()\n \t\t_mission_item.autocontinue = true;\n \t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n-\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"#audio: RTL: completed, landed\");\n+\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"RTL: completed, landed\");\n \t\tbreak;\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b3422161442dd00522860616527df6c46079c7b/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionFeasibilityChecker::checkFixedWingLanding",
        "RTL::set_rtl_item",
        "MissionBlock::is_mission_item_reached",
        "GpsFailure::advance_gpsf",
        "Navigator::task_main",
        "EngineFailure::advance_ef",
        "Geofence::inside",
        "RCLoss::advance_rcl",
        "RTL::on_activation",
        "MissionFeasibilityChecker::checkGeofence",
        "Geofence::loadFromFile",
        "DataLinkLoss::advance_dll"
      ],
      "by_file": {
        "src/modules/navigator/datalinkloss.cpp": [
          "DataLinkLoss::advance_dll"
        ],
        "src/modules/navigator/enginefailure.cpp": [
          "EngineFailure::advance_ef"
        ],
        "src/modules/navigator/geofence.cpp": [
          "Geofence::loadFromFile",
          "Geofence::inside"
        ],
        "src/modules/navigator/gpsfailure.cpp": [
          "GpsFailure::advance_gpsf"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkFixedWingLanding",
          "MissionFeasibilityChecker::checkGeofence"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ],
        "src/modules/navigator/rcloss.cpp": [
          "RCLoss::advance_rcl"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::set_rtl_item",
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "MS5611 reliability",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/2011",
    "number": 2011,
    "created_at": "2015-04-10T23:36:19Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "LorenzMeier",
      "body": "This fixes reliability issues found in the reset logic in #2007. Likely not going to improve / affect operation on Pixhawk, but helpful for anyone operating via I2C.\n",
      "issue_comments": [
        {
          "author": "bansiesta",
          "created_at": "2015-05-25T16:27:50Z",
          "body": "Reviewed, can be merged in my opinion.\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR explicitly states it fixes reliability issues in the reset logic for the MS5611 driver, which indicates incorrect behavior/state transitions rather than a syntax or style issue. The change targets improper reset handling that produced unreliable operation (especially over I2C), fitting the definition of a logic error.",
    "patches": {
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -55,7 +55,8 @@\n #include \"navigator.h\"\n \n Loiter::Loiter(Navigator *navigator, const char *name) :\n-\tMissionBlock(navigator, name)\n+\tMissionBlock(navigator, name),\n+\t_param_min_alt(this, \"MIS_TAKEOFF_ALT\", false)\n {\n \t/* load initial params */\n \tupdateParams();\n@@ -74,7 +75,7 @@ void\n Loiter::on_activation()\n {\n \t/* set current mission item to loiter */\n-\tset_loiter_item(&_mission_item);\n+\tset_loiter_item(&_mission_item, _param_min_alt.get());\n \n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73d179fb59eb996d7cf95ab524b399c8efc8d407/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/loiter.h": {
        "filename": "src/modules/navigator/loiter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -59,6 +59,9 @@ class Loiter : public MissionBlock\n \tvirtual void on_activation();\n \n \tvirtual void on_active();\n+\n+private:\n+\tcontrol::BlockParamFloat _param_min_alt;\n };\n \n #endif",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73d179fb59eb996d7cf95ab524b399c8efc8d407/src%2Fmodules%2Fnavigator%2Floiter.h"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 8,
        "changes": 32,
        "patch": "@@ -377,6 +377,7 @@ Mission::set_mission_items()\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n+\t\t\tuser_feedback_done = true;\n \t\t}\n \t\t_mission_type = MISSION_TYPE_ONBOARD;\n \n@@ -385,28 +386,25 @@ Mission::set_mission_items()\n \t\t/* if mission type changed, notify */\n \t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n \t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n+\t\t\tuser_feedback_done = true;\n \t\t}\n \t\t_mission_type = MISSION_TYPE_OFFBOARD;\n \t} else {\n \t\t/* no mission available or mission finished, switch to loiter */\n \t\tif (_mission_type != MISSION_TYPE_NONE) {\n \t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n+\t\t\tuser_feedback_done = true;\n \n \t\t\t/* use last setpoint for loiter */\n \t\t\t_navigator->set_can_loiter_at_sp(true);\n \n-\t\t} else if (!user_feedback_done) {\n-\t\t\t/* only tell users that we got no mission if there has not been any\n-\t\t\t * better, more specific feedback yet\n-\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n-\t\t\t */\n-\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n \t\t}\n+\n \t\t_mission_type = MISSION_TYPE_NONE;\n \n-\t\t/* set loiter mission item */\n-\t\tset_loiter_item(&_mission_item);\n+\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n+\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n \n \t\t/* update position setpoint triplet  */\n \t\tpos_sp_triplet->previous.valid = false;\n@@ -418,6 +416,24 @@ Mission::set_mission_items()\n \n \t\tset_mission_finished();\n \n+\t\tif (!user_feedback_done) {\n+\t\t\t/* only tell users that we got no mission if there has not been any\n+\t\t\t * better, more specific feedback yet\n+\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n+\t\t\t */\n+\n+\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n+\t\t\t\t/* landed, refusing to take off without a mission */\n+\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n+\t\t\t} else {\n+\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n+\t\t\t}\n+\n+\t\t\tuser_feedback_done = true;\n+\n+\t\t}\n+\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \t\treturn;\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73d179fb59eb996d7cf95ab524b399c8efc8d407/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "patch": "@@ -228,7 +228,7 @@ MissionBlock::set_previous_pos_setpoint()\n }\n \n void\n-MissionBlock::set_loiter_item(struct mission_item_s *item)\n+MissionBlock::set_loiter_item(struct mission_item_s *item, float min_clearance)\n {\n \tif (_navigator->get_vstatus()->condition_landed) {\n \t\t/* landed, don't takeoff, but switch to IDLE mode */\n@@ -246,10 +246,14 @@ MissionBlock::set_loiter_item(struct mission_item_s *item)\n \t\t\titem->altitude = pos_sp_triplet->current.alt;\n \n \t\t} else {\n-\t\t\t/* use current position */\n+\t\t\t/* use current position and use return altitude as clearance */\n \t\t\titem->lat = _navigator->get_global_position()->lat;\n \t\t\titem->lon = _navigator->get_global_position()->lon;\n \t\t\titem->altitude = _navigator->get_global_position()->alt;\n+\n+\t\t\tif (min_clearance > 0.0f && item->altitude < _navigator->get_home_position()->alt + min_clearance) {\n+\t\t\t\titem->altitude = _navigator->get_home_position()->alt + min_clearance;\n+\t\t\t}\n \t\t}\n \n \t\titem->altitude_is_relative = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73d179fb59eb996d7cf95ab524b399c8efc8d407/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -91,7 +91,7 @@ class MissionBlock : public NavigatorMode\n \t/**\n \t * Set a loiter mission item, if possible reuse the position setpoint, otherwise take the current position\n \t */\n-\tvoid set_loiter_item(struct mission_item_s *item);\n+\tvoid set_loiter_item(struct mission_item_s *item, float min_clearance = -1.0f);\n \n \tmission_item_s _mission_item;\n \tbool _waypoint_position_reached;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/73d179fb59eb996d7cf95ab524b399c8efc8d407/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_previous_pos_setpoint",
        "Loiter::on_activation",
        "MissionBlock::set_loiter_item",
        "Mission::set_mission_items",
        "set_loiter_item"
      ],
      "by_file": {
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_activation"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::set_mission_items"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_previous_pos_setpoint",
          "MissionBlock::set_loiter_item"
        ],
        "src/modules/navigator/mission_block.h": [
          "set_loiter_item"
        ]
      }
    }
  },
  {
    "title": "rtl_direct: fix on_inactive()",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22869",
    "number": 22869,
    "created_at": "2024-03-12T09:34:31Z",
    "merged": true,
    "merged_at": "2024-03-12T10:27:50Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Came in yesterday with https://github.com/PX4/PX4-Autopilot/pull/22742\r\nSymptom: on every boot with an invalid mission the system gave warning \"No valid mission available, refusing takeoff\"",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T09:37:21Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The reported symptom (repeated 'No valid mission available, refusing takeoff' warning on every boot with an invalid mission) indicates incorrect program behavior rather than a crash, likely due to wrong state/condition handling in on_inactive(). The PR title and description indicate it fixes that improper state/conditional logic, so this is a logic error fix.",
    "patches": {
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -83,7 +83,7 @@ RtlDirectMissionLand::updateDatamanCache()\n \n void RtlDirectMissionLand::on_inactive()\n {\n-\tMissionBase::on_active();\n+\tMissionBase::on_inactive();\n \n \tupdateDatamanCache();\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/232ff608f9e6f59c5faeadce4fe94576b4e9cf99/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirectMissionLand::updateDatamanCache"
      ],
      "by_file": {
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::updateDatamanCache"
        ]
      }
    }
  },
  {
    "title": "mission: The mission check not reevaluated for RTL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22864",
    "number": 22864,
    "created_at": "2024-03-11T14:03:13Z",
    "merged": true,
    "merged_at": "2024-03-11T16:08:56Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "\r\n<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nA mission on RTL mission landing can not be executed, when the mission is invalid on activation (e.g. when the vehicle in the meantime is too far away to pass the first mission item).\r\n\r\n### Solution\r\n- We need to make sure that when the RTL is triggered, it should not reevaluate it, as when it was valid but evaluated to false on activation, it can't do a RTL.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix Fix a mission RTL not being executed if mission validity changes.\r\n\r\n```\r\n\r\n### Alternatives\r\nThis is only a quick fix for the problem. The mission validity should not change depending on the vehicle current position. If it is evaluated once for the takeoff/current position, it should not reevaluate it. Also the mission feasibility checker should be run separately when any of the relevant data changes (mission, geofence, parameters, etc.). So the state of the mission validity is always known.\r\n\r\n### Test coverage\r\n\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T15:10:01Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses a logic error where mission feasibility was being re-evaluated at RTL activation, causing missions that were valid at activation to be incorrectly treated as invalid due to changed vehicle position. This is an incorrect conditional/state-handling issue (improper re-evaluation), and the change prevents that wrong behavior so RTL can execute as intended.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -86,6 +86,8 @@ Mission::on_activation()\n {\n \t_need_mission_save = true;\n \n+\tcheck_mission_valid(true);\n+\n \tMissionBase::on_activation();\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d726a3ee3d6f7c6d7e0b37e8dbe75c835e60cded/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -207,8 +207,6 @@ MissionBase::on_activation()\n \t_mission_has_been_activated = true;\n \t_system_disarmed_while_inactive = false;\n \n-\tcheck_mission_valid(true);\n-\n \tupdate_mission();\n \n \t// reset the cache and fill it with the items up to the previous item. The cache contains",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d726a3ee3d6f7c6d7e0b37e8dbe75c835e60cded/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -215,6 +215,12 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tbool isMissionValid() const;\n \n+\t/**\n+\t * @brief Check whether a mission is ready to go\n+\t * @param[in] forced flag if the check has to be run irregardles of any updates.\n+\t */\n+\tvoid check_mission_valid(bool forced = false);\n+\n \t/**\n \t * On mission update\n \t * Change behaviour after external mission update.\n@@ -344,12 +350,6 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tvoid updateMavlinkMission();\n \n-\t/**\n-\t * @brief Check whether a mission is ready to go\n-\t * @param[in] forced flag if the check has to be run irregardles of any updates.\n-\t */\n-\tvoid check_mission_valid(bool forced = false);\n-\n \t/**\n \t * Reset mission\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d726a3ee3d6f7c6d7e0b37e8dbe75c835e60cded/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "check_mission_valid",
        "Mission::on_activation",
        "MissionBase::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::on_activation"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_activation"
        ],
        "src/modules/navigator/mission_base.h": [
          "check_mission_valid"
        ]
      }
    }
  },
  {
    "title": " Commander: make low remaining flight time configurable and fix clearing condition",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22863",
    "number": 22863,
    "created_at": "2024-03-11T13:04:51Z",
    "merged": true,
    "merged_at": "2024-03-12T11:56:01Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nAround remaining flight time low failsafe:\r\n- not possible to disable\r\n- not possible to switch out of RTL, as it keeps getting re-engaged\r\n\r\n### Solution\r\n- new param `COM_FLTT_LOW_ACT`\r\n- update rlt time estimate also in RTL, and use it to set the flight_time_low flag to false if it applies (e.g. because user has moved the RTL destination, see screen recording)\r\n- add hysteresis to make instant re-triggering less likely\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nImprovement:  Commander: make low remaining flight time configurable and do not clear\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Screenrecordings\r\n\r\nWithout the fix:\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/assets/26798987/ff9b6042-5dc7-4b8e-8714-36d39d1cec27\r\n\r\n\r\nWith the fix:\r\n\r\nUploading AMC_RTL_time_with_fix_2.mp4â€¦\r\n\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-12T09:39:10Z",
          "body": "Flash overflow - propose https://github.com/PX4/PX4-Autopilot/pull/22870",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2025-01-17T10:37:53Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/issue-with-battery-status-in-px4/43200/4\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T14:05:02Z",
          "body": "```suggestion\r\n * Action the system takes when the remaining flight time is below\r\n```",
          "path": "src/modules/commander/commander_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T14:32:27Z",
          "body": "Shouldn't we only set those when the return parameter is set?",
          "path": "src/modules/commander/failsafe/failsafe.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T15:26:28Z",
          "body": "I put the clear condition now into the switch.",
          "path": "src/modules/commander/failsafe/failsafe.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T15:09:27Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T15:26:28Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "2024-03-12T09:05:55Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect runtime behavior of the low-remaining-flight-time failsafe: the flag could not be disabled and RTL would be repeatedly re-engaged because the remaining-time estimate wasn't updated/cleared correctly. The changes introduce a configurable action, update the RTL time estimate so the flight_time_low flag can be cleared when appropriate, and add hysteresis to avoid immediate re-triggering, which fixes improper state transitions and boundary handling.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 19,
        "changes": 51,
        "patch": "@@ -208,32 +208,37 @@ void RTL::on_inactive()\n \tif ((now - _destination_check_time) > 2_s) {\n \t\t_destination_check_time = now;\n \t\tsetRtlTypeAndDestination();\n+\t\tpublishRemainingTimeEstimate();\n+\t}\n \n-\t\tconst bool global_position_recently_updated = _global_pos_sub.get().timestamp > 0\n-\t\t\t\t&& hrt_elapsed_time(&_global_pos_sub.get().timestamp) < 10_s;\n+}\n \n-\t\trtl_time_estimate_s estimated_time{};\n-\t\testimated_time.valid = false;\n+void RTL::publishRemainingTimeEstimate()\n+{\n+\tconst bool global_position_recently_updated = _global_pos_sub.get().timestamp > 0\n+\t\t\t&& hrt_elapsed_time(&_global_pos_sub.get().timestamp) < 10_s;\n \n-\t\tif (_navigator->home_global_position_valid() && global_position_recently_updated) {\n-\t\t\tswitch (_rtl_type) {\n-\t\t\tcase RtlType::RTL_DIRECT:\n-\t\t\t\testimated_time = _rtl_direct.calc_rtl_time_estimate();\n-\t\t\t\tbreak;\n+\trtl_time_estimate_s estimated_time{};\n+\testimated_time.valid = false;\n \n-\t\t\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n-\t\t\tcase RtlType::RTL_MISSION_FAST:\n-\t\t\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n-\t\t\t\testimated_time = _rtl_mission_type_handle->calc_rtl_time_estimate();\n-\t\t\t\tbreak;\n+\tif (_navigator->home_global_position_valid() && global_position_recently_updated) {\n+\t\tswitch (_rtl_type) {\n+\t\tcase RtlType::RTL_DIRECT:\n+\t\t\testimated_time = _rtl_direct.calc_rtl_time_estimate();\n+\t\t\tbreak;\n \n-\t\t\tdefault:\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n+\t\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n+\t\tcase RtlType::RTL_MISSION_FAST:\n+\t\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n+\t\t\testimated_time = _rtl_mission_type_handle->calc_rtl_time_estimate();\n+\t\t\tbreak;\n \n-\t\t_rtl_time_estimate_pub.publish(estimated_time);\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n \t}\n+\n+\t_rtl_time_estimate_pub.publish(estimated_time);\n }\n \n void RTL::on_activation()\n@@ -287,6 +292,14 @@ void RTL::on_active()\n \tdefault:\n \t\tbreak;\n \t}\n+\n+\t// Keep publishing remaining time estimates every 2 seconds\n+\thrt_abstime now{hrt_absolute_time()};\n+\n+\tif ((now - _destination_check_time) > 2_s) {\n+\t\t_destination_check_time = now;\n+\t\tpublishRemainingTimeEstimate();\n+\t}\n }\n \n void RTL::setRtlTypeAndDestination()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0729b04817bbaa8a155ee891d26e462d35028a49/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -106,6 +106,12 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tvoid setRtlTypeAndDestination();\n \n+\t/**\n+\t * @brief Publish the remaining time estimate to go to the RTL landing point.\n+\t *\n+\t */\n+\tvoid publishRemainingTimeEstimate();\n+\n \t/**\n \t * @brief Find RTL destination.\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0729b04817bbaa8a155ee891d26e462d35028a49/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "hrt_elapsed_time",
        "RTL::on_active",
        "RTL::on_inactive"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "hrt_elapsed_time",
          "RTL::on_active",
          "RTL::on_inactive"
        ]
      }
    }
  },
  {
    "title": "mission_base: land_start_item invalid only when negative.",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22856",
    "number": 22856,
    "created_at": "2024-03-08T16:36:40Z",
    "merged": true,
    "merged_at": "2024-03-11T08:46:16Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen flying and setting a mission with only a vtol land, it is not executed.\r\n\r\n### Solution\r\n- Check for land_start_inex is wrong. only check if it is negative.\r\n\r\n",
      "issue_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T07:41:22Z",
          "body": "Thanks @dagar ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2024-03-08T19:52:21Z",
          "body": "```suggestion\r\n\treturn _mission_sub.get().land_start_index >= 0 && _mission_sub.get().land_index >= 0;\r\n```",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T18:09:57Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "2024-03-08T19:52:21Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T08:35:11Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes an incorrect conditional that treated a valid land_start index as invalid (causing VTOL-only land missions to not execute). Changing the check to only consider negative values as invalid corrects the program logic and resolves the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -123,7 +123,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t * @return true If mission has a land start of land item and a land item\n \t * @return false otherwise\n \t */\n-\tbool hasMissionLandStart() const { return _mission.land_start_index > 0 && _mission.land_index > 0;};\n+\tbool hasMissionLandStart() const { return _mission.land_start_index >= 0 && _mission.land_index >= 0;};\n \t/**\n \t * @brief Go to next Mission Item\n \t * Go to next non jump mission item",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bd346235c769dd10faf5dcd7a989c0271123318f/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -604,7 +604,7 @@ void RTL::parameters_update()\n \n bool RTL::hasMissionLandStart() const\n {\n-\treturn _mission_sub.get().land_start_index > 0;\n+\treturn _mission_sub.get().land_start_index >= 0 && _mission_sub.get().land_index >= 0;\n }\n \n bool RTL::hasVtolLandApproach(const PositionYawSetpoint &rtl_position) const",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bd346235c769dd10faf5dcd7a989c0271123318f/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "hasMissionLandStart",
        "RTL::parameters_update"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.h": [
          "hasMissionLandStart"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::parameters_update"
        ]
      }
    }
  },
  {
    "title": "Fix mission check for init mission",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22846",
    "number": 22846,
    "created_at": "2024-03-06T12:42:38Z",
    "merged": true,
    "merged_at": "2024-03-08T16:26:04Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nThe mission feasibility checks could return a wrong result on startup for the loaded mission on the storage.\r\n\r\n### Solution\r\n- Only run the mission feasibility check after the geofence has loaded all the data.\r\n- Only run mission feasibility check after a global position topic has been published.\r\n- Some Bugfixes\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix Correclty check mission feasilbity on startup\r\n```\r\n\r\n### Alternatives\r\nWe really should decouple the feasibility check from the mission execution.\r\n\r\n### Test coverage\r\n- SITL test:\r\n  - Test case 1: Define a valid mission and store it on the vehicle. Stop the simulation. Start it again, with a different location far away.\r\n  - Test case 2: Define a mission and a geofence, where the mission violates the geofence. Stop the simulation. Start it again.\r\n  - Test results: Prior in both cases, the vehicle would arm then immediately shut down again since the reevaluation of the mission feasibility returned the expected result. However, with the PR, the vehicle is not even armed, as it properly determines the mission feasibility at startup.\r\n\r\n#### BE AWARE OF\r\n\r\n- What should be happening if we don't have a global position? (i guess we anyways can't fly the mission, so it should be fine).\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-06T15:27:19Z",
          "body": "Okay I've checked the state about requirement when to run the feasibility checker and when not (what is now in `canRunMissionFeasibility()`).\r\nWith current main the mission feasibility checks [return false if ho valid Home is set](https://github.com/PX4/PX4-Autopilot/blob/c5835a48deb2abc7d403aaab7a657e1a5f624af8/src/modules/navigator/mission_feasibility_checker.cpp#L71). And it is not possible to set a Home position manually because of it's [rejected if local position is invalid.](https://github.com/PX4/PX4-Autopilot/blob/c5835a48deb2abc7d403aaab7a657e1a5f624af8/src/modules/commander/HomePosition.cpp#L253).\r\nWith the changes as proposed here the behavior is different in that it will in the \"no GPS\" case always upload the mission instead of rejecting it, but then it will check the feasibility of it once it gets a GPS lock. Seems better to me, and it's still safe as you won't be able to execute an invalid mission in both ways.\r\n\r\nIt would be nice to support planning missions offline or with a vehicle without GPS lock and still run the checks that are possible (e.g. by assuming that the vehicle position is at the planned Home), but this is for me a new feature request.",
          "type": "issue_comment"
        },
        {
          "author": "jongell",
          "created_at": "2024-03-08T05:33:05Z",
          "body": "Tested with VTOL:\r\n\r\nWorks with: \r\n-Existing Takeoff in the mission, but missing landing pattern\r\n-1st Waypoint too far\r\n\r\nFound one corner case:\r\n1. MIS_DIST_1WP = 10000\r\n2. Upload normal VTOL Mission with Take off and Land Pattern within 10000m\r\n3. Change MIS_DIST_1WP to 1m\r\n4. Start Mission without reuploading it via Action in AMC\r\n\r\nHere the Vehicle first arms, switches to Mission and then triggers the no valid mission failsafe, switches to return, waits and disarms",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-08T07:28:44Z",
          "body": "> Tested with VTOL:\r\n> \r\n> Works with: -Existing Takeoff in the mission, but missing landing pattern -1st Waypoint too far\r\n> \r\n> Found one corner case:\r\n> \r\n> 1. MIS_DIST_1WP = 10000\r\n> 2. Upload normal VTOL Mission with Take off and Land Pattern within 10000m\r\n> 3. Change MIS_DIST_1WP to 1m\r\n> 4. Start Mission without reuploading it via Action in AMC\r\n> \r\n> Here the Vehicle first arms, switches to Mission and then triggers the no valid mission failsafe, switches to return, waits and disarms\r\n\r\nThanks for testing. Yeah, the check is not rerun on parameters change that is why the commander thinks the mission is feasible and switches to the mission. On mission activation however, the check is performed again, and thus, at this point it know that it is infeasible and shuts down again. I think we should address this later when we properly fix/refactor the check. I will only make a small change to make sure that the mission is rechecked on activation (currently depending on timing, you could change the parameter such that the mission is infeasible and still fly the mission). @sfuhrer for visibility",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-06T15:31:57Z",
          "body": "All good findings, and for me the right solutions. As you say probably not the last bugs in the logic but certainly a stab in the right direction. ",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T09:24:23Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses a logic bug where mission feasibility was evaluated at the wrong time (before geofence data and a global position/home were available), leading to incorrect accept/reject outcomes on startup. The fix changes the ordering/conditions for running the feasibility check (and adds recheck on activation), correcting the incorrect state-dependent behavior rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "patch": "@@ -46,13 +46,6 @@ FeasibilityChecker::FeasibilityChecker() :\n \n void FeasibilityChecker::reset()\n {\n-\n-\t_is_landed = false;\n-\t_home_alt_msl = NAN;\n-\t_home_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n-\t_current_position_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n-\t_vehicle_type = VehicleType::RotaryWing;\n-\n \t_mission_validity_failed = false;\n \t_takeoff_failed = false;\n \t_land_pattern_validity_failed = false;\n@@ -86,10 +79,16 @@ void FeasibilityChecker::updateData()\n \n \t\tif (home.valid_hpos) {\n \t\t\t_home_lat_lon = matrix::Vector2d(home.lat, home.lon);\n+\n+\t\t} else {\n+\t\t\t_home_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n \t\t}\n \n \t\tif (home.valid_alt) {\n \t\t\t_home_alt_msl = home.alt;\n+\n+\t\t} else {\n+\t\t\t_home_alt_msl = NAN;\n \t\t}\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3c87bd2fa6b8a4ff2997dcd8e6d27325e7b12ee/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityCheckerTest.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityCheckerTest.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "patch": "@@ -65,6 +65,18 @@ class TestFeasibilityChecker : public FeasibilityChecker\n \t\torb_publish(ORB_ID(home_position), home_pub, &home);\n \t}\n \n+\tvoid publishInvalidHome()\n+\t{\n+\t\thome_position_s home = {};\n+\t\thome.alt = 0.f;\n+\t\thome.valid_alt = false;\n+\t\thome.lat = 0.;\n+\t\thome.lon = 0.;\n+\t\thome.valid_hpos = false;\n+\t\torb_advert_t home_pub = orb_advertise(ORB_ID(home_position), &home);\n+\t\torb_publish(ORB_ID(home_position), home_pub, &home);\n+\t}\n+\n \tvoid publishCurrentPosition(double lat, double lon)\n \t{\n \t\tvehicle_global_position_s gpos = {};\n@@ -122,6 +134,7 @@ TEST_F(FeasibilityCheckerTest, mission_item_validity)\n \tASSERT_EQ(ret, false);\n \n \tchecker.reset();\n+\tchecker.publishInvalidHome();\n \tmission_item.nav_cmd = NAV_CMD_TAKEOFF;\n \tmission_item.altitude_is_relative = true;\n \tret = checker.processNextItem(mission_item, 0, 5);\n@@ -190,6 +203,7 @@ TEST_F(FeasibilityCheckerTest, check_below_home)\n \n \t// this is done to invalidate the home position\n \tchecker.reset();\n+\tchecker.publishInvalidHome();\n \tchecker.publishLanded(true);\n \tchecker.processNextItem(mission_item, 0, 1);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3c87bd2fa6b8a4ff2997dcd8e6d27325e7b12ee/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityCheckerTest.cpp"
      },
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "patch": "@@ -81,6 +81,8 @@ Geofence::Geofence(Navigator *navigator) :\n \tif (_navigator != nullptr) {\n \t\tupdateFence();\n \t}\n+\n+\t_geofence_status_pub.advertise();\n }\n \n Geofence::~Geofence()\n@@ -101,6 +103,14 @@ void Geofence::run()\n \t\tif (_initiate_fence_updated) {\n \t\t\t_initiate_fence_updated = false;\n \t\t\t_dataman_state\t= DatamanState::Read;\n+\n+\t\t\tgeofence_status_s status;\n+\t\t\tstatus.timestamp = hrt_absolute_time();\n+\t\t\tstatus.geofence_id = _opaque_id;\n+\t\t\tstatus.status = geofence_status_s::GF_STATUS_LOADING;\n+\n+\t\t\t_geofence_status_pub.publish(status);\n+\n \t\t}\n \n \t\tbreak;\n@@ -147,6 +157,14 @@ void Geofence::run()\n \n \t\t\t} else {\n \t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n+\t\t\t\t_fence_updated = true;\n+\n+\t\t\t\tgeofence_status_s status;\n+\t\t\t\tstatus.timestamp = hrt_absolute_time();\n+\t\t\t\tstatus.geofence_id = _opaque_id;\n+\t\t\t\tstatus.status = geofence_status_s::GF_STATUS_READY;\n+\n+\t\t\t\t_geofence_status_pub.publish(status);\n \t\t\t}\n \t\t}\n \n@@ -160,6 +178,13 @@ void Geofence::run()\n \t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n \t\t\t_updateFence();\n \t\t\t_fence_updated = true;\n+\n+\t\t\tgeofence_status_s status;\n+\t\t\tstatus.timestamp = hrt_absolute_time();\n+\t\t\tstatus.geofence_id = _opaque_id;\n+\t\t\tstatus.status = geofence_status_s::GF_STATUS_READY;\n+\n+\t\t\t_geofence_status_pub.publish(status);\n \t\t}\n \n \t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3c87bd2fa6b8a4ff2997dcd8e6d27325e7b12ee/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/geofence.h": {
        "filename": "src/modules/navigator/geofence.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -49,6 +49,7 @@\n #include <lib/geo/geo.h>\n #include <px4_platform_common/defines.h>\n #include <uORB/Subscription.hpp>\n+#include <uORB/topics/geofence_status.h>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/sensor_gps.h>\n@@ -171,7 +172,7 @@ class Geofence : public ModuleParams\n \tmission_stats_entry_s _stats;\n \tDatamanState _dataman_state{DatamanState::UpdateRequestWait};\n \tDatamanState _error_state{DatamanState::UpdateRequestWait};\n-\tDatamanCache _dataman_cache{\"geofence_dm_cache_miss\", 4};\n+\tDatamanCache _dataman_cache{\"geofence_dm_cache_miss\", 0};\n \tDatamanClient\t&_dataman_client = _dataman_cache.client();\n \n \tfloat _altitude_min{0.0f};\n@@ -185,6 +186,8 @@ class Geofence : public ModuleParams\n \tbool _fence_updated{true};  ///< flag indicating if fence are updated to dataman cache\n \tbool _initiate_fence_updated{true}; ///< flag indicating if fence updated is needed\n \n+\tuORB::Publication<geofence_status_s> _geofence_status_pub{ORB_ID(geofence_status)};\n+\n \t/**\n \t * implementation of updateFence()\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3c87bd2fa6b8a4ff2997dcd8e6d27325e7b12ee/src%2Fmodules%2Fnavigator%2Fgeofence.h"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 51,
        "changes": 119,
        "patch": "@@ -52,38 +52,22 @@ MissionBase::MissionBase(Navigator *navigator, int32_t dataman_cache_size_signed\n \t_dataman_cache_size_signed(dataman_cache_size_signed)\n {\n \t_dataman_cache.resize(abs(dataman_cache_size_signed));\n-\t_is_current_planned_mission_item_valid = (initMission() == PX4_OK);\n \n-\tupdateDatamanCache();\n+\t// Reset _mission here, and listen on changes on the uorb topic instead of initialize from dataman.\n+\t_mission.mission_dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n+\t_mission.fence_dataman_id = DM_KEY_FENCE_POINTS_0;\n+\t_mission.safepoint_dataman_id = DM_KEY_SAFE_POINTS_0;\n+\t_mission.count = 0;\n+\t_mission.current_seq = 0;\n+\t_mission.land_start_index = -1;\n+\t_mission.land_index = -1;\n+\t_mission.mission_id = 0;\n+\t_mission.geofence_id = 0;\n+\t_mission.safe_points_id = 0;\n \n \t_mission_pub.advertise();\n }\n \n-int MissionBase::initMission()\n-{\n-\tmission_s mission;\n-\tint ret_val{PX4_ERROR};\n-\n-\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission),\n-\t\t\t\t\t\tsizeof(mission_s));\n-\n-\tif (success) {\n-\t\tif (isMissionValid(mission)) {\n-\t\t\t_mission = mission;\n-\t\t\tret_val = PX4_OK;\n-\n-\t\t} else {\n-\t\t\tresetMission();\n-\t\t}\n-\n-\t} else {\n-\t\tPX4_ERR(\"Could not initialize Mission: Dataman read failed\");\n-\t\tresetMission();\n-\t}\n-\n-\treturn ret_val;\n-}\n-\n void\n MissionBase::updateDatamanCache()\n {\n@@ -118,31 +102,35 @@ void MissionBase::updateMavlinkMission()\n \t\t\t\t\t\t  static_cast<int32_t>(new_mission.count) - 1);\n \t\t}\n \n-\t\t_mission = new_mission;\n+\t\tif (new_mission.geofence_id != _mission.geofence_id) {\n+\t\t\t// New geofence data, need to check mission again.\n+\t\t\t_mission_checked = false;\n+\t\t}\n \n-\t\t_is_current_planned_mission_item_valid = isMissionValid(_mission);\n+\t\t_mission = new_mission;\n \n \t\t/* Relevant mission items updated externally*/\n \t\tif (mission_data_changed) {\n \n \t\t\tonMissionUpdate(mission_items_changed);\n \t\t}\n+\n+\t\t_is_current_planned_mission_item_valid = isMissionValid();\n \t}\n }\n \n void MissionBase::onMissionUpdate(bool has_mission_items_changed)\n {\n-\t_is_current_planned_mission_item_valid = _mission.count > 0;\n-\n \tif (has_mission_items_changed) {\n \t\t_dataman_cache.invalidate();\n \t\t_load_mission_index = -1;\n \n-\t\tcheck_mission_valid();\n+\t\tif (canRunMissionFeasibility()) {\n+\t\t\t_mission_checked = true;\n+\t\t\tcheck_mission_valid();\n \n-\t\t// only warn if the check failed on merit\n-\t\tif ((!_navigator->get_mission_result()->valid) && _mission.count > 0U) {\n-\t\t\tPX4_WARN(\"mission check failed\");\n+\t\t} else {\n+\t\t\t_mission_checked = false;\n \t\t}\n \t}\n \n@@ -168,15 +156,17 @@ MissionBase::on_inactive()\n \t_land_detected_sub.update();\n \t_vehicle_status_sub.update();\n \t_global_pos_sub.update();\n+\t_geofence_status_sub.update();\n \n \tparameters_update();\n \n \tupdateMavlinkMission();\n \n-\t/* Need to check the initialized mission once, have to do it here, since we need to wait for the home position. */\n-\tif (_navigator->home_global_position_valid() && !_initialized_mission_checked) {\n+\t/* Check the mission */\n+\tif (!_mission_checked && canRunMissionFeasibility()) {\n+\t\t_mission_checked = true;\n \t\tcheck_mission_valid();\n-\t\t_initialized_mission_checked = true;\n+\t\t_is_current_planned_mission_item_valid = isMissionValid();\n \t}\n \n \tif (_vehicle_status_sub.get().arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n@@ -217,7 +207,7 @@ MissionBase::on_activation()\n \t_mission_has_been_activated = true;\n \t_system_disarmed_while_inactive = false;\n \n-\tcheck_mission_valid();\n+\tcheck_mission_valid(true);\n \n \tupdate_mission();\n \n@@ -259,12 +249,22 @@ MissionBase::on_active()\n \t_land_detected_sub.update();\n \t_vehicle_status_sub.update();\n \t_global_pos_sub.update();\n+\t_geofence_status_sub.update();\n \n \tparameters_update();\n \n \tupdateMavlinkMission();\n \tupdateDatamanCache();\n \n+\t/* Check the mission */\n+\tif (!_mission_checked && canRunMissionFeasibility()) {\n+\t\t_mission_checked = true;\n+\t\tcheck_mission_valid();\n+\t\t_is_current_planned_mission_item_valid = isMissionValid();\n+\t\tupdate_mission();\n+\t\tset_mission_items();\n+\t}\n+\n \t// check if heading alignment is necessary, and add it to the current mission item if necessary\n \tif (_align_heading_necessary && is_mission_item_reached_or_completed()) {\n \n@@ -678,7 +678,7 @@ MissionBase::checkMissionRestart()\n \t    && ((_mission.current_seq + 1) == _mission.count)) {\n \t\tsetMissionIndex(0);\n \t\t_inactivation_index = -1; // reset\n-\t\t_is_current_planned_mission_item_valid = isMissionValid(_mission);\n+\t\t_is_current_planned_mission_item_valid = isMissionValid();\n \t\tresetMissionJumpCounter();\n \t\t_navigator->reset_cruising_speed();\n \t\t_navigator->reset_vroi();\n@@ -687,11 +687,13 @@ MissionBase::checkMissionRestart()\n }\n \n void\n-MissionBase::check_mission_valid()\n+MissionBase::check_mission_valid(bool forced)\n {\n-\tif ((_navigator->get_mission_result()->mission_id != _mission.mission_id)\n-\t    || (_navigator->get_mission_result()->geofence_id != _mission.geofence_id)\n-\t    || (_navigator->get_mission_result()->home_position_counter != _navigator->get_home_position()->update_count)) {\n+\t// Allow forcing it, since we currently not rechecking if parameters have changed.\n+\tif (forced ||\n+\t    (_navigator->get_mission_result()->mission_id != _mission.mission_id) ||\n+\t    (_navigator->get_mission_result()->geofence_id != _mission.geofence_id) ||\n+\t    (_navigator->get_mission_result()->home_position_counter != _navigator->get_home_position()->update_count)) {\n \n \t\t_navigator->get_mission_result()->mission_id = _mission.mission_id;\n \t\t_navigator->get_mission_result()->geofence_id = _mission.geofence_id;\n@@ -704,6 +706,12 @@ MissionBase::check_mission_valid()\n \t\t_navigator->get_mission_result()->failure = false;\n \n \t\tset_mission_result();\n+\n+\t\t// only warn if the check failed on merit\n+\t\tif ((!_navigator->get_mission_result()->valid) && _mission.count > 0U) {\n+\t\t\tPX4_WARN(\"mission check failed\");\n+\t\t}\n+\n \t}\n }\n \n@@ -876,16 +884,16 @@ void MissionBase::publish_navigator_mission_item()\n \t_navigator_mission_item_pub.publish(navigator_mission_item);\n }\n \n-bool MissionBase::isMissionValid(mission_s &mission) const\n+bool MissionBase::isMissionValid() const\n {\n \tbool ret_val{false};\n \n-\tif (((mission.current_seq < mission.count) || (mission.count == 0U && mission.current_seq <= 0)) &&\n-\t    (mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0\n-\t     || mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) &&\n-\t    (mission.timestamp != 0u)) {\n+\tif (((_mission.current_seq < _mission.count) || (_mission.count == 0U && _mission.current_seq <= 0)) &&\n+\t    (_mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ||\n+\t     _mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) &&\n+\t    (_mission.timestamp != 0u) &&\n+\t    (_navigator->get_mission_result()->valid)) {\n \t\tret_val = true;\n-\n \t}\n \n \treturn ret_val;\n@@ -1141,7 +1149,7 @@ int MissionBase::setMissionToClosestItem(double lat, double lon, float alt, floa\n void MissionBase::resetMission()\n {\n \t/* we do not need to reset mission if is already.*/\n-\tif (_mission.count == 0u && isMissionValid(_mission)) {\n+\tif (_mission.count == 0u) {\n \t\treturn;\n \t}\n \n@@ -1360,3 +1368,12 @@ bool MissionBase::checkMissionDataChanged(mission_s new_mission)\n \t\t(new_mission.mission_id != _mission.mission_id) ||\n \t\t(new_mission.current_seq != _mission.current_seq));\n }\n+\n+bool MissionBase::canRunMissionFeasibility()\n+{\n+\treturn _navigator->home_global_position_valid() && // Need to have a home position checked\n+\t       _navigator->get_global_position()->timestamp > 0 && // Need to have a position, for first waypoint check\n+\t       (_geofence_status_sub.get().timestamp > 0) && // Geofence data must be loaded\n+\t       (_geofence_status_sub.get().geofence_id == _mission.geofence_id) &&\n+\t       (_geofence_status_sub.get().status == geofence_status_s::GF_STATUS_READY);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3c87bd2fa6b8a4ff2997dcd8e6d27325e7b12ee/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "patch": "@@ -43,6 +43,7 @@\n #include <drivers/drv_hrt.h>\n #include <px4_platform_common/module_params.h>\n #include <dataman_client/DatamanClient.hpp>\n+#include <uORB/topics/geofence_status.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/navigator_mission_item.h>\n #include <uORB/topics/parameter_update.h>\n@@ -207,13 +208,12 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tint getNonJumpItem(int32_t &mission_index, mission_item_s &mission, bool execute_jump, bool write_jumps,\n \t\t\t   bool mission_direction_backward = false);\n \t/**\n-\t * @brief Is Mission Parameters Valid\n+\t * @brief Is Mission Valid\n \t *\n-\t * @param mission Mission struct\n-\t * @return true is mission parameters are valid\n+\t * @return true is mission is valid\n \t * @return false otherwise\n \t */\n-\tbool isMissionValid(mission_s &mission) const;\n+\tbool isMissionValid() const;\n \n \t/**\n \t * On mission update\n@@ -309,7 +309,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \n \tbool _is_current_planned_mission_item_valid{false};\t/**< Flag indicating if the currently loaded mission item is valid*/\n \tbool _mission_has_been_activated{false};\t\t/**< Flag indicating if the mission has been activated*/\n-\tbool _initialized_mission_checked{false};\t\t/**< Flag indicating if the initialized mission has been checked by the mission validator*/\n+\tbool _mission_checked{false};\t\t\t\t/**< Flag indicating if the mission has been checked by the mission validator*/\n \tbool _system_disarmed_while_inactive{false};\t\t/**< Flag indicating if the system has been disarmed while mission is inactive*/\n \tmission_s _mission;\t\t\t\t\t/**< Currently active mission*/\n \tfloat _mission_init_climb_altitude_amsl{NAN}; \t\t/**< altitude AMSL the vehicle will climb to when mission starts */\n@@ -342,9 +342,10 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvoid updateMavlinkMission();\n \n \t/**\n-\t * Check whether a mission is ready to go\n+\t * @brief Check whether a mission is ready to go\n+\t * @param[in] forced flag if the check has to be run irregardles of any updates.\n \t */\n-\tvoid check_mission_valid();\n+\tvoid check_mission_valid(bool forced = false);\n \n \t/**\n \t * Reset mission\n@@ -444,6 +445,8 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tbool checkMissionDataChanged(mission_s new_mission);\n \n+\tbool canRunMissionFeasibility();\n+\n \tint32_t _load_mission_index{-1}; /**< Mission inted of loaded mission items in dataman cache*/\n \tint32_t _dataman_cache_size_signed; /**< Size of the dataman cache. A negativ value indicates that previous mission items should be loaded, a positiv value the next mission items*/\n \n@@ -461,4 +464,5 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t)\n \n \tuORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};\n+\tuORB::SubscriptionData<geofence_status_s> _geofence_status_sub{ORB_ID(geofence_status)};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d3c87bd2fa6b8a4ff2997dcd8e6d27325e7b12ee/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::MissionBase",
        "MissionBase::checkMissionDataChanged",
        "MissionBase::publish_navigator_mission_item",
        "check_mission_valid",
        "matrix::Vector2d",
        "Geofence::Geofence",
        "FeasibilityChecker::FeasibilityChecker",
        "isMissionValid",
        "MissionBase::initMission",
        "MissionBase::on_active",
        "MissionBase::isMissionValid",
        "FeasibilityChecker::updateData",
        "MissionBase::updateMavlinkMission",
        "Geofence::run",
        "MissionBase::checkMissionRestart",
        "MissionBase::on_activation",
        "MissionBase::on_inactive",
        "MissionBase::check_mission_valid",
        "MissionBase::setMissionToClosestItem"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::updateData",
          "FeasibilityChecker::FeasibilityChecker",
          "matrix::Vector2d"
        ],
        "src/modules/navigator/geofence.cpp": [
          "Geofence::run",
          "Geofence::Geofence"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::MissionBase",
          "MissionBase::checkMissionDataChanged",
          "MissionBase::publish_navigator_mission_item",
          "MissionBase::updateMavlinkMission",
          "MissionBase::checkMissionRestart",
          "MissionBase::on_activation",
          "MissionBase::initMission",
          "MissionBase::on_inactive",
          "MissionBase::on_active",
          "MissionBase::check_mission_valid",
          "MissionBase::setMissionToClosestItem",
          "MissionBase::isMissionValid"
        ],
        "src/modules/navigator/mission_base.h": [
          "check_mission_valid",
          "isMissionValid"
        ]
      }
    }
  },
  {
    "title": "Navigator: remove vtol_takeoff special handling for RTL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22844",
    "number": 22844,
    "created_at": "2024-03-06T08:54:15Z",
    "merged": true,
    "merged_at": "2024-03-08T10:40:14Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "We had a special handling for RTL triggered in vtol_takeoff state. The idea is to wait until the VTOL Takeoff is completed and only then switch to RTL. On a second thought this special handling isn't really necessary and for the sake of simplicity should be removed. This also removes the side effect of the indicated flight mode after RTL being set to VTOL_Takeoff again.\r\nWhile testing it I found that currently RTL in the hover phase of the VTOL Takeoff is completely broken, it just stays hovering. This change here fixes that.\r\nDownside of this change: when triggering RTL shortly after the transition to FW is compete, the vehicle will loiter around the current location to climb to RTL_RETURN_ALT instead of climbing at the defined loiter position, but for me that's an acceptable state.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: RTL during VTOL Takeoff in hover phase not working\r\n```\r\n\r\n### Alternatives\r\n",
      "issue_comments": [
        {
          "author": "jongell",
          "created_at": "2024-03-06T11:30:30Z",
          "body": "@sfuhrer Tested here https://suite.auterion.com/flights/01HR9R2Z6FYB9ZJTCF9P9Y5DDV\r\n\r\nSwitching to return while in VTOL Take off Flight mode and hover with RC works\r\nBut after landing and disarm it still switches to VTOL Take off Flight Mode\r\n\r\nSame problem when letting it front transition and commanding return via AMC actions. Lands disarms and switches to VTOL Take off Flight Mode: https://suite.auterion.com/flights/01HR9R9NSDR0FN9A3A8M8FWHPA\r\n\r\nOne improvement is that it immediately flies into the return loiter circle upon commanding return from AMC instead of continuing the take off and climbing into the take off loiter.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-07T09:33:38Z",
          "body": ">But after landing and disarm it still switches to VTOL Take off Flight Mode\r\n\r\nI checked and this seems to be the correct behavior: after landing in RTL it always switches back to the mode that it was in before the RTL was triggered. @bkueng correct?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-08T08:51:54Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR removes a special-case state handling that caused incorrect behavior and state transitions: RTL during the VTOL takeoff hover phase would not actually execute (it just hovered) and the flight mode indicator could be left in VTOL_Takeoff after RTL. These are logic errors (improper state transition/conditional handling), and the change corrects that behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 11,
        "changes": 12,
        "patch": "@@ -783,17 +783,7 @@ void Navigator::run()\n \t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\t}\n \n-#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n-\n-\t\t\t// If we are in VTOL takeoff, do not switch until it is finished.\n-\t\t\tif (_navigation_mode == &_vtol_takeoff && !get_mission_result()->finished) {\n-\t\t\t\tnavigation_mode_new = &_vtol_takeoff;\n-\n-\t\t\t} else\n-#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n-\t\t\t{\n-\t\t\t\tnavigation_mode_new = &_rtl;\n-\t\t\t}\n+\t\t\tnavigation_mode_new = &_rtl;\n \n \t\t\tbreak;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/07ae2be14ef90703084cce6c98180a528cb37eb6/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "update mission after changing home position",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22834",
    "number": 22834,
    "created_at": "2024-03-04T14:29:22Z",
    "merged": true,
    "merged_at": "2024-03-20T07:37:19Z",
    "state": "closed",
    "conversation": {
      "author": "Drone-Lab",
      "body": "### Solved Problem\r\nfix the bug which cause  drone can't finish mission after changing home altitude.Update mission after changing home position.\r\n\r\n ### Summary\r\nThis state management bug will result in the drone being unable to reach the waypoint and thus continuing the mission.And continues to drift irregularly near the waypoints.\r\n\r\n### Details\r\n1. When the drone is executing a mission, PX4 calculates the distance between the drone and the current target waypoint, and checks if it has reached the vicinity.\r\n\r\n   Here calculates the distance.\r\nhttps://github.com/PX4/PX4-Autopilot/blob/8b96cd5372c343ef2a3f8a8b805d5b39b47a8008/src/modules/navigator/mission_block.cpp#L197-L201\r\n   When mission altitude mode is **Relative to Launch** `mission_item_altitude_amsl=mission_item.altitude + home_alt`\r\n\r\n   And here checks whether it is less than the acceptable radius.\r\nhttps://github.com/PX4/PX4-Autopilot/blob/8b96cd5372c343ef2a3f8a8b805d5b39b47a8008/src/modules/navigator/mission_block.cpp#L394-L396\r\n\r\n2. When the drone is executing a mission, if the user modifies the home point to a new location (with a different altitude), the value of 'dist' will immediately change based on the new home point's altitude (which determines the check for whether the drone has reached the waypoint). However, the current actual executed 'mission_item' does not get updated.\r\n\r\n   This will result in a discrepancy between the actual executed target of the drone and the checked completion target, causing the drone to start randomly oscillating near the waypoint.\r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/151698793/59782bec-8394-4621-9250-27d0e4ec038e)\r\n\r\n\r\n### Verification\r\n\r\nWe added some debug output to watch the drone's state change,and found every time the user changes the home point, 'dist_z' (altitude) also changes accordingly, but the 'mission_item' does not.\r\n\r\n### Temporary Patch\r\n\r\nThere are currently two patching approaches based on the expectations for how the drone should operate after modifying the home point: \r\n1. After changing the drone's home point altitude, the currently executed mission target should also change immediately \r\n2. Once the mission is uploaded and completed, the 'mission_item' should no longer change, even if the home altitude changes; the waypoint altitude should remain relative to the altitude at the time of mission upload\r\n\r\n### Impact\r\n- This vulnerability could be exploited by attackers for covert attacks\r\n- When a benign user modifies the home point while the drone is executing a mission, the drone may oscillate, come into contact with surrounding obstacles, and ultimately crash\r\n- Modifying the home point to a new location during the mission execution will result in the drone randomly drifting near the next waypoint. This could lead to collisions and crashes.https://github.com/PX4/PX4-Autopilot/issues/22576\r\n\r\n\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/assets/151698793/273dd910-c92e-4817-8385-45c7ad38c3f8\r\n\r\nSome bugs prevent you from directly viewing the video.You can **download** and check this vedio.\r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/151698793/41d03721-bdd4-4e6d-a1ec-e6b47780ffb5)\r\n\r\n\r\n\r\n### Solution\r\n- Add an update for the current setpoint altitude when the home point is changed. \r\n\r\n\r\n### Test coverage\r\n- Simulation/hardware testing logs:https://logs.px4.io/plot_app?log=0488b27d-6137-481a-9bb1-1b084777b2de\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-04T14:30:34Z",
          "body": "@bkueng  Following your advice, I utilized _navigator->get_home_position()->update_count.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-11T04:19:30Z",
          "body": "Resolved Conflict Code",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T00:54:49Z",
          "body": "@KonradRudin Looking forward to receiving your advice.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T11:45:40Z",
          "body": "@KonradRudin How about this modification?",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-14T09:00:08Z",
          "body": "> Thanks for the changes. Looking good for me, but there seems to be a conflict we recent changes. If you rebase it on newest main, i can approve.\r\n\r\n@KonradRudin  Thank you for your feedback! I've addressed the conflict and rebased the changes on the latest main branch. ",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-15T15:21:47Z",
          "body": "@bkueng it's ready to merge",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-03-18T08:37:18Z",
          "body": "Can you run `make format`, commit the result & rebase? CI should then pass.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-18T12:17:50Z",
          "body": "> Can you run `make format`, commit the result & rebase? CI should then pass.\r\n\r\n@bkueng OK ï¼ŒI have finished it.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T10:08:46Z",
          "body": "We should also check if the previous and next setpoint are valid and finite as well, if they are, correct them as well.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T10:36:49Z",
          "body": "> We should also check if the previous and next setpoint are valid and finite as well, if they are, correct them as well.\r\n\r\n\r\n@KonradRudin This is not necessary because when the next item starts execution, the altitude will be recalculated based on the current home altitude. Therefore, here we only need to consider the target altitude of the task currently being executed.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T10:45:12Z",
          "body": "But if i'm not mistaken, it makes a first order hold of the altitude for fixed wing and tracks that slope. If you don't change the previous altitude this calculation will be wrong as well. Not sure if the next altitude is actually used somewhere. https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/fw_pos_control/FixedwingPositionControl.cpp#L1062-L1091 . For multicopter it should be fine.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T10:54:16Z",
          "body": "you are correct.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T15:19:36Z",
          "body": "```suggestion\r\n\t\tfloat new_alt = get_absolute_altitude_for_item(_mission_item);\r\n\t\tfloat altitude_diff = new_alt - _navigator->get_position_setpoint_triplet()->current.alt;\r\n```\r\n\r\nIf you do it like this, you shouldn't need the _last_home_alt variable. Also it should be fine as well when the mission item is in global coordinates.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T15:26:19Z",
          "body": "```suggestion\r\n\t\tif (_navigator->get_position_setpoint_triplet()->previous.valid && PX4_ISFINITE(_navigator->get_position_setpoint_triplet()->previous.alt)) {\r\n\t\t    _navigator->get_position_setpoint_triplet()->previous.alt = _navigator->get_position_setpoint_triplet()->previous.alt + altitude_diff;\r\n\t\t    }\r\n\t\t    \r\n```\r\n\r\nYou only need to change it if it is valid and actually has a useful altitude. Also do the same for the next item.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T16:10:53Z",
          "body": "Thank you, I have made the modifications according to your suggestion.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T10:09:18Z",
          "body": "Thansk for the bug fix. Looks fine to me, just extend it for the previous and next as well.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T10:36:49Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T10:45:12Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T10:54:16Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-12T15:26:26Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-03-12T16:10:53Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-13T07:10:05Z",
          "body": "Thanks for the changes. Looking good for me, but there seems to be a conflict we recent changes. If you rebase it on newest main, i can approve.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-14T12:48:49Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” this is a state-management logic bug: when the home altitude is changed mid-mission the computed distance check (using mission_item_altitude_amsl = mission_item.altitude + home_alt) no longer matches the actual mission_item target, causing incorrect completion checks and waypoint oscillation. The PR updates the current setpoint/mission_item altitude when the home point changes, removing the state discrepancy and fixing the incorrect behavior.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "patch": "@@ -253,6 +253,7 @@ MissionBase::on_active()\n \n \tupdateMavlinkMission();\n \tupdateDatamanCache();\n+\tupdateMissionAltAfterHomeChanged();\n \n \t/* Check the mission */\n \tif (!_mission_checked && canRunMissionFeasibility()) {\n@@ -1375,3 +1376,29 @@ bool MissionBase::canRunMissionFeasibility()\n \t       (_geofence_status_sub.get().geofence_id == _mission.geofence_id) &&\n \t       (_geofence_status_sub.get().status == geofence_status_s::GF_STATUS_READY);\n }\n+\n+void MissionBase::updateMissionAltAfterHomeChanged()\n+{\n+\tif (_navigator->get_home_position()->update_count > _home_update_counter) {\n+\t\tfloat new_alt = get_absolute_altitude_for_item(_mission_item);\n+\t\tfloat altitude_diff = new_alt - _navigator->get_position_setpoint_triplet()->current.alt;\n+\n+\t\tif (_navigator->get_position_setpoint_triplet()->previous.valid\n+\t\t    && PX4_ISFINITE(_navigator->get_position_setpoint_triplet()->previous.alt)) {\n+\t\t\t_navigator->get_position_setpoint_triplet()->previous.alt = _navigator->get_position_setpoint_triplet()->previous.alt +\n+\t\t\t\t\taltitude_diff;\n+\t\t}\n+\n+\t\t_navigator->get_position_setpoint_triplet()->current.alt = _navigator->get_position_setpoint_triplet()->current.alt +\n+\t\t\t\taltitude_diff;\n+\n+\t\tif (_navigator->get_position_setpoint_triplet()->next.valid\n+\t\t    && PX4_ISFINITE(_navigator->get_position_setpoint_triplet()->next.alt)) {\n+\t\t\t_navigator->get_position_setpoint_triplet()->next.alt = _navigator->get_position_setpoint_triplet()->next.alt +\n+\t\t\t\t\taltitude_diff;\n+\t\t}\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t_home_update_counter = _navigator->get_home_position()->update_count;\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/572a723ce069bcec79057bbedeb87ac660fd25da/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -448,8 +448,16 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tbool checkMissionDataChanged(mission_s new_mission);\n \n+\t/**\n+\t * @brief update current mission altitude after the home position has changed.\n+\t */\n+\n+\tvoid updateMissionAltAfterHomeChanged();\n+\n \tbool canRunMissionFeasibility();\n \n+\tuint32_t _home_update_counter = 0; /**< Variable to store the previous value for home change detection.*/\n+\n \tbool _align_heading_necessary{false}; // if true, heading of vehicle needs to be aligned with heading of next waypoint. Used to create new mission items for heading alignment.\n \n \tmission_item_s _last_gimbal_configure_item {};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/572a723ce069bcec79057bbedeb87ac660fd25da/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_active",
        "MissionBase::canRunMissionFeasibility"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::canRunMissionFeasibility"
        ]
      }
    }
  },
  {
    "title": "fix the bug which cause  drone can't finish mission after changing home altitude",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22833",
    "number": 22833,
    "created_at": "2024-03-04T14:04:53Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "Drone-Lab",
      "body": "### Solved Problem\r\nfix the bug which cause  drone can't finish mission after changing home altitude\r\n\r\n I have conducted a detailed analysis of the bug here.\r\nhttps://github.com/PX4/PX4-Autopilot/security/advisories/GHSA-f72j-ghwh-h86j\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/151698793/59782bec-8394-4621-9250-27d0e4ec038e)\r\nhttps://github.com/PX4/PX4-Autopilot/assets/151698793/273dd910-c92e-4817-8385-45c7ad38c3f8\r\n\r\nSome bugs prevent you from directly viewing the video.You can **download** and check this vedio.\r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/151698793/41d03721-bdd4-4e6d-a1ec-e6b47780ffb5)\r\n\r\n### Solution\r\n- Add an update for the current setpoint altitude when the home point is changed. \r\n\r\n\r\n### Test coverage\r\n- Simulation/hardware testing logs:https://logs.px4.io/plot_app?log=0488b27d-6137-481a-9bb1-1b084777b2de\r\n\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes a state/data-flow bug: when the home altitude changed the active altitude setpoint was not updated, leaving mission completion checks operating on stale state and preventing the mission from finishing. Updating the current setpoint altitude on home change corrects this incorrect state transition/logic.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -264,6 +264,7 @@ MissionBase::on_active()\n \n \tupdateMavlinkMission();\n \tupdateDatamanCache();\n+\tupdateMissionAltAfterHomeChanged();\n \n \t// check if heading alignment is necessary, and add it to the current mission item if necessary\n \tif (_align_heading_necessary && is_mission_item_reached_or_completed()) {\n@@ -1360,3 +1361,13 @@ bool MissionBase::checkMissionDataChanged(mission_s new_mission)\n \t\t(new_mission.mission_id != _mission.mission_id) ||\n \t\t(new_mission.current_seq != _mission.current_seq));\n }\n+\n+void MissionBase::updateMissionAltAfterHomeChanged()\n+{\n+\tif (_navigator->get_home_position()->update_count > _home_update_counter) {\n+\t\t_navigator->get_position_setpoint_triplet()->current.alt = get_absolute_altitude_for_item(_mission_item);\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t_home_update_counter = _navigator->get_home_position()->update_count;\n+\t}\n+}\n+",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/42d51f005f91e3efd1575b3562a8ecf1947065d6/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -444,6 +444,12 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tbool checkMissionDataChanged(mission_s new_mission);\n \n+\t/**\n+\t * @brief update current mission altitude after the home position has changed.\n+\t */\n+\n+\tvoid updateMissionAltAfterHomeChanged();\n+\n \tint32_t _load_mission_index{-1}; /**< Mission inted of loaded mission items in dataman cache*/\n \tint32_t _dataman_cache_size_signed; /**< Size of the dataman cache. A negativ value indicates that previous mission items should be loaded, a positiv value the next mission items*/\n \n@@ -455,6 +461,8 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tmission_item_s _last_camera_trigger_item {};\n \tmission_item_s _last_speed_change_item {};\n \n+\tuint32_t _home_update_counter=0; /**< Variable to store the previous value for home change detection.*/\n+\n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/42d51f005f91e3efd1575b3562a8ecf1947065d6/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_active",
        "MissionBase::checkMissionDataChanged"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::checkMissionDataChanged"
        ]
      }
    }
  },
  {
    "title": "Navigator: Prevent busy-looping if Dataman read/write times out",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22778",
    "number": 22778,
    "created_at": "2024-02-20T09:38:29Z",
    "merged": true,
    "merged_at": "2024-02-21T12:31:43Z",
    "state": "closed",
    "conversation": {
      "author": "niklaut",
      "body": "### Solved Problem\r\n\r\nMissionBase did not initialize its mission data, thus could enter an infinite loop in updateDatamanCache() if the initMission() failed to read the mission off, for example, due to the SDCard storage task taking longer than the timeout to respond.\r\n\r\nHere you can see the navigator task taking up all idle CPU:\r\n```\r\n(gdb) px4_tasks\r\n       â•·                        â•·                                   â•·        â•·      \r\n       â”‚                        â”‚                                   â”‚        â”‚      \r\n   pid â”‚ Task Name              â”‚ Location                          â”‚ CPU(%) â”‚ Prio \r\n â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•\r\n     0 â”‚ Idle Task              â”‚ nx_start                          â”‚    0.0 â”‚    0 \r\n     1 â”‚ hpwork                 â”‚ nxsem_wait                        â”‚    0.0 â”‚  249 \r\n     2 â”‚ lpwork                 â”‚ nxsem_wait                        â”‚    0.0 â”‚   50 \r\n     3 â”‚ nsh_main               â”‚ nxsem_wait                        â”‚    0.0 â”‚  100 \r\n     4 â”‚ wq:manager             â”‚ nxsem_wait                        â”‚    0.0 â”‚  255 \r\n     5 â”‚ wq:lp_default          â”‚ nxsem_wait                        â”‚    0.1 â”‚  205 \r\n     6 â”‚ netinit                â”‚ nxsig_timedwait                   â”‚    0.0 â”‚   49 \r\n   200 â”‚ wq:hp_default          â”‚ nxsem_wait                        â”‚    1.5 â”‚  237 \r\n   203 â”‚ wq:I2C3                â”‚ nxsem_wait                        â”‚    0.3 â”‚  244 \r\n   951 â”‚ dataman                â”‚ setbasepri                        â”‚    0.0 â”‚   90 \r\n   970 â”‚ wq:I2C2                â”‚ nxsem_wait                        â”‚    0.4 â”‚  245 \r\n  1100 â”‚ wq:rate_ctrl           â”‚ nxsem_wait                        â”‚   11.7 â”‚  255 \r\n  1119 â”‚ wq:SPI2                â”‚ nxsem_wait                        â”‚    4.3 â”‚  252 \r\n  1159 â”‚ wq:SPI3                â”‚ nxsem_wait                        â”‚    6.3 â”‚  251 \r\n  1166 â”‚ wq:SPI1                â”‚ nxsem_wait                        â”‚    5.1 â”‚  253 \r\n  1168 â”‚ wq:I2C4                â”‚ nxsem_wait                        â”‚    0.6 â”‚  243 \r\n  1306 â”‚ wq:nav_and_controllers â”‚ 0x800826e                         â”‚    9.9 â”‚  242 \r\n  1307 â”‚ wq:INS0                â”‚ 0xffffffff                        â”‚   13.0 â”‚  241 \r\n  1310 â”‚ commander              â”‚ nxsig_timedwait                   â”‚    1.3 â”‚  231 \r\n  1366 â”‚ mavlink_if0            â”‚ nxsig_timedwait                   â”‚    0.0 â”‚  100 \r\n  1368 â”‚ mavlink_rcv_if0        â”‚ nxsig_timedwait                   â”‚    0.1 â”‚  175 \r\n  1397 â”‚ wq:ttyS7               â”‚ nxsem_wait                        â”‚    0.1 â”‚  227 \r\n  1593 â”‚ gps                    â”‚ nxsem_wait                        â”‚    0.4 â”‚  205 \r\n  1842 â”‚ mavlink_if1            â”‚ nxsig_timedwait                   â”‚    0.0 â”‚  100 \r\n  1843 â”‚ mavlink_rcv_if1        â”‚ nxsem_wait                        â”‚    0.4 â”‚  175 \r\n  1948 â”‚ mavlink_if2            â”‚ nxsig_timedwait                   â”‚    0.0 â”‚  100 \r\n  1961 â”‚ mavlink_rcv_if2        â”‚ nxsem_wait                        â”‚    0.3 â”‚  175 \r\n  2029 â”‚ uxrce_dds_client       â”‚ nxsem_wait                        â”‚    0.0 â”‚  100 \r\n  2065 â”‚ navigator              â”‚ MissionBase::updateDatamanCache() â”‚   33.9 â”‚  105 \r\n  2228 â”‚ gimbal                 â”‚ nxsem_wait                        â”‚    0.0 â”‚  100 \r\n  2578 â”‚ logger                 â”‚ nxsig_timedwait                   â”‚    0.4 â”‚  230 \r\n  2592 â”‚ pt-0x80c6d7d           â”‚ setbasepri                        â”‚    0.0 â”‚   60 \r\n       â•µ                        â•µ                                   â•µ        â•µ      \r\n```\r\n\r\nThe specific location of the busy looping code is in `MissionBase::updateDatamanCache()` and we can see that the `index` of the local loop is all wrong:\r\n\r\n```\r\n(gdb) backtrace full\r\n#0  DatamanCache::load (this=this@entry=0x200532f8, item=254, index=index@entry=4165722759) at src/lib/dataman_client/DatamanClient.cpp:496\r\n#1  0x080f0fa4 in MissionBase::updateDatamanCache (this=this@entry=0x20053240) at src/modules/navigator/mission_base.cpp:99\r\n        index = -129244537\r\n        start_index = <optimized out>\r\n        end_index = 0\r\n#2  0x080f2650 in MissionBase::MissionBase (this=0x20053240, navigator=<optimized out>, dataman_cache_size_signed=10) at src/modules/navigator/mission_base.cpp:57\r\n#3  0x080f3eb2 in Mission::Mission (this=0x20053240, navigator=<optimized out>) at src/modules/navigator/mission.cpp:68\r\n#4  0x080eeade in Navigator::Navigator (this=0x20052a00) at src/modules/navigator/navigator_main.cpp:83\r\n#5  0x080eee5a in Navigator::instantiate (argc=<optimized out>, argv=<optimized out>) at src/modules/navigator/navigator_main.cpp:1096\r\n#6  0x080ef600 in ModuleBase<Navigator>::run_trampoline (argc=<optimized out>, argv=<optimized out>) at platforms/common/include/px4_platform_common/module.h:176\r\n#7  0x08017432 in nxtask_startup (entrypt=entrypt@entry=0x80ef5f5 <ModuleBase<Navigator>::run_trampoline(int, char**)>, argc=2, argv=0x2004f1c8) at platforms/nuttx/NuttX/nuttx/libs/libc/sched/task_startup.c:70\r\n#8  0x0800c2ea in nxtask_start () at platforms/nuttx/NuttX/nuttx/sched/task/task_start.c:134\r\n```\r\n\r\nThe reason is that `MissionBase::_mission` is filled with garbage data since the `initMission()` in the constructor failed, as seen by `MissionBase:: _is_current_planned_mission_item_valid`:\r\n```\r\n(gdb) up\r\n#1  0x080f0fa4 in MissionBase::updateDatamanCache (this=this@entry=0x20053240) at src/modules/navigator/mission_base.cpp:99\r\n99\t\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.dataman_id), index);\r\n(gdb) p _mission\r\n$1 = {\r\n  timestamp = 17431310179885766522,\r\n  current_seq = -1414509569,\r\n  land_start_index = 238190632,\r\n  land_index = -1201203459,\r\n  mission_id = 3653239979,\r\n  geofence_id = 3039716647,\r\n  safe_points_id = 3491407048,\r\n  count = 62201,\r\n  dataman_id = 254 '\\376',\r\n  _padding0 = \"\\035\\060\\\\B\\020\"\r\n}\r\n(gdb) p _is_current_planned_mission_item_valid\r\n$2 = false\r\n```\r\n\r\nIf we restart this code again and put a breakpoint on the constructor we can see that the `MissionBase::_mission` memory is initialized with `0xdeadbeef` values, which is the stack watermarking value:\r\n\r\n```\r\n(gdb) p/x _mission\r\n$3 = {\r\n  timestamp = 0xdeadbeefdeadbeef,\r\n  current_seq = 0xdeadbeef,\r\n  land_start_index = 0xdeadbeef,\r\n  land_index = 0xdeadbeef,\r\n  mission_id = 0xdeadbeef,\r\n  geofence_id = 0xdeadbeef,\r\n  safe_points_id = 0xdeadbeef,\r\n  count = 62201,\r\n  dataman_id = 173 '\\255',\r\n  _padding0 = \"\\336\", <incomplete sequence \\336>\r\n}\r\n```\r\n\r\n`MissionBase::_mission` is not initialized because `MissionBase::initMission()` failed, because `_dataman_client.readSync()` timed out. And then `MissionBase::resetMission()` only copied the new data on `_dataman_client.writeSync()` success, which also timed out.\r\n\r\nYou can reproduce this failure by placing [a `usleep(2'000'000);` into the `dataman.cpp` `DM_WRITE` and `DM_READ` code](https://github.com/PX4/PX4-Autopilot/blob/8a7573351182bcc7181bb0377e35f62b2ad267ff/src/modules/dataman/dataman.cpp#L742-L775).\r\n\r\n### Solution\r\n\r\nThis change constrains the loading loop and resets the mission data even if the data write failed.\r\n\r\n### Changelog Entry\r\n\r\nFor release notes:\r\n```\r\nBugfix Prevent busy-looping on Navigator startup\r\n```",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-02-21T12:30:57Z",
          "body": "Looks good, thanks",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error. initMission() could fail on dataman read/write timeouts leaving MissionBase::_mission with garbage values, which caused updateDatamanCache() to busy-loop with invalid indices; the change bounds the loading loop and resets mission data even on write failure, preventing the incorrect state and infinite CPU usage.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 19,
        "changes": 35,
        "patch": "@@ -89,10 +89,9 @@ MissionBase::updateDatamanCache()\n {\n \tif ((_mission.count > 0) && (_mission.current_seq != _load_mission_index)) {\n \n-\t\tint32_t start_index = _mission.current_seq;\n-\t\tint32_t end_index = start_index + _dataman_cache_size_signed;\n-\n-\t\tend_index = math::max(math::min(end_index, static_cast<int32_t>(_mission.count)), INT32_C(0));\n+\t\tconst int32_t start_index = math::constrain(_mission.current_seq, INT32_C(0), int32_t(_mission.count) - 1);\n+\t\tconst int32_t end_index = math::constrain(start_index + _dataman_cache_size_signed, INT32_C(0),\n+\t\t\t\t\t  int32_t(_mission.count) - 1);\n \n \t\tfor (int32_t index = start_index; index != end_index; index += math::signNoZero(_dataman_cache_size_signed)) {\n \n@@ -115,8 +114,8 @@ void MissionBase::updateMavlinkMission()\n \t\tconst bool mission_data_changed = checkMissionDataChanged(new_mission);\n \n \t\tif (new_mission.current_seq < 0) {\n-\t\t\tnew_mission.current_seq = math::max(math::min(_mission.current_seq, static_cast<int32_t>(new_mission.count) - 1),\n-\t\t\t\t\t\t\t    INT32_C(0));\n+\t\t\tnew_mission.current_seq = math::constrain(_mission.current_seq, INT32_C(0),\n+\t\t\t\t\t\t  static_cast<int32_t>(new_mission.count) - 1);\n \t\t}\n \n \t\t_mission = new_mission;\n@@ -1147,22 +1146,20 @@ void MissionBase::resetMission()\n \t}\n \n \t/* Set a new mission*/\n-\tmission_s new_mission{_mission};\n-\tnew_mission.timestamp = hrt_absolute_time();\n-\tnew_mission.current_seq = 0;\n-\tnew_mission.land_start_index = -1;\n-\tnew_mission.land_index = -1;\n-\tnew_mission.count = 0u;\n-\tnew_mission.mission_id = 0u;\n-\tnew_mission.mission_dataman_id = _mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ?\n-\t\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_1 :\n-\t\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_0;\n-\n-\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&new_mission),\n+\t_mission.timestamp = hrt_absolute_time();\n+\t_mission.current_seq = 0;\n+\t_mission.land_start_index = -1;\n+\t_mission.land_index = -1;\n+\t_mission.count = 0u;\n+\t_mission.mission_id = 0u;\n+\t_mission.mission_dataman_id = _mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ?\n+\t\t\t\t      DM_KEY_WAYPOINTS_OFFBOARD_1 :\n+\t\t\t\t      DM_KEY_WAYPOINTS_OFFBOARD_0;\n+\n+\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&_mission),\n \t\t\tsizeof(mission_s));\n \n \tif (success) {\n-\t\t_mission = new_mission;\n \t\t_mission_pub.publish(_mission);\n \n \t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eb71c0a9cbd313c3a5eed228817c18fa02d85c77/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "math::max",
        "MissionBase::updateMavlinkMission",
        "MissionBase::updateDatamanCache",
        "MissionBase::resetMission"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "math::max",
          "MissionBase::updateMavlinkMission",
          "MissionBase::updateDatamanCache",
          "MissionBase::resetMission"
        ]
      }
    }
  },
  {
    "title": "Navigator: fix VTOL land waypoint calculation",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22773",
    "number": 22773,
    "created_at": "2024-02-19T12:32:22Z",
    "merged": true,
    "merged_at": "2024-02-19T13:54:28Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "The setpoint.yaw can be NAN, and this made the calculated land point NAN as well. Looking at the current yaw is anyway a better way to approximate the course over ground that fundamentally should be used.\r\n\r\nNB As we only need a rough idea of the current course over ground, I think it's not worth to calculate it by using the ground velocity, as then we'd have instabilities when approaching 0 ground speed.\r\n\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix \r\n```\r\n",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-19T12:47:14Z",
          "body": "> `_navigator->get_vstatus()->is_vtol` just before the changed part\r\n\r\nNever mind, what I wrote would apply for multicopter ðŸ¤¦â€â™‚ï¸ ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-19T12:40:51Z",
          "body": "That works yes.\r\n\r\nWould it be an exageration to check if there is a yaw setpoint and use it if it's not NAN? I'd prefer that because otherwise you often have these constantly slightly changing altitudes and yaws when you switch in and out of things. Maybe it's a detail and should be improved later.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error where using setpoint.yaw (which can be NaN) caused the computed VTOL land waypoint to become NaN. Switching to the current yaw as an approximation prevents NaN propagation and corrects the unintended waypoint calculation (the reviewer suggestion to prefer a non-NaN yaw setpoint is an improvement but doesn't change that this is a logic bug fix).",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -83,7 +83,7 @@ Land::on_active()\n \n \t\t// create a virtual wp 1m in front of the vehicle to track during the backtransition\n \t\twaypoint_from_heading_and_distance(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t\t\t   _navigator->get_position_setpoint_triplet()->current.yaw, 1.f,\n+\t\t\t\t\t\t   _navigator->get_local_position()->heading, 1.f,\n \t\t\t\t\t\t   &pos_sp_triplet->current.lat, &pos_sp_triplet->current.lon);\n \n \t\t_navigator->set_position_setpoint_triplet_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a815a589123b637b77619a681eb6862f678f4630/src%2Fmodules%2Fnavigator%2Fland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_active"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ]
      }
    }
  },
  {
    "title": "Add mission check land when no approach",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22750",
    "number": 22750,
    "created_at": "2024-02-14T09:50:26Z",
    "merged": true,
    "merged_at": "2024-02-16T09:27:22Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen a VTOL is flying in air, we want to make sure that a landing is defined either by VTOL land approaches on home/rally points or the mission. Thus when uploading a new mission in air, the mission should get rejected, when it does not define a landing and there are no landing approaches defined for the safe points.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\nAdd a new mission check option in MIS_TKO_LAND_REQ. This option checks, if a landing is defined, when in air and no safe point approaches are defined. While on the ground, it will use the same logic as MIS_TKO_LAND_REQ=4\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: New Mission takeoff/landing required option to check for a valid landing (either mission landing or land approaches) when in air.\r\n```\r\n### Test coverage\r\n- Unit/integration test: ...\r\n- Simulation/hardware testing logs: https://review.px4.io/\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-02-15T07:09:21Z",
          "body": "```suggestion\r\nbool has_vtol_approach \t\t      # flag if approaches are defined for current RTL_TYPE parameter setting\r\n```",
          "path": "msg/RtlStatus.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-02-15T07:58:47Z",
          "body": "Maybe replace the comment with something like\r\n\"The ID is generated per upload of a group of safe points\"",
          "path": "msg/RtlStatus.msg",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-02-15T08:03:01Z",
          "body": "Works for me, and the extra RTL debugging should help as well!",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-02-16T09:27:05Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes mission validation logic to reject missions that don't define a landing when the vehicle is airborne and no safe-point land approaches exist. That fixes incorrect behavior (accepting/uploading missions that would leave a VTOL without a valid landing), which is a classic logic error related to improper state validation.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 9,
        "changes": 46,
        "patch": "@@ -125,6 +125,12 @@ void FeasibilityChecker::updateData()\n \t\t_current_position_lat_lon = matrix::Vector2d(vehicle_global_position.lat, vehicle_global_position.lon);\n \t}\n \n+\tif (_rtl_status_sub.updated()) {\n+\t\trtl_status_s rtl_status = {};\n+\t\t_rtl_status_sub.copy(&rtl_status);\n+\t\t_has_vtol_approach = rtl_status.has_vtol_approach;\n+\t}\n+\n \tparam_t handle = param_find(\"FW_LND_ANG\");\n \n \tif (handle != PARAM_INVALID) {\n@@ -577,17 +583,22 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \t\tbreak;\n \n \tcase 4:\n-\t\tresult = _has_takeoff == _landing_valid;\n+\t\tresult = hasMissionBothOrNeitherTakeoffAndLanding();\n+\n+\t\tbreak;\n \n-\t\tif (!result && (_has_takeoff)) {\n-\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Add Landing item or remove Takeoff.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_add_land_or_rm_to\"), {events::Log::Error, events::LogInternal::Info},\n-\t\t\t\t     \"Mission rejected: Add Landing item or remove Takeoff\");\n+\tcase 5:\n+\t\tif (!_is_landed && !_has_vtol_approach) {\n+\t\t\tresult = _landing_valid;\n \n-\t\t} else if (!result && (_landing_valid)) {\n-\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Add Takeoff item or remove Landing.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_add_to_or_rm_land\"), {events::Log::Error, events::LogInternal::Info},\n-\t\t\t\t     \"Mission rejected: Add Takeoff item or remove Landing\");\n+\t\t\tif (!result) {\n+\t\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Landing waypoint/pattern required.\");\n+\t\t\t\tevents::send(events::ID(\"feasibility_mis_in_air_landing_req\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\t\t     \"Mission rejected: Landing waypoint/pattern required\");\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tresult = hasMissionBothOrNeitherTakeoffAndLanding();\n \t\t}\n \n \t\tbreak;\n@@ -600,6 +611,23 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \treturn result;\n }\n \n+bool FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding()\n+{\n+\tbool result{_has_takeoff == _landing_valid};\n+\n+\tif (!result && (_has_takeoff)) {\n+\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Add Landing item or remove Takeoff.\\t\");\n+\t\tevents::send(events::ID(\"navigator_mis_add_land_or_rm_to\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t     \"Mission rejected: Add Landing item or remove Takeoff\");\n+\n+\t} else if (!result && (_landing_valid)) {\n+\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Add Takeoff item or remove Landing.\\t\");\n+\t\tevents::send(events::ID(\"navigator_mis_add_to_or_rm_land\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t     \"Mission rejected: Add Takeoff item or remove Landing\");\n+\t}\n+\n+\treturn result;\n+}\n \n bool FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint(mission_item_s &mission_item)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3565df7cfcbb5a240bb412d22dc3ba752cafd126/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -36,6 +36,7 @@\n #include \"../navigation.h\"\n #include <mathlib/mathlib.h>\n #include <uORB/topics/home_position.h>\n+#include <uORB/topics/rtl_status.h>\n #include <uORB/topics/vehicle_status.h>\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/vehicle_land_detected.h>\n@@ -97,6 +98,7 @@ class FeasibilityChecker : public ModuleParams\n \tuORB::Subscription _status_sub{ORB_ID(vehicle_status)};\n \tuORB::Subscription _land_detector_sub{ORB_ID(vehicle_land_detected)};\n \tuORB::Subscription _vehicle_global_position_sub{ORB_ID(vehicle_global_position)};\n+\tuORB::Subscription _rtl_status_sub{ORB_ID(rtl_status)};\n \n \t// parameters\n \tfloat _param_fw_lnd_ang{0.f};\n@@ -106,6 +108,7 @@ class FeasibilityChecker : public ModuleParams\n \n \tbool _is_landed{false};\n \tfloat _home_alt_msl{NAN};\n+\tbool _has_vtol_approach{false};\n \tmatrix::Vector2d _home_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n \tmatrix::Vector2d _current_position_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n \tVehicleType _vehicle_type{VehicleType::RotaryWing};\n@@ -247,4 +250,8 @@ class FeasibilityChecker : public ModuleParams\n \t * @return False if the check failed.\n \t*/\n \tvoid doMulticopterChecks(mission_item_s &mission_item, const int current_index);\n+\n+\t// Helper functions\n+\n+\tbool hasMissionBothOrNeitherTakeoffAndLanding();\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3565df7cfcbb5a240bb412d22dc3ba752cafd126/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.hpp"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -68,6 +68,7 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n  * @value 2 Require a landing\n  * @value 3 Require a takeoff and a landing\n  * @value 4 Require both a takeoff and a landing, or neither\n+ * @value 5 Same as previous, but require a landing if in air and no valid VTOL landing approach is present\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_TKO_LAND_REQ, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3565df7cfcbb5a240bb412d22dc3ba752cafd126/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -208,7 +208,7 @@ void Navigator::run()\n \n \t\t\tif (mission.safe_points_id != safe_points_id) {\n \t\t\t\tsafe_points_id = mission.safe_points_id;\n-\t\t\t\t_rtl.updateSafePoints();\n+\t\t\t\t_rtl.updateSafePoints(safe_points_id);\n \t\t\t}\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3565df7cfcbb5a240bb412d22dc3ba752cafd126/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 4,
        "changes": 39,
        "patch": "@@ -294,12 +294,14 @@ void RTL::setRtlTypeAndDestination()\n \n \tinit_rtl_mission_type();\n \n+\tuint8_t safe_point_index{0U};\n+\n \tif (_param_rtl_type.get() != 2) {\n \t\t// check the closest allowed destination.\n \t\tDestinationType destination_type{DestinationType::DESTINATION_TYPE_HOME};\n \t\tPositionYawSetpoint rtl_position;\n \t\tfloat rtl_alt;\n-\t\tfindRtlDestination(destination_type, rtl_position, rtl_alt);\n+\t\tfindRtlDestination(destination_type, rtl_position, rtl_alt, safe_point_index);\n \n \t\tswitch (destination_type) {\n \t\tcase DestinationType::DESTINATION_TYPE_MISSION_LAND:\n@@ -331,9 +333,29 @@ void RTL::setRtlTypeAndDestination()\n \t\t\tbreak;\n \t\t}\n \t}\n+\n+\t// Publish rtl status\n+\t_rtl_status_pub.get().timestamp = hrt_absolute_time();\n+\t_rtl_status_pub.get().safe_points_id = _safe_points_id;\n+\t_rtl_status_pub.get().is_evaluation_pending = _dataman_state != DatamanState::UpdateRequestWait;\n+\t_rtl_status_pub.get().has_vtol_approach = false;\n+\n+\tif ((_param_rtl_type.get() == 0) || (_param_rtl_type.get() == 3)) {\n+\t\t_rtl_status_pub.get().has_vtol_approach = _home_has_land_approach || _one_rally_point_has_land_approach;\n+\n+\t} else if (_param_rtl_type.get() == 1) {\n+\t\t_rtl_status_pub.get().has_vtol_approach = _one_rally_point_has_land_approach;\n+\t}\n+\n+\t_rtl_status_pub.get().rtl_type = static_cast<uint8_t>(_rtl_type);\n+\t_rtl_status_pub.get().safe_point_index = safe_point_index;\n+\n+\t_rtl_status_pub.update();\n+\n }\n \n-void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpoint &rtl_position, float &rtl_alt)\n+void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpoint &rtl_position, float &rtl_alt,\n+\t\t\t     uint8_t &safe_point_index)\n {\n \t// set destination to home per default, then check if other valid landing spot is closer\n \trtl_position.alt = _home_pos_sub.get().alt;\n@@ -352,8 +374,10 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \tfloat home_dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, rtl_position.lat, rtl_position.lon)};\n \tfloat min_dist;\n \n+\t_home_has_land_approach = hasVtolLandApproach(rtl_position);\n+\n \tif (((_param_rtl_type.get() == 1) && !vtol_in_rw_mode) || (vtol_in_fw_mode && (_param_rtl_approach_force.get() == 1)\n-\t\t\t&& !hasVtolLandApproach(rtl_position))) {\n+\t\t\t&& !_home_has_land_approach)) {\n \t\t// Set minimum distance to maximum value when RTL_TYPE is set to 1 and we are not in RW mode or we forces approach landing for vtol in fw and it is not defined for home.\n \t\tmin_dist = FLT_MAX;\n \n@@ -394,6 +418,8 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \n \tif (_safe_points_updated) {\n \n+\t\t_one_rally_point_has_land_approach = false;\n+\n \t\tfor (int current_seq = 0; current_seq < _dataman_cache_safepoint.size(); ++current_seq) {\n \t\t\tmission_item_s mission_safe_point;\n \n@@ -416,11 +442,16 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \t\t\t\tPositionYawSetpoint safepoint_position;\n \t\t\t\tsetSafepointAsDestination(safepoint_position, mission_safe_point);\n \n+\t\t\t\tbool current_safe_point_has_approaches{hasVtolLandApproach(safepoint_position)};\n+\n+\t\t\t\t_one_rally_point_has_land_approach |= current_safe_point_has_approaches;\n+\n \t\t\t\tif (((dist + MIN_DIST_THRESHOLD) < min_dist) && (!vtol_in_fw_mode || (_param_rtl_approach_force.get() == 0)\n-\t\t\t\t\t\t|| hasVtolLandApproach(safepoint_position))) {\n+\t\t\t\t\t\t|| current_safe_point_has_approaches)) {\n \t\t\t\t\tmin_dist = dist;\n \t\t\t\t\trtl_position = safepoint_position;\n \t\t\t\t\tdestination_type = DestinationType::DESTINATION_TYPE_SAFE_POINT;\n+\t\t\t\t\tsafe_point_index = current_seq;\n \t\t\t\t}\n \t\t\t}\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3565df7cfcbb5a240bb412d22dc3ba752cafd126/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "patch": "@@ -58,6 +58,7 @@\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/parameter_update.h>\n+#include <uORB/topics/rtl_status.h>\n #include <uORB/topics/rtl_time_estimate.h>\n \n class Navigator;\n@@ -86,7 +87,7 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tvoid set_return_alt_min(bool min) { _enforce_rtl_alt = min; }\n \n-\tvoid updateSafePoints() { _initiate_safe_points_updated = true; }\n+\tvoid updateSafePoints(uint32_t new_safe_point_id) { _initiate_safe_points_updated = true; _safe_points_id = new_safe_point_id; }\n \n private:\n \tenum class DestinationType {\n@@ -109,7 +110,8 @@ class RTL : public NavigatorMode, public ModuleParams\n \t * @brief Find RTL destination.\n \t *\n \t */\n-\tvoid findRtlDestination(DestinationType &destination_type, PositionYawSetpoint &rtl_position, float &rtl_alt);\n+\tvoid findRtlDestination(DestinationType &destination_type, PositionYawSetpoint &rtl_position, float &rtl_alt,\n+\t\t\t\tuint8_t &safe_point_index);\n \n \t/**\n \t * @brief Set the position of the land start marker in the planned mission as destination.\n@@ -188,6 +190,9 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tRtlType _rtl_type{RtlType::RTL_DIRECT};\n \n+\tbool _home_has_land_approach;\t\t\t///< Flag if the home position has a land approach defined\n+\tbool _one_rally_point_has_land_approach;\t///< Flag if a rally point has a land approach defined\n+\n \tDatamanState _dataman_state{DatamanState::UpdateRequestWait};\n \tDatamanState _error_state{DatamanState::UpdateRequestWait};\n \tuint32_t _opaque_id{0}; ///< dataman safepoint id: if it does not match, safe points data was updated\n@@ -197,6 +202,7 @@ class RTL : public NavigatorMode, public ModuleParams\n \tbool _initiate_safe_points_updated{true}; ///< flag indicating if safe points update is needed\n \tmutable DatamanCache _dataman_cache_landItem{\"rtl_dm_cache_miss_land\", 2};\n \tuint32_t _mission_id = 0u;\n+\tuint32_t _safe_points_id = 0u;\n \n \tmission_stats_entry_s _stats;\n \n@@ -222,4 +228,5 @@ class RTL : public NavigatorMode, public ModuleParams\n \tuORB::SubscriptionData<wind_s>\t\t_wind_sub{ORB_ID(wind)};\n \n \tuORB::Publication<rtl_time_estimate_s> _rtl_time_estimate_pub{ORB_ID(rtl_time_estimate)};\n+\tuORB::PublicationData<rtl_status_s> _rtl_status_pub{ORB_ID(rtl_status)};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/3565df7cfcbb5a240bb412d22dc3ba752cafd126/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::setRtlTypeAndDestination",
        "FeasibilityChecker::updateData",
        "findRtlDestination",
        "updateSafePoints",
        "Navigator::run",
        "FeasibilityChecker::checkTakeoffLandAvailable",
        "RTL::findRtlDestination"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::updateData",
          "FeasibilityChecker::checkTakeoffLandAvailable"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::setRtlTypeAndDestination",
          "RTL::findRtlDestination"
        ],
        "src/modules/navigator/rtl.h": [
          "updateSafePoints",
          "findRtlDestination"
        ]
      }
    }
  },
  {
    "title": "Add time estimate for RTL mission land",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22742",
    "number": 22742,
    "created_at": "2024-02-12T08:59:38Z",
    "merged": true,
    "merged_at": "2024-03-11T13:04:02Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nCurrently, there is no time estimate available, when the RTL has selected the mission landing as destination.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- Add calculations for time estimate to the RTL mission landing, based on the time estimate in the RTL home landing.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix Add time estimate for RTL Mission landing\r\n```\r\n\r\n### Test coverage\r\n- Unit/integration test: ...\r\n- Simulation/hardware testing logs: https://review.px4.io/\r\n\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T15:34:26Z",
          "body": "what happens if home is not valid?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T15:41:17Z",
          "body": "we should probably remove this check and instead check validity of destination",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T17:10:51Z",
          "body": "This could be improved - if you have similar altitude and horizontal differences then both matter, not the max().",
          "path": "src/lib/rtl/rtl_time_estimator.cpp",
          "position": 117,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T17:28:47Z",
          "body": "Ideally we would invalidate the estimate if one of the params cannot be fetched.",
          "path": "src/lib/rtl/rtl_time_estimator.cpp",
          "position": 187,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T17:56:17Z",
          "body": "That's not actually used or am I missing something?",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 206,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T17:58:01Z",
          "body": "done",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T09:17:31Z",
          "body": "How do you mean that? ",
          "path": "src/lib/rtl/rtl_time_estimator.cpp",
          "position": 117,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T09:19:40Z",
          "body": "This is just copied code, but i think the idea was that for vtol types, where it does not matter, just add a very high number so it doesn't add to the time estimate. But that part of code should anyways be rearranged so it can properly estimate for different vtol types.",
          "path": "src/lib/rtl/rtl_time_estimator.cpp",
          "position": 187,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T09:29:16Z",
          "body": "Which ones? The altitude and hor positions are used to calculate the distances to the next_position_mission_item. and the start_item_index to search for the next position item.",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 206,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T12:07:00Z",
          "body": "never mind, it doesn't really matter.",
          "path": "src/lib/rtl/rtl_time_estimator.cpp",
          "position": 117,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T12:07:29Z",
          "body": "I missed the while loop, never mind.",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 206,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T12:08:01Z",
          "body": "can be changed later. Better invalidate the estimate instead of publishing a small one.",
          "path": "src/lib/rtl/rtl_time_estimator.cpp",
          "position": 187,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T17:57:51Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-08T17:58:01Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T09:17:31Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T09:19:40Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-03-11T09:29:16Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T12:07:00Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T12:07:30Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-03-11T12:08:01Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect behavior where no time estimate was produced when RTL selected mission landing as the destination. Adding the time-estimate calculation (reusing the RTL home-landing logic) corrects the program's state/output for that scenario, which is a logic error rather than a syntax/style change.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -69,4 +69,5 @@ px4_add_module(\n \t\tgeofence_breach_avoidance\n \t\tmotion_planning\n \t\tmission_feasibility_checker\n+\t\trtl_time_estimator\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -315,6 +315,9 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tfloat _mission_init_climb_altitude_amsl{NAN}; \t\t/**< altitude AMSL the vehicle will climb to when mission starts */\n \tint _inactivation_index{-1}; // index of mission item at which the mission was paused. Used to resume survey missions at previous waypoint to not lose images.\n \n+\tint32_t _load_mission_index{-1}; /**< Mission inted of loaded mission items in dataman cache*/\n+\tint32_t _dataman_cache_size_signed; /**< Size of the dataman cache. A negativ value indicates that previous mission items should be loaded, a positiv value the next mission items*/\n+\n \tDatamanCache _dataman_cache{\"mission_dm_cache_miss\", 10}; /**< Dataman cache of mission items*/\n \tDatamanClient\t&_dataman_client = _dataman_cache.client(); /**< Dataman client*/\n \n@@ -334,7 +337,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t * @brief Update Dataman cache\n \t *\n \t */\n-\tvoid updateDatamanCache();\n+\tvirtual void updateDatamanCache();\n \t/**\n \t * @brief Update mission subscription\n \t *\n@@ -447,9 +450,6 @@ class MissionBase : public MissionBlock, public ModuleParams\n \n \tbool canRunMissionFeasibility();\n \n-\tint32_t _load_mission_index{-1}; /**< Mission inted of loaded mission items in dataman cache*/\n-\tint32_t _dataman_cache_size_signed; /**< Size of the dataman cache. A negativ value indicates that previous mission items should be loaded, a positiv value the next mission items*/\n-\n \tbool _align_heading_necessary{false}; // if true, heading of vehicle needs to be aligned with heading of next waypoint. Used to create new mission items for heading alignment.\n \n \tmission_item_s _last_gimbal_configure_item {};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -202,10 +202,10 @@ void RTL::on_inactive()\n \t\tbreak;\n \t}\n \n-\t// Limit inactive calculation to 1Hz\n+\t// Limit inactive calculation to 0.5Hz\n \thrt_abstime now{hrt_absolute_time()};\n \n-\tif ((now - _destination_check_time) > 1_s) {\n+\tif ((now - _destination_check_time) > 2_s) {\n \t\t_destination_check_time = now;\n \t\tsetRtlTypeAndDestination();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 178,
        "changes": 233,
        "patch": "@@ -1,6 +1,6 @@\n /****************************************************************************\n  *\n- *   Copyright (c) 2013-2020 PX4 Development Team. All rights reserved.\n+ *   Copyright (c) 2013-2024 PX4 Development Team. All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions\n@@ -59,15 +59,6 @@ RtlDirect::RtlDirect(Navigator *navigator) :\n \t_land_approach.lat = static_cast<double>(NAN);\n \t_land_approach.lon = static_cast<double>(NAN);\n \t_land_approach.height_m = NAN;\n-\n-\t_param_mpc_z_v_auto_up = param_find(\"MPC_Z_V_AUTO_UP\");\n-\t_param_mpc_z_v_auto_dn = param_find(\"MPC_Z_V_AUTO_DN\");\n-\t_param_mpc_land_speed = param_find(\"MPC_LAND_SPEED\");\n-\t_param_fw_climb_rate = param_find(\"FW_T_CLMB_R_SP\");\n-\t_param_fw_sink_rate = param_find(\"FW_T_SINK_R_SP\");\n-\t_param_fw_airspeed_trim = param_find(\"FW_AIRSPD_TRIM\");\n-\t_param_mpc_xy_cruise = param_find(\"MPC_XY_CRUISE\");\n-\t_param_rover_cruise_speed = param_find(\"GND_SPEED_THR_SC\");\n }\n \n void RtlDirect::on_inactivation()\n@@ -130,7 +121,6 @@ void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s\n \n \t// Only allow to set a new approach if the mode is not activated yet.\n \tif (!isActive()) {\n-\t\t_land_approach = loiter_pos;\n \t\t_destination = rtl_position;\n \t\t_force_heading = false;\n \n@@ -148,24 +138,12 @@ void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s\n \t\t\t_destination.alt = _home_pos_sub.get().alt;\n \t\t}\n \n-\t\tif (!PX4_ISFINITE(_land_approach.lat) || !PX4_ISFINITE(_land_approach.lon)) {\n-\t\t\t_land_approach.lat = _destination.lat;\n-\t\t\t_land_approach.lon = _destination.lon;\n-\n-\t\t} else {\n-\t\t\tconst float dist_to_destination{get_distance_to_next_waypoint(_land_approach.lat, _land_approach.lon, _destination.lat, _destination.lon)};\n-\n-\t\t\tif (dist_to_destination > _navigator->get_acceptance_radius()) {\n-\t\t\t\t_force_heading = true;\n-\t\t\t}\n-\t\t}\n+\t\t_land_approach = sanitizeLandApproach(loiter_pos);\n \n-\t\tif (!PX4_ISFINITE(_land_approach.height_m)) {\n-\t\t\t_land_approach.height_m = _destination.alt + _param_rtl_descend_alt.get();\n-\t\t}\n+\t\tconst float dist_to_destination{get_distance_to_next_waypoint(_land_approach.lat, _land_approach.lon, _destination.lat, _destination.lon)};\n \n-\t\tif (!PX4_ISFINITE(_land_approach.loiter_radius_m) || fabsf(_land_approach.loiter_radius_m) <= FLT_EPSILON) {\n-\t\t\t_land_approach.loiter_radius_m = _param_rtl_loiter_rad.get();\n+\t\tif (dist_to_destination > _navigator->get_acceptance_radius()) {\n+\t\t\t_force_heading = true;\n \t\t}\n \t}\n }\n@@ -287,7 +265,7 @@ void RtlDirect::set_rtl_item()\n \t\t\t// location and land location after exiting the loiter circle\n \t\t\tpos_sp_triplet->previous.lat = _land_approach.lat;\n \t\t\tpos_sp_triplet->previous.lon = _land_approach.lon;\n-\t\t\tpos_sp_triplet->previous.alt = _mission_item.altitude;\n+\t\t\tpos_sp_triplet->previous.alt = get_absolute_altitude_for_item(_mission_item);\n \t\t\tpos_sp_triplet->previous.valid = true;\n \n \t\t\t_rtl_state = RTLState::TRANSITION_TO_MC;\n@@ -379,8 +357,9 @@ RtlDirect::RTLState RtlDirect::getActivationLandState()\n rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n {\n \t_global_pos_sub.update();\n+\t_rtl_time_estimator.update();\n \n-\trtl_time_estimate_s rtl_time_estimate{};\n+\t_rtl_time_estimator.reset();\n \n \tRTLState start_state_for_estimate;\n \n@@ -391,34 +370,31 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\tstart_state_for_estimate = getActivationLandState();\n \t}\n \n-\t// Calculate RTL time estimate only when there is a valid home position\n+\t// Calculate RTL time estimate only when there is a valid destination\n \t// TODO: Also check if vehicle position is valid\n-\tif (!_navigator->home_global_position_valid()) {\n-\t\trtl_time_estimate.valid = false;\n+\tif (PX4_ISFINITE(_destination.lat) && PX4_ISFINITE(_destination.lon) && PX4_ISFINITE(_destination.alt)) {\n \n-\t} else {\n-\t\trtl_time_estimate.valid = true;\n-\t\trtl_time_estimate.time_estimate = 0.f;\n+\t\tloiter_point_s land_approach = sanitizeLandApproach(_land_approach);\n \n-\t\tconst float loiter_altitude = min(_land_approach.height_m, _rtl_alt);\n+\t\tconst float loiter_altitude = min(land_approach.height_m, _rtl_alt);\n \n \t\t// Sum up time estimate for various segments of the landing procedure\n \t\tswitch (start_state_for_estimate) {\n \t\tcase RTLState::CLIMBING: {\n \t\t\t\t// Climb segment is only relevant if the drone is below return altitude\n-\t\t\t\tconst float climb_dist = _global_pos_sub.get().alt < _rtl_alt ? (_rtl_alt - _global_pos_sub.get().alt) : 0;\n-\n-\t\t\t\tif (climb_dist > FLT_EPSILON) {\n-\t\t\t\t\trtl_time_estimate.time_estimate += climb_dist / getClimbRate();\n+\t\t\t\tif ((_global_pos_sub.get().alt < _rtl_alt) || _enforce_rtl_alt) {\n+\t\t\t\t\t_rtl_time_estimator.addVertDistance(_rtl_alt - _global_pos_sub.get().alt);\n \t\t\t\t}\n \t\t\t}\n \n \t\t// FALLTHROUGH\n-\t\tcase RTLState::MOVE_TO_LOITER:\n-\n-\t\t\t// Add cruise segment to home\n-\t\t\trtl_time_estimate.time_estimate += get_distance_to_next_waypoint(\n-\t\t\t\t\t_land_approach.lat, _land_approach.lon, _global_pos_sub.get().lat, _global_pos_sub.get().lon) / getCruiseGroundSpeed();\n+\t\tcase RTLState::MOVE_TO_LOITER: {\n+\t\t\t\tmatrix::Vector2f direction{};\n+\t\t\t\tget_vector_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_approach.lat,\n+\t\t\t\t\t\t\t    land_approach.lon, &direction(0), &direction(1));\n+\t\t\t\t_rtl_time_estimator.addDistance(get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon,\n+\t\t\t\t\t\t\t\tland_approach.lat, land_approach.lon), direction, 0.f);\n+\t\t\t}\n \n \t\t// FALLTHROUGH\n \t\tcase RTLState::LOITER_DOWN: {\n@@ -434,35 +410,41 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\t\t\t\tinitial_altitude = _rtl_alt; // CLIMB and RETURN\n \t\t\t\t}\n \n-\t\t\t\t// Add descend segment (first landing phase: return alt to loiter alt)\n-\t\t\t\trtl_time_estimate.time_estimate += fabsf(initial_altitude - loiter_altitude) / getDescendRate();\n+\t\t\t\t_rtl_time_estimator.addVertDistance(loiter_altitude - initial_altitude);\n \t\t\t}\n \n \t\t// FALLTHROUGH\n \t\tcase RTLState::LOITER_HOLD:\n \t\t\t// Add land delay (the short pause for deploying landing gear)\n-\t\t\t// TODO: Check if landing gear is deployed or not\n-\t\t\trtl_time_estimate.time_estimate += _param_rtl_land_delay.get();\n+\t\t\t_rtl_time_estimator.addWait(_param_rtl_land_delay.get());\n+\n+\t\t\tif (_param_rtl_land_delay.get() < -FLT_EPSILON) { // Set to loiter infinitely and not land. Stop calculation here\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n \n \t\t// FALLTHROUGH\n \t\tcase RTLState::MOVE_TO_LAND:\n \t\tcase RTLState::TRANSITION_TO_MC:\n \t\tcase RTLState::MOVE_TO_LAND_HOVER: {\n \t\t\t\t// Add cruise segment to home\n \t\t\t\tfloat move_to_land_dist{0.f};\n+\t\t\t\tmatrix::Vector2f direction{};\n \n \t\t\t\tif (start_state_for_estimate >= RTLState::MOVE_TO_LAND) {\n \t\t\t\t\tmove_to_land_dist = get_distance_to_next_waypoint(\n-\t\t\t\t\t\t\t\t    _destination.lat, _destination.lon, _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n+\t\t\t\t\t\t\t\t    _global_pos_sub.get().lat, _global_pos_sub.get().lon, _destination.lat, _destination.lon);\n+\t\t\t\t\tget_vector_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, _destination.lat, _destination.lon,\n+\t\t\t\t\t\t\t\t    &direction(0), &direction(1));\n \n \t\t\t\t} else {\n \t\t\t\t\tmove_to_land_dist = get_distance_to_next_waypoint(\n-\t\t\t\t\t\t\t\t    _destination.lat, _destination.lon, _land_approach.lat, _land_approach.lon);\n+\t\t\t\t\t\t\t\t    land_approach.lat, land_approach.lon, _destination.lat, _destination.lon);\n+\t\t\t\t\tget_vector_to_next_waypoint(land_approach.lat, land_approach.lon, _destination.lat, _destination.lon, &direction(0),\n+\t\t\t\t\t\t\t\t    &direction(1));\n \t\t\t\t}\n \n-\t\t\t\tif (move_to_land_dist > FLT_EPSILON) {\n-\t\t\t\t\trtl_time_estimate.time_estimate += move_to_land_dist / getCruiseGroundSpeed();\n-\t\t\t\t}\n+\t\t\t\t_rtl_time_estimator.addDistance(move_to_land_dist, direction, 0.f);\n \t\t\t}\n \n \t\t// FALLTHROUGH\n@@ -482,10 +464,7 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\t\t\t\tinitial_altitude = loiter_altitude;\n \t\t\t\t}\n \n-\t\t\t\t// Prevent negative times when close to the ground\n-\t\t\t\tif (initial_altitude > _destination.alt) {\n-\t\t\t\t\trtl_time_estimate.time_estimate += (initial_altitude - _destination.alt) / getHoverLandSpeed();\n-\t\t\t\t}\n+\t\t\t\t_rtl_time_estimator.addDescendMCLand(_destination.alt - initial_altitude);\n \t\t\t}\n \n \t\t\tbreak;\n@@ -494,142 +473,40 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\t\t// Remaining time is 0\n \t\t\tbreak;\n \t\t}\n-\n-\t\t// Prevent negative durations as phyiscally they make no sense. These can\n-\t\t// occur during the last phase of landing when close to the ground.\n-\t\trtl_time_estimate.time_estimate = math::max(0.f, rtl_time_estimate.time_estimate);\n-\n-\t\t// Use actual time estimate to compute the safer time estimate with additional scale factor and a margin\n-\t\trtl_time_estimate.safe_time_estimate = _param_rtl_time_factor.get() * rtl_time_estimate.time_estimate\n-\t\t\t\t\t\t       + _param_rtl_time_margin.get();\n-\t}\n-\n-\t// return message\n-\trtl_time_estimate.timestamp = hrt_absolute_time();\n-\n-\treturn rtl_time_estimate;\n-}\n-\n-float RtlDirect::getCruiseSpeed()\n-{\n-\tfloat ret = 1e6f;\n-\n-\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\tif (_param_mpc_xy_cruise == PARAM_INVALID || param_get(_param_mpc_xy_cruise, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n-\n-\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n-\t\tif (_param_fw_airspeed_trim == PARAM_INVALID || param_get(_param_fw_airspeed_trim, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n-\n-\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n-\t\tif (_param_rover_cruise_speed == PARAM_INVALID || param_get(_param_rover_cruise_speed, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n \t}\n \n-\treturn ret;\n+\treturn _rtl_time_estimator.getEstimate();\n }\n \n-float RtlDirect::getHoverLandSpeed()\n-{\n-\tfloat ret = 1e6f;\n-\n-\tif (_param_mpc_land_speed == PARAM_INVALID || param_get(_param_mpc_land_speed, &ret) != PX4_OK) {\n-\t\tret = 1e6f;\n-\t}\n-\n-\treturn ret;\n-}\n-\n-matrix::Vector2f RtlDirect::get_wind()\n+void RtlDirect::parameters_update()\n {\n-\t_wind_sub.update();\n-\tmatrix::Vector2f wind;\n+\tif (_parameter_update_sub.updated()) {\n+\t\tparameter_update_s param_update;\n+\t\t_parameter_update_sub.copy(&param_update);\n \n-\tif (hrt_absolute_time() - _wind_sub.get().timestamp < 1_s) {\n-\t\twind(0) = _wind_sub.get().windspeed_north;\n-\t\twind(1) = _wind_sub.get().windspeed_east;\n+\t\t// If any parameter updated, call updateParams() to check if\n+\t\t// this class attributes need updating (and do so).\n+\t\tupdateParams();\n \t}\n-\n-\treturn wind;\n }\n \n-float RtlDirect::getClimbRate()\n+loiter_point_s RtlDirect::sanitizeLandApproach(loiter_point_s land_approach) const\n {\n-\tfloat ret = 1e6f;\n+\tloiter_point_s sanitized_land_approach{land_approach};\n \n-\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\tif (_param_mpc_z_v_auto_up == PARAM_INVALID || param_get(_param_mpc_z_v_auto_up, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n-\n-\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\tif (!PX4_ISFINITE(land_approach.lat) || !PX4_ISFINITE(land_approach.lon)) {\n+\t\tsanitized_land_approach.lat = _destination.lat;\n+\t\tsanitized_land_approach.lon = _destination.lon;\n \n-\t\tif (_param_fw_climb_rate == PARAM_INVALID || param_get(_param_fw_climb_rate, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n \t}\n \n-\treturn ret;\n-}\n-\n-float RtlDirect::getDescendRate()\n-{\n-\tfloat ret = 1e6f;\n-\n-\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\tif (_param_mpc_z_v_auto_dn == PARAM_INVALID || param_get(_param_mpc_z_v_auto_dn, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n-\n-\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n-\t\tif (_param_fw_sink_rate == PARAM_INVALID || param_get(_param_fw_sink_rate, &ret) != PX4_OK) {\n-\t\t\tret = 1e6f;\n-\t\t}\n+\tif (!PX4_ISFINITE(land_approach.height_m)) {\n+\t\tsanitized_land_approach.height_m = _destination.alt + _param_rtl_descend_alt.get();\n \t}\n \n-\treturn ret;\n-}\n-\n-float RtlDirect::getCruiseGroundSpeed()\n-{\n-\tfloat cruise_speed = getCruiseSpeed();\n-\n-\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n-\t\tconst vehicle_global_position_s &global_position = *_navigator->get_global_position();\n-\t\tmatrix::Vector2f wind = get_wind();\n-\n-\t\tmatrix::Vector2f to_destination_vec;\n-\t\tget_vector_to_next_waypoint(global_position.lat, global_position.lon, _destination.lat, _destination.lon,\n-\t\t\t\t\t    &to_destination_vec(0), &to_destination_vec(1));\n-\n-\t\tconst matrix::Vector2f to_home_dir = to_destination_vec.unit_or_zero();\n-\n-\t\tconst float wind_towards_home = wind.dot(to_home_dir);\n-\t\tconst float wind_across_home = matrix::Vector2f(wind - to_home_dir * wind_towards_home).norm();\n-\n-\n-\t\t// Note: use fminf so that we don't _rely_ on wind towards home to make RTL more efficient\n-\t\tconst float ground_speed = sqrtf(cruise_speed * cruise_speed - wind_across_home * wind_across_home) + fminf(\n-\t\t\t\t\t\t   0.f, wind_towards_home);\n-\n-\t\tcruise_speed = ground_speed;\n+\tif (!PX4_ISFINITE(land_approach.loiter_radius_m) || fabsf(land_approach.loiter_radius_m) <= FLT_EPSILON) {\n+\t\tsanitized_land_approach.loiter_radius_m = _param_rtl_loiter_rad.get();\n \t}\n \n-\treturn cruise_speed;\n-}\n-\n-void RtlDirect::parameters_update()\n-{\n-\tif (_parameter_update_sub.updated()) {\n-\t\tparameter_update_s param_update;\n-\t\t_parameter_update_sub.copy(&param_update);\n-\n-\t\t// If any parameter updated, call updateParams() to check if\n-\t\t// this class attributes need updating (and do so).\n-\t\tupdateParams();\n-\t}\n+\treturn sanitized_land_approach;\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 4,
        "deletions": 50,
        "changes": 54,
        "patch": "@@ -54,6 +54,7 @@\n #include <uORB/topics/vehicle_status.h>\n #include <uORB/topics/wind.h>\n \n+#include <lib/rtl/rtl_time_estimator.h>\n #include \"mission_block.h\"\n #include \"navigation.h\"\n #include \"safe_point_land.hpp\"\n@@ -119,53 +120,17 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t} _rtl_state{RTLState::IDLE}; /*< Current state in the state machine.*/\n \n private:\n-\t/**\n-\t * @brief Get the horizontal wind velocity\n-\t *\n-\t * @return horizontal wind velocity.\n-\t */\n-\tmatrix::Vector2f get_wind();\n-\n \t/**\n \t * @brief Set the return to launch control setpoint.\n \t *\n \t */\n \tvoid set_rtl_item();\n \n \t/**\n-\t * @brief Get the Cruise Ground Speed\n-\t *\n-\t * @return Ground speed in cruise mode [m/s].\n-\t */\n-\tfloat getCruiseGroundSpeed();\n-\n-\t/**\n-\t * @brief Get the climb rate\n-\t *\n-\t * @return Climb rate [m/s]\n-\t */\n-\tfloat getClimbRate();\n-\n-\t/**\n-\t * @brief Get the descend rate\n-\t *\n-\t * @return descend rate [m/s]\n-\t */\n-\tfloat getDescendRate();\n-\n-\t/**\n-\t * @brief Get the cruise speed\n+\t * @brief sanitize land_approach\n \t *\n-\t * @return cruise speed [m/s]\n \t */\n-\tfloat getCruiseSpeed();\n-\n-\t/**\n-\t * @brief Get the Hover Land Speed\n-\t *\n-\t * @return Hover land speed [m/s]\n-\t */\n-\tfloat getHoverLandSpeed();\n+\tloiter_point_s sanitizeLandApproach(loiter_point_s land_approach) const;\n \n \t/**\n \t * Check for parameter changes and update them if needed.\n@@ -178,6 +143,7 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \n \tbool _enforce_rtl_alt{false};\n \tbool _force_heading{false};\n+\tRtlTimeEstimator _rtl_time_estimator;\n \n \tPositionYawSetpoint _destination; ///< the RTL position to fly to\n \tloiter_point_s _land_approach;\n@@ -190,23 +156,11 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t\t(ParamFloat<px4::params::RTL_MIN_DIST>)    _param_rtl_min_dist,\n \t\t(ParamInt<px4::params::RTL_PLD_MD>)        _param_rtl_pld_md,\n \t\t(ParamFloat<px4::params::RTL_LOITER_RAD>)  _param_rtl_loiter_rad,\n-\t\t(ParamFloat<px4::params::RTL_TIME_FACTOR>) _param_rtl_time_factor,\n-\t\t(ParamInt<px4::params::RTL_TIME_MARGIN>)   _param_rtl_time_margin,\n \n \t\t// external params\n \t\t(ParamBool<px4::params::WV_EN>) _param_wv_en\n \t)\n \n-\tparam_t\t\t_param_mpc_z_v_auto_up{PARAM_INVALID};\n-\tparam_t\t\t_param_mpc_z_v_auto_dn{PARAM_INVALID};\n-\tparam_t\t\t_param_mpc_land_speed{PARAM_INVALID};\n-\tparam_t\t\t_param_fw_climb_rate{PARAM_INVALID};\n-\tparam_t\t\t_param_fw_sink_rate{PARAM_INVALID};\n-\n-\tparam_t \t_param_fw_airspeed_trim{PARAM_INVALID};\n-\tparam_t \t_param_mpc_xy_cruise{PARAM_INVALID};\n-\tparam_t \t_param_rover_cruise_speed{PARAM_INVALID};\n-\n \tuORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};\n \tuORB::SubscriptionData<vehicle_global_position_s> _global_pos_sub{ORB_ID(vehicle_global_position)};\t/**< global position subscription */\n \tuORB::SubscriptionData<home_position_s> _home_pos_sub{ORB_ID(home_position)};\t\t/**< home position subscription */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 203,
        "deletions": 11,
        "changes": 214,
        "patch": "@@ -52,6 +52,42 @@ RtlDirectMissionLand::RtlDirectMissionLand(Navigator *navigator) :\n \n }\n \n+void\n+RtlDirectMissionLand::updateDatamanCache()\n+{\n+\tint32_t start_index;\n+\n+\tstart_index = math::min(_mission.land_start_index, static_cast<int32_t>(_mission.count));\n+\n+\tif ((start_index >= 0) && (_mission.count > 0) && hasMissionLandStart() && (start_index != _load_mission_index)) {\n+\n+\t\tint32_t end_index = static_cast<int32_t>(_mission.count);\n+\n+\t\t// Check that we load all data into the cache\n+\t\tif (end_index - start_index > _dataman_cache_size_signed) {\n+\t\t\t_dataman_cache.invalidate();\n+\t\t\t_dataman_cache_size_signed = end_index - start_index;\n+\t\t\t_dataman_cache.resize(_dataman_cache_size_signed);\n+\t\t}\n+\n+\t\tfor (int32_t index = start_index; index != end_index; index += math::signNoZero(_dataman_cache_size_signed)) {\n+\n+\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.mission_dataman_id), index);\n+\t\t}\n+\n+\t\t_load_mission_index = start_index;\n+\t}\n+\n+\t_dataman_cache.update();\n+}\n+\n+void RtlDirectMissionLand::on_inactive()\n+{\n+\tMissionBase::on_active();\n+\n+\tupdateDatamanCache();\n+}\n+\n void RtlDirectMissionLand::on_activation()\n {\n \t_land_detected_sub.update();\n@@ -62,13 +98,7 @@ void RtlDirectMissionLand::on_activation()\n \tif (hasMissionLandStart()) {\n \t\t_is_current_planned_mission_item_valid = (goToItem(_mission.land_start_index, false) == PX4_OK);\n \n-\t\tif ((_global_pos_sub.get().alt < _rtl_alt) || _enforce_rtl_alt) {\n-\n-\t\t\t// If lower than return altitude, climb up first.\n-\t\t\t// If enforce_rtl_alt is true then forcing altitude change even if above.\n-\t\t\t_needs_climbing = true;\n-\n-\t\t}\n+\t\t_needs_climbing = checkNeedsToClimb();\n \n \t} else {\n \t\t_is_current_planned_mission_item_valid = false;\n@@ -202,9 +232,171 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \n rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n {\n-\trtl_time_estimate_s time_estimate;\n-\ttime_estimate.valid = false;\n-\ttime_estimate.timestamp = hrt_absolute_time();\n+\t_rtl_time_estimator.update();\n+\t_rtl_time_estimator.reset();\n+\n+\tif (_mission.count > 0 && hasMissionLandStart()) {\n+\t\tint32_t start_item_index{-1};\n+\t\tbool is_in_climbing_submode{false};\n+\n+\t\tif (isActive()) {\n+\t\t\tstart_item_index = math::max(_mission.current_seq, _mission.land_start_index);\n+\t\t\tis_in_climbing_submode = _needs_climbing;\n+\n+\t\t} else {\n+\t\t\tstart_item_index = _mission.land_start_index;\n+\t\t\tis_in_climbing_submode = checkNeedsToClimb();\n+\t\t}\n+\n+\t\tif (start_item_index >= 0 && start_item_index < static_cast<int32_t>(_mission.count)) {\n+\t\t\tfloat altitude_at_calculation_point;\n+\t\t\tmatrix::Vector2d hor_position_at_calculation_point{_global_pos_sub.get().lat, _global_pos_sub.get().lon};\n+\n+\t\t\tif (is_in_climbing_submode) {\n+\t\t\t\tif (_enforce_rtl_alt) {\n+\t\t\t\t\t_rtl_time_estimator.addVertDistance(_rtl_alt - _global_pos_sub.get().alt);\n+\t\t\t\t\taltitude_at_calculation_point = _rtl_alt;\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tif (_global_pos_sub.get().alt < _rtl_alt) {\n+\t\t\t\t\t\t_rtl_time_estimator.addVertDistance(_rtl_alt - _global_pos_sub.get().alt);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\taltitude_at_calculation_point = math::max(_rtl_alt, _global_pos_sub.get().alt);\n+\t\t\t\t}\n+\n+\t\t\t} else {\n+\t\t\t\taltitude_at_calculation_point = _global_pos_sub.get().alt;\n+\t\t\t}\n+\n+\t\t\twhile (start_item_index < _mission.count && start_item_index >= 0) {\n+\t\t\t\tint32_t next_mission_item_index;\n+\t\t\t\tsize_t num_found_items{0U};\n+\t\t\t\tgetNextPositionItems(start_item_index, &next_mission_item_index, num_found_items, 1U);\n+\n+\t\t\t\tif (num_found_items > 0U) {\n+\t\t\t\t\tmission_item_s next_position_mission_item;\n+\t\t\t\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n+\t\t\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index,\n+\t\t\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_position_mission_item), sizeof(next_position_mission_item), MAX_DATAMAN_LOAD_WAIT);\n+\n+\t\t\t\t\tif (!success) {\n+\t\t\t\t\t\t// Could not load the mission item, mark time estimate as invalid.\n+\t\t\t\t\t\t_rtl_time_estimator.reset();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tswitch (next_position_mission_item.nav_cmd) {\n+\t\t\t\t\tcase NAV_CMD_LOITER_UNLIMITED: {\n+\t\t\t\t\t\t\t_rtl_time_estimator.reset();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\tcase NAV_CMD_LOITER_TIME_LIMIT: {\n+\t\t\t\t\t\t\t// Go to loiter\n+\t\t\t\t\t\t\tmatrix::Vector2f direction{};\n+\t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\n+\t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\n+\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction, 0.f);\n+\n+\t\t\t\t\t\t\t// add time\n+\t\t\t\t\t\t\t_rtl_time_estimator.addWait(next_position_mission_item.time_inside);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\tcase NAV_CMD_LOITER_TO_ALT: {\n+\t\t\t\t\t\t\t// Go to point horizontally\n+\t\t\t\t\t\t\tmatrix::Vector2f direction{};\n+\t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\n+\t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\n+\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction, 0.f);\n+\n+\t\t\t\t\t\t\t// Add the vertical loiter\n+\t\t\t\t\t\t\t_rtl_time_estimator.addVertDistance(get_absolute_altitude_for_item(next_position_mission_item) -\n+\t\t\t\t\t\t\t\t\t\t\t    altitude_at_calculation_point);\n+\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\tcase NAV_CMD_LAND: // Fallthrough\n+\t\t\t\t\tcase NAV_CMD_VTOL_LAND: {\n+\n+\t\t\t\t\t\t\tmatrix::Vector2f direction{};\n+\t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\n+\t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\n+\t\t\t\t\t\t\t// For fixed wing, add diagonal line\n+\t\t\t\t\t\t\tif ((_vehicle_status_sub.get().vehicle_type != vehicle_status_s::VEHICLE_TYPE_FIXED_WING)\n+\t\t\t\t\t\t\t    && (!_vehicle_status_sub.get().is_vtol)) {\n+\n+\n+\t\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction,\n+\t\t\t\t\t\t\t\t\t\t\t\tget_absolute_altitude_for_item(next_position_mission_item) - altitude_at_calculation_point);\n+\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// For VTOL, Rotary, go there horizontally first, then land\n+\t\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction, 0.f);\n+\n+\t\t\t\t\t\t\t\t_rtl_time_estimator.addDescendMCLand(get_absolute_altitude_for_item(next_position_mission_item) -\n+\t\t\t\t\t\t\t\t\t\t\t\t     altitude_at_calculation_point);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\tdefault: {\n+\t\t\t\t\t\t\t// Default assume can go to the location directly\n+\t\t\t\t\t\t\tmatrix::Vector2f direction{};\n+\t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\n+\t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\n+\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction,\n+\t\t\t\t\t\t\t\t\t\t\tget_absolute_altitude_for_item(next_position_mission_item) - altitude_at_calculation_point);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tstart_item_index = next_mission_item_index + 1;\n+\t\t\t\t\thor_position_at_calculation_point(0) = next_position_mission_item.lat;\n+\t\t\t\t\thor_position_at_calculation_point(1) = next_position_mission_item.lon;\n+\t\t\t\t\taltitude_at_calculation_point = get_absolute_altitude_for_item(next_position_mission_item);\n+\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tstart_item_index = -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn _rtl_time_estimator.getEstimate();\n+}\n+\n+bool RtlDirectMissionLand::checkNeedsToClimb()\n+{\n+\tbool needs_climbing{false};\n+\n+\tif ((_global_pos_sub.get().alt < _rtl_alt) || _enforce_rtl_alt) {\n+\n+\t\t// If lower than return altitude, climb up first.\n+\t\t// If enforce_rtl_alt is true then forcing altitude change even if above.\n+\t\tneeds_climbing = true;\n+\n+\t}\n \n-\treturn time_estimate;\n+\treturn needs_climbing;\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.h": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -43,6 +43,8 @@\n \n #include \"rtl_base.h\"\n \n+#include <lib/rtl/rtl_time_estimator.h>\n+\n #include <uORB/Subscription.hpp>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/rtl_time_estimate.h>\n@@ -56,6 +58,7 @@ class RtlDirectMissionLand : public RtlBase\n \t~RtlDirectMissionLand() = default;\n \n \tvoid on_activation() override;\n+\tvoid on_inactive() override;\n \n \trtl_time_estimate_s calc_rtl_time_estimate() override;\n \n@@ -65,8 +68,12 @@ class RtlDirectMissionLand : public RtlBase\n private:\n \tbool setNextMissionItem() override;\n \tvoid setActiveMissionItems() override;\n+\tvoid updateDatamanCache() override;\n+\tbool checkNeedsToClimb();\n \n \tbool _needs_climbing{false}; \t//< Flag if climbing is required at the start\n \tbool _enforce_rtl_alt{false};\n \tfloat _rtl_alt{0.0f};\t///< AMSL altitude at which the vehicle should return to the land position\n+\n+\tRtlTimeEstimator _rtl_time_estimator;\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b4abab2a5f9a130d2e027562de9bb2cba2370ec4/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.h"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirect::setRtlPosition",
        "getDescendRate",
        "RTL::on_inactive",
        "RtlDirect::getCruiseGroundSpeed",
        "math::max",
        "matrix::Vector2f",
        "updateDatamanCache",
        "RtlDirect::getDescendRate",
        "getCruiseGroundSpeed",
        "RtlDirect::getActivationLandState",
        "getCruiseSpeed",
        "getClimbRate",
        "RtlDirect::RtlDirect",
        "RtlDirect::get_wind",
        "RtlDirect::parameters_update",
        "getHoverLandSpeed",
        "RtlDirect::calc_rtl_time_estimate",
        "RtlDirect::getClimbRate",
        "Copyright",
        "RtlDirect::set_rtl_item",
        "RtlDirect::getHoverLandSpeed",
        "RtlDirectMissionLand::RtlDirectMissionLand",
        "RtlDirectMissionLand::on_activation",
        "RtlDirectMissionLand::setActiveMissionItems",
        "RtlDirect::getCruiseSpeed"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.h": [
          "updateDatamanCache"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_inactive"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::RtlDirect",
          "RtlDirect::get_wind",
          "RtlDirect::parameters_update",
          "RtlDirect::setRtlPosition",
          "RtlDirect::calc_rtl_time_estimate",
          "RtlDirect::getClimbRate",
          "RtlDirect::getCruiseGroundSpeed",
          "Copyright",
          "math::max",
          "matrix::Vector2f",
          "RtlDirect::set_rtl_item",
          "RtlDirect::getHoverLandSpeed",
          "RtlDirect::getDescendRate",
          "RtlDirect::getActivationLandState",
          "RtlDirect::getCruiseSpeed"
        ],
        "src/modules/navigator/rtl_direct.h": [
          "getHoverLandSpeed",
          "getDescendRate",
          "getCruiseGroundSpeed",
          "getCruiseSpeed",
          "getClimbRate"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::on_activation",
          "RtlDirectMissionLand::setActiveMissionItems",
          "RtlDirectMissionLand::RtlDirectMissionLand"
        ]
      }
    }
  },
  {
    "title": "global: Maximum number of WPs can be set in board config",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22741",
    "number": 22741,
    "created_at": "2024-02-12T07:26:33Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nThe maximum number of WAYPOINT is 500.\r\nI create more than 500 flight plans.\r\n\r\n### Solution\r\n\r\nRAM size and flash size are different by FC.\r\nTherefore, the maximum number of WAYPOINT can be set in board_config.h.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\n\r\nError message was displayed on PIXHAWK6X-RT after uploading a flight plan that exceeded the maximum number of WAYPOINT.\r\n\r\n### Context\r\n\r\n![Screenshot from 2024-02-12 16-30-31](https://github.com/PX4/PX4-Autopilot/assets/646194/f0a4459b-75d6-4ac0-a0f3-42f1838288a3)\r\n",
      "issue_comments": [
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2024-02-12T08:29:13Z",
          "body": "I think if we make this configurable it would be better to introduce a Kconfig symbol. \r\nFor example `CONFIG_NUM_MISSIONS_SUPPORTED` with the current default `500`\r\nhttps://github.com/PX4/PX4-Autopilot/blob/5082d23777abd44c5ea7b37444be47ffece6db44/src/modules/navigator/Kconfig",
          "type": "issue_comment"
        },
        {
          "author": "muramura",
          "created_at": "2024-02-18T05:33:04Z",
          "body": "I added the WP max number to Kconfig.\r\nI changed default.px4board to allow the maximum number of WPs to be specified.\r\n\r\nCONFIG_NUM_MISSIONS with y to set the value of CONFIG_NUM_MISSIONS_SUPPORTED to NUM_MISSIONS_SUPPORTED.\r\n\r\nSpecifying n for CONFIG_NUM_MISSIONS sets the default value to NUM_MISSIONS_SUPPORTED.\r\n\r\nCONFIG_NUM_MISSIONS set y\r\n![Screenshot from 2024-02-18 13-48-53](https://github.com/PX4/PX4-Autopilot/assets/646194/ab14f4b7-46d6-41bc-b2a7-9df8483a1029)\r\n\r\nCONFIG_NUM_MISSIONS set n\r\n![Screenshot from 2024-02-18 13-51-09](https://github.com/PX4/PX4-Autopilot/assets/646194/2fa7f142-b0b3-4b49-bc8b-f51f113dac02)\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2024-02-19T15:49:45Z",
          "body": "The `NUM_MISSIONS` is redundant please just only use `NUM_MISSIONS_SUPPORTED`\r\nAlso there's a Kconfig naming convention https://docs.px4.io/main/en/hardware/porting_guide_config.html#px4-kconfig-symbol-naming-convention\r\nPlease rename `NUM_MISSIONS_SUPPORTED` to `NAVIGATOR_NUM_MISSIONS_SUPPORTED` and guard it with `if MODULES_NAVIGATOR`",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a hard-coded boundary condition (maximum 500 WAYPOINTs) that caused incorrect behavior when users uploaded more than 500 missions. Making the limit configurable per board/Kconfig corrects the program logic (a boundary/limit logic error); reviewer comments are about naming and Kconfig placement but do not change that this addresses a logic bug.",
    "patches": {
      "src/modules/navigator/Kconfig": {
        "filename": "src/modules/navigator/Kconfig",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "patch": "@@ -19,3 +19,20 @@ menuconfig MODE_NAVIGATOR_VTOL_TAKEOFF\n \t\tAdd VTOL takeoff mode to enable support for MAV_CMD_NAV_VTOL_TAKEOFF.\n \t\tThe VTOL takes off in MC mode and transition to FW. The mode ends with\n \t\tan infinite loiter\n+\n+menuconfig NUM_MISSIONS\n+\tbool \"Specify the maximum number of WPs\"\n+\tdefault n\n+\tdepends on MODULES_NAVIGATOR\n+\t---help---\n+\t\tEnable WP maximum number specification.\n+\n+if NUM_MISSIONS\n+\n+config NUM_MISSIONS_SUPPORTED\n+\tint \"maximum number of WPs\"\n+\tdefault 500\n+\t---help---\n+\t\tAfter changing the maximum number of WPs, check the telemetry communication response.\n+\n+endif # NUM_MISSIONS",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4a9f47cc4d0df3ae248a4b72f5bf0c95b51b32af/src%2Fmodules%2Fnavigator%2FKconfig"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -53,7 +53,11 @@\n #elif defined(RAM_BASED_MISSIONS)\n #  define NUM_MISSIONS_SUPPORTED 500\n #else\n+#ifndef CONFIG_NUM_MISSIONS_SUPPORTED\n #  define NUM_MISSIONS_SUPPORTED 500\n+#else\n+#  define NUM_MISSIONS_SUPPORTED CONFIG_NUM_MISSIONS_SUPPORTED\n+#endif\n #endif\n \n #define NAV_EPSILON_POSITION\t0.001f\t/**< Anything smaller than this is considered zero */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4a9f47cc4d0df3ae248a4b72f5bf0c95b51b32af/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "RTL: change when to set a heading setpoint, generally leave it up to executer",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22731",
    "number": 22731,
    "created_at": "2024-02-08T13:18:33Z",
    "merged": true,
    "merged_at": "2024-02-13T09:34:58Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nVTOLs yawing to the home position heading when descending in hover during RTL instead of weather-vaning.\r\n\r\n### Solution\r\nContinue with what was started in https://github.com/PX4/PX4-Autopilot/pull/22532: \r\n- remove `RTL_HDG_MD` (necessity of it hasn't been proven and it interferes with the here proposed solution)\r\n- only set heading setpoint in `Navigator::RTL` once above landing point, or when RTL is triggered close to it\r\n- never set a heading setpoint in the RTL if weather vane is enabled\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Fix weather vane in RTL\r\nFeature: Make RTL behavior more deterministic by removing the parameter RTL_HDG_MD.\r\n```\r\n\r\n### Test coverage\r\nSITL tested. \r\n\r\n### Context\r\nThis is how a normal RTL with a MC looks like (the behavior doesn't change with this PR):\r\n- climb while keeping heading\r\n- return over landing point without a specified heading --> executor (FlightTaskAuto) sets heading in direction of flight\r\n- once over landing point set destination heading (home position heading in this case) and don't change it anymore\r\n\r\nhttps://github.com/PX4/PX4-Autopilot/assets/26798987/394599d1-555a-4b40-92b6-a775a5bf7ffc\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-12T14:13:53Z",
          "body": "@sfuhrer I rebased and added a commit which I'd presume does the same without the duplication in the interface. Did I overlook something?",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2024-07-25T01:09:32Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-v1-15-public-changes-what-needs-docs/39850/3\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-12T13:34:37Z",
          "body": "```suggestion\r\n\t\t\t// set final yaw if weather vane is disabled\r\n```",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-12T13:40:12Z",
          "body": "The passed on destination already has a yaw(/heading?) which now gets ignored at least in this case here ðŸ¤¯ ",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-02-12T15:02:11Z",
          "body": "correct - let's go with your proposed solution.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-12T15:12:47Z",
          "body": "```suggestion\r\n\t\tfloat loiter_time, float loiter_radius) const\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-12T13:44:46Z",
          "body": "Nice. Thanks for this generally nice improvement!\r\nThe only question I have is about this `DestinationPosition dest` which contains a yaw. As I read it this was supposed to contain the actual heading setpoint and I would have probably gone back to this. But if we have a separate `heading_sp` then I'd suggest only having one way. Or make it very clear when to use which.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-02-12T15:02:11Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-12T15:14:15Z",
          "body": "Much clearer ðŸ‘ ",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-02-13T09:34:50Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect runtime behavior (VTOLs yawing to home heading during descent instead of weather-vaning) by changing when a heading setpoint is applied and preventing it when weather-vane is enabled. This is a logic-level bug (wrong condition/state transition) rather than a syntax/style issue, so the change addresses a logic error in the RTL heading decision flow.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 48,
        "changes": 70,
        "patch": "@@ -928,16 +928,15 @@ MissionBlock::initialize()\n \t_mission_item.origin = ORIGIN_ONBOARD;\n }\n \n-void MissionBlock::setLoiterToAltMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_radius,\n-\t\tHeadingMode heading_mode) const\n+void MissionBlock::setLoiterToAltMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp,\n+\t\tfloat loiter_radius) const\n {\n \titem.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n-\titem.lat = dest.lat;\n-\titem.lon = dest.lon;\n-\titem.altitude = dest.alt;\n+\titem.lat = pos_yaw_sp.lat;\n+\titem.lon = pos_yaw_sp.lon;\n+\titem.altitude = pos_yaw_sp.alt;\n \titem.altitude_is_relative = false;\n-\n-\titem. yaw = setYawFromHeadingMode(dest, heading_mode);\n+\titem.yaw = pos_yaw_sp.yaw;\n \n \titem.acceptance_radius = _navigator->get_acceptance_radius();\n \titem.time_inside = 0.0f;\n@@ -946,8 +945,8 @@ void MissionBlock::setLoiterToAltMissionItem(mission_item_s &item, const Destina\n \titem.loiter_radius = loiter_radius;\n }\n \n-void MissionBlock::setLoiterHoldMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_time,\n-\t\tfloat loiter_radius, HeadingMode heading_mode) const\n+void MissionBlock::setLoiterHoldMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp,\n+\t\tfloat loiter_time, float loiter_radius) const\n {\n \tconst bool autocontinue = (loiter_time > -FLT_EPSILON);\n \n@@ -958,12 +957,12 @@ void MissionBlock::setLoiterHoldMissionItem(mission_item_s &item, const Destinat\n \t\titem.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n \t}\n \n-\titem.lat = dest.lat;\n-\titem.lon = dest.lon;\n-\titem.altitude = dest.alt;\n+\titem.lat = pos_yaw_sp.lat;\n+\titem.lon = pos_yaw_sp.lon;\n+\titem.altitude = pos_yaw_sp.alt;\n \titem.altitude_is_relative = false;\n \n-\titem. yaw = setYawFromHeadingMode(dest, heading_mode);\n+\titem.yaw = NAN;\n \n \titem.acceptance_radius = _navigator->get_acceptance_radius();\n \titem.time_inside = math::max(loiter_time, 0.0f);\n@@ -972,60 +971,35 @@ void MissionBlock::setLoiterHoldMissionItem(mission_item_s &item, const Destinat\n \titem.loiter_radius = loiter_radius;\n }\n \n-void MissionBlock::setMoveToPositionMissionItem(mission_item_s &item, const DestinationPosition &dest,\n-\t\tHeadingMode heading_mode) const\n+void MissionBlock::setMoveToPositionMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const\n {\n \titem.nav_cmd = NAV_CMD_WAYPOINT;\n-\titem.lat = dest.lat;\n-\titem.lon = dest.lon;\n-\titem.altitude = dest.alt;\n+\titem.lat = pos_yaw_sp.lat;\n+\titem.lon = pos_yaw_sp.lon;\n+\titem.altitude = pos_yaw_sp.alt;\n \titem.altitude_is_relative = false;\n \n \titem.autocontinue = true;\n \titem.acceptance_radius = _navigator->get_acceptance_radius();\n \titem.time_inside = 0.f;\n \titem.origin = ORIGIN_ONBOARD;\n \n-\titem. yaw = setYawFromHeadingMode(dest, heading_mode);\n+\titem.yaw = pos_yaw_sp.yaw;\n }\n \n-void MissionBlock::setLandMissionItem(mission_item_s &item, const DestinationPosition &dest,\n-\t\t\t\t      HeadingMode heading_mode) const\n+void MissionBlock::setLandMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const\n {\n \titem.nav_cmd = NAV_CMD_LAND;\n-\titem.lat = dest.lat;\n-\titem.lon = dest.lon;\n-\titem.altitude = dest.alt;\n-\n-\tif (heading_mode == HeadingMode::CURRENT_HEADING) {\n-\t\titem.yaw = _navigator->get_local_position()->heading;\n-\n-\t} else {\n-\t\titem.yaw = dest.yaw;\n-\t}\n-\n+\titem.lat = pos_yaw_sp.lat;\n+\titem.lon = pos_yaw_sp.lon;\n+\titem.altitude = pos_yaw_sp.alt;\n+\titem.yaw = pos_yaw_sp.yaw;\n \titem.acceptance_radius = _navigator->get_acceptance_radius();\n \titem.time_inside = 0.0f;\n \titem.autocontinue = true;\n \titem.origin = ORIGIN_ONBOARD;\n }\n \n-float MissionBlock::setYawFromHeadingMode(const DestinationPosition &dest, HeadingMode heading_mode) const\n-{\n-\tfloat desired_yaw(_navigator->get_local_position()->heading);\n-\n-\tif (heading_mode == HeadingMode::NAVIGATION_HEADING) {\n-\t\tdesired_yaw = get_bearing_to_next_waypoint(_navigator->get_global_position()->lat,\n-\t\t\t\t_navigator->get_global_position()->lon, dest.lat, dest.lon);\n-\n-\t} else if (heading_mode == HeadingMode::DESTINATION_HEADING) {\n-\t\tdesired_yaw = dest.yaw;\n-\n-\t}\n-\n-\treturn desired_yaw;\n-}\n-\n void MissionBlock::startPrecLand(uint16_t land_precision)\n {\n \tif (_mission_item.land_precision == 1) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 5,
        "deletions": 9,
        "changes": 14,
        "patch": "@@ -205,18 +205,14 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_vtol_transition_item(struct mission_item_s *item, const uint8_t new_mode);\n \n-\tvoid setLoiterToAltMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_radius,\n-\t\t\t\t       HeadingMode heading_mode) const;\n+\tvoid setLoiterToAltMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp, float loiter_radius) const;\n \n-\tvoid setLoiterHoldMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_time,\n-\t\t\t\t      float loiter_radius, HeadingMode heading_mode) const;\n+\tvoid setLoiterHoldMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp, float loiter_time,\n+\t\t\t\t      float loiter_radius) const;\n \n-\tvoid setMoveToPositionMissionItem(mission_item_s &item, const DestinationPosition &dest,\n-\t\t\t\t\t  HeadingMode heading_mode) const;\n+\tvoid setMoveToPositionMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const;\n \n-\tvoid setLandMissionItem(mission_item_s &item, const DestinationPosition &dest, HeadingMode heading_mode) const;\n-\n-\tfloat setYawFromHeadingMode(const DestinationPosition &dest, HeadingMode heading_mode) const;\n+\tvoid setLandMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const;\n \n \tvoid startPrecLand(uint16_t land_precision);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "patch": "@@ -230,15 +230,15 @@ struct mission_fence_point_s {\n };\n \n /**\n- * @brief Return to launch position.\n- * Defines the position and landing yaw for the return to launch destination.\n+ * @brief Position and yaw setpoint struct.\n+ * Used in RTL state machine.\n  *\n  */\n-struct DestinationPosition {\n-\tdouble lat;\t/**< latitude in WGS84 [rad].*/\n-\tdouble lon;\t/**< longitude in WGS84 [rad].*/\n-\tfloat alt;\t/**< altitude in MSL [m].*/\n-\tfloat yaw;\t/**< final yaw when landed [rad].*/\n+struct PositionYawSetpoint {\n+\tdouble lat;\t/**< latitude setpoint in WGS84 [rad].*/\n+\tdouble lon;\t/**< longitude setpoint in WGS84 [rad].*/\n+\tfloat alt;\t/**< altitude setpoint in MSL [m].*/\n+\tfloat yaw;\t/**< yaw setpoint [rad].*/\n };\n \n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -297,7 +297,7 @@ void RTL::setRtlTypeAndDestination()\n \tif (_param_rtl_type.get() != 2) {\n \t\t// check the closest allowed destination.\n \t\tDestinationType destination_type{DestinationType::DESTINATION_TYPE_HOME};\n-\t\tDestinationPosition rtl_position;\n+\t\tPositionYawSetpoint rtl_position;\n \t\tfloat rtl_alt;\n \t\tfindRtlDestination(destination_type, rtl_position, rtl_alt);\n \n@@ -333,7 +333,7 @@ void RTL::setRtlTypeAndDestination()\n \t}\n }\n \n-void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosition &rtl_position, float &rtl_alt)\n+void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpoint &rtl_position, float &rtl_alt)\n {\n \t// set destination to home per default, then check if other valid landing spot is closer\n \trtl_position.alt = _home_pos_sub.get().alt;\n@@ -413,7 +413,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosit\n \t\t\tif (mission_safe_point.nav_cmd == NAV_CMD_RALLY_POINT && dist_to_home > MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n \t\t\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, mission_safe_point.lat, mission_safe_point.lon)};\n \n-\t\t\t\tDestinationPosition safepoint_position;\n+\t\t\t\tPositionYawSetpoint safepoint_position;\n \t\t\t\tsetSafepointAsDestination(safepoint_position, mission_safe_point);\n \n \t\t\t\tif (((dist + MIN_DIST_THRESHOLD) < min_dist) && (!vtol_in_fw_mode || (_param_rtl_approach_force.get() == 0)\n@@ -435,7 +435,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosit\n \t}\n }\n \n-void RTL::setLandPosAsDestination(DestinationPosition &rtl_position, mission_item_s &land_mission_item) const\n+void RTL::setLandPosAsDestination(PositionYawSetpoint &rtl_position, mission_item_s &land_mission_item) const\n {\n \trtl_position.alt = land_mission_item.altitude_is_relative ?\tland_mission_item.altitude +\n \t\t\t   _home_pos_sub.get().alt : land_mission_item.altitude;\n@@ -444,7 +444,7 @@ void RTL::setLandPosAsDestination(DestinationPosition &rtl_position, mission_ite\n \trtl_position.yaw = _home_pos_sub.get().yaw;\n }\n \n-void RTL::setSafepointAsDestination(DestinationPosition &rtl_position,\n+void RTL::setSafepointAsDestination(PositionYawSetpoint &rtl_position,\n \t\t\t\t    const mission_item_s &mission_safe_point) const\n {\n \t// There is a safe point closer than home/mission landing\n@@ -472,7 +472,7 @@ void RTL::setSafepointAsDestination(DestinationPosition &rtl_position,\n \t}\n }\n \n-float RTL::calculate_return_alt_from_cone_half_angle(const DestinationPosition &rtl_position,\n+float RTL::calculate_return_alt_from_cone_half_angle(const PositionYawSetpoint &rtl_position,\n \t\tfloat cone_half_angle_deg) const\n {\n \t// horizontal distance to destination\n@@ -576,7 +576,7 @@ bool RTL::hasMissionLandStart() const\n \treturn _mission_sub.get().land_start_index > 0;\n }\n \n-bool RTL::hasVtolLandApproach(const DestinationPosition &rtl_position) const\n+bool RTL::hasVtolLandApproach(const PositionYawSetpoint &rtl_position) const\n {\n \treturn readVtolLandApproaches(rtl_position).isAnyApproachValid();\n }\n@@ -611,7 +611,7 @@ loiter_point_s RTL::chooseBestLandingApproach(const land_approaches_s &vtol_land\n \t}\n }\n \n-land_approaches_s RTL::readVtolLandApproaches(DestinationPosition rtl_position) const\n+land_approaches_s RTL::readVtolLandApproaches(PositionYawSetpoint rtl_position) const\n {\n \n \t// go through all mission items in the rally point storage. If we find a mission item of type NAV_CMD_RALLY_POINT",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -109,20 +109,20 @@ class RTL : public NavigatorMode, public ModuleParams\n \t * @brief Find RTL destination.\n \t *\n \t */\n-\tvoid findRtlDestination(DestinationType &destination_type, DestinationPosition &rtl_position, float &rtl_alt);\n+\tvoid findRtlDestination(DestinationType &destination_type, PositionYawSetpoint &rtl_position, float &rtl_alt);\n \n \t/**\n \t * @brief Set the position of the land start marker in the planned mission as destination.\n \t *\n \t */\n-\tvoid setLandPosAsDestination(DestinationPosition &rtl_position, mission_item_s &land_mission_item) const;\n+\tvoid setLandPosAsDestination(PositionYawSetpoint &rtl_position, mission_item_s &land_mission_item) const;\n \n \t/**\n \t * @brief Set the safepoint as destination.\n \t *\n \t * @param mission_safe_point is the mission safe point/rally point to set as destination.\n \t */\n-\tvoid setSafepointAsDestination(DestinationPosition &rtl_position, const mission_item_s &mission_safe_point) const;\n+\tvoid setSafepointAsDestination(PositionYawSetpoint &rtl_position, const mission_item_s &mission_safe_point) const;\n \n \t/**\n \t * @brief calculate return altitude from cone half angle\n@@ -131,7 +131,7 @@ class RTL : public NavigatorMode, public ModuleParams\n \t * @param[in] cone_half_angle_deg half angle of the cone [deg]\n \t * @return return altitude\n \t */\n-\tfloat calculate_return_alt_from_cone_half_angle(const DestinationPosition &rtl_position,\n+\tfloat calculate_return_alt_from_cone_half_angle(const PositionYawSetpoint &rtl_position,\n \t\t\tfloat cone_half_angle_deg) const;\n \n \t/**\n@@ -152,7 +152,7 @@ class RTL : public NavigatorMode, public ModuleParams\n \t * @param[in] rtl_position landing position of the rtl\n \t *\n \t */\n-\tland_approaches_s readVtolLandApproaches(DestinationPosition rtl_position) const;\n+\tland_approaches_s readVtolLandApproaches(PositionYawSetpoint rtl_position) const;\n \n \t/**\n \t * @brief Has VTOL land approach\n@@ -162,7 +162,7 @@ class RTL : public NavigatorMode, public ModuleParams\n \t * @return true if home land approaches are defined for home position\n \t * @return false otherwise\n \t */\n-\tbool hasVtolLandApproach(const DestinationPosition &rtl_position) const;\n+\tbool hasVtolLandApproach(const PositionYawSetpoint &rtl_position) const;\n \n \t/**\n \t * @brief Choose best landing approach",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "patch": "@@ -122,7 +122,7 @@ void RtlDirect::on_active()\n \t}\n }\n \n-void RtlDirect::setRtlPosition(DestinationPosition rtl_position, loiter_point_s loiter_pos)\n+void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s loiter_pos)\n {\n \t_home_pos_sub.update();\n \n@@ -178,41 +178,39 @@ void RtlDirect::set_rtl_item()\n \t\t\t\t       _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n \tconst float loiter_altitude = math::min(_land_approach.height_m, _rtl_alt);\n \n-\tHeadingMode rtl_heading_mode = static_cast<HeadingMode>(_param_rtl_hdg_md.get());\n-\n-\tif ((rtl_heading_mode == HeadingMode::NAVIGATION_HEADING) && (destination_dist < _param_rtl_min_dist.get())) {\n-\t\trtl_heading_mode = HeadingMode::DESTINATION_HEADING;\n-\t}\n+\tconst bool is_close_to_destination = destination_dist < _param_rtl_min_dist.get();\n \n \tswitch (_rtl_state) {\n \tcase RTLState::CLIMBING: {\n-\t\t\tDestinationPosition dest {\n+\t\t\tPositionYawSetpoint pos_yaw_sp {\n \t\t\t\t.lat = _global_pos_sub.get().lat,\n \t\t\t\t.lon = _global_pos_sub.get().lon,\n \t\t\t\t.alt = _rtl_alt,\n+\t\t\t\t.yaw = _param_wv_en.get() ? NAN : _navigator->get_local_position()->heading,\n \t\t\t};\n-\n-\t\t\tsetLoiterToAltMissionItem(_mission_item, dest, _navigator->get_loiter_radius(), HeadingMode::CURRENT_HEADING);\n+\t\t\tsetLoiterToAltMissionItem(_mission_item, pos_yaw_sp, _navigator->get_loiter_radius());\n \n \t\t\t_rtl_state = RTLState::MOVE_TO_LOITER;\n \t\t\tbreak;\n \t\t}\n \n \tcase RTLState::MOVE_TO_LOITER: {\n-\t\t\tDestinationPosition dest {\n+\t\t\tPositionYawSetpoint pos_yaw_sp {\n \t\t\t\t.lat = _land_approach.lat,\n \t\t\t\t.lon = _land_approach.lon,\n \t\t\t\t.alt = _rtl_alt,\n-\t\t\t\t.yaw = _destination.yaw,\n \t\t\t};\n \n \t\t\t// For FW flight:set to LOITER_TIME (with 0s loiter time), such that the loiter (orbit) status\n \t\t\t// can be displayed on groundstation and the WP is accepted once within loiter radius\n \t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n-\t\t\t\tsetLoiterHoldMissionItem(_mission_item, dest, 0.f, _land_approach.loiter_radius_m, rtl_heading_mode);\n+\t\t\t\tpos_yaw_sp.yaw = NAN;\n+\t\t\t\tsetLoiterHoldMissionItem(_mission_item, pos_yaw_sp, 0.f, _land_approach.loiter_radius_m);\n \n \t\t\t} else {\n-\t\t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n+\t\t\t\t// already set final yaw if close to destination and weather vane is disabled\n+\t\t\t\tpos_yaw_sp.yaw = (is_close_to_destination && !_param_wv_en.get()) ? _destination.yaw : NAN;\n+\t\t\t\tsetMoveToPositionMissionItem(_mission_item, pos_yaw_sp);\n \t\t\t}\n \n \t\t\t_rtl_state = RTLState::LOITER_DOWN;\n@@ -221,14 +219,14 @@ void RtlDirect::set_rtl_item()\n \t\t}\n \n \tcase RTLState::LOITER_DOWN: {\n-\t\t\tDestinationPosition dest{\n+\t\t\tPositionYawSetpoint pos_yaw_sp{\n \t\t\t\t.lat = _land_approach.lat,\n \t\t\t\t.lon = _land_approach.lon,\n \t\t\t\t.alt = loiter_altitude,\n-\t\t\t\t.yaw = _destination.yaw,\n+\t\t\t\t.yaw = !_param_wv_en.get() ? _destination.yaw : NAN, // set final yaw if weather vane is disabled\n \t\t\t};\n \n-\t\t\tsetLoiterToAltMissionItem(_mission_item, dest, _land_approach.loiter_radius_m, rtl_heading_mode);\n+\t\t\tsetLoiterToAltMissionItem(_mission_item, pos_yaw_sp, _land_approach.loiter_radius_m);\n \n \t\t\tpos_sp_triplet->next.valid = true;\n \t\t\tpos_sp_triplet->next.lat = _destination.lat;\n@@ -248,15 +246,14 @@ void RtlDirect::set_rtl_item()\n \t\t}\n \n \tcase RTLState::LOITER_HOLD: {\n-\t\t\tDestinationPosition dest {\n+\t\t\tPositionYawSetpoint pos_yaw_sp {\n \t\t\t\t.lat = _land_approach.lat,\n \t\t\t\t.lon = _land_approach.lon,\n \t\t\t\t.alt = loiter_altitude,\n-\t\t\t\t.yaw = _destination.yaw,\n+\t\t\t\t.yaw = !_param_wv_en.get() ? _destination.yaw : NAN, // set final yaw if weather vane is disabled\n \t\t\t};\n \n-\t\t\tsetLoiterHoldMissionItem(_mission_item, dest, _param_rtl_land_delay.get(), _land_approach.loiter_radius_m,\n-\t\t\t\t\t\t rtl_heading_mode);\n+\t\t\tsetLoiterHoldMissionItem(_mission_item, pos_yaw_sp, _param_rtl_land_delay.get(), _land_approach.loiter_radius_m);\n \n \t\t\tif (_param_rtl_land_delay.get() < -FLT_EPSILON) {\n \t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: completed, loitering\\t\");\n@@ -276,10 +273,11 @@ void RtlDirect::set_rtl_item()\n \n \tcase RTLState::MOVE_TO_LAND: {\n \n-\t\t\tDestinationPosition dest{_destination};\n-\t\t\tdest.alt = loiter_altitude;\n+\t\t\tPositionYawSetpoint pos_yaw_sp{_destination};\n+\t\t\tpos_yaw_sp.alt = loiter_altitude;\n+\t\t\tpos_yaw_sp.yaw = NAN;\n \n-\t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n+\t\t\tsetMoveToPositionMissionItem(_mission_item, pos_yaw_sp);\n \n \t\t\t// Prepare for transition\n \t\t\t_mission_item.vtol_back_transition = true;\n@@ -306,10 +304,11 @@ void RtlDirect::set_rtl_item()\n \t\t}\n \n \tcase RTLState::MOVE_TO_LAND_HOVER: {\n-\t\t\tDestinationPosition dest{_destination};\n-\t\t\tdest.alt = loiter_altitude;\n+\t\t\tPositionYawSetpoint pos_yaw_sp{_destination};\n+\t\t\tpos_yaw_sp.alt = loiter_altitude;\n+\t\t\tpos_yaw_sp.yaw = !_param_wv_en.get() ? _destination.yaw : NAN; // set final yaw if weather vane is disabled\n \n-\t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n+\t\t\tsetMoveToPositionMissionItem(_mission_item, pos_yaw_sp);\n \t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n \n \t\t\t_rtl_state = RTLState::LAND;\n@@ -318,8 +317,9 @@ void RtlDirect::set_rtl_item()\n \t\t}\n \n \tcase RTLState::LAND: {\n-\n-\t\t\tsetLandMissionItem(_mission_item, _destination, rtl_heading_mode);\n+\t\t\tPositionYawSetpoint pos_yaw_sp{_destination};\n+\t\t\tpos_yaw_sp.yaw = !_param_wv_en.get() ? _destination.yaw : NAN; // set final yaw if weather vane is disabled\n+\t\t\tsetLandMissionItem(_mission_item, pos_yaw_sp);\n \n \t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "patch": "@@ -99,7 +99,7 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \tvoid setReturnAltMin(bool min) { _enforce_rtl_alt = min; }\n \tvoid setRtlAlt(float alt) {_rtl_alt = alt;};\n \n-\tvoid setRtlPosition(DestinationPosition position, loiter_point_s loiter_pos);\n+\tvoid setRtlPosition(PositionYawSetpoint position, loiter_point_s loiter_pos);\n \n private:\n \t/**\n@@ -179,7 +179,7 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \tbool _enforce_rtl_alt{false};\n \tbool _force_heading{false};\n \n-\tDestinationPosition _destination; ///< the RTL position to fly to\n+\tPositionYawSetpoint _destination; ///< the RTL position to fly to\n \tloiter_point_s _land_approach;\n \n \tfloat _rtl_alt{0.0f};\t///< AMSL altitude at which the vehicle should return to the home position\n@@ -190,9 +190,11 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t\t(ParamFloat<px4::params::RTL_MIN_DIST>)    _param_rtl_min_dist,\n \t\t(ParamInt<px4::params::RTL_PLD_MD>)        _param_rtl_pld_md,\n \t\t(ParamFloat<px4::params::RTL_LOITER_RAD>)  _param_rtl_loiter_rad,\n-\t\t(ParamInt<px4::params::RTL_HDG_MD>)        _param_rtl_hdg_md,\n \t\t(ParamFloat<px4::params::RTL_TIME_FACTOR>) _param_rtl_time_factor,\n-\t\t(ParamInt<px4::params::RTL_TIME_MARGIN>)   _param_rtl_time_margin\n+\t\t(ParamInt<px4::params::RTL_TIME_MARGIN>)   _param_rtl_time_margin,\n+\n+\t\t// external params\n+\t\t(ParamBool<px4::params::WV_EN>) _param_wv_en\n \t)\n \n \tparam_t\t\t_param_mpc_z_v_auto_up{PARAM_INVALID};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "patch": "@@ -160,18 +160,6 @@ PARAM_DEFINE_INT32(RTL_PLD_MD, 0);\n  */\n PARAM_DEFINE_FLOAT(RTL_LOITER_RAD, 80.0f);\n \n-/**\n- * RTL heading mode\n- *\n- * Defines the heading behavior during RTL\n- *\n- * @value 0 Towards next waypoint.\n- * @value 1 Heading matches destination.\n- * @value 2 Use current heading.\n- * @group Return Mode\n- */\n-PARAM_DEFINE_INT32(RTL_HDG_MD, 0);\n-\n /**\n  * RTL time estimate safety margin factor\n  *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/24f405cbd63c80be7cee1ee428f8f39facf9c996/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "setLandMissionItem",
        "setLandPosAsDestination",
        "MissionBlock::setMoveToPositionMissionItem",
        "MissionBlock::setYawFromHeadingMode",
        "setSafepointAsDestination",
        "RTL::chooseBestLandingApproach",
        "RTL::setLandPosAsDestination",
        "RtlDirect::setRtlPosition",
        "setRtlPosition",
        "RTL::calculate_return_alt_from_cone_half_angle",
        "MissionBlock::setLoiterToAltMissionItem",
        "RTL::hasMissionLandStart",
        "RtlDirect::on_active",
        "hasVtolLandApproach",
        "RTL::readVtolLandApproaches",
        "RTL::findRtlDestination",
        "MissionBlock::initialize",
        "setYawFromHeadingMode",
        "desired_yaw",
        "RTL::setSafepointAsDestination",
        "findRtlDestination",
        "MissionBlock::setLandMissionItem",
        "readVtolLandApproaches",
        "RTL::setRtlTypeAndDestination",
        "RtlDirect::set_rtl_item",
        "MissionBlock::setLoiterHoldMissionItem",
        "RTL::hasVtolLandApproach"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::setMoveToPositionMissionItem",
          "MissionBlock::setYawFromHeadingMode",
          "MissionBlock::initialize",
          "desired_yaw",
          "MissionBlock::setLandMissionItem",
          "MissionBlock::setLoiterToAltMissionItem",
          "MissionBlock::setLoiterHoldMissionItem"
        ],
        "src/modules/navigator/mission_block.h": [
          "setLandMissionItem",
          "setYawFromHeadingMode"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::chooseBestLandingApproach",
          "RTL::setLandPosAsDestination",
          "RTL::calculate_return_alt_from_cone_half_angle",
          "RTL::setSafepointAsDestination",
          "RTL::hasMissionLandStart",
          "RTL::setRtlTypeAndDestination",
          "RTL::readVtolLandApproaches",
          "RTL::findRtlDestination",
          "RTL::hasVtolLandApproach"
        ],
        "src/modules/navigator/rtl.h": [
          "setLandPosAsDestination",
          "setSafepointAsDestination",
          "findRtlDestination",
          "readVtolLandApproaches",
          "hasVtolLandApproach"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::setRtlPosition",
          "RtlDirect::on_active",
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/rtl_direct.h": [
          "setRtlPosition"
        ]
      }
    }
  },
  {
    "title": "fix navigator: prevent race condition when receiving multiple commands at once",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22651",
    "number": 22651,
    "created_at": "2024-01-18T08:17:06Z",
    "merged": true,
    "merged_at": "2024-01-22T17:45:54Z",
    "state": "closed",
    "conversation": {
      "author": "bkueng",
      "body": "When handling multiple commands, it could happen that the first command updates _reposition_triplet. Normally this would then get handled after getting the mode change from commander through vehicle_status. But if the next command is handled before an update from commander, it could overwrite the triplet.\r\nThis patch ensures that navigator waits for an update from commander (and therefore process the _reposition_triplet) before handling the next command.\r\n\r\nThis happened specifically when pressing 'Pause' from QGC during a mission. QGC sends VEHICLE_CMD_DO_REPOSITION twice, first for pausing, then changing the altitude.\r\nThe result was that the vehicle would not stop at the current location but continue to the next mission waypoint and stop there.\r\n\r\nFixes https://github.com/PX4/PX4-Autopilot/issues/22492\r\n\r\nThanks to @Drone-Lab for the investigation and testing.",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2024-01-22T17:45:32Z",
          "body": "This is fine for an immediate fix, but we really need to be eliminating these patterns in the first place.",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2024-01-25T07:54:15Z",
          "body": "> How so? Commander publishes vehicle_status regularly, so navigator will proceed in any case.\r\n\r\n@bkueng Let's assume the following situation: the ground control station sends two successive CMDs, one instructing the drone to pause and the other to change altitude.\r\n\r\n The commander thread has received both CMDs and updated the vehicle_status twice accordingly. \r\n\r\nIn the navigator_main thread, the braking point is calculated based on the first CMD, and it is published because _vstatus.timestamp > _wait_for_vehicle_status_timestamp.\r\n\r\nHowever, when it comes to executing the second CMD (change altitude), the navigator_main is blocked since the vehicle_status no longer changes. \r\n\r\nThrough my testing, the current patch can address the existing issue. This is because the commander's update of vehicle_status is slightly slower than the execution in navigator_main (which is also the initial reason why the drone couldn't pause). However, if in the future, there are new functionalities in navigator_main that execute more slowly than vehicle_status, it will trigger the aforementioned problem.\r\n\r\n**Do you think we should further introduce mutex or semaphore mechanisms? Currently, the time lock in the patch is not reliable.**\r\n\r\nBecause you published that security advisory, I am unable to reply there. Therefore, I am discussing with you here.\r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2024-01-31T08:39:00Z",
          "body": "> However, when it comes to executing the second CMD (change altitude), the navigator_main is blocked since the vehicle_status no longer changes.\r\n\r\nThis is not the case, as commander publishes the topic regularly: https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/commander/Commander.cpp#L1889\r\nI think this holds up for now, but I also think a better structure is required longer-term to address this more cleanly.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2024-01-22T17:45:39Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a timing/synchronization bug (race condition) where handling multiple commands could overwrite navigator state (_reposition_triplet) before the commander-provided vehicle_status update was processed, leading to incorrect vehicle behavior (not pausing at the correct location). The change enforces waiting for the commander update so state transitions occur in the intended order, which corrects the improper behavior.",
    "patches": {
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -335,6 +335,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tGeofenceBreachAvoidance _gf_breach_avoidance;\n \thrt_abstime _last_geofence_check = 0;\n \n+\thrt_abstime _wait_for_vehicle_status_timestamp{0}; /**< If non-zero, wait for vehicle_status update before processing next cmd */\n+\n \tbool\t\t_geofence_reposition_sent{false};\t\t/**< flag if reposition command has been sent for current geofence breach*/\n \thrt_abstime\t_time_loitering_after_gf_breach{0};\t\t/**< timestamp of when loitering after a geofence breach was started */\n \tbool\t\t_pos_sp_triplet_updated{false};\t\t\t/**< flags if position SP triplet needs to be published */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d7f66b571d89166316ab7cf86bc86048d8bee8a/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "patch": "@@ -239,7 +239,8 @@ void Navigator::run()\n \t\t// Handle Vehicle commands\n \t\tint vehicle_command_updates = 0;\n \n-\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n+\t\twhile (_wait_for_vehicle_status_timestamp == 0 && _vehicle_command_sub.updated()\n+\t\t       && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n \t\t\tvehicle_command_updates++;\n \t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n \n@@ -261,6 +262,9 @@ void Navigator::run()\n \t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n \t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n \n+\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n+\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n+\n \t\t\t\tvehicle_global_position_s position_setpoint{};\n \n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n@@ -420,6 +424,9 @@ void Navigator::run()\n \t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n \n+\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n+\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n+\n \t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n@@ -493,6 +500,9 @@ void Navigator::run()\n \t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n \n+\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n+\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n+\n \t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n@@ -538,6 +548,9 @@ void Navigator::run()\n \t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n \t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n \n+\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n+\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n+\n \t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n@@ -869,6 +882,10 @@ void Navigator::run()\n \n \t\t_navigation_mode = navigation_mode_new;\n \n+\t\tif (_wait_for_vehicle_status_timestamp != 0 && _vstatus.timestamp > _wait_for_vehicle_status_timestamp) {\n+\t\t\t_wait_for_vehicle_status_timestamp = 0;\n+\t\t}\n+\n \t\t/* iterate through navigation modes and set active/inactive for each */\n \t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n \t\t\tif (_navigation_mode_array[i]) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d7f66b571d89166316ab7cf86bc86048d8bee8a/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Avoid waypoint following during backtransition which can lead to strong banking",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22642",
    "number": 22642,
    "created_at": "2024-01-16T09:02:51Z",
    "merged": true,
    "merged_at": "2024-01-29T08:45:40Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nWhen the vehicle overshoots the transition, the controller tries to fly back to the current waypoint and commands a large banking angle. This is not desired during a backtransition as it can cause the transition to be prolonged and also it will go off path which is most likely not desired.\r\n\r\n### Solution\r\nDuring the backtransition let the controller track the line between current waypoint and previous waypoint. If it overshoots it will just follow the line which is the  best it can do. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix XYZ\r\nDocumentation: Fixed banking maneuver during a backtransition when the vehicle overshoots the landing point.\r\n```\r\n\r\n### Alternatives\r\nWe could also instead of checking for an active backtransition, populate the land setpoint type in the triplet and have the controller figure out in that way that it's doing a backtransition.\r\n\r\n### Test coverage\r\nSITL so far\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:24:50Z",
          "body": "@KonradRudin \r\n\r\n> What is the benefit of enter the mode already before the transition is happening? Can't we just let it run on normal auto mode until the transition is really triggered?\r\n\r\nThe benefit is that you can have specific logic apply when it's clear that we are heading towards a transition waypoint. Once example would be that you don't want to start loitering even if there is a larger altitude error. This has been an issue in the past.",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T11:34:49Z",
          "body": "I synced with @KonradRudin on a call and we agreed to the following:\r\n1) The position controller will only switch to the transition mode (APPROACH_TRANSITION currently) when we are actually in transition mode. That way we are sure to execute the correct logic and we are not depending on an external module to issue the transition command.\r\n2) When the vehicle is heading towards the transition point, it needs to be aware that there's potentially a transition coming and thus e.g. should not loiter as a result of an altitude error. We do this by setting the next position setpoint in the triplet to type LAND.\r\nThat way the position controller is made aware of the intention to land and can act accordingly.\r\n3) Having a VTOL transition item as part of a normal waypoint mission (not a VTOL LAND waypoint) will not be handled in any special way, e..g the position controller will continue doing normal waypoint following. \r\n",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-19T14:04:31Z",
          "body": "@KonradRudin @sfuhrer @tstastny I've done the changes discussed with Konrad, summarized in my post above.\r\nThe position controller will now only run the special control_transition method when the vehicle is actually doing a backtransition.\r\nI still need to check how to add some logic which prevents a vehicle starting to loiter when it's approaching the backtransition due to alt error. What we discussed with Konrad is to check if the next waypoint is of type LAND. If yes, and we are a vtol, then we should not loiter, since we expect a backtransition to happen.",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-25T11:49:19Z",
          "body": "@KonradRudin @tstastny @sfuhrer Could you guys please update your reviews?",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2025-06-13T12:15:01Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/vtol-backtransition-overshoot-unexpected-behavior-why-random-new-target/45798/3\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "tstastny",
          "created_at": "2024-01-16T12:34:27Z",
          "body": "This can work in the short term to mitigate this bug -- but more generally we need to reevaluate why VTOL transitioning is handled in a control_auto_position method in the first place. It's a different modality than just waypoint control, right?\r\n\r\nWe don't need to fix it immediately.. but this again brings me back to 1. breaking apart all the different specific mode logic in FW pos ctrl (not reusing things with if statements) and 2. reallllly wanting to split up vtol module from fixed-wing pure module.. and now that we especially are starting to have explicit methods like navigate line, navigate waypoint(s) -- we can just include those libraries in either module and use them with the specific logic the specific airframe requires.\r\n\r\nAnyway.. just ranting.. again.. let's see if we can find time to do the work!",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:04:37Z",
          "body": "is it possible that a vtol land is triggered without a valid previous waypoint? what will happen then in the FW pos ctrl?",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-16T13:14:44Z",
          "body": "@tstastny What we can do shorterm is maybe to move this code into a `control_backtransition` method? In a follow up PR to this I am actually trying to make navigator set the setpoint type to \"LAND\" which should give the position controller and idea that we are currently doing a vtol landing.\r\nThen we don't need to mix the logic with the standard waypoint following logic. What do you think?",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:27:59Z",
          "body": "> control_backtransition\r\n\r\nCould be one way - at least to start splitting out the functionalities.. and then once we can do a larger module split.. the methods are already delineated and ready to migrate\r\n\r\n> In a follow up PR to this I am actually trying to make navigator set the setpoint type to \"LAND\" which should give the position controller and idea that we are currently doing a vtol landing.\r\n\r\nI don't fully get what you mean -- but maybe this we could chat offline\r\n\r\n> Then we don't need to mix the logic with the standard waypoint following logic. What do you think?\r\n\r\nWould be the idea",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-16T13:37:52Z",
          "body": "Currently, the position controller has no clue that he's steering towards a transition waypoint. This is because navigator just publishes a standard position waypoint. If navigator does not do that but just keeps the original intent (which is to land), then the position controller can call the appropriate control functions.\r\n\r\nAnd yes, I agree that the logic should then at some point be pulled into a mode. But as you said, it's clearly easier to do that refactor if the code is already split up nicely in the controller now.",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:42:27Z",
          "body": "> Currently, the position controller has no clue that he's steering towards a transition waypoint. This is because navigator just publishes a standard position waypoint. If navigator does not do that but just keeps the original intent (which is to land), then the position controller can call the appropriate control functions.\r\n\r\nOok i understand you now. Yes that would be a nice start!",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:42:39Z",
          "body": "@RomanBapst what about this question?",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T07:31:02Z",
          "body": "@tstastny Please have a look again. There is now a dedicated method for controlling backtransitions. If the previous waypoint is not valid it will default to waypoint following.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-01-18T08:09:32Z",
          "body": "This could be a bool no?",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-01-18T08:27:12Z",
          "body": "Why was this change required? Didn't we on purpose have it accept the transition WP already when the transition was started before?\r\nAnd I find the comment \"transition to RW requested etc\" useful, would you mind putting it back? Otherwise one has to look up what \"3\" stands for.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-01-18T08:31:05Z",
          "body": "This is required such that the type goes to CMD_LAND? Do you see any other side effects from the change? E.g. the heading setpoint could now be different to what it was set previously in setMoveToPositionMissionItem() no?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-01-18T08:32:53Z",
          "body": "Why is this now required?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-18T09:30:44Z",
          "body": "Why did you change that? I think it is because you want to enter the FW_POSCTRL_MODE_APPROACH_TRANSITON already before the transition happens, but is this really necessary? Now you are dependent, that somewhere exxternally the transition command will be executed, else you will land in FW in your mode, and for this i would still prefer the specific FW landing modes.",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-18T10:00:38Z",
          "body": "With this, it can happen again, that we make a hard turn after we past the waypoit, no? Shouldn't we make it like that: if the current setpoint is a loiter, then navigateLoiter, if it is velocity, then navigatePathTangent, if it is position and has previous navigate line previous to current, and else navigateLine vehicle position to current setpoint position?\nI am not sure if this is complete, but i think you want to avoid that mif transitioning it willreverse the direction by passing by.",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-18T10:04:16Z",
          "body": "With this, you can enter your mode only if you explicitly want to land and make the back transition. That is the most use case i think, but why not try to make it also when back transitioning mid air?",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:34:55Z",
          "body": "@KonradRudin I don't understand your point. \r\n\r\n> Now you are dependent, that somewhere exxternally the transition command will be executed\r\n\r\nWe have always been dependent on someone externally triggering the transition. It's navigator who publishes the transition command the the vtol controller executes. Not that I am a fan of that, but that's how it currently is.\r\n\r\n> Why did you change that? I think it is because you want to enter the FW_POSCTRL_MODE_APPROACH_TRANSITON already before the transition happens, but is this really necessary? \r\n\r\nExactly, I want the controller to be aware of that, because then it can specifically execute. E.g. it will not try to loiter even if there is a large altitude error. Only handling the transition is not enough, because you might have already started loitering. And honestly, I don't want to extend the logic in navigator.",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:36:55Z",
          "body": "@KonradRudin Yes, in theory it can. I have verified that it should under normal circumstances not happen when you plan a mission landing or when you use the home land approaches. I am currently actually testing what happens when you use a plan transition command.\r\nI am not opposed to add logic (similar to what we have done on the older releases) which handles that case.",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:39:55Z",
          "body": "@sfuhrer Yes, that was the logic before, but I don't it makes sense. Why do you accept a transition when the transition is not done. That's exactly what causes the position controllers and the navigator to be out of sync. Navigator will happily move to the next waypoint while the controller is still dealing with a vehicle in full fw condition.\r\nI am not saying you can't make it work, but I'd rather have everything in sync as good as possible.\r\n\r\nCommands are a bit weird in that case.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-19T12:34:25Z",
          "body": "@sfuhrer Because we don't want line following when moving to the land waypoint during hover.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-19T14:00:27Z",
          "body": "@tstastny Should not be an issue anymore, if now the previous waypoint  is invalid, the controller will use the position at the start of the transition and the land point for line following.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-22T08:53:01Z",
          "body": "Shouldn't you also set the pitch and throttle?",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 140,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-22T13:54:34Z",
          "body": "Are you sure this works? Now in FW the waypoint gets accepted when only horizontally at the landing point. This might be good for VTOL but for FW? It might accept it now before it actually is on the ground, no? Maybe only do this for VTOL land and not for land?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-22T14:13:05Z",
          "body": "@KonradRudin I removed it while doing my investigation for the bug. Did not fix the bug but still will be gone.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-23T13:57:48Z",
          "body": "@KonradRudin \r\n> Did i miss something, I thought we need now set the next position setpoint triplet to land, in order to detect, that w can ignore the altitude. IS that in and i missed it?\r\n\r\nThis is where the check is done",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 73,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-26T12:56:51Z",
          "body": "I don't think this is needed, no? Now it won't loiter at the endpoint but bank even harder and make the flower pattern when it reached the end waypoint horizontally but not in altitude...\nBut this should never happen as the waypoint should be accepted when it reached it horizontally. Also from the landing scenarios you are coming mostly from a SETPOINT_TYPE_LOITER",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 74,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-26T13:01:07Z",
          "body": "Cosmetic: Could rename it to MODE_BACK_TRANSITION",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-26T13:33:34Z",
          "body": "That is not what i meant, sorry, i saw that we correctly set the next position setpoint to land. but within the https://github.com/PX4/PX4-Autopilot/blob/5aa2518f8cb0277c6036efbf19f7719d529bc143/src/modules/navigator/mission_block.cpp#L65 function, it still only accept it when both within the horizontal and altitude acceptance. You might need to tweak this function here https://github.com/PX4/PX4-Autopilot/blob/5aa2518f8cb0277c6036efbf19f7719d529bc143/src/modules/navigator/navigator_main.cpp#L1108-L1109\r\nTo set altitude acceptance to infinite when  we know that the backtransition is happening.\r\nThinking more about it and seeing, that in fixed wing case, we actually want to make the opposite, maybe we really need to add vtol_back_transition flag from the mission_item also in the setpoint triplet, so we know, that we can ignore altitude.",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 73,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-29T06:24:02Z",
          "body": "@KonradRudin Maybe I'm missing something but we do set the altitude acceptance radius to infinity if the mission item has the flag `vtol_back_transition` set to true.\r\nhttps://github.com/PX4/PX4-Autopilot/blob/main/src/modules/navigator/mission_block.cpp#L357C5-L357C18",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 73,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-29T06:36:06Z",
          "body": "@KonradRudin The reason I added that is because we have two separate modules (navigator & position controller) which could use different horizontal acceptance radius and therefore not be \"in sync\" anymore. I agree that in theory now this should not be needed as I assume navigator and the position controller use the same value.\r\nIt's a protection in the sense that if we know we are expecting a backtransition, I don't ever want it to loiter.\r\nThe only bad case I see is if for some reason the logic in navigator for switching to the next waypoint would not trigger, but that would mean that the vehicle is blown away so much that the distance to the land waypoint does not reach the minimum required.\r\nThat could in theory happen when you have extremely strong wind and thus a very low groundspeed. That would make the transition distance very small and in theory it would be possible to \"miss\" the transition point.\r\nWe could add a minimum transition distance to make sure that risk is lower.\r\nWhat do you think?",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 74,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-29T06:57:31Z",
          "body": "@KonradRudin I made a quick test and increased the altitude of the mission item when the vehicle is approaching the transition by a value of 1000m. To me everything looks nominal, navigator accepts the mission item despite the huge altitude error. Is this what you meant?\r\n\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/7610489/a5f7a703-615b-468c-ab94-25019fe4db7c)\r\n",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 73,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:06:08Z",
          "body": "one minor concern on if VTOL land is triggered without valid previous waypoint -- pls take a look at that comment",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-16T13:14:44Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:27:59Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-16T13:37:52Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:42:27Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "tstastny",
          "created_at": "2024-01-16T13:42:39Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T07:31:02Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-01-18T08:33:47Z",
          "body": "I have some questions in the navigator part, as as we know small changes can cause a lot of ripple effects there. Fully on board with the changes otherwise, splitting it up as you do is the right way forward.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-18T10:06:25Z",
          "body": "What is the benefit of enter the mode already before the transition is happening? Can't we just let it run on normal auto mode until the transition is really triggered?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:34:55Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:36:55Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-18T10:39:55Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-19T12:34:25Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-19T14:00:27Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-22T14:00:00Z",
          "body": "Did i miss something, I thought we need now set the next position setpoint triplet to land, in order to detect, that w can ignore the altitude. IS that in and i missed it?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-22T14:13:05Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-23T13:57:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-26T13:33:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-29T06:24:02Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-29T06:36:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-01-29T06:57:31Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-29T07:38:58Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-29T07:56:15Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-01-29T08:21:14Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect controller behavior (improper state/trajectory handling) during VTOL backtransition that caused excessive banking and off-path motion when the vehicle overshot the transition point. The change alters control logic and state detection (track the line between current and previous waypoint during backtransition and only run transition-specific control when actually in backtransition, plus marking next setpoint as LAND) which addresses an improper state/flow and resulting undesired outputs. Review comments note an edge case (missing previous waypoint) but do not change that this is a logic bug fix.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -574,10 +574,6 @@ void MissionBase::handleLanding(WorkItemType &new_work_item_type, mission_item_s\n \t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n \n \t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n-\n-\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following\n-\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n-\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n \t\t}\n \n \t} else if (needs_to_land) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1ab03a93840c94f7070130021ca98c458976c988/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -110,7 +110,8 @@ MissionBlock::is_mission_item_reached_or_completed()\n \n \t\tif (int(_mission_item.params[0]) == 3) {\n \t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n-\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n+\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n+\t\t\t       && !_navigator->get_vstatus()->in_transition_mode;\n \n \t\t} else if (int(_mission_item.params[0]) == 4) {\n \t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1ab03a93840c94f7070130021ca98c458976c988/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -310,6 +310,7 @@ void RtlDirect::set_rtl_item()\n \t\t\tdest.alt = loiter_altitude;\n \n \t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n+\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n \n \t\t\t_rtl_state = RTLState::LAND;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1ab03a93840c94f7070130021ca98c458976c988/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed",
        "RtlDirect::set_rtl_item",
        "MissionBase::handleLanding"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::handleLanding"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "MissionFeasibilityChecker: remove below home check",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22624",
    "number": 22624,
    "created_at": "2024-01-11T10:34:03Z",
    "merged": true,
    "merged_at": "2024-01-12T08:53:15Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "This check gave a warning when one or more mission items were below the Home altitude. As it is a valid use case to plan missions below Home, those warnings were too often seen as a inconvenience and are thus removed here.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: MissionFeasibilityChecker: remove below home check\r\n```\r\n\r\nfyi @cmic0 ",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-01-11T10:40:27Z",
          "body": "I didn't even know this exists. I'm not a big fan since if there is an actual use case it's probably annoying.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR removes a validation that produced false-positive warnings when mission items were below the Home altitude. Treating valid mission plans as erroneous is an incorrect behavioral check (improper conditional/validation), so removing it fixes that logic error.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "patch": "@@ -58,7 +58,6 @@ void FeasibilityChecker::reset()\n \t_land_pattern_validity_failed = false;\n \t_distance_first_waypoint_failed = false;\n \t_distance_between_waypoints_failed = false;\n-\t_below_home_alt_failed = false;\n \t_fixed_wing_land_approach_failed = false;\n \t_takeoff_land_available_failed = false;\n \n@@ -199,10 +198,6 @@ void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int\n \t\t_distance_first_waypoint_failed = !checkHorizontalDistanceToFirstWaypoint(mission_item);\n \t}\n \n-\tif (!_below_home_alt_failed) {\n-\t\t_below_home_alt_failed = !checkIfBelowHomeAltitude(mission_item, current_index);\n-\t}\n-\n \tif (!_takeoff_failed) {\n \t\t_takeoff_failed = !checkTakeoff(mission_item);\n \t}\n@@ -682,21 +677,6 @@ bool FeasibilityChecker::checkDistancesBetweenWaypoints(const mission_item_s &mi\n \treturn true;\n }\n \n-bool FeasibilityChecker::checkIfBelowHomeAltitude(const mission_item_s &mission_item, const int current_index)\n-{\n-\t/* calculate the global waypoint altitude */\n-\tfloat wp_alt = (mission_item.altitude_is_relative) ? mission_item.altitude + _home_alt_msl : mission_item.altitude;\n-\n-\tif (PX4_ISFINITE(_home_alt_msl) && _home_alt_msl > wp_alt && MissionBlock::item_contains_position(mission_item)) {\n-\n-\t\tmavlink_log_critical(_mavlink_log_pub, \"Warning: Waypoint %d below home\\t\", current_index + 1);\n-\t\tevents::send<int16_t>(events::ID(\"navigator_mis_wp_below_home\"), {events::Log::Warning, events::LogInternal::Info},\n-\t\t\t\t      \"Waypoint {1} below home\", current_index + 1);\n-\t}\n-\n-\treturn true;\n-}\n-\n bool FeasibilityChecker::checkItemsFitToVehicleType(const mission_item_s &mission_item)\n {\n \tif (_vehicle_type != VehicleType::Vtol &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d52c13d8f319bbc5784939c09fd96568cddc9a3d/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "patch": "@@ -81,7 +81,6 @@ class FeasibilityChecker : public ModuleParams\n \t\t       _distance_between_waypoints_failed ||\n \t\t       _land_pattern_validity_failed ||\n \t\t       _fixed_wing_land_approach_failed ||\n-\t\t       _below_home_alt_failed ||\n \t\t       _mission_validity_failed ||\n \t\t       _takeoff_land_available_failed;\n \t}\n@@ -117,7 +116,6 @@ class FeasibilityChecker : public ModuleParams\n \tbool _land_pattern_validity_failed{false};\n \tbool _distance_first_waypoint_failed{false};\n \tbool _distance_between_waypoints_failed{false};\n-\tbool _below_home_alt_failed{false};\n \tbool _fixed_wing_land_approach_failed{false};\n \tbool _takeoff_land_available_failed{false};\n \tbool _items_fit_to_vehicle_type_failed{false};\n@@ -198,15 +196,6 @@ class FeasibilityChecker : public ModuleParams\n \t*/\n \tbool checkDistancesBetweenWaypoints(const mission_item_s &mission_item);\n \n-\t/**\n-\t * @brief Check if any waypoint is below the home altitude. Issues warning only.\n-\t *\n-\t * @param mission_item The current mission item\n-\t * @param current_index The current mission index\n-\t * @return Always returns true, only issues warning.\n-\t*/\n-\tbool checkIfBelowHomeAltitude(const mission_item_s &mission_item, const int current_index);\n-\n \t/**\n \t * @brief Check fixed wing land approach (fixed wing only)\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d52c13d8f319bbc5784939c09fd96568cddc9a3d/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.hpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::item_contains_position",
        "FeasibilityChecker::checkIfBelowHomeAltitude",
        "FeasibilityChecker::reset",
        "FeasibilityChecker::doCommonChecks",
        "checkIfBelowHomeAltitude",
        "FeasibilityChecker::checkDistancesBetweenWaypoints"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "MissionBlock::item_contains_position",
          "FeasibilityChecker::checkIfBelowHomeAltitude",
          "FeasibilityChecker::doCommonChecks",
          "FeasibilityChecker::reset",
          "FeasibilityChecker::checkDistancesBetweenWaypoints"
        ],
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": [
          "checkIfBelowHomeAltitude"
        ]
      }
    }
  },
  {
    "title": "mission: skip a vtol takoff mission item if already in air",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23319",
    "number": 23319,
    "created_at": "2024-06-24T14:32:08Z",
    "merged": true,
    "merged_at": "2024-06-25T14:33:45Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen a mission is planned including a vtol takeoff item while the VTOL is already in Air and converted to a fixed wing, the VTOL immediately accepts the takeoff item, but is using an altitude ramp to the next waypoint item. This is due to the fact that although the vtol takeoff item is accepted immediately, it is still set as the position setpoint previous item including the transition altitude specified. This results in the VTOL losing altitude up to the transition item when the current altitude is higher. It should completely ignore the vtol takeoff item when already airborne.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- For all mission modes, ignore the VTOL Takeoff item if the vehicle is already in Air and already transitioned to fixed wing.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix Ignore VTOL takeoff when already in air and transitioned to fixed wing\r\n```\r\n\r\n### Test coverage\r\n- SITL testing using the standard vtol. \r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-06-24T14:51:52Z",
          "body": "Thanks for taking care of that. Do we then still need the stuff implemented previously in https://github.com/PX4/PX4-Autopilot/pull/19985/files?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-06-24T16:06:44Z",
          "body": "`'RTL with Reverse Mission': failed`\r\n@KonradRudin it maybe breaks something in the mission reversing logic, see CI.\r\nI've btw added a small extension to skip Takeoff items also for pure fixed-wing vehicles.",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-06-24T16:26:36Z",
          "body": "> Thanks for taking care of that. Do we then still need the stuff implemented previously in https://github.com/PX4/PX4-Autopilot/pull/19985/files?\r\n\r\nI still think the changes from this PR are good. This means that when the VTOL takeoff is performed on the ground, as soon as the vehicle transitioned, then the Takeoff is accepted and it flies to the line between the takeoff and the next waypoint instead of explicitly flying to the takeoff position until it is accepted. So you don't need to fly backwards if the vehicle flew past it while transitioning etc. But this is open for discussion.",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-06-24T16:27:29Z",
          "body": "> `'RTL with Reverse Mission': failed` @KonradRudin it maybe breaks something in the mission reversing logic, see CI. I've btw added a small extension to skip Takeoff items also for pure fixed-wing vehicles.\r\n\r\nDammit, forgot about that one, yes this one might actually break. need to check up on this. Thanks for mentioning it.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-06-25T12:18:37Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: the mission executor previously accepted a VTOL takeoff item while the vehicle was already airborne, kept it as the previous setpoint (including transition altitude), and caused unintended altitude changes. The change explicitly ignores VTOL takeoff items when already in air/converted to fixed-wing, correcting incorrect state/mission-item handling (though reviewers note it may affect mission-reverse logic).",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "patch": "@@ -216,6 +216,23 @@ void Mission::setActiveMissionItems()\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \tconst position_setpoint_s current_setpoint_copy = pos_sp_triplet->current;\n \n+\t/* Skip VTOL/FW Takeoff item if in air, fixed-wing and didn't start the takeoff already*/\n+\tif ((_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_TAKEOFF) &&\n+\t    (_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) &&\n+\t    (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) &&\n+\t    !_land_detected_sub.get().landed) {\n+\t\tif (setNextMissionItem()) {\n+\t\t\tif (!loadCurrentMissionItem()) {\n+\t\t\t\tsetEndOfMissionItems();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tsetEndOfMissionItems();\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n \tif (item_contains_position(_mission_item)) {\n \n \t\thandleTakeoff(new_work_item_type, next_mission_items, num_found_items);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bb89615af3428775216e149912f12ff35044eae0/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "patch": "@@ -92,6 +92,23 @@ void RtlMissionFast::setActiveMissionItems()\n \tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n+\t/* Skip VTOL/FW Takeoff item if in air, fixed-wing and didn't start the takeoff already*/\n+\tif ((_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_TAKEOFF) &&\n+\t    (_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) &&\n+\t    (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) &&\n+\t    !_land_detected_sub.get().landed) {\n+\t\tif (setNextMissionItem()) {\n+\t\t\tif (!loadCurrentMissionItem()) {\n+\t\t\t\tsetEndOfMissionItems();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tsetEndOfMissionItems();\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n \t// Transition to fixed wing if necessary.\n \tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n \t    _vehicle_status_sub.get().is_vtol &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bb89615af3428775216e149912f12ff35044eae0/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::setActiveMissionItems",
        "RtlMissionFast::setActiveMissionItems"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast.cpp": [
          "RtlMissionFast::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "vehicle_command_ack: rename `result_param1` to `progress` and comment usage",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23295",
    "number": 23295,
    "created_at": "2024-06-18T14:55:11Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "MaEtUgR",
      "body": "### Solved Problem\r\nWhen talking with @teopiaz about the progress of autotuning I found that our definition of the [COMMAND_ACK](https://mavlink.io/en/messages/common.html#COMMAND_ACK)`.progress` is `vehicle_command_ack.result_param1` which is confusing.\r\n\r\nI don't know exactly where this is coming from e.g. https://github.com/mavlink/mavlink/commit/e8108ae9b406feefca86f9136d3c21068f94cac0#diff-9ef151b30f09d6d4f130434d941db479c3411ec15eca23580c5587b2c3b59ecdR3212\r\n\r\n### Solution\r\nTo avoid confusion:\r\n- naming consistent with MAVLink definition\r\n- comments about the few different ways the field is used\r\n\r\n### Test coverage\r\nIt's just naming refactor and comments",
      "issue_comments": [
        {
          "author": "junwoo091400",
          "created_at": "2024-06-18T15:04:01Z",
          "body": "Seems like it was added in\r\nhttps://github.com/PX4/PX4-Autopilot/pull/7821/files#diff-265ed8513e8ed30145a43cf197745d15ef81304caf8d390786d6e4f8be7d8a7cR13\r\nand was never renamed to progress.\r\n\r\nThe change seems good!\r\n\r\nMatthias Grob ***@***.***> schrieb am Di., 18. Juni 2024,\r\n16:55:\r\n\r\n> @MaEtUgR <https://github.com/MaEtUgR> requested your review on: #23295\r\n> <https://github.com/PX4/PX4-Autopilot/pull/23295> vehicle_command_ack:\r\n> rename result_param1 to progress and comment usage.\r\n>\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/PX4/PX4-Autopilot/pull/23295#event-13202549980>, or\r\n> unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AFRS5GYABXSPDGCDZRQA3U3ZIBC6JAVCNFSM6AAAAABJQG54ESVHI2DSMVQWIX3LMV45UABCJFZXG5LFIV3GK3TUJZXXI2LGNFRWC5DJN5XDWMJTGIYDENJUHE4TQMA>\r\n> .\r\n> You are receiving this because your review was requested.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "junwoo091400",
          "created_at": "2024-06-18T15:05:53Z",
          "body": "Perhaps change comment so that it is used as progress, and that it can also be used for other purposes?",
          "path": "msg/VehicleCommandAck.msg",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2024-06-18T15:11:58Z",
          "body": "You could add a constant for unknown progress. Keeping this consistent/compatible with mavlink is fine, but in general try to start thinking of vehicle_command/vehicle_command_ack as completely independent of mavlink (we'll get there someday).\r\n\r\n```suggestion\r\n\t\tvcmd_ack.progress = UINT8_MAX; // unknown progress according to MAVLink definition\r\n```",
          "path": "src/modules/payload_deliverer/payload_deliverer.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "junwoo091400",
          "created_at": "2024-06-18T15:05:53Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "junwoo091400",
          "created_at": "2024-06-18T15:06:00Z",
          "body": "Nice!",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "2024-06-18T15:11:59Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR only renames a field (result_param1 -> progress) to match the MAVLink COMMAND_ACK naming and adds explanatory comments. The author states it's a naming refactor with no behavioral changes; there is no indication it addresses incorrect program logic, state transitions, or unintended output.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -1418,7 +1418,7 @@ void Navigator::publish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_\n \tcommand_ack.from_external = false;\n \n \tcommand_ack.result = result;\n-\tcommand_ack.result_param1 = 0;\n+\tcommand_ack.progress = 0;\n \tcommand_ack.result_param2 = 0;\n \n \t_vehicle_cmd_ack_pub.publish(command_ack);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e2c80c7970fcc0a3040c5c6bf2079699622ac659/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::publish_vehicle_command_ack"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_vehicle_command_ack"
        ]
      }
    }
  },
  {
    "title": "Increase default of MIS_DIST_1WP to 10km",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23193",
    "number": 23193,
    "created_at": "2024-05-28T15:14:15Z",
    "merged": true,
    "merged_at": "2024-05-30T01:00:35Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nA too low value on this check is very annoying and not really necessary. It's main purpose is to prevent a mission plan that was not planned at the current flight location to be executed.\r\n\r\n### Solution\r\nIncrease default to 10km. \r\n\r\nI've also removed a custom setting of MIS_DIST_1WP from some aiframes that I think is not needed anymore. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nImprovement: Increase default of MIS_DIST_1WP to 10km\r\n```\r\n\r\n### Alternatives\r\nWe could also remove the check around MIS_DIST_1WP completely?\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2024-05-30T01:00:16Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR changes a default configuration value (increasing MIS_DIST_1WP to 10 km) and removes custom per-airframe overrides. That is parameter tuning/config cleanup to reduce annoying but intended behavior, not a correction of incorrect conditional logic or algorithmic flow, so it is not a code-level logic error fix.",
    "patches": {
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -87,7 +87,7 @@ PARAM_DEFINE_INT32(MIS_TKO_LAND_REQ, 0);\n  * @increment 100\n  * @group Mission\n  */\n-PARAM_DEFINE_FLOAT(MIS_DIST_1WP, 900);\n+PARAM_DEFINE_FLOAT(MIS_DIST_1WP, 10000);\n \n /**\n * Enable yaw control of the mount. (Only affects multicopters and ROI mission items)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2b75823d662e22d149525eb98bbaa615115322d9/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Navigator: do not leave mission path with RTL_TYPE=2 when RTL triggered in Mission",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23181",
    "number": 23181,
    "created_at": "2024-05-24T11:50:56Z",
    "merged": true,
    "merged_at": "2024-05-27T10:03:16Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nOn a system with RTL_TYPE=2, the current behavior is that it will always start the RTL from the closes WP, and not from the current active one. If by chance e.g. WP 5 is closer than the current WP 2, it will go to 5. If there's an obstacle between 2 and 5 there is no way to ensure it won't hit it.\r\n\r\n### Solution\r\nOnly start from closest WP if not in Mission when RTL is started. Otherwise, if in Mission, the proceed mission from currently active one (case where it follows mission to the Land), or start from the previous item (if mission doesn't include a landing and it thus does it in reverse).  \r\n\r\n### Changelog Entry\r\nFor release notes: \r\n```\r\nFeature: do not leave mission path with RTL_TYPE=2 when RTL triggered in Mission\r\n```\r\n\r\n### Test coverage\r\nBasic SITL testing. \r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:52:15Z",
          "body": "Cleaned up commits and force pushed.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-05-27T06:52:00Z",
          "body": "```suggestion\r\nuint8 RTL_STATUS_TYPE_FOLLOW_MISSION=3 \t\t# Following the mission from start index to mission landing. Start index is current WP if in mission mode, and closest WP otherwise.\r\nuint8 RTL_STATUS_TYPE_FOLLOW_MISSION_REVERSE=4 \t# Following the mission in reverse from start index to the beginning of the mission. Start index is previous WP if in mission mode, and closest WP otherwise.\r\n```",
          "path": "msg/RtlStatus.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-05-27T06:57:24Z",
          "body": "```suggestion\r\n\t\t_is_current_planned_mission_item_valid = isMissionValid();\r\n```",
          "path": "src/modules/navigator/rtl_mission_fast.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-05-27T06:58:07Z",
          "body": "```suggestion\r\n\t\t_is_current_planned_mission_item_valid = isMissionValid();\r\n```",
          "path": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:33:24Z",
          "body": "done - plus only check isMissionValid() after setMissionIndex().",
          "path": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:33:51Z",
          "body": "done - plus only check isMissionValid() after setMissionIndex().",
          "path": "src/modules/navigator/rtl_mission_fast.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:34:41Z",
          "body": "I kept the Mission written as that as I write all flight modes with capitalization, but addressed the other things here.",
          "path": "msg/RtlStatus.msg",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-05-27T06:58:36Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:33:24Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:33:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-05-27T07:34:41Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-05-27T07:46:33Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect decision logic: with RTL_TYPE=2 the system chose the nearest waypoint rather than respecting the current mission state, causing unintended path deviations and potential collisions. The change corrects the state-dependent waypoint selection (use current/previous mission item when in a mission, nearest only when not), which is a logic/state-transition fix.",
    "patches": {
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "patch": "@@ -314,6 +314,13 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tbool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;\n \n+\t/**\n+\t * @brief Set the Mission Index\n+\t *\n+\t * @param[in] index Index of the mission item\n+\t */\n+\tvoid setMissionIndex(int32_t index);\n+\n \tbool _is_current_planned_mission_item_valid{false};\t/**< Flag indicating if the currently loaded mission item is valid*/\n \tbool _mission_has_been_activated{false};\t\t/**< Flag indicating if the mission has been activated*/\n \tbool _mission_checked{false};\t\t\t\t/**< Flag indicating if the mission has been checked by the mission validator*/\n@@ -421,13 +428,6 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tbool cameraWasTriggering();\n \n-\t/**\n-\t * @brief Set the Mission Index\n-\t *\n-\t * @param[in] index Index of the mission item\n-\t */\n-\tvoid setMissionIndex(int32_t index);\n-\n \t/**\n \t * @brief Parameters update\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9c803b824971a715b1ba94d0f5ff6e407036d05f/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "patch": "@@ -52,12 +52,27 @@ RtlMissionFast::RtlMissionFast(Navigator *navigator) :\n \n }\n \n+void RtlMissionFast::on_inactive()\n+{\n+\tMissionBase::on_inactive();\n+\t_vehicle_status_sub.update();\n+\t_mission_index_prior_rtl = _vehicle_status_sub.get().nav_state == vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION ?\n+\t\t\t\t   _mission.current_seq : -1;\n+}\n+\n void RtlMissionFast::on_activation()\n {\n \t_home_pos_sub.update();\n \n-\t_is_current_planned_mission_item_valid = setMissionToClosestItem(_global_pos_sub.get().lat, _global_pos_sub.get().lon,\n-\t\t\t_global_pos_sub.get().alt, _home_pos_sub.get().alt, _vehicle_status_sub.get()) == PX4_OK;\n+\t// set mission item to closest item if not already in mission\n+\tif (_mission_index_prior_rtl < 0) {\n+\t\t_is_current_planned_mission_item_valid = setMissionToClosestItem(_global_pos_sub.get().lat, _global_pos_sub.get().lon,\n+\t\t\t\t_global_pos_sub.get().alt, _home_pos_sub.get().alt, _vehicle_status_sub.get()) == PX4_OK;\n+\n+\t} else {\n+\t\tsetMissionIndex(_mission_index_prior_rtl);\n+\t\t_is_current_planned_mission_item_valid = isMissionValid();\n+\t}\n \n \tif (_land_detected_sub.get().landed) {\n \t\t// already landed, no need to do anything, invalidad the position mission item.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9c803b824971a715b1ba94d0f5ff6e407036d05f/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.h": {
        "filename": "src/modules/navigator/rtl_mission_fast.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -56,12 +56,15 @@ class RtlMissionFast : public RtlBase\n \t~RtlMissionFast() = default;\n \n \tvoid on_activation() override;\n+\tvoid on_inactive() override;\n \n \trtl_time_estimate_s calc_rtl_time_estimate() override;\n \n private:\n \tbool setNextMissionItem() override;\n \tvoid setActiveMissionItems() override;\n \n+\tint _mission_index_prior_rtl{-1};\n+\n \tuORB::SubscriptionData<home_position_s> _home_pos_sub{ORB_ID(home_position)};\t\t/**< home position subscription */\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9c803b824971a715b1ba94d0f5ff6e407036d05f/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.h"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "patch": "@@ -52,12 +52,27 @@ RtlMissionFastReverse::RtlMissionFastReverse(Navigator *navigator) :\n \n }\n \n+void RtlMissionFastReverse::on_inactive()\n+{\n+\tMissionBase::on_inactive();\n+\t_vehicle_status_sub.update();\n+\t_mission_index_prior_rtl = _vehicle_status_sub.get().nav_state == vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION ?\n+\t\t\t\t   _mission.current_seq : -1;\n+}\n+\n void RtlMissionFastReverse::on_activation()\n {\n \t_home_pos_sub.update();\n \n-\t_is_current_planned_mission_item_valid = setMissionToClosestItem(_global_pos_sub.get().lat, _global_pos_sub.get().lon,\n-\t\t\t_global_pos_sub.get().alt, _home_pos_sub.get().alt, _vehicle_status_sub.get()) == PX4_OK;\n+\t// set mission item to closest item if not already in mission. If we are in mission, set to the previous item.\n+\tif (_mission_index_prior_rtl < 0) {\n+\t\t_is_current_planned_mission_item_valid = setMissionToClosestItem(_global_pos_sub.get().lat, _global_pos_sub.get().lon,\n+\t\t\t\t_global_pos_sub.get().alt, _home_pos_sub.get().alt, _vehicle_status_sub.get()) == PX4_OK;\n+\n+\t} else {\n+\t\tsetMissionIndex(math::max(_mission_index_prior_rtl - 1, 0));\n+\t\t_is_current_planned_mission_item_valid = isMissionValid();\n+\t}\n \n \tif (_land_detected_sub.get().landed) {\n \t\t// already landed, no need to do anything, invalidate the position mission item.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9c803b824971a715b1ba94d0f5ff6e407036d05f/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.h": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -57,6 +57,7 @@ class RtlMissionFastReverse : public RtlBase\n \n \tvoid on_activation() override;\n \tvoid on_active() override;\n+\tvoid on_inactive() override;\n \n \trtl_time_estimate_s calc_rtl_time_estimate() override;\n \n@@ -65,5 +66,7 @@ class RtlMissionFastReverse : public RtlBase\n \tvoid setActiveMissionItems() override;\n \tvoid handleLanding(WorkItemType &new_work_item_type);\n \n+\tint _mission_index_prior_rtl{-1};\n+\n \tuORB::SubscriptionData<home_position_s> _home_pos_sub{ORB_ID(home_position)};\t\t/**< home position subscription */\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9c803b824971a715b1ba94d0f5ff6e407036d05f/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.h"
      }
    },
    "modified_functions": {
      "all": [
        "setMissionIndex",
        "RtlMissionFastReverse::RtlMissionFastReverse",
        "RtlMissionFast::RtlMissionFast"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.h": [
          "setMissionIndex"
        ],
        "src/modules/navigator/rtl_mission_fast.cpp": [
          "RtlMissionFast::RtlMissionFast"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::RtlMissionFastReverse"
        ]
      }
    }
  },
  {
    "title": "Use target camera in image capture start/stop messages",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23115",
    "number": 23115,
    "created_at": "2024-05-09T07:10:10Z",
    "merged": true,
    "merged_at": "2024-10-09T08:10:08Z",
    "state": "closed",
    "conversation": {
      "author": "hamishwillee",
      "body": "[MAV_CMD_IMAGE_START_CAPTURE](https://mavlink.io/en/messages/common.html#MAV_CMD_IMAGE_START_CAPTURE) and [MAV_CMD_IMAGE_STOP_CAPTURE](https://mavlink.io/en/messages/common.html#MAV_CMD_IMAGE_STOP_CAPTURE) now take  the component ID of the target camera in `param1`. \r\nThis allows the commands to be addressed to a particular camera when used in a mission.\r\n\r\nThis change modifies the code that publishes the commands to a mavlink camera to use the id if it is between 1 and 255 (inclusive) and otherwise use `100` (the allocated first ID in for cameras).\r\nNote that range 1 to 6 (inclusive) are supposed to be reserved for cameras connected to FCs, so if we ever support that case, we'd need to change this code.\r\n\r\nPreviously the command was always addressed to 100. This is a little poor, since IDs cannot be guaranteed to be reserved.\r\n\r\n- Also added support for [MAV_CMD_SET_CAMERA_SOURCE](https://mavlink.io/en/messages/common.html#MAV_CMD_SET_CAMERA_SOURCE) (not caching though).\r\n",
      "issue_comments": [
        {
          "author": "hamishwillee",
          "created_at": "2024-05-23T00:51:28Z",
          "body": "@julianoes OK, so I added code to set the ID for SET_CAMERA_MODE too.\r\n\r\nSo for this to be \"rock solid\" we may need to add support for caching of MAV_CMD_SET_CAMERA_SOURCE. As per https://github.com/PX4/PX4-Autopilot/pull/23115#discussion_r1600977412 \"can you do this?\"\r\n\r\nIf not, let me know.\r\n\r\n----\r\n\r\nA complete aside:\r\n- the changes made here are good for setting the target id in the explicit camera cases - they default to the camera id specified or 100.\r\n- But other mavlink commands, including the video commands will be sent to all cameras - we don't index them by component id but by stream id. In theory we should probably maintain a mapping of stream id and component id and send commands addressed to a particular stream id to only that camera. ",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2024-05-23T02:19:32Z",
          "body": "@hamishwillee make sure to run `make format` to fix styling.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-08-07T01:05:25Z",
          "body": "@julianoes I finally got around to running format on this, which cleared your approval. There is a SITL error, which I suspect is unrelated. Can you confirm?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "hamishwillee",
          "created_at": "2024-05-09T07:11:34Z",
          "body": "I marked this case up because:\r\n- It isn't \"any camera\" - that would be '0'\r\n- Is there any way we can set this so that a manual control can actually set the camera ID to control? Maybe not worth it since if you only have one camera you can probably set its ID to 100.",
          "path": "src/modules/manual_control/ManualControl.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2024-05-09T19:57:07Z",
          "body": "Right, I remember discussing this for various commands in the past.\r\n\r\nIt turns out that some commands encode it in `param1`, e.g.\r\nhttps://mavlink.io/en/messages/common.html#MAV_CMD_IMAGE_START_CAPTURE\r\n\r\nBut SET_MODE does not:\r\nhttps://mavlink.io/en/messages/common.html#MAV_CMD_SET_CAMERA_MODE\r\n\r\nWe could add it, but it's a one by one process of adding it.",
          "path": "src/modules/manual_control/ManualControl.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-09T21:53:15Z",
          "body": "Yes. The update in the PR is to add the id for those commands that support it now - those were added in a few months ago. I think we should add it to camera mode, and if you agree, will add a PR to add for the missing cases next week (?).\r\n\r\nPrevious discussions have suggested having a generic target ID setter that you change before calling an API. This mostly makes sense because some commands have few free params. I don't like that design as it makes the API more complicated. We'll address it when we come to it.\r\n",
          "path": "src/modules/manual_control/ManualControl.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-15T05:43:50Z",
          "body": "FYI, this comment was meaningless - new one reflects the protocol version where is relevant",
          "path": "src/drivers/camera_trigger/camera_trigger_params.c",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-15T05:47:02Z",
          "body": "@julianoes OK, so I added support for `MAV_CMD_SET_CAMERA_SOURCE` as well, everywhere except the caching code - for example in `MissionBase::cacheItem(const mission_item_s &mission_item)` - I was wondering if you could tidy that bit because I am concerned I would screw it up. Will do it if you are not happy to take that on.\r\n\r\nThat is the thing that sets an IR camera or a Visible light camera - I think it is a completely independent setting so propably has its own cache entry.",
          "path": "src/modules/manual_control/ManualControl.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-15T06:11:46Z",
          "body": "PS Finding out the other commands to add this to in https://github.com/mavlink/mavlink/pull/2111",
          "path": "src/modules/manual_control/ManualControl.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-23T00:46:41Z",
          "body": "OK, as per discussion in https://github.com/mavlink/mavlink/pull/2111 the only other command to add for this PR was SET_CAMERA_MODE (DONE)",
          "path": "src/modules/manual_control/ManualControl.cpp",
          "position": 5,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "hamishwillee",
          "created_at": "2024-05-09T07:11:34Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "julianoes",
          "created_at": "2024-05-09T19:57:11Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-09T21:53:15Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-15T05:43:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-15T05:47:02Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-15T06:11:46Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-05-23T00:46:41Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "julianoes",
          "created_at": "2024-05-23T02:18:38Z",
          "body": "Nice, thanks!",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "julianoes",
          "created_at": "2024-10-09T08:09:45Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect command-targeting logic: previously image start/stop (and SET_CAMERA_MODE) were always addressed to component ID 100, which could send commands to the wrong camera. The change uses the param1 component ID when valid (1â€“255) and falls back to 100, fixing the unintended behavior of misaddressed camera commands.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -293,6 +293,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \t    mission_item.nav_cmd != NAV_CMD_OBLIQUE_SURVEY &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL &&\n \t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n+\t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_SOURCE &&\n \t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n \t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n@@ -378,6 +379,7 @@ bool FeasibilityChecker::checkTakeoff(mission_item_s &mission_item)\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_OBLIQUE_SURVEY &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n+\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_SOURCE &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a684f0b4a504f0a0d8a6cfb79152a5f7a4c2d449/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -91,6 +91,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tcase NAV_CMD_OBLIQUE_SURVEY:\n \tcase NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:\n \tcase NAV_CMD_SET_CAMERA_MODE:\n+\tcase NAV_CMD_SET_CAMERA_SOURCE:\n \tcase NAV_CMD_SET_CAMERA_ZOOM:\n \tcase NAV_CMD_SET_CAMERA_FOCUS:\n \tcase NAV_CMD_DO_CHANGE_SPEED:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a684f0b4a504f0a0d8a6cfb79152a5f7a4c2d449/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -89,6 +89,7 @@ enum NAV_CMD {\n \tNAV_CMD_DO_SET_CAM_TRIGG_DIST = 206,\n \tNAV_CMD_OBLIQUE_SURVEY = 260,\n \tNAV_CMD_SET_CAMERA_MODE = 530,\n+\tNAV_CMD_SET_CAMERA_SOURCE = 534,\n \tNAV_CMD_SET_CAMERA_ZOOM = 531,\n \tNAV_CMD_SET_CAMERA_FOCUS = 532,\n \tNAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW = 1000,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a684f0b4a504f0a0d8a6cfb79152a5f7a4c2d449/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 2,
        "changes": 48,
        "patch": "@@ -1364,9 +1364,13 @@ void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n \tvcmd->confirmation = false;\n \tvcmd->from_external = false;\n \n+\tint target_camera_component_id;\n+\n \t// The camera commands are not processed on the autopilot but will be\n \t// sent to the mavlink links to other components.\n \tswitch (vcmd->command) {\n+\n+\n \tcase NAV_CMD_IMAGE_START_CAPTURE:\n \n \t\tif (static_cast<int>(vcmd->param3) == 1) {\n@@ -1386,12 +1390,52 @@ void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n \t\t\t_is_capturing_images = true;\n \t\t}\n \n-\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\n+\t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n+\t\t\tvcmd->target_component = target_camera_component_id;\n+\n+\t\t} else {\n+\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t}\n+\n \t\tbreak;\n \n \tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n \t\t_is_capturing_images = false;\n-\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\n+\t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n+\t\t\tvcmd->target_component = target_camera_component_id;\n+\n+\t\t} else {\n+\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase NAV_CMD_SET_CAMERA_MODE:\n+\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\n+\t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n+\t\t\tvcmd->target_component = target_camera_component_id;\n+\n+\t\t} else {\n+\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase NAV_CMD_SET_CAMERA_SOURCE:\n+\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\n+\t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n+\t\t\tvcmd->target_component = target_camera_component_id;\n+\n+\t\t} else {\n+\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t}\n+\n \t\tbreak;\n \n \tcase NAV_CMD_VIDEO_START_CAPTURE:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a684f0b4a504f0a0d8a6cfb79152a5f7a4c2d449/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::checkMissionItemValidity",
        "MissionBlock::is_mission_item_reached_or_completed",
        "Navigator::publish_vehicle_cmd",
        "FeasibilityChecker::checkTakeoff"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkMissionItemValidity",
          "FeasibilityChecker::checkTakeoff"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_vehicle_cmd"
        ]
      }
    }
  },
  {
    "title": "vehicle_command: add initial frame support (GLOBAL & GLOBAL_RELATIVE_ALT)",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23080",
    "number": 23080,
    "created_at": "2024-05-01T22:20:17Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "dagar",
      "body": "This adds initial frame support to vehicle_command so that things like DO_REPOSITION can specify relative or absolute altitude. Ideally this would be updated to strictly respect the specification and reject anything other than GLOBAL/GLOBAL_RELATIVE_ALT, but for now I've left it open to hopefully not break any compatibility until we can verify.\r\n\r\nIn the future this can be nicely expanded to support things like MAV_FRAME_LOCAL_NED, MAV_FRAME_GLOBAL_TERRAIN_ALT, MAV_FRAME_BODY_FRD etc.\r\n\r\n - fixes https://github.com/PX4/PX4-Autopilot/issues/10246\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2024-05-01T23:44:46Z",
          "body": "I've updated this to actually reject any COMMAND_INT that has a frame other than GLOBAL or GLOBAL_RELATIVE_ALT, however longer term I think it would be more appropriate to push this out to the final handler (eg DO_REPOSITION) where we can have proper granularity for supported/unsupported frames for each command. Additionally we have no way to distinguish the frame being not set (MAV_FRAME 0) from MAV_FRAME_GLOBAL and some commands don't actually require a frame.",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T15:35:22Z",
          "body": "I rebased on main and added my suggestions. I'm not 100% sure if it breaks any flawed but popular use cases that we need to transition. For sure we need testing to make sure there's nothing obvious.",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T16:03:21Z",
          "body": "In my SILT SIH tests the usual stuff with QGC like takeoff, land, goto, orbit all work fine but when I put together a relative altitude goto it flies slowly into the ground like the original issue said. The new logic gets called and add home altitude and parameter but that somehow doesn't matter. Maybe my test is set up wrongly ðŸ‘€ ",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T16:18:19Z",
          "body": "The addition of the home altitude really doesn't end up in the triplet\r\n![image](https://github.com/PX4/PX4-Autopilot/assets/4668506/15ebb5bc-541f-4b7f-b9e4-81b7dddf99a8)\r\nI'll have to check what's going on later.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T14:45:23Z",
          "body": "```suggestion\r\n```",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T14:45:33Z",
          "body": "```suggestion\r\n```",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T14:45:56Z",
          "body": "```suggestion\r\nuint8 FRAME_GLOBAL_RELATIVE_ALTITUDE = 2 # Global (WGS84) coordinate frame + altitude relative to the home position.\r\n```",
          "path": "msg/VehicleCommand.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T15:23:03Z",
          "body": "Should return the unsupported frame result, that is in my understanding exactly what it was added for.",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-05-02T15:30:26Z",
          "body": "I have some suggestions, will add a commit.",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes incorrect handling of the MAV_FRAME on vehicle_command/COMMAND_INT which caused relative vs absolute altitude to be misinterpreted (e.g., relative-altitude DO_REPOSITION flying into the ground). The change adds initial frame support and validation (restricting to GLOBAL/GLOBAL_RELATIVE_ALT), correcting the incorrect behavior/state transition in altitude interpretation.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -108,6 +108,7 @@ Land::on_active()\n \t\tvehicle_command_s vcmd = {};\n \n \t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n+\t\tvcmd.frame = vehicle_command_s::FRAME_GLOBAL;\n \t\tvcmd.param1 = -1;\n \t\tvcmd.param2 = 1;\n \t\tvcmd.param5 = _navigator->get_global_position()->lat;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d5d96e8f9cd924a1ad59ea08fce56169f098eaf/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -855,6 +855,7 @@ MissionBase::do_abort_landing()\n \tvehicle_command_s vcmd = {};\n \n \tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n+\tvcmd.frame = vehicle_command_s::FRAME_GLOBAL;\n \tvcmd.param1 = -1;\n \tvcmd.param2 = 1;\n \tvcmd.param5 = _mission_item.lat;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d5d96e8f9cd924a1ad59ea08fce56169f098eaf/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "patch": "@@ -267,6 +267,7 @@ void Navigator::run()\n \n \t\t\t\tvehicle_global_position_s position_setpoint{};\n \n+\t\t\t\t// latitude/longitude\n \t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n \t\t\t\t\tposition_setpoint.lat = cmd.param5;\n \t\t\t\t\tposition_setpoint.lon = cmd.param6;\n@@ -276,7 +277,22 @@ void Navigator::run()\n \t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n \t\t\t\t}\n \n-\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n+\t\t\t\t// altitude\n+\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n+\t\t\t\t\tswitch (cmd.frame) {\n+\t\t\t\t\tdefault:\n+\t\t\t\t\tcase vehicle_command_s::FRAME_GLOBAL:\n+\t\t\t\t\t\tposition_setpoint.alt = cmd.param7;\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase vehicle_command_s::FRAME_GLOBAL_RELATIVE_ALTITUDE:\n+\t\t\t\t\t\tposition_setpoint.alt = cmd.param7 + get_home_position()->alt;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tposition_setpoint.alt = get_global_position()->alt;\n+\t\t\t\t}\n \n \t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1d5d96e8f9cd924a1ad59ea08fce56169f098eaf/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_active",
        "MissionBase::do_abort_landing",
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::do_abort_landing"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "navigator: Change multiple decisions to SWITCH statements",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23065",
    "number": 23065,
    "created_at": "2024-04-28T05:13:42Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nComparing the same variable value to multiple decision values.\r\n\r\n### Solution\r\n\r\nChange to SWITCH statement.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\nNone\r\n\r\n### Context\r\n\r\nNone\r\n",
      "issue_comments": [
        {
          "author": "muramura",
          "created_at": "2024-08-12T04:18:52Z",
          "body": "PR again.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2024-04-28T12:37:53Z",
          "body": "Can we please refrain from using `goto` the `break` statement was fine here in the if context, just keep the code as is if you ask me.",
          "path": "src/modules/navigator/geofence.cpp",
          "position": 18,
          "type": "review_comment"
        },
        {
          "author": "muramura",
          "created_at": "2024-04-29T10:26:57Z",
          "body": "@PetervdPerk-NXP san.\r\nThe break in the if statement exits the for statement.\r\nA break in a switch statement exits from a switch statement.\r\nBefore the change, the GOTO statement was used because it is a break to exit from the for statement.",
          "path": "src/modules/navigator/geofence.cpp",
          "position": 18,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2024-04-28T12:37:53Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "muramura",
          "created_at": "2024-04-29T10:26:57Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR description indicates a refactor (replacing multiple comparisons with a switch) rather than correcting incorrect behavior; there is no mention of a bug, failing behavior, or tests demonstrating a logic fault. Without further detail showing the prior code produced wrong outputs or state, this appears to be a stylistic/clarity change rather than a fix for a logic error.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "patch": "@@ -452,12 +452,17 @@ bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (temp_vertex_i.frame != NAV_FRAME_GLOBAL && temp_vertex_i.frame != NAV_FRAME_GLOBAL_INT\n-\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n-\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n+\t\tswitch (temp_vertex_i.frame) {\n+\t\tcase NAV_FRAME_GLOBAL:\n+\t\tcase NAV_FRAME_GLOBAL_INT:\n+\t\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT:\n+\t\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT_INT:\n+\t\t\tbreak;\n+\n+\t\tdefault:\n \t\t\t// TODO: handle different frames\n \t\t\tPX4_ERR(\"Frame type %i not supported\", (int)temp_vertex_i.frame);\n-\t\t\tbreak;\n+\t\t\tgoto loop_exit;\n \t\t}\n \n \t\tif (((double)temp_vertex_i.lon >= lon) != ((double)temp_vertex_j.lon >= lon) &&\n@@ -467,6 +472,8 @@ bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon,\n \t\t}\n \t}\n \n+loop_exit:\n+\t\n \treturn c;\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bf0917d109abecebea02e9998847559a6a54d9a1/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::insidePolygon"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::insidePolygon"
        ]
      }
    }
  },
  {
    "title": "global:  Change the IF statement to a SWITCH statement",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23061",
    "number": 23061,
    "created_at": "2024-04-26T22:39:57Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nThe same variable was being determined by multiple IF statements.\r\n\r\n### Solution\r\n\r\nChange to SWITCH statement.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\nNone\r\n\r\n### Context\r\n\r\nNone",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR explicitly addresses a case where the same variable was being set by multiple IF statements, which can produce incorrect final values when the conditions overlap. Replacing the independent IFs with a SWITCH (or mutually exclusive branches) corrects the conditional logic and prevents unintended state, so this is a logic bug fix.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 14,
        "changes": 46,
        "patch": "@@ -406,17 +406,25 @@ bool Geofence::checkPointAgainstPolygonCircle(const PolygonInfo &polygon, double\n {\n \tbool checksPass = true;\n \n-\tif (polygon.fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n+\tswitch (polygon.fence_type) {\n+\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n \t\tchecksPass &= insideCircle(polygon, lat, lon, altitude);\n+\t\tbreak;\n \n-\t} else if (polygon.fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n+\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n \t\tchecksPass &= !insideCircle(polygon, lat, lon, altitude);\n+\t\tbreak;\n \n-\t} else if (polygon.fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n+\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n \t\tchecksPass &= insidePolygon(polygon, lat, lon, altitude);\n+\t\tbreak;\n \n-\t} else if (polygon.fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION) {\n+\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n \t\tchecksPass &= !insidePolygon(polygon, lat, lon, altitude);\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n \t}\n \n \treturn checksPass;\n@@ -482,9 +490,14 @@ bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon,\n \t\treturn false;\n \t}\n \n-\tif (circle_point.frame != NAV_FRAME_GLOBAL && circle_point.frame != NAV_FRAME_GLOBAL_INT\n-\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n-\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n+\tswitch (circle_point.nav_cmd) {\n+\tcase NAV_FRAME_GLOBAL:\n+\tcase NAV_FRAME_GLOBAL_INT:\n+\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT:\n+\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT_INT:\n+\t\tbreak;\n+\n+\tdefault:\n \t\t// TODO: handle different frames\n \t\tPX4_ERR(\"Frame type %i not supported\", (int)circle_point.frame);\n \t\treturn false;\n@@ -675,20 +688,25 @@ void Geofence::printStatus()\n \tfor (int i = 0; i < _num_polygons; ++i) {\n \t\ttotal_num_vertices += _polygons[i].vertex_count;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n+\t\tswitch (_polygons[i].fence_type) {\n+\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n \t\t\t++num_inclusion_polygons;\n-\t\t}\n+\t\t\tbreak;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION) {\n+\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n \t\t\t++num_exclusion_polygons;\n-\t\t}\n+\t\t\tbreak;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n+\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n \t\t\t++num_inclusion_circles;\n-\t\t}\n+\t\t\tbreak;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n+\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n \t\t\t++num_exclusion_circles;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tbreak;\n \t\t}\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bdee94cd545682b769917a7bcf505e3845f50004/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::checkPointAgainstPolygonCircle",
        "Geofence::printStatus",
        "Geofence::insideCircle"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::checkPointAgainstPolygonCircle",
          "Geofence::printStatus",
          "Geofence::insideCircle"
        ]
      }
    }
  },
  {
    "title": "navigator: Determine RTL behavior by definition name",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23014",
    "number": 23014,
    "created_at": "2024-04-13T11:51:23Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nRTL behavior was being determined by value.\r\n\r\n### Solution\r\n\r\nRTL behavior is defined.\r\nJudged by definition name.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\nNone\r\n\r\n### Context\r\n\r\nNone",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect decision logic: RTL behavior was being inferred from a value rather than from the element/definition name. That is a faulty conditional/state decision causing incorrect layout direction; changing the check to use the definition name corrects the logic so behavior is determined by the intended property.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "patch": "@@ -309,7 +309,7 @@ void RTL::setRtlTypeAndDestination()\n \n \tuint8_t safe_point_index{0U};\n \n-\tif (_param_rtl_type.get() != 2) {\n+\tif (RtlType(_param_rtl_type.get()) != RtlType::RTL_DIRECT_MISSION_LAND) {\n \t\t// check the closest allowed destination.\n \t\tDestinationType destination_type{DestinationType::DESTINATION_TYPE_HOME};\n \t\tPositionYawSetpoint rtl_position;\n@@ -353,11 +353,18 @@ void RTL::setRtlTypeAndDestination()\n \t_rtl_status_pub.get().is_evaluation_pending = _dataman_state != DatamanState::UpdateRequestWait;\n \t_rtl_status_pub.get().has_vtol_approach = false;\n \n-\tif ((_param_rtl_type.get() == 0) || (_param_rtl_type.get() == 3)) {\n+\tswitch (RtlType(_param_rtl_type.get())) {\n+\tcase RtlType::NONE:\n+\tcase RtlType::RTL_MISSION_FAST:\n \t\t_rtl_status_pub.get().has_vtol_approach = _home_has_land_approach || _one_rally_point_has_land_approach;\n+\t\tbreak;\n \n-\t} else if (_param_rtl_type.get() == 1) {\n+\tcase RtlType::RTL_DIRECT:\n \t\t_rtl_status_pub.get().has_vtol_approach = _one_rally_point_has_land_approach;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n \t}\n \n \t_rtl_status_pub.get().rtl_type = static_cast<uint8_t>(_rtl_type);\n@@ -389,8 +396,8 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \n \t_home_has_land_approach = hasVtolLandApproach(rtl_position);\n \n-\tif (((_param_rtl_type.get() == 1) && !vtol_in_rw_mode) || (vtol_in_fw_mode && (_param_rtl_approach_force.get() == 1)\n-\t\t\t&& !_home_has_land_approach)) {\n+\tif (((RtlType(_param_rtl_type.get()) == RtlType::RTL_DIRECT) && !vtol_in_rw_mode)\n+\t    || (vtol_in_fw_mode && (_param_rtl_approach_force.get() == 1) && !_home_has_land_approach)) {\n \t\t// Set minimum distance to maximum value when RTL_TYPE is set to 1 and we are not in RW mode or we forces approach landing for vtol in fw and it is not defined for home.\n \t\tmin_dist = FLT_MAX;\n \n@@ -399,8 +406,9 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \t}\n \n \t// consider the mission landing if available and allowed\n-\tif (((_param_rtl_type.get() == 1) || (_param_rtl_type.get() == 3) || (fabsf(FLT_MAX - min_dist) < FLT_EPSILON))\n-\t    && hasMissionLandStart()) {\n+\tif (((RtlType(_param_rtl_type.get()) == RtlType::RTL_DIRECT)\n+\t     || (RtlType(_param_rtl_type.get()) == RtlType::RTL_MISSION_FAST)\n+\t     || (fabsf(FLT_MAX - min_dist) < FLT_EPSILON)) && hasMissionLandStart()) {\n \t\tmission_item_s land_mission_item;\n \t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().mission_dataman_id);\n \t\tbool success = _dataman_cache_landItem.loadWait(dm_item, _mission_sub.get().land_index,\n@@ -416,7 +424,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_mission_item.lat, land_mission_item.lon)};\n \n \t\tif ((dist + MIN_DIST_THRESHOLD) < min_dist) {\n-\t\t\tif (_param_rtl_type.get() != 0) {\n+\t\t\tif (RtlType(_param_rtl_type.get()) != RtlType::NONE) {\n \t\t\t\tmin_dist = dist;\n \n \t\t\t} else {\n@@ -556,7 +564,7 @@ void RTL::init_rtl_mission_type()\n {\n \tRtlType new_rtl_mission_type{RtlType::RTL_DIRECT_MISSION_LAND};\n \n-\tif (_param_rtl_type.get() == 2) {\n+\tif (RtlType(_param_rtl_type.get()) == RtlType::RTL_DIRECT_MISSION_LAND) {\n \t\tif (hasMissionLandStart()) {\n \t\t\tnew_rtl_mission_type = RtlType::RTL_MISSION_FAST;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/a9a4df1fa4cb88e745c5eabff8a9d9fb452eba41/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::init_rtl_mission_type",
        "RTL::setRtlTypeAndDestination",
        "RTL::findRtlDestination",
        "hasMissionLandStart"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::init_rtl_mission_type",
          "RTL::setRtlTypeAndDestination",
          "RTL::findRtlDestination",
          "hasMissionLandStart"
        ]
      }
    }
  },
  {
    "title": "Add Precision loiter [WIP]",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23012",
    "number": 23012,
    "created_at": "2024-04-12T05:21:21Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "asimopunov",
      "body": "https://github.com/mavlink/rfcs/pull/21\r\n\r\nhttps://github.com/mavlink/mavlink/pull/1858",
      "issue_comments": [
        {
          "author": "bresch",
          "created_at": "2024-04-12T06:54:17Z",
          "body": "> Added â€œprecision loiterâ€ functionality which is identical to precision land except hovers\r\nover the target instead of landing on it.\r\n\r\nI would then say that instead of copy pasting and modifying precision landing you should rather split precision landing into \"approach\", \"search\" and \"landing\". Then you can have all of them for precision landing and just remove landing in precision hover. (when I say split, I mean \"refactor\" and \"extract to a separate class that can be used by both modes\")",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR adds a new feature (precision loiter) that mirrors precision land but hovers instead of landing. Comments discuss refactoring to avoid copy-paste, but there is no indication the change corrects an incorrect behavior or fixes an existing logic bug. It appears to be a feature addition/refactor suggestion rather than a logic error fix.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -49,6 +49,7 @@ set(NAVIGATOR_SOURCES\n \ttakeoff.cpp\n \tland.cpp\n \tprecland.cpp\n+\tprecloiter.cpp\n \tmission_feasibility_checker.cpp\n \tgeofence.cpp)\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -295,7 +295,8 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n \t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n \t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n-\t    mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n+\t    mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION &&\n+\t    mission_item.nav_cmd != NAV_CMD_DO_PRECISION_HOLD) {\n \n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: item %i: unsupported cmd: %d\\t\",\n \t\t\t\t     (int)(current_index + 1),",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -223,7 +223,7 @@ void Mission::setActiveMissionItems()\n \t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n \n \t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n-\t\tif (new_work_item_type != WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n+\t\tif (new_work_item_type != WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND && new_work_item_type != WorkItemType::WORK_ITEM_TYPE_PRECISION_LOITER) {\n \t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "patch": "@@ -187,6 +187,11 @@ MissionBase::on_inactivation()\n \t\t_navigator->get_precland()->on_inactivation();\n \t}\n \n+\t:\n+\tif (_navigator->get_precloiter()->is_activated()) {\n+\t\t_navigator->get_precloiter()->on_inactivation();\n+\t}\n+\n \t/* reset so current mission item gets restarted if mission was paused */\n \t_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n \n@@ -352,6 +357,14 @@ MissionBase::on_active()\n \t} else if (_navigator->get_precland()->is_activated()) {\n \t\t_navigator->get_precland()->on_inactivation();\n \t}\n+\n+\t:\n+\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_PRECISION_LOITER) {\n+\t\t_navigator->get_precloiter()->on_active();\n+\n+\t} else if (_navigator->get_precloiter()->is_activated()) {\n+\t\t_navigator->get_precloiter()->on_inactivation();\n+\t}\n }\n \n void MissionBase::update_mission()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -89,7 +89,8 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t\tWORK_ITEM_TYPE_ALIGN_HEADING,\t\t/**< align for next waypoint */\n \t\tWORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF,\n \t\tWORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION,\n-\t\tWORK_ITEM_TYPE_PRECISION_LAND\n+\t\tWORK_ITEM_TYPE_PRECISION_LAND,\n+\t\tWORK_ITEM_TYPE_PRECISION_LOITER\n \t} _work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\t/**< current type of work to do (sub mission item) */\n \n \tenum class MissionType {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "patch": "@@ -325,7 +325,14 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t\t_time_wp_reached = now;\n \t\t\t\t}\n \t\t\t}\n-\n+\t\t:\n+\t\t} else if (_mission_item.nav_cmd == NAV_CMD_DO_PRECISION_HOLD) {\n+\t\t\t// Check if the precloiter item has finished\n+\t\t\tif (!_navigator->get_precloiter()->is_activated()) {\n+\t\t\t\t_waypoint_position_reached = true;\n+\t\t\t\t_waypoint_yaw_reached = true;\n+\t\t\t\t_time_wp_reached = now;\n+\t\t\t}\n \t\t} else {\n \n \t\t\tfloat acceptance_radius = _navigator->get_acceptance_radius();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -88,6 +88,7 @@ enum NAV_CMD {\n \tNAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = 214,\n \tNAV_CMD_DO_SET_CAM_TRIGG_DIST = 206,\n \tNAV_CMD_OBLIQUE_SURVEY = 260,\n+\tNAV_CMD_DO_PRECISION_HOLD = 303,\n \tNAV_CMD_SET_CAMERA_MODE = 530,\n \tNAV_CMD_SET_CAMERA_ZOOM = 531,\n \tNAV_CMD_SET_CAMERA_FOCUS = 532,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -44,6 +44,7 @@\n #include \"geofence.h\"\n #include \"land.h\"\n #include \"precland.h\"\n+#include \"precloiter.h\"\n #include \"loiter.h\"\n #include \"mission.h\"\n #include \"navigator_mode.h\"\n@@ -163,6 +164,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvehicle_status_s            *get_vstatus() { return &_vstatus; }\n \n \tPrecLand *get_precland() { return &_precland; } /**< allow others, e.g. Mission, to use the precision land block */\n+\tPrecLoiter *get_precloiter() { return &_precloiter; } /**< allow others, e.g. Mission, to use the precision loiter block */\n \n \tconst vehicle_roi_s &get_vroi() { return _vroi; }\n \n@@ -350,6 +352,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \tLand\t\t_land;\t\t\t/**< class for handling land commands */\n \tPrecLand\t_precland;\t\t\t/**< class for handling precision land commands */\n+\tPrecLoiter\t_precloiter;\t\t\t/**< class for handling precision loiter commands */\n \tRTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */\n \tAdsbConflict \t_adsb_conflict;\t\t\t/**< class that handles ADSB conflict avoidance */\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -80,6 +80,7 @@ Navigator::Navigator() :\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \t_land(this),\n \t_precland(this),\n+\t_precloiter(this),\n \t_rtl(this)\n {\n \t/* Create a list of our possible navigation types */\n@@ -92,6 +93,7 @@ Navigator::Navigator() :\n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \t_navigation_mode_array[6] = &_vtol_takeoff;\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n+\t_navigation_mode_array[7] = &_precloiter;\n \n \t/* iterate through navigation modes and initialize _mission_item for each */\n \tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/precloiter.cpp": {
        "filename": "src/modules/navigator/precloiter.cpp",
        "status": "added",
        "additions": 601,
        "deletions": 0,
        "changes": 601,
        "patch": "@@ -0,0 +1,601 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2017 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+\n+#include \"precloiter.h\"\n+#include \"navigator.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <math.h>\n+#include <fcntl.h>\n+\n+#include <systemlib/err.h>\n+#include <systemlib/mavlink_log.h>\n+\n+#include <uORB/uORB.h>\n+#include <uORB/topics/position_setpoint_triplet.h>\n+#include <uORB/topics/vehicle_status.h>\n+#include <uORB/topics/vehicle_command.h>\n+\n+#define STATE_TIMEOUT 20_s // [us] Maximum time to spend in any state\n+\n+PrecLoiter::PrecLoiter(Navigator *navigator) :\n+\tMissionBlock(navigator),\n+\tModuleParams(navigator)\n+{\n+\t_handle_param_acceleration_hor = param_find(\"MPC_ACC_HOR\");\n+\t_handle_param_xy_vel_cruise = param_find(\"MPC_XY_CRUISE\");\n+\n+\tupdateParams();\n+}\n+\n+void\n+PrecLoiter::on_activation()\n+{\n+\t_state = PrecLoiterState::Start;\n+\t_search_cnt = 0;\n+\t_last_slewrate_time = 0;\n+\n+\tvehicle_local_position_s *vehicle_local_position = _navigator->get_local_position();\n+\n+\tif (!_map_ref.isInitialized()) {\n+\t\t_map_ref.initReference(vehicle_local_position->ref_lat, vehicle_local_position->ref_lon);\n+\t}\n+\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\tpos_sp_triplet->next.valid = false;\n+\tpos_sp_triplet->previous.valid = false;\n+\n+\tpos_sp_triplet->current.lat = _navigator->get_global_position()->lat;\n+\tpos_sp_triplet->current.lon = _navigator->get_global_position()->lon;\n+\tpos_sp_triplet->current.alt = _navigator->get_global_position()->alt;\n+\tpos_sp_triplet->current.valid = true;\n+\tpos_sp_triplet->current.timestamp = hrt_absolute_time();\n+\n+\t_sp_pev = matrix::Vector2f(0, 0);\n+\t_sp_pev_prev = matrix::Vector2f(0, 0);\n+\t_last_slewrate_time = 0;\n+\n+\tswitch_to_state_start();\n+\n+\t_is_activated = true;\n+}\n+\n+void\n+PrecLoiter::on_active()\n+{\n+\t// get new target measurement\n+\t_target_pose_updated = _target_pose_sub.update(&_target_pose);\n+\n+\tif (_target_pose_updated) {\n+\t\t_target_pose_valid = true;\n+\t}\n+\n+\tif ((hrt_elapsed_time(&_target_pose.timestamp) / 1e6f) > _param_pld_btout.get()) {\n+\t\t_target_pose_valid = false;\n+\t}\n+\n+\tswitch (_state) {\n+\tcase PrecLoiterState::Start:\n+\t\trun_state_start();\n+\t\tbreak;\n+\n+\tcase PrecLoiterState::HorizontalApproach:\n+\t\trun_state_horizontal_approach();\n+\t\tbreak;\n+\n+\tcase PrecLoiterState::DescendAboveTarget:\n+\t\trun_state_descend_above_target();\n+\t\tbreak;\n+\n+\t// case PrecLoiterState::FinalApproach:\n+\t// \trun_state_final_approach();\n+\t// \tbreak;\n+\n+\tcase PrecLoiterState::Search:\n+\t\trun_state_search();\n+\t\tbreak;\n+\n+\tcase PrecLoiterState::Fallback:\n+\t\trun_state_fallback();\n+\t\tbreak;\n+\n+\tcase PrecLoiterState::Done:\n+\t\t// nothing to do\n+\t\t_is_activated = false;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\t// unknown state\n+\t\tbreak;\n+\t}\n+\n+\tprecision_action_status_s precision_action_status{};\n+\tprecision_action_status.timestamp = hrt_absolute_time();\n+\tprecision_action_status.state = (unsigned int)_state;\n+\tprecision_action_status.acquired = (_state == PrecLoiterState::HorizontalApproach) ||\n+\t\t\t\t\t\t\t\t\t\t(_state == PrecLoiterState::DescendAboveTarget);\n+\t_precision_action_status_pub.publish(precision_action_status);\n+}\n+\n+void\n+PrecLoiter::on_inactivation()\n+{\n+\t_is_activated = false;\n+}\n+\n+void\n+PrecLoiter::updateParams()\n+{\n+\tModuleParams::updateParams();\n+\n+\tif (_handle_param_acceleration_hor != PARAM_INVALID) {\n+\t\tparam_get(_handle_param_acceleration_hor, &_param_acceleration_hor);\n+\t}\n+\n+\tif (_handle_param_xy_vel_cruise != PARAM_INVALID) {\n+\t\tparam_get(_handle_param_xy_vel_cruise, &_param_xy_vel_cruise);\n+\t}\n+}\n+\n+bool PrecLoiter::arrived_at_setpoint()\n+{\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t// TODO: acceptance?\n+\tif (fabsf(pos_sp_triplet->current.alt - _navigator->get_global_position()->alt) < 0.1f) {\n+\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+void\n+PrecLoiter::run_state_start()\n+{\n+\t// check if target visible and go to horizontal approach\n+\tif (switch_to_state_horizontal_approach()) {\n+\t\treturn;\n+\t}\n+\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tfloat dist = get_distance_to_next_waypoint(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon,\n+\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\n+\t// check if we've reached the start point\n+\tif (dist < _navigator->get_acceptance_radius()) {\n+\t\tif (!_point_reached_time) {\n+\t\t\t_point_reached_time = hrt_absolute_time();\n+\t\t}\n+\n+\t\t// if we don't see the target after 1 second, search for it\n+\t\tif (_param_pld_srch_tout.get() > 0) {\n+\n+\t\t\t// Waits 2 seconds before descending... wtf why?\n+\t\t\tif (hrt_absolute_time() - _point_reached_time > 2000000) {\n+\t\t\t\tif (!switch_to_state_search()) {\n+\t\t\t\t\tswitch_to_state_fallback();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tswitch_to_state_fallback();\n+\t\t}\n+\t}\n+}\n+\n+void\n+PrecLoiter::run_state_horizontal_approach()\n+{\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t// check if target visible, if not go to start\n+\tif (!check_state_conditions(PrecLoiterState::HorizontalApproach)) {\n+\t\tPX4_WARN(\"Lost target while in horizontal approach.\");\n+\n+\t\t// Stay at current position for searching for the landing target\n+\t\tpos_sp_triplet->current.lat = _navigator->get_global_position()->lat;\n+\t\tpos_sp_triplet->current.lon = _navigator->get_global_position()->lon;\n+\t\tpos_sp_triplet->current.alt = _navigator->get_global_position()->alt;\n+\n+\t\tif (!switch_to_state_start()) {\n+\t\t\tswitch_to_state_fallback();\n+\t\t}\n+\n+\t\treturn;\n+\t}\n+\n+\tif (check_state_conditions(PrecLoiterState::DescendAboveTarget)) {\n+\t\tif (!_point_reached_time) {\n+\t\t\t_point_reached_time = hrt_absolute_time();\n+\t\t}\n+\n+\t\tif (hrt_absolute_time() - _point_reached_time > 2000000) {\n+\t\t\t// if close enough for descent above target go to descend above target\n+\t\t\tif (switch_to_state_descend_above_target()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+\tif (hrt_absolute_time() - _state_start_time > STATE_TIMEOUT) {\n+\t\tPX4_ERR(\"Precision descend took too long during horizontal approach phase.\");\n+\t\tswitch_to_state_fallback();\n+\t\treturn;\n+\t}\n+\n+\tfloat x = _target_pose.x_abs;\n+\tfloat y = _target_pose.y_abs;\n+\n+\tslewrate(x, y);\n+\n+\t// XXX need to transform to GPS coords because mc_pos_control only looks at that\n+\t_map_ref.reproject(x, y, pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n+\n+\tpos_sp_triplet->current.lat = pos_sp_triplet->current.lat;\n+\tpos_sp_triplet->current.lon = pos_sp_triplet->current.lon;\n+\tpos_sp_triplet->current.alt = _approach_alt;\n+\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\n+\t// Watts yaw-hack\n+\t// note: abs_pos_valid was alraedy checked as a condition to enter this state\n+\tpos_sp_triplet->current.yaw = matrix::Eulerf(matrix::Quaternionf(_target_pose.q)).psi();\n+\t//pos_sp_triplet->current.yaw_valid = true;\n+\n+\t// Disable previous and next setpoint, since they won't be correct and will cause the\n+\t// setpoint smoothing in FlightTaskAuto to interfere with the precision maneuver.\n+\t// For some reason disabling it once on activation is not enough and the flags are re-enabled.\n+\tpos_sp_triplet->previous.valid = false;\n+\tpos_sp_triplet->next.valid = false;\n+\n+\t_navigator->set_position_setpoint_triplet_updated();\n+}\n+\n+void\n+PrecLoiter::run_state_descend_above_target()\n+{\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t// check if target visible\n+\tif (!check_state_conditions(PrecLoiterState::DescendAboveTarget)) {\n+\t\tswitch_to_state_search();\n+\t\treturn;\n+\t}\n+\n+\t// XXX need to transform to GPS coords because mc_pos_control only looks at that\n+\t_map_ref.reproject(_target_pose.x_abs, _target_pose.y_abs, pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n+\n+\t// Use range finder if available\n+\tvehicle_local_position_s* local_pos = _navigator->get_local_position();\n+\tfloat distance_agl = local_pos->dist_bottom_valid ? local_pos->dist_bottom : local_pos->z;\n+\n+\tpos_sp_triplet->current.lat = pos_sp_triplet->current.lat;\n+\tpos_sp_triplet->current.lon = pos_sp_triplet->current.lon;\n+\tpos_sp_triplet->current.alt = (_navigator->get_global_position()->alt - distance_agl) + _height_above_target;\n+\n+\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\n+\t// Watts: control yaw\n+\tpos_sp_triplet->current.yaw = matrix::Eulerf(matrix::Quaternionf(_target_pose.q)).psi();\n+\t//pos_sp_triplet->current.yaw_valid = true;\n+\n+\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t// stop if we are at the set point\n+\tif (arrived_at_setpoint()) {\n+\t\tswitch_to_state_done();\n+\t}\n+}\n+\n+void\n+PrecLoiter::run_state_search()\n+{\n+\t// check if we can see the target\n+\tif (check_state_conditions(PrecLoiterState::HorizontalApproach)) {\n+\t\tif (!_target_acquired_time) {\n+\t\t\t// target just became visible. Stop climbing, but give it some margin so we don't stop too apruptly\n+\t\t\t_target_acquired_time = hrt_absolute_time();\n+\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\t\tfloat new_alt = _navigator->get_global_position()->alt + 1.0f;\n+\t\t\tpos_sp_triplet->current.alt = new_alt < pos_sp_triplet->current.alt ? new_alt : pos_sp_triplet->current.alt;\n+\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t}\n+\n+\t}\n+\n+\t// stay at that height for a second to allow the vehicle to settle\n+\tif (_target_acquired_time && (hrt_absolute_time() - _target_acquired_time) > 1_s) {\n+\t\t// try to switch to horizontal approach\n+\t\tif (switch_to_state_horizontal_approach()) {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\t// check if search timed out and go to fallback\n+\tif (hrt_absolute_time() - _state_start_time > _param_pld_srch_tout.get()*1_s) {\n+\t\tPX4_WARN(\"Search timed out\");\n+\t\tswitch_to_state_fallback();\n+\t}\n+}\n+\n+void\n+PrecLoiter::run_state_fallback()\n+{\n+\t// stop if we are at the set point\n+\tif (arrived_at_setpoint()) {\n+\t\tswitch_to_state_done();\n+\t}\n+\n+\t// TODO: rewrite this bullshit. This function already calls: check_state_conditions(PrecLandState::DescendAboveTarget)\n+\tif (switch_to_state_descend_above_target()) {\n+\t\t// PX4_INFO(\"Acquired target, precision landing\");\n+\t}\n+}\n+\n+bool\n+PrecLoiter::switch_to_state_start()\n+{\n+\tif (check_state_conditions(PrecLoiterState::Start)) {\n+\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t_search_cnt++;\n+\n+\t\t_point_reached_time = 0;\n+\n+\t\t_state = PrecLoiterState::Start;\n+\t\t_state_start_time = hrt_absolute_time();\n+\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool\n+PrecLoiter::switch_to_state_horizontal_approach()\n+{\n+\tif (check_state_conditions(PrecLoiterState::HorizontalApproach)) {\n+\t\t_approach_alt = _navigator->get_global_position()->alt;\n+\n+\t\t_point_reached_time = 0;\n+\n+\t\t_state = PrecLoiterState::HorizontalApproach;\n+\t\t_state_start_time = hrt_absolute_time();\n+\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool\n+PrecLoiter::switch_to_state_descend_above_target()\n+{\n+\tif (check_state_conditions(PrecLoiterState::DescendAboveTarget)) {\n+\t\t_state = PrecLoiterState::DescendAboveTarget;\n+\t\t_state_start_time = hrt_absolute_time();\n+\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+// bool\n+// PrecLoiter::switch_to_state_final_approach()\n+// {\n+// \tPX4_INFO(\"PrecLoiter::switch_to_state_final_approach\");\n+\n+// \tif (check_state_conditions(PrecLoiterState::FinalApproach)) {\n+// \t\t_state = PrecLoiterState::FinalApproach;\n+// \t\t_state_start_time = hrt_absolute_time();\n+// \t\treturn true;\n+// \t}\n+\n+// \treturn false;\n+// }\n+\n+bool\n+PrecLoiter::switch_to_state_search()\n+{\n+\tPX4_INFO(\"Climbing to search altitude.\");\n+\thome_position_s *home_position = _navigator->get_home_position();\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\tpos_sp_triplet->current.alt = home_position->alt + _param_pld_srch_alt.get();\n+\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t_target_acquired_time = 0;\n+\n+\t_state = PrecLoiterState::Search;\n+\t_state_start_time = hrt_absolute_time();\n+\treturn true;\n+}\n+\n+bool\n+PrecLoiter::switch_to_state_fallback()\n+{\n+\tPX4_INFO(\"Falling back to normal descend.\");\n+\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tpos_sp_triplet->current.lat = _navigator->get_global_position()->lat;\n+\tpos_sp_triplet->current.lon = _navigator->get_global_position()->lon;\n+\n+\tvehicle_local_position_s* local_pos = _navigator->get_local_position();\n+\tfloat distance_agl = local_pos->dist_bottom_valid ? local_pos->dist_bottom : local_pos->z;\n+\tpos_sp_triplet->current.alt = (_navigator->get_global_position()->alt - distance_agl) + _height_above_target;\n+\n+\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n+\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t_state = PrecLoiterState::Fallback;\n+\t_state_start_time = hrt_absolute_time();\n+\treturn true;\n+}\n+\n+bool\n+PrecLoiter::switch_to_state_done()\n+{\n+\t_state = PrecLoiterState::Done;\n+\t_state_start_time = hrt_absolute_time();\n+\treturn true;\n+}\n+\n+bool PrecLoiter::check_state_conditions(PrecLoiterState state)\n+{\n+\tvehicle_local_position_s *vehicle_local_position = _navigator->get_local_position();\n+\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\tswitch (state) {\n+\tcase PrecLoiterState::Start:\n+\t\treturn _search_cnt <= _param_pld_max_srch.get();\n+\n+\tcase PrecLoiterState::HorizontalApproach:\n+\n+\t\t// if we're already in this state, only want to make it invalid if we reached the target but can't see it anymore\n+\t\tif (_state == PrecLoiterState::HorizontalApproach) {\n+\t\t\tif (fabsf(_target_pose.x_abs - vehicle_local_position->x) < _param_pld_hacc_rad.get()\n+\t\t\t    && fabsf(_target_pose.y_abs - vehicle_local_position->y) < _param_pld_hacc_rad.get()) {\n+\t\t\t\t// we've reached the position where we last saw the target. If we don't see it now, we need to do something\n+\t\t\t\treturn _target_pose_valid && _target_pose.abs_pos_valid;\n+\n+\t\t\t} else {\n+\t\t\t\t// We've seen the target sometime during horizontal approach.\n+\t\t\t\t// Even if we don't see it as we're moving towards it, continue approaching last known location\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we're trying to switch to this state, the target needs to be visible\n+\t\treturn _target_pose_updated && _target_pose_valid && _target_pose.abs_pos_valid;\n+\n+\tcase PrecLoiterState::DescendAboveTarget:\n+\n+\t\t// if we're already in this state, only leave it if target becomes unusable, don't care about horizontall offset to target\n+\t\tif (_state == PrecLoiterState::DescendAboveTarget) {\n+\t\t\t// if we're close to the ground, we're more critical of target timeouts so we quickly go into descend\n+\t\t\t// if (check_state_conditions(PrecLoiterState::FinalApproach)) {\n+\t\t\t// \treturn hrt_absolute_time() - _target_pose.timestamp < 500000; // 0.5s\n+\n+\t\t\t// } else {\n+\t\t\t// \treturn _target_pose_valid && _target_pose.abs_pos_valid;\n+\t\t\t// }\n+\t\t\t// No!\n+\t\t\treturn true;\n+\n+\t\t} else {\n+\t\t\t// if not already in this state, need to be above target to enter it\n+\t\t\treturn _target_pose_updated && _target_pose.abs_pos_valid\n+\t\t\t\t\t&& fabsf(pos_sp_triplet->current.yaw - vehicle_local_position->heading) < _param_pld_yaw_delta.get()\n+\t\t\t\t\t&& fabsf(_target_pose.x_abs - vehicle_local_position->x) < _param_pld_hacc_rad.get()\n+\t\t\t\t\t&& fabsf(_target_pose.y_abs - vehicle_local_position->y) < _param_pld_hacc_rad.get();\n+\t\t}\n+\n+\t// case PrecLoiterState::FinalApproach:\n+\t// \treturn _target_pose_valid && _target_pose.abs_pos_valid\n+\t// \t       && (_target_pose.z_abs - vehicle_local_position->z) < _param_pld_fappr_alt.get();\n+\n+\tcase PrecLoiterState::Search:\n+\t\treturn true;\n+\n+\tcase PrecLoiterState::Fallback:\n+\t\treturn true;\n+\n+\tdefault:\n+\t\treturn false;\n+\t}\n+}\n+\n+void PrecLoiter::slewrate(float &sp_x, float &sp_y)\n+{\n+\tmatrix::Vector2f sp_curr(sp_x, sp_y);\n+\tuint64_t now = hrt_absolute_time();\n+\n+\tfloat dt = (now - _last_slewrate_time);\n+\n+\tif (dt < 1) {\n+\t\t// bad dt, can't divide by it\n+\t\treturn;\n+\t}\n+\n+\tdt /= 1_s;\n+\n+\tif (!_last_slewrate_time) {\n+\t\t// running the first time since switching to precloiter\n+\n+\t\t// assume dt will be about 50000us\n+\t\tdt = 50000 / 1_s;\n+\n+\t\t// set a best guess for previous setpoints for smooth transition\n+\t\t_sp_pev = _map_ref.project(_navigator->get_position_setpoint_triplet()->current.lat,\n+\t\t\t\t\t   _navigator->get_position_setpoint_triplet()->current.lon);\n+\t\t_sp_pev_prev(0) = _sp_pev(0) - _navigator->get_local_position()->vx * dt;\n+\t\t_sp_pev_prev(1) = _sp_pev(1) - _navigator->get_local_position()->vy * dt;\n+\t}\n+\n+\t_last_slewrate_time = now;\n+\n+\t// limit the setpoint speed to the maximum cruise speed\n+\tmatrix::Vector2f sp_vel = (sp_curr - _sp_pev) / dt; // velocity of the setpoints\n+\n+\tif (sp_vel.length() > _param_xy_vel_cruise) {\n+\t\tsp_vel = sp_vel.normalized() * _param_xy_vel_cruise;\n+\t\tsp_curr = _sp_pev + sp_vel * dt;\n+\t}\n+\n+\t// limit the setpoint acceleration to the maximum acceleration\n+\tmatrix::Vector2f sp_acc = (sp_curr - _sp_pev * 2 + _sp_pev_prev) / (dt * dt); // acceleration of the setpoints\n+\n+\tif (sp_acc.length() > _param_acceleration_hor) {\n+\t\tsp_acc = sp_acc.normalized() * _param_acceleration_hor;\n+\t\tsp_curr = _sp_pev * 2 - _sp_pev_prev + sp_acc * (dt * dt);\n+\t}\n+\n+\t// limit the setpoint speed such that we can stop at the setpoint given the maximum acceleration/deceleration\n+\tfloat max_spd = sqrtf(_param_acceleration_hor * ((matrix::Vector2f)(_sp_pev - matrix::Vector2f(sp_x,\n+\t\t\t      sp_y))).length());\n+\tsp_vel = (sp_curr - _sp_pev) / dt; // velocity of the setpoints\n+\n+\tif (sp_vel.length() > max_spd) {\n+\t\tsp_vel = sp_vel.normalized() * max_spd;\n+\t\tsp_curr = _sp_pev + sp_vel * dt;\n+\t}\n+\n+\t_sp_pev_prev = _sp_pev;\n+\t_sp_pev = sp_curr;\n+\n+\tsp_x = sp_curr(0);\n+\tsp_y = sp_curr(1);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fprecloiter.cpp"
      },
      "src/modules/navigator/precloiter.h": {
        "filename": "src/modules/navigator/precloiter.h",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "patch": "@@ -0,0 +1,140 @@\n+/***************************************************************************\n+ *\n+ *   Copyright (c) 2022 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+\n+#pragma once\n+\n+#include <matrix/math.hpp>\n+#include <lib/geo/geo.h>\n+#include <px4_platform_common/module_params.h>\n+#include <uORB/Subscription.hpp>\n+#include <uORB/topics/landing_target_pose.h>\n+#include <uORB/topics/precision_action_status.h>\n+\n+#include \"navigator_mode.h\"\n+#include \"mission_block.h\"\n+\n+enum class PrecLoiterState {\n+\tStart, // Starting state\n+\tHorizontalApproach, // Positioning over landing target while maintaining altitude\n+\tDescendAboveTarget, // Stay over landing target while descending\n+\tSearch, // Search for landing target\n+\tFallback, // Fallback landing method\n+\tDone // Done landing\n+};\n+\n+class PrecLoiter : public MissionBlock, public ModuleParams\n+{\n+public:\n+\tPrecLoiter(Navigator *navigator);\n+\t~PrecLoiter() override = default;\n+\n+\tvoid on_activation() override;\n+\tvoid on_active() override;\n+\tvoid on_inactivation() override;\n+\n+\tbool is_activated() { return _is_activated; };\n+\n+\tvoid set_height_above_target(float height) { _height_above_target = height; };\n+\n+private:\n+\n+\tvoid updateParams() override;\n+\n+\t// run the control loop for each state\n+\tvoid run_state_start();\n+\tvoid run_state_horizontal_approach();\n+\tvoid run_state_descend_above_target();\n+\t// void run_state_final_approach();\n+\tvoid run_state_search();\n+\tvoid run_state_fallback();\n+\n+\t// attempt to switch to a different state. Returns true if state change was successful, false otherwise\n+\tbool switch_to_state_start();\n+\tbool switch_to_state_horizontal_approach();\n+\tbool switch_to_state_descend_above_target();\n+\t// bool switch_to_state_final_approach();\n+\tbool switch_to_state_search();\n+\tbool switch_to_state_fallback();\n+\tbool switch_to_state_done();\n+\n+\tbool arrived_at_setpoint();\n+\n+\t// check if a given state could be changed into. Return true if possible to transition to state, false otherwise\n+\tbool check_state_conditions(PrecLoiterState state);\n+\tvoid slewrate(float &sp_x, float &sp_y);\n+\n+\tlanding_target_pose_s _target_pose{}; /**< precision landing target position */\n+\n+\tuORB::Subscription _target_pose_sub{ORB_ID(landing_target_pose)};\n+\n+\tuORB::Publication<precision_action_status_s>\t_precision_action_status_pub{ORB_ID(precision_action_status)};\n+\n+\tbool _target_pose_valid{false}; /**< whether we have received a landing target position message */\n+\tbool _target_pose_updated{false}; /**< wether the landing target position message is updated */\n+\n+\tMapProjection _map_ref {}; /**< reference for local/global projections */\n+\n+\tuint64_t _state_start_time{0}; /**< time when we entered current state */\n+\tuint64_t _last_slewrate_time{0}; /**< time when we last limited setpoint changes */\n+\tuint64_t _target_acquired_time{0}; /**< time when we first saw the landing target during search */\n+\tuint64_t _point_reached_time{0}; /**< time when we reached a setpoint */\n+\n+\tint _search_cnt{0}; /**< counter of how many times we had to search for the landing target */\n+\tfloat _approach_alt{0.0f}; /**< altitude at which to stay during horizontal approach */\n+\n+\tmatrix::Vector2f _sp_pev;\n+\tmatrix::Vector2f _sp_pev_prev;\n+\n+\tPrecLoiterState _state{PrecLoiterState::Start};\n+\n+\tfloat _height_above_target{};\n+\n+\tbool _is_activated {false}; /**< indicates if precloiter is activated */\n+\n+\tDEFINE_PARAMETERS(\n+\t\t(ParamFloat<px4::params::PLD_BTOUT>) _param_pld_btout,\n+\t\t(ParamFloat<px4::params::PLD_HACC_RAD>) _param_pld_hacc_rad,\n+\t\t(ParamFloat<px4::params::PLD_FAPPR_ALT>) _param_pld_fappr_alt,\n+\t\t(ParamFloat<px4::params::PLD_SRCH_ALT>) _param_pld_srch_alt,\n+\t\t(ParamFloat<px4::params::PLD_SRCH_TOUT>) _param_pld_srch_tout,\n+\t\t(ParamInt<px4::params::PLD_MAX_SRCH>) _param_pld_max_srch,\n+\t\t(ParamFloat<px4::params::PLD_YAW_DELTA>) _param_pld_yaw_delta\n+\t)\n+\n+\t// non-navigator parameters\n+\tparam_t\t_handle_param_acceleration_hor{PARAM_INVALID};\n+\tparam_t\t_handle_param_xy_vel_cruise{PARAM_INVALID};\n+\tfloat\t_param_acceleration_hor{0.0f};\n+\tfloat\t_param_xy_vel_cruise{0.0f};\n+\n+};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Fprecloiter.h"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "patch": "@@ -117,6 +117,16 @@ void RtlMissionFast::setActiveMissionItems()\n \t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n \t\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n \n+\t\t} else if (_mission_item.nav_cmd == NAV_CMD_DO_PRECISION_HOLD && :\n+\t\t\t_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT &&\n+\t\t\tnew_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n+\n+\t\t\tPX4_INFO(\"Processing NAV_CMD_DO_PRECISION_HOLD\");\n+\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_PRECISION_LOITER;\n+\t\t\t_mission_item.autocontinue = true;\n+\t\t\t_navigator->get_precloiter()->set_height_above_target(_mission_item.params[0]); // Set the height above target\n+\t\t\t_navigator->get_precloiter()->on_activation();\n+\n \t\t} else {\n \t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n \t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6269b46374cbbe7b98b8cbb425a0935008d79f09/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::checkMissionItemValidity",
        "Mission::setActiveMissionItems",
        "MissionBase::on_inactivation",
        "Navigator::Navigator",
        "MissionBase::on_active",
        "MissionBlock::is_mission_item_reached_or_completed",
        "RtlMissionFast::setActiveMissionItems"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkMissionItemValidity"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::setActiveMissionItems"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::on_inactivation"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::Navigator"
        ],
        "src/modules/navigator/rtl_mission_fast.cpp": [
          "RtlMissionFast::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "mission_base: fix to set the end of mission item on error",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23000",
    "number": 23000,
    "created_at": "2024-04-10T08:42:10Z",
    "merged": true,
    "merged_at": "2024-04-11T08:21:52Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nThe UAV could make a fly away, if a mission could not be started but the mission was still declared valid.\r\n\r\n### Solution\r\n- Make sure to properly set a loiter item or idle item, when a mission can't be started or the current mission item could not be loaded\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Prevent flyaway when an in air mission could not be started and the mission item could not be properly loaded\r\n```\r\n### Test coverage\r\n- Simulation test: Tested on gazebo-classic_standard_vtol\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-04-11T08:21:45Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect runtime behavior caused by improper state handling: a mission remained marked valid even when it couldn't be started or a mission item couldn't be loaded, allowing the vehicle to continue with unintended navigation (flyaway). Ensuring a loiter/idle end-of-mission item on error corrects the program logic and prevents the unintended state transition.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 9,
        "changes": 29,
        "patch": "@@ -356,7 +356,7 @@ MissionBase::on_active()\n \n void MissionBase::update_mission()\n {\n-\tif (_mission.count == 0u || !_is_current_planned_mission_item_valid || !_navigator->get_mission_result()->valid) {\n+\tif (_mission.count == 0u || !_is_current_planned_mission_item_valid || !isMissionValid()) {\n \t\tif (_land_detected_sub.get().landed) {\n \t\t\t/* landed, refusing to take off without a mission */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, refusing takeoff\\t\");\n@@ -441,24 +441,33 @@ MissionBase::advance_mission()\n void\n MissionBase::set_mission_items()\n {\n-\tif (_is_current_planned_mission_item_valid) {\n+\tbool set_end_of_mission{false};\n+\n+\tif (_is_current_planned_mission_item_valid && _mission_type == MissionType::MISSION_TYPE_MISSION && isMissionValid()) {\n \t\t/* By default set the mission item to the current planned mission item. Depending on request, it can be altered. */\n-\t\tloadCurrentMissionItem();\n+\t\tif (loadCurrentMissionItem()) {\n+\t\t\t/* force vtol land */\n+\t\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n+\t\t\t}\n \n-\t\t/* force vtol land */\n-\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n-\t\t}\n+\t\t\tsetActiveMissionItems();\n \n-\t\tsetActiveMissionItems();\n+\t\t} else {\n+\t\t\tset_end_of_mission = true;\n+\t\t}\n \n \t} else {\n+\t\tset_end_of_mission = true;\n+\t}\n+\n+\tif (set_end_of_mission) {\n \t\tsetEndOfMissionItems();\n \t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION);\n \t}\n }\n \n-void MissionBase::loadCurrentMissionItem()\n+bool MissionBase::loadCurrentMissionItem()\n {\n \tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission.mission_dataman_id);\n \tbool success = _dataman_cache.loadWait(dm_item, _mission.current_seq, reinterpret_cast<uint8_t *>(&_mission_item),\n@@ -469,6 +478,8 @@ void MissionBase::loadCurrentMissionItem()\n \t\tevents::send(events::ID(\"mission_item_set_failed\"), events::Log::Error,\n \t\t\t     \"Mission item could not be set\");\n \t}\n+\n+\treturn success;\n }\n \n void MissionBase::setEndOfMissionItems()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1250010ea0a39a66f3c111c46857c802f9aa3060/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -250,8 +250,9 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t * @brief Load current mission item\n \t *\n \t * Load current mission item from dataman cache.\n+\t * @return true, if the mission item could be loaded, false otherwise\n \t */\n-\tvoid loadCurrentMissionItem();\n+\tbool loadCurrentMissionItem();\n \n \t/**\n \t * Set the mission result",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1250010ea0a39a66f3c111c46857c802f9aa3060/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_active",
        "MissionBase::advance_mission",
        "loadCurrentMissionItem",
        "MissionBase::loadCurrentMissionItem"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::advance_mission",
          "MissionBase::loadCurrentMissionItem"
        ],
        "src/modules/navigator/mission_base.h": [
          "loadCurrentMissionItem"
        ]
      }
    }
  },
  {
    "title": "FeasibilityChecks: MIS_TKO_LAND_REQ=5: only require both or neither TO/LND when landed",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22985",
    "number": 22985,
    "created_at": "2024-04-05T14:40:38Z",
    "merged": true,
    "merged_at": "2024-04-09T11:24:46Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nWith MIS_TKO_LAND_REQ=5, it required a takeoff and a land or neither also when in air and there was a valid home/safe point approach. This is wrong, and it only should require that when on the ground.\r\n\r\n### Solution\r\nFix logic, only handle hasMissionBothOrNeitherTakeoffAndLanding() if on ground if MIS_TKO_LAND_REQ=5, in air and without safe approach only check for landing.\r\n\r\n### Changelog Entry\r\nFor release notes: \r\n```\r\nBugfix: FeasibilityChecks: MIS_TKO_LAND_REQ=5: only require both or neither TO/LND when landed\r\n```\r\n\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-04-09T10:22:37Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect conditional logic in feasibility checks: MIS_TKO_LAND_REQ=5 was enforcing 'both or neither takeoff/landing' even when the vehicle was already airborne (with a valid safe/home approach), which is unintended. This is a logic bug (wrong conditional/state handling), and the change restricts that requirement to when the vehicle is on the ground, restoring the intended behavior.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -587,17 +587,17 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \t\tbreak;\n \n \tcase 5:\n-\t\tif (!_is_landed && !_has_vtol_approach) {\n+\t\tif (_is_landed) {\n+\t\t\tresult = hasMissionBothOrNeitherTakeoffAndLanding();\n+\n+\t\t} else if (!_has_vtol_approach) {\n \t\t\tresult = _landing_valid;\n \n \t\t\tif (!result) {\n \t\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Landing waypoint/pattern required.\");\n \t\t\t\tevents::send(events::ID(\"feasibility_mis_in_air_landing_req\"), {events::Log::Error, events::LogInternal::Info},\n \t\t\t\t\t     \"Mission rejected: Landing waypoint/pattern required\");\n \t\t\t}\n-\n-\t\t} else {\n-\t\t\tresult = hasMissionBothOrNeitherTakeoffAndLanding();\n \t\t}\n \n \t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/28085b2f18e70be5ab3f597dd87f1132e0ce1b2d/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -68,7 +68,7 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n  * @value 2 Require a landing\n  * @value 3 Require a takeoff and a landing\n  * @value 4 Require both a takeoff and a landing, or neither\n- * @value 5 Same as previous, but require a landing if in air and no valid VTOL landing approach is present\n+ * @value 5 Same as previous when landed, in-air require landing only if no valid VTOL approach is present\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_TKO_LAND_REQ, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/28085b2f18e70be5ab3f597dd87f1132e0ce1b2d/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -266,7 +266,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tint get_loiter_min_alt() const { return _param_min_ltr_alt.get(); }\n \tint get_landing_abort_min_alt() const { return _param_mis_lnd_abrt_alt.get(); }\n \tfloat get_param_mis_takeoff_alt() const { return _param_mis_takeoff_alt.get(); }\n-\tint  get_takeoff_land_required() const { return _para_mis_takeoff_land_req.get(); }\n \tfloat get_yaw_timeout() const { return _param_mis_yaw_tmt.get(); }\n \tfloat get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n \n@@ -406,7 +405,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \t\t// non-navigator parameters: Mission (MIS_*)\n \t\t(ParamFloat<px4::params::MIS_TAKEOFF_ALT>) _param_mis_takeoff_alt,\n-\t\t(ParamInt<px4::params::MIS_TKO_LAND_REQ>)  _para_mis_takeoff_land_req,\n \t\t(ParamFloat<px4::params::MIS_YAW_TMT>)     _param_mis_yaw_tmt,\n \t\t(ParamFloat<px4::params::MIS_YAW_ERR>)     _param_mis_yaw_err,\n \t\t(ParamFloat<px4::params::MIS_PD_TO>)       _param_mis_payload_delivery_timeout,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/28085b2f18e70be5ab3f597dd87f1132e0ce1b2d/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      }
    },
    "modified_functions": {
      "all": [
        "get_takeoff_land_required",
        "FeasibilityChecker::checkTakeoffLandAvailable"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkTakeoffLandAvailable"
        ],
        "src/modules/navigator/navigator.h": [
          "get_takeoff_land_required"
        ]
      }
    }
  },
  {
    "title": "RTL: fix corner case where vehicle loiters in place instead of doing the RTL to Home",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/22984",
    "number": 22984,
    "created_at": "2024-04-05T13:57:58Z",
    "merged": true,
    "merged_at": "2024-04-11T11:47:17Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nWith `RTL_TYPE=0` and `RTL_APPR_FORCE=1`, the logic in [RTL::findRtlDestination()](https://github.com/PX4/PX4-Autopilot/blob/4d0a88fdf8745c02f19f4142f0e98765a0a47b02/src/modules/navigator/rtl.cpp#L402-L403) does not check if the mission is valid, only if the mission has a valid land item. If the mission is not valid, it will result in anyway switching into the Mission RTL, only to then find that the mission is invalid and loiter at place instead of returning. \r\n\r\n### Solution\r\n Instead of adding an additional check for the mission validity there, the proposal here is to not return `hasMissionLandStart()` as true.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: RTL: fix corner case where vehicle loiters in place instead of doing the RTL to Home.\r\n```\r\n\r\n### Alternatives\r\nAdd a check for mission validity in https://github.com/PX4/PX4-Autopilot/blob/4d0a88fdf8745c02f19f4142f0e98765a0a47b02/src/modules/navigator/rtl.cpp#L402-L403\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-04-11T11:44:59Z",
          "body": "> If the mission is still evaluated valid although it is invalid (e.g. through mission checker parameter change) It will use the mission landing because the mission is not evaluated anymore (For a mission though it will enter mission mode, but then loiter as it wont execute the mission).\r\n\r\nCorner case though is that when you try to start an invalid mission it will then keep the mission invalidated, meaning that it won't use if for the RTL neither. \r\nBut as you said, to cleanly solve that we need to restructure a lot, and basically split up the landing part of a mission from the main mission body.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-04-09T10:19:40Z",
          "body": "The changes do not fix the issue. The RTL has another function here https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/navigator/rtl.cpp#L618-L621 You would need to fix this function. But both the RTL and the mission_base should have the same logic in the function. Maybe a library function would be better here.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-04-11T10:39:44Z",
          "body": "LGTM. Current behavior as i tested it:\r\n- If a mission was evaluated invalid, it wont choose the mission landing. If there is no valid RTL point available, it will fly back to takeoff\r\n- If the mission is valid and the RTL_type right, it will use the mission landing\r\n- If the mission is still evaluated valid although it is invalid (e.g. through mission checker parameter change) It will use the mission landing because the mission is not evaluated anymore (For a mission though it will enter mission mode, but then loiter as it wont execute the mission).\r\nAll the above seems ok for me, as a fix for the last point would need some restructuring on how the mission checker is performed.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR corrects incorrect RTL selection logic: the code previously used hasMissionLandStart() without ensuring the mission itself was valid, causing the vehicle to enter Mission RTL then loiter when the mission proved invalid. The change prevents treating an invalid mission as a valid mission-landing start, which fixes the reported incorrect behavior, though reviewers note a related code path may also need the same check.",
    "patches": {
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -118,12 +118,12 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvoid getNextPositionItems(int32_t start_index, int32_t items_index[], size_t &num_found_items,\n \t\t\t\t  uint8_t max_num_items);\n \t/**\n-\t * @brief Has Mission a Land Start or Land Item\n+\t * @brief Mission has a land start, a land, and is valid\n \t *\n-\t * @return true If mission has a land start of land item and a land item\n+\t * @return true If mission has a land start and a land item and is valid\n \t * @return false otherwise\n \t */\n-\tbool hasMissionLandStart() const { return _mission.land_start_index >= 0 && _mission.land_index >= 0;};\n+\tbool hasMissionLandStart() const { return _mission.land_start_index >= 0 && _mission.land_index >= 0 && isMissionValid();};\n \t/**\n \t * @brief Go to next Mission Item\n \t * Go to next non jump mission item",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c7f61dc08db3fe339a757ac8c0da7fffc3dfb2ed/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -617,7 +617,8 @@ void RTL::parameters_update()\n \n bool RTL::hasMissionLandStart() const\n {\n-\treturn _mission_sub.get().land_start_index >= 0 && _mission_sub.get().land_index >= 0;\n+\treturn _mission_sub.get().land_start_index >= 0 && _mission_sub.get().land_index >= 0\n+\t       && _navigator->get_mission_result()->valid;\n }\n \n bool RTL::hasVtolLandApproach(const PositionYawSetpoint &rtl_position) const",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c7f61dc08db3fe339a757ac8c0da7fffc3dfb2ed/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -97,6 +97,11 @@ class RTL : public NavigatorMode, public ModuleParams\n \t};\n \n private:\n+\n+\t/**\n+\t * @brief Check mission landing validity\n+\t * @return true if mission has a land start, a land and is valid\n+\t */\n \tbool hasMissionLandStart() const;\n \n \t/**",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c7f61dc08db3fe339a757ac8c0da7fffc3dfb2ed/src%2Fmodules%2Fnavigator%2Frtl.h"
      }
    },
    "modified_functions": {
      "all": [
        "hasMissionLandStart",
        "RTL::parameters_update"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.h": [
          "hasMissionLandStart"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::parameters_update"
        ]
      }
    }
  },
  {
    "title": "[RFC] Remove IDLE",
    "url": "https://githuapi_pr_build.pyb.com/PX4/PX4-Autopilot/pull/23704",
    "number": 23704,
    "created_at": "2024-09-20T16:24:39Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "sfuhrer",
      "body": "Remove `position_setpoint_s::SETPOINT_TYPE_IDLE` and handling for `mission_item.nav_cmd::NAV_CMD_IDLE` (which doesn't seem to exist on MAVLink anyway?).\r\n\r\n### Solved Problem\r\nWe has many issues with IDLE, because it's a not well defined waypoint type. That was one of them: https://github.com/PX4/PX4-Autopilot/pull/22114. And it came up again in https://github.com/PX4/PX4-Autopilot/pull/23681. \r\nLetting Navigator decide on whether to publish a IDLE or POSITION setpoint based on land_detection is quite fragile and prone for race conditions, so I would rather have Navigator publish only real position setpoints and add logic in the controllers to idle the motors if needed.\r\n\r\n\r\n### Solution\r\nRemove IDLE.\r\nInstead it should be the controllers responsibility to not spin up the motors if landed and not in a mode that allows takeoff (takeoff mode/type or in a manual control mode, but certainly not in Loiter). That is already done for MC, and with 5a38ad7dfb38a5a766fd4f9581611894a50a4840 I added this also to FW. \r\n\r\n\r\n### Test coverage\r\nI tested only very basic things in SITL yet, like \r\n- arming in Loiter mode (motors should not go above idle)\r\n- MC takeoff and RTL (motors should cleanly ramp down)",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-09-20T16:26:35Z",
          "body": "Not sure if needed - maybe we can only do `setEndOfMissionItems() `if !landed?",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 8,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-20T16:28:07Z",
          "body": "Can a takeoff item even be reached if landed? This may need some hardening again.",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2024-09-23T12:42:04Z",
          "body": "As is now preserves the previous behavior no?\r\n",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 8,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-09-20T16:26:36Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-20T16:28:07Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2024-09-23T12:41:34Z",
          "body": "Thanks! I think this in the right direction.\r\n\r\nWas always wondering what IDLE as a waypoint item should do anyway.",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2024-09-23T12:42:04Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR removes an ill-defined 'IDLE' setpoint type whose handling caused fragile behavior and race conditions between Navigator and controllers. Moving the responsibility for idling motors into the controllers and only publishing concrete position setpoints eliminates improper state transitions and inconsistent behavior, which is a classic logic error fix.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "patch": "@@ -248,8 +248,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \t}\n \n \t// check if we find unsupported items and reject mission if so\n-\tif (mission_item.nav_cmd != NAV_CMD_IDLE &&\n-\t    mission_item.nav_cmd != NAV_CMD_WAYPOINT &&\n+\tif (mission_item.nav_cmd != NAV_CMD_WAYPOINT &&\n \t    mission_item.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n \t    mission_item.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n \t    mission_item.nav_cmd != NAV_CMD_RETURN_TO_LAUNCH &&\n@@ -346,8 +345,7 @@ bool FeasibilityChecker::checkTakeoff(mission_item_s &mission_item)\n \t}\n \n \tif (!_found_item_with_position) {\n-\t\t_found_item_with_position = (mission_item.nav_cmd != NAV_CMD_IDLE &&\n-\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DELAY &&\n+\t\t_found_item_with_position = (mission_item.nav_cmd != NAV_CMD_DELAY &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_JUMP &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_CHANGE_SPEED &&\n \t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_HOME &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -97,7 +97,6 @@ Land::on_active()\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n \t\t_navigator->mode_completed(getNavigatorStateId());\n-\t\tset_idle_item(&_mission_item);\n \n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 31,
        "changes": 45,
        "patch": "@@ -76,45 +76,28 @@ Loiter::on_active()\n void\n Loiter::set_loiter_position()\n {\n-\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n-\t    _navigator->get_land_detected()->landed) {\n-\n-\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n-\t\t// setpoint as invalid and idle (both, just to be sure).\n-\n-\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n-\t\t_navigator->set_position_setpoint_triplet_updated();\n-\t\treturn;\n-\n-\t}\n \n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\tif (_navigator->get_land_detected()->landed) {\n-\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n+\t// Check if we already loiter on a circle and are on the loiter pattern.\n+\tbool on_loiter{false};\n \n-\t} else {\n-\t\t// Check if we already loiter on a circle and are on the loiter pattern.\n-\t\tbool on_loiter{false};\n-\n-\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER\n-\t\t    && pos_sp_triplet->current.loiter_pattern == position_setpoint_s::LOITER_TYPE_ORBIT) {\n-\t\t\tconst float d_current = get_distance_to_next_waypoint(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon,\n-\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n-\t\t\ton_loiter = d_current <= (_navigator->get_acceptance_radius() + pos_sp_triplet->current.loiter_radius);\n-\n-\t\t}\n+\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER\n+\t    && pos_sp_triplet->current.loiter_pattern == position_setpoint_s::LOITER_TYPE_ORBIT) {\n+\t\tconst float d_current = get_distance_to_next_waypoint(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon,\n+\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\t\ton_loiter = d_current <= (_navigator->get_acceptance_radius() + pos_sp_triplet->current.loiter_radius);\n \n-\t\tif (on_loiter) {\n-\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t}\n \n-\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n+\tif (on_loiter) {\n+\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n \n-\t\t} else {\n-\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n-\t\t}\n+\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n \n+\t} else {\n+\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n \t}\n \n \t// convert mission item to current setpoint",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "patch": "@@ -535,10 +535,8 @@ void MissionBase::setEndOfMissionItems()\n {\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\tif (_land_detected_sub.get().landed) {\n-\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n-\n-\t} else {\n+\t// set a loiter item if not landed\n+\tif (!_land_detected_sub.get().landed) {\n \t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n \t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "patch": "@@ -102,7 +102,6 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tcase NAV_CMD_VTOL_LAND:\n \t\treturn _navigator->get_land_detected()->landed;\n \n-\tcase NAV_CMD_IDLE: /* fall through */\n \tcase NAV_CMD_LOITER_UNLIMITED:\n \t\treturn false;\n \n@@ -685,9 +684,6 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tsp->gliding_enabled = (_navigator->get_cruising_throttle() < FLT_EPSILON);\n \n \tswitch (item.nav_cmd) {\n-\tcase NAV_CMD_IDLE:\n-\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n-\t\tbreak;\n \n \tcase NAV_CMD_TAKEOFF:\n \tcase NAV_CMD_VTOL_TAKEOFF:\n@@ -844,22 +840,6 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \titem->origin = ORIGIN_ONBOARD;\n }\n \n-void\n-MissionBlock::set_idle_item(struct mission_item_s *item)\n-{\n-\titem->nav_cmd = NAV_CMD_IDLE;\n-\titem->lat = _navigator->get_home_position()->lat;\n-\titem->lon = _navigator->get_home_position()->lon;\n-\titem->altitude_is_relative = false;\n-\titem->altitude = _navigator->get_home_position()->alt;\n-\titem->yaw = NAN;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n-\titem->acceptance_radius = _navigator->get_acceptance_radius();\n-\titem->time_inside = 0.0f;\n-\titem->autocontinue = true;\n-\titem->origin = ORIGIN_ONBOARD;\n-}\n-\n void\n MissionBlock::set_vtol_transition_item(struct mission_item_s *item, const uint8_t new_mode)\n {\n@@ -1030,7 +1010,6 @@ void MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet(mission_i\n \n \tif (_navigator->get_nav_min_gnd_dist_param() > FLT_EPSILON && _mission_item.nav_cmd != NAV_CMD_LAND\n \t    && _mission_item.nav_cmd != NAV_CMD_VTOL_LAND && _mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION\n-\t    && _mission_item.nav_cmd != NAV_CMD_IDLE\n \t    && _navigator->get_local_position()->dist_bottom_valid\n \t    && _navigator->get_local_position()->dist_bottom < _navigator->get_nav_min_gnd_dist_param()\n \t    && _navigator->get_local_position()->vz > FLT_EPSILON",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "patch": "@@ -197,11 +197,6 @@ class MissionBlock : public NavigatorMode\n \t */\n \tvoid set_land_item(struct mission_item_s *item);\n \n-\t/**\n-\t * Set idle mission item\n-\t */\n-\tvoid set_idle_item(struct mission_item_s *item);\n-\n \t/**\n \t * Set vtol transition item\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -60,7 +60,6 @@\n \n /* compatible to mavlink MAV_CMD */\n enum NAV_CMD {\n-\tNAV_CMD_IDLE = 0,\n \tNAV_CMD_WAYPOINT = 16,\n \tNAV_CMD_LOITER_UNLIMITED = 17,\n \tNAV_CMD_LOITER_TIME_LIMIT = 19,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -1176,7 +1176,7 @@ void Navigator::reset_position_setpoint(position_setpoint_s &sp)\n \tsp.cruising_speed = get_cruising_speed();\n \tsp.cruising_throttle = get_cruising_throttle();\n \tsp.valid = false;\n-\tsp.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n+\tsp.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n \tsp.loiter_direction_counter_clockwise = false;\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -352,7 +352,6 @@ void RtlDirect::set_rtl_item()\n \t\t}\n \n \tcase RTLState::IDLE: {\n-\t\t\tset_idle_item(&_mission_item);\n \t\t\t_navigator->mode_completed(getNavigatorStateId());\n \t\t\tbreak;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "patch": "@@ -72,17 +72,11 @@ Takeoff::on_active()\n \n \t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t\t// set loiter item so position controllers stop doing takeoff logic\n-\t\tif (_navigator->get_land_detected()->landed) {\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n+\t\tif (pos_sp_triplet->current.valid) {\n+\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n \n \t\t} else {\n-\t\t\tif (pos_sp_triplet->current.valid) {\n-\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n-\n-\t\t\t} else {\n-\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n-\t\t\t}\n+\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n \t\t}\n \n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/5a38ad7dfb38a5a766fd4f9581611894a50a4840/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::setEndOfMissionItems",
        "set_idle_item",
        "FeasibilityChecker::checkTakeoff",
        "Land::on_active",
        "FeasibilityChecker::checkMissionItemValidity",
        "Loiter::on_active",
        "MissionBlock::set_land_item",
        "RtlDirect::set_rtl_item",
        "Takeoff::on_active",
        "Navigator::reset_position_setpoint",
        "MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet",
        "MissionBlock::is_mission_item_reached_or_completed",
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkMissionItemValidity",
          "FeasibilityChecker::checkTakeoff"
        ],
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ],
        "src/modules/navigator/loiter.cpp": [
          "Loiter::on_active"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::setEndOfMissionItems"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet",
          "MissionBlock::is_mission_item_reached_or_completed",
          "MissionBlock::set_land_item",
          "MissionBlock::mission_item_to_position_setpoint"
        ],
        "src/modules/navigator/mission_block.h": [
          "set_idle_item"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::reset_position_setpoint"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Bugfix: unexpected vertical deceleration and acceleration during multicopter RTL final land phase",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23689",
    "number": 23689,
    "created_at": "2024-09-18T14:49:29Z",
    "merged": true,
    "merged_at": "2024-09-23T16:33:03Z",
    "state": "closed",
    "conversation": {
      "author": "MaEtUgR",
      "body": "### Solved Problem\r\nTest report: Strange-looking vertical deceleration and acceleration during the final landing phase of a multicopter RTL.\r\nVisible in the log, reproducible in default SITL SIH:\r\n![image](https://github.com/user-attachments/assets/8c6966a2-c5bd-45b4-be9e-2e7167959ebd)\r\nTurns out it's because there are additional mission items at the RTL loiter altitude `RTL_DESCEND_ALT`\r\n![image](https://github.com/user-attachments/assets/75064a73-1f45-48e3-b78b-5b11874f5268)\r\n\r\n### Solution\r\nSkip the RTL states between flight to home/rally point and land if there is no delay configured `RTL_LAND_DELAY = 0` (default).\r\n\r\nThis was already done\r\nhttps://github.com/PX4/PX4-Autopilot/blob/26fd4c852c52837e306790e0f86b27d0b0df516e/src/modules/navigator/rtl_direct.cpp#L432-L444\r\nbefore the refactor https://github.com/PX4/PX4-Autopilot/pull/21049 and was assumed not to be necessary anymore.\r\n\r\nNote: To not break the VTOL and fixed-wing use case I had to make sure the states are can only get skipped for multirotors (or a VTOL returning as multicopter). I checked in with @KonradRudin and the additional mission items do not cause problems when flying as fixed wing even if there's no delay between them.\r\n\r\n### Changelog Entry\r\n```\r\nBugfix: unexpected vertical deceleration and acceleration durn multicopter RTL final land phase\r\n```\r\n\r\n### Alternatives\r\nI'd like to eventually break out multicopter RTL from navigator. The execution should just receive the target land location and turn out rather simple and not conflicting with other vehicle types.\r\n\r\n### Test coverage\r\nI ran a multicopter only test in SITL SIH and the states are skipped, mission items not present hence slow down resolved:\r\n![image](https://github.com/user-attachments/assets/bc32e757-2618-4f53-87d3-ea1caab30378)\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "DronecodeBot",
          "created_at": "2024-09-18T15:46:36Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-sync-q-a-sep-18-2024/40762/1\n",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-09-19T02:41:15Z",
          "body": "It came to my mind that before there was a `DESCEND` state which now we're skipping completely. This could have the implications:\r\n1. ~Slower land speed from higher up~ disproven\r\n2. Nudging possible from higher up - confirmed but I don't see an issue with that\r\n3. RTL time estimate being calculated wrong - I checked and it looks completely broken for multicopter, the time increases linearly after reaching the horizontal home point while descending but independently from this PR ðŸ¤¦I guess there are more bugs that slipped in from the RTL refactor.\r\n\r\nSo I guess I have to check more things than it just the vertical speed dip being gone âœ… ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-09-23T16:32:04Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect RTL state handling that was introduced by a refactor. The navigator was leaving/adding RTL mission states (and mission items at the RTL loiter altitude) even when no land delay was configured, causing unintended vertical deceleration/acceleration; restoring the prior skip logic for multicopters fixes an improper state transition / unintended behavior (a classic logic bug).",
    "patches": {
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "patch": "@@ -157,6 +157,10 @@ void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s\n \n void RtlDirect::_updateRtlState()\n {\n+\t// RTL_LAND_DELAY > 0 -> wait seconds, < 0 wait indefinitely\n+\tconst bool wait_at_rtl_descend_alt = fabsf(_param_rtl_land_delay.get()) > FLT_EPSILON;\n+\tconst bool is_multicopter = (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING);\n+\n \tRTLState new_state{RTLState::IDLE};\n \n \tswitch (_rtl_state) {\n@@ -165,7 +169,13 @@ void RtlDirect::_updateRtlState()\n \t\tbreak;\n \n \tcase RTLState::MOVE_TO_LOITER:\n-\t\tnew_state = RTLState::LOITER_DOWN;\n+\t\tif (!is_multicopter || wait_at_rtl_descend_alt) {\n+\t\t\tnew_state = RTLState::LOITER_DOWN;\n+\n+\t\t} else {\n+\t\t\tnew_state = RTLState::LAND;\n+\t\t}\n+\n \t\tbreak;\n \n \tcase RTLState::LOITER_DOWN:\n@@ -206,7 +216,6 @@ void RtlDirect::_updateRtlState()\n \t}\n \n \t_rtl_state = new_state;\n-\n }\n \n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/dff8f198dd2136b7832ab8b9c5bd7effb35d22f4/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirect::setRtlPosition",
        "RtlDirect::_updateRtlState"
      ],
      "by_file": {
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::setRtlPosition",
          "RtlDirect::_updateRtlState"
        ]
      }
    }
  },
  {
    "title": "rtl_direct: loiter hold should track altitude as best effort ",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23688",
    "number": 23688,
    "created_at": "2024-09-18T12:15:33Z",
    "merged": true,
    "merged_at": "2024-09-23T09:02:02Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen during the RTL loiter down, the terrain avoidance is triggered and the vehicle is kept on an altitude higher than the indented one, it will try to sink to the indented altitude again at the end of the loiter. This is due to the loiter hold after the loiter down enforcing the altitude again.\r\n\r\n### Solution\r\n- The loiter hold should only track the altitude as best effort but accept any altitude error. it should only check on the loiter time.\r\n- Also make sure that the loiter hold forces the heading if necessary. Not an issue per se but it was only implicitely set from the prior mission item\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix After RTL terrain avoidance is triggered during the loiter down, make sure to not try to sink again before proceeding to the land destination\r\n```\r\n\r\n### Test coverage\r\n- SITL testing: Tested in sitl with faking an altitude difference by setting the loiter hold altitude lower than the loiter down altitude in the code\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-09-18T14:10:30Z",
          "body": "that was a separate issue?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 18,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-18T14:12:12Z",
          "body": "Remind me again - with NAN it uses the default altitude acceptance radius?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 28,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-18T14:15:13Z",
          "body": "Yes, if it is NAN it uses the default one set from the params.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 28,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-18T14:15:36Z",
          "body": "Which one?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 18,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-18T14:46:46Z",
          "body": "forcing the heading - all good, the change makes sense.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 18,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-23T08:08:58Z",
          "body": " Split the commit and added a small comment in the PR description to clarify it.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 18,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-23T09:25:34Z",
          "body": "perfect thanks for the diligence!",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 18,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-09-18T14:12:16Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-18T14:15:13Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-18T14:15:36Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-18T14:45:14Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-18T14:46:46Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-23T08:08:58Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-23T09:25:35Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect behavior in the RTL loiter/state logic where the loiter-hold step rigidly re-enforced a target altitude (causing an undesired sink after terrain avoidance). The change makes altitude tracking best-effort and only enforces checks at loiter time (and explicitly handles heading), which fixes the improper state transition/constraint enforcement causing the bug.",
    "patches": {
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -220,6 +220,8 @@ void RtlDirect::set_rtl_item()\n \n \tconst bool is_close_to_destination = destination_dist < _param_rtl_min_dist.get();\n \n+\tfloat altitude_acceptance_radius = static_cast<float>(NAN);\n+\n \tswitch (_rtl_state) {\n \tcase RTLState::CLIMBING: {\n \t\t\tPositionYawSetpoint pos_yaw_sp {\n@@ -293,6 +295,14 @@ void RtlDirect::set_rtl_item()\n \t\t\tif (_param_rtl_land_delay.get() < -FLT_EPSILON) {\n \t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: completed, loitering\\t\");\n \t\t\t\tevents::send(events::ID(\"rtl_completed_loiter\"), events::Log::Info, \"RTL: completed, loitering\");\n+\n+\t\t\t} else {\n+\t\t\t\t/* Set the altitude tracking to best effort but not strictly enforce it */\n+\t\t\t\taltitude_acceptance_radius = FLT_MAX;\n+\n+\t\t\t\tif (_force_heading) {\n+\t\t\t\t\t_mission_item.force_heading = true;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tbreak;\n@@ -370,6 +380,7 @@ void RtlDirect::set_rtl_item()\n \t} else {\n \t\t// Convert mission item to current position setpoint and make it valid.\n \t\tif (mission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current)) {\n+\t\t\tpos_sp_triplet->current.alt_acceptance_radius = altitude_acceptance_radius;\n \t\t\t_navigator->set_position_setpoint_triplet_updated();\n \t\t}\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eb616e585e5e5a9988da351d126343bfeeca4cb4/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirect::set_rtl_item"
      ],
      "by_file": {
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "MPC: LAND: Split Landing out of FlightTaskAuto into FlightTaskLand",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23678",
    "number": 23678,
    "created_at": "2024-09-17T07:18:43Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "Claudio-Chies",
      "body": "### Solved Problem\r\n![image](https://github.com/user-attachments/assets/53c3d369-0eb0-4fa2-b05b-d5ef18549eaf)\r\nThe https://github.com/PX4/PX4-Autopilot/pull/23546 did not consider the case when we trigger land from Altitude or Manual FlightTask, where the commanded velocity can greatly exceed the velocity possible in FlightTaskAuto.\r\n\r\n### Solution\r\n- Creation of a Landing Flighttask\r\n- adding of a \"stop\" motion primitive, to slow down the vehicle to a complete stop given any initial velocity.\r\n\r\nWith this PR, we are splitting the Landing Logic into a separate FlighTask called FlightTaskLand, and handle the landing logic in there.\r\n\r\n**Test on Hardware**\r\n![image](https://github.com/user-attachments/assets/4f15e07c-608a-47b0-95ad-ea19be01f96e)\r\n\r\n<img src=\"https://github.com/user-attachments/assets/1331ba76-75be-4d22-9ebd-65180d920ac1\" width=500/>\r\n\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Multicopter vehicles slow down smoothly when transitioning from a manual flight mode to the landing flight mode.\r\n```\r\n### Dependent PR's\r\nhttps://github.com/PX4/PX4-Autopilot/pull/23757 documents the part of temporarily extending the speed limits when already entering the mode too fast.\r\n\r\n### Test coverage\r\n\r\n- [X] Tested in SITL [Flightreview](https://review.px4.io/plot_app?log=ad18fd14-cff7-4b45-8875-d401d5e5cd1e)\r\n- [X] Tested on Hardware [Flightreview](https://review.px4.io/plot_app?log=fe1828df-1b2a-4b91-bbaf-d97acc3aa18c)\r\n",
      "issue_comments": [
        {
          "author": "dakejahl",
          "created_at": "2024-09-17T19:00:29Z",
          "body": "I wonder how does this effect PrecisionLand? The precland logic lives in [navigator as a submode](https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/navigator/navigator_main.cpp#L87-L94), and I believe puts the vehicle into FlightTaskAuto with a land setpoint type. Something to keep in mind!",
          "type": "issue_comment"
        },
        {
          "author": "Claudio-Chies",
          "created_at": "2024-09-30T09:34:37Z",
          "body": "@dakejahl \r\n> I wonder how does this effect PrecisionLand? The precland logic lives in [navigator as a submode](https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/navigator/navigator_main.cpp#L87-L94), and I believe puts the vehicle into FlightTaskAuto with a land setpoint type. Something to keep in mind!\r\n\r\nI now made it so that Landing Flightmode goes into FlightTaskLand, and Precision landing remains in FlightTaskAuto.\r\nThis way we can/should split out precision landing into its own flight task in the future, or also integrate it into FlightTaskLand.\r\n\r\nI wasn't able to also integrate precision landing into it, as i dont have the means to test it, and FlightTaskLand is currently not set up to handle movement around to setpoint triplets as FlightTaskAuto. it just brakes, and lands. ",
          "type": "issue_comment"
        },
        {
          "author": "github-actions[bot]",
          "created_at": "2024-12-16T14:35:44Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 3560 byte (0.17 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.2% +3.48Ki  +0.2% +3.48Ki    .text\n    [NEW] +2.15Ki  [NEW] +2.15Ki    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +1.18Ki  [NEW] +1.18Ki    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +7.8%    +220  +7.8%    +220    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +0.1%    +157  +0.1%    +157    [section .text]\n    +0.8%     +28  +0.8%     +28    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.2%     +24  +0.2%     +24    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    +0.1%      +8  +0.1%      +8    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.6%      +4  +0.6%      +4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n    -0.6%      -2  -0.6%      -2    ../../src/modules/flight_mode_manager/tasks/Failsafe/FlightTaskFailsafe.cpp\n    -0.1%      -4  -0.1%      -4    ../../src/lib/collision_prevention/CollisionPrevention.cpp\n    -7.6%     -28  -7.6%     -28    ../../src/modules/navigator/land.cpp\n    -8.2%     -36  -8.2%     -36    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -14.3%    -228 -14.3%    -228    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n  +0.3% +5.88Ki  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    [NEW] +3.17Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +2.63Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.7%     +21  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.3%    +576  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    [NEW]    +376  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW]    +152  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n     +35%     +56  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.4% +1.66Ki  [ = ]       0    .debug_frame\n  +0.6%  +165Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%    +288  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.2%    +356  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.1%     +29  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/FlightTask/FlightTask.cpp\n    [NEW]  +105Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +57.0Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/mc_pos_control/GotoControl/GotoControl.cpp\n    +0.0%     +50  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    -0.1%     -30  [ = ]       0    ../../src/modules/navigator/land.cpp\n    -0.0%      -1  [ = ]       0    msg/topics_sources/uORBMessageFieldsGenerated.cpp\n    +0.1%     +13  [ = ]       0    msg/topics_sources/vehicle_constraints.cpp\n    +1.7% +2.10Ki  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.3% +15.6Ki  [ = ]       0    .debug_line\n    +0.1%      +2  [ = ]       0    ../../src/lib/motion_planning/ManualVelocitySmoothingZ.cpp\n    +0.0%      +1  [ = ]       0    ../../src/lib/tecs/TECS.cpp\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +1.1%    +122  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.5%    +110  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    [NEW] +9.00Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    +0.0%      +1  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp\n    [NEW] +6.00Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    -0.1%      -3  [ = ]       0    ../../src/modules/mc_pos_control/GotoControl/GotoControl.cpp\n    +0.2%     +42  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    -1.9%     -61  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +3.7%    +381  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    -0.3%      -3  [ = ]       0    task/task_cancelpt.c\n  +0.6% +34.5Ki  [ = ]       0    .debug_loc\n    +1.2%     +99  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +2.3% +1.10Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.0%     +16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    [NEW] +19.3Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    +0.7%    +186  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp\n    +0.0%      +2  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Transition/FlightTaskTransition.cpp\n    [NEW] +12.9Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.1%     +38  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    +0.0%    +118  [ = ]       0    [section .debug_loc]\n    +4.0%    +729  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.5% +6.82Ki  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +0.5%     +40  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    [NEW] +3.71Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +2.95Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.2%     +24  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n     +12%     +24  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +2.0%     +80  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +3.1%      +2  [ = ]       0    task/task_cancelpt.c\n  +0.0% +1.32Ki  [ = ]       0    .debug_str\n    +0.2%    +129  [ = ]       0    \n   -10.8%    -454  [ = ]       0    ../../src/lib/collision_prevention/CollisionPrevention.cpp\n    +0.1%    +108  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n   -13.4%    -404  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.2%      +9  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    +0.7%     +22  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Descend/FlightTaskDescend.cpp\n    -1.5%     -15  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/FlightTask/FlightTask.cpp\n    [NEW] +1.23Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    -5.9%     -23  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -3.8%     -62  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Transition/FlightTaskTransition.cpp\n    [NEW]     +45  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    -0.6%    -188  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    +0.0%      +7  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +4.4%    +917  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -1.0%      -2  [ = ]       0    .shstrtab\n  +0.2% +1.21Ki  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    +0.5%     +10  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    [NEW]    +890  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n   -30.9%    -184  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -26.8%    -219  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    [NEW]    +263  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.1%     +73  [ = ]       0    [section .strtab]\n     +52%    +441  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.2% +1.08Ki  [ = ]       0    .symtab\n    +1.2%     +16  [ = ]       0    ../../src/drivers/imu/analog_devices/adis16507/ADIS16507.cpp\n    -3.6%     -16  [ = ]       0    ../../src/lib/system_identification/system_identification.cpp\n    -8.8%     -80  [ = ]       0    ../../src/lib/version/version.c\n    +1.4%     +16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    [NEW]    +864  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n   -16.7%     -48  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -30.0%    -240  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    [NEW]    +256  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    -1.1%     -16  [ = ]       0    ../../src/modules/simulation/sensor_gps_sim/SensorGpsSim.cpp\n    +0.1%     +80  [ = ]       0    [section .symtab]\n     +33%     +16  [ = ]       0    msg/topics_sources/action_request.cpp\n     +36%    +256  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    -0.0%     -16  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n -21.4% -3.48Ki  [ = ]       0    [Unmapped]\n  +0.5%  +233Ki  +0.2% +3.48Ki    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 3560 byte (0.18 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.2% +3.48Ki  +0.2% +3.48Ki    .text\n    [NEW] +2.15Ki  [NEW] +2.15Ki    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +1.18Ki  [NEW] +1.18Ki    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +7.8%    +220  +7.8%    +220    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +0.1%    +157  +0.1%    +157    [section .text]\n    +0.8%     +28  +0.8%     +28    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.2%     +24  +0.2%     +24    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    +0.1%      +8  +0.1%      +8    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.6%      +4  +0.6%      +4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n    -0.6%      -2  -0.6%      -2    ../../src/modules/flight_mode_manager/tasks/Failsafe/FlightTaskFailsafe.cpp\n    -0.1%      -4  -0.1%      -4    ../../src/lib/collision_prevention/CollisionPrevention.cpp\n    -7.6%     -28  -7.6%     -28    ../../src/modules/navigator/land.cpp\n    -8.2%     -36  -8.2%     -36    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -14.3%    -228 -14.3%    -228    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n  +0.3% +5.88Ki  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    [NEW] +3.17Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +2.63Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.7%     +21  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.4%    +576  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    [NEW]    +376  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW]    +152  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n     +35%     +56  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.4% +1.66Ki  [ = ]       0    .debug_frame\n  +0.6%  +164Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%    +288  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.2%    +356  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.1%     +29  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/FlightTask/FlightTask.cpp\n    [NEW]  +104Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +56.6Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/mc_pos_control/GotoControl/GotoControl.cpp\n    +0.0%     +50  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    -0.1%     -30  [ = ]       0    ../../src/modules/navigator/land.cpp\n    -0.0%      -1  [ = ]       0    msg/topics_sources/uORBMessageFieldsGenerated.cpp\n    +0.1%     +13  [ = ]       0    msg/topics_sources/vehicle_constraints.cpp\n    +1.7% +2.10Ki  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.3% +15.6Ki  [ = ]       0    .debug_line\n    +0.1%      +2  [ = ]       0    ../../src/lib/motion_planning/ManualVelocitySmoothingZ.cpp\n    +0.0%      +1  [ = ]       0    ../../src/lib/tecs/TECS.cpp\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +1.1%    +122  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.5%    +110  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    [NEW] +9.00Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +6.00Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    -0.1%      -3  [ = ]       0    ../../src/modules/mc_pos_control/GotoControl/GotoControl.cpp\n    +0.2%     +42  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    -1.9%     -61  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +3.7%    +381  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    -0.3%      -3  [ = ]       0    task/task_cancelpt.c\n  +0.7% +34.2Ki  [ = ]       0    .debug_loc\n    +1.2%     +99  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +2.3% +1.10Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    [NEW] +19.3Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    -0.0%     -13  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp\n    [NEW] +12.9Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.0%     +23  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    +0.0%    +118  [ = ]       0    [section .debug_loc]\n    +4.0%    +729  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.6% +6.82Ki  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +0.5%     +40  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    [NEW] +3.71Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    [NEW] +2.95Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.2%     +24  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n     +12%     +24  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +2.0%     +80  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    -3.0%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0% +1.32Ki  [ = ]       0    .debug_str\n    +0.2%    +129  [ = ]       0    \n   -10.8%    -454  [ = ]       0    ../../src/lib/collision_prevention/CollisionPrevention.cpp\n    +0.1%    +108  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n   -13.7%    -415  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.2%      +9  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    +0.7%     +22  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Descend/FlightTaskDescend.cpp\n    -1.5%     -15  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/FlightTask/FlightTask.cpp\n    [NEW] +1.24Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n    -5.9%     -23  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -3.8%     -62  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Transition/FlightTaskTransition.cpp\n    [NEW]     +45  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    -0.6%    -188  [ = ]       0    ../../src/modules/mc_pos_control/MulticopterPositionControl.cpp\n    +0.0%      +7  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +4.4%    +917  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.9%      -2  [ = ]       0    .shstrtab\n  +0.2% +1.21Ki  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    +0.5%     +10  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    [NEW]    +890  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n   -30.9%    -184  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -26.6%    -219  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    [NEW]    +263  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.1%     +73  [ = ]       0    [section .strtab]\n     +52%    +441  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.2% +1.08Ki  [ = ]       0    .symtab\n     +17%     +16  [ = ]       0    ../../platforms/common/uORB/SubscriptionInterval.cpp\n    -1.1%     -16  [ = ]       0    ../../src/drivers/adc/ads1115/ads1115_main.cpp\n    -8.8%     -80  [ = ]       0    ../../src/lib/version/version.c\n    +1.4%     +16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    [NEW]    +848  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Land/FlightTaskLand.cpp\n   -17.6%     -48  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -28.8%    -240  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    -2.1%     -16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp\n    [NEW]    +256  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/Stop.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +0.2%    +112  [ = ]       0    [section .symtab]\n     +33%     +16  [ = ]       0    msg/topics_sources/action_request.cpp\n     +34%    +240  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    -0.0%     -16  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  -4.8% -3.48Ki  [ = ]       0    [Unmapped]\n  +0.5%  +232Ki  +0.2% +3.48Ki    TOTAL\n\n  ```\n</details>\n\n**Updated: _2024-12-16T14:35:43_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behaviour (a logic bug) where landing transitions from Manual/Altitude could inherit commanded velocities too large for FlightTaskAuto, causing unsafe/excessive motion. The change splits landing into a dedicated FlightTaskLand and adds a 'stop' primitive to correctly handle deceleration/state transition and enforce appropriate velocity limits during landing.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "patch": "@@ -57,12 +57,6 @@ Land::on_activation()\n \n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n-\t    && _navigator->get_local_position()->xy_global) { // only execute if global position is valid\n-\t\t_navigator->preproject_stop_point(_mission_item.lat, _mission_item.lon);\n-\t}\n-\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \tpos_sp_triplet->previous.valid = false;\n \tpos_sp_triplet->next.valid = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4d003fd7826d071a9e50197f51a12eb900ce9581/src%2Fmodules%2Fnavigator%2Fland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ]
      }
    }
  },
  {
    "title": "mission_base: do not make terrain avoidance check on idle",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23674",
    "number": 23674,
    "created_at": "2024-09-13T10:44:54Z",
    "merged": true,
    "merged_at": "2024-09-13T11:59:24Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "\r\n\r\n<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nCurrently the terrain avoidance check in the mission is always run when the mission mode is activated. it is even run when the mission has ended and the mission mode sets the idle navigation item. \r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- Do not make terrain avoidance check on idle mission item\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Do not make terrain avoidance check on idle mission item\r\n```\r\n\r\n### Alternatives\r\nWe could also check that we are landed and prevent the terrain avoidance check then or do not call the function on these conditions.\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-09-13T10:59:43Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect behavior where a terrain-avoidance check was performed even when the mission was idle/ended. That is an improper state-based condition (running logic for an idle navigation item), so the change fixes a logic error by preventing an inappropriate check in the idle state.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -1030,6 +1030,7 @@ void MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet(mission_i\n \n \tif (_navigator->get_nav_min_gnd_dist_param() > FLT_EPSILON && _mission_item.nav_cmd != NAV_CMD_LAND\n \t    && _mission_item.nav_cmd != NAV_CMD_VTOL_LAND && _mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION\n+\t    && _mission_item.nav_cmd != NAV_CMD_IDLE\n \t    && _navigator->get_local_position()->dist_bottom_valid\n \t    && _navigator->get_local_position()->dist_bottom < _navigator->get_nav_min_gnd_dist_param()\n \t    && _navigator->get_local_position()->vz > FLT_EPSILON",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c72c58e5514054a05e774c94b09dcb7895a1032d/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet"
        ]
      }
    }
  },
  {
    "title": "Fix max-hagl restriction to position/altitude control",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23667",
    "number": 23667,
    "created_at": "2024-09-11T08:54:18Z",
    "merged": true,
    "merged_at": "2025-01-20T14:50:21Z",
    "state": "closed",
    "conversation": {
      "author": "haumarco",
      "body": "Currently, when flying with only optical flow in position mode, you can easily surpass the max HAGL by continuously pushing the throttle up. The vehicle decelerates until it eventually exceeds the limit. At that point, we immediately lose optical flow measurements (when above the max height), and consequently, the HAGL max parameter is no longer set.\r\nI modified the controller to limit the altitude to 1 meter (or 10%) below the actual max height limit. This ensures that even after approaching the limit, optical flow remains active, and the controller tries to correct the altitude.\r\n\r\nPreviously, the HAGL max also influenced the controller in altitude mode, which was undesirable when using a range sensor or barometer. To resolve this, I split the HAGL max field of the local position message into hagl_max_z (for vertical control) and hagl_max_xy (for horizontal position control).\r\n\r\nWhen flying at max_hgt_xy, the platform descends if the terrain elevation decreases, in order to maintain a valid local position estimate. Additionally, when flying near the hagl_max_xy limit, I adjust the maximum horizontal velocity to reduce the risk of losing optical flow due to rapid elevation changes.\r\n\r\nTo avoid adding new subscribers, the hagl_max controller setting is still handled in the estimator.\r\nIn the FlightTaskManAcc, I now set the max_dist_to_ground of the FlightTaskManAlt because it depends on whether ManAcc is running. Since ManAlt cannot directly check if ManAcc is running (as it's a cascaded controller), this adjustment was necessary in order to keep it simple.\r\n\r\n![image](https://github.com/user-attachments/assets/e17b1b34-0892-4720-95ae-97113366f2fa)\r\n\r\n\r\n---\r\nPlease also give some feedback if this behavior fits what a typical user would expect.\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2024-11-18T09:50:56Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 608 byte (0.03 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +608  +0.0%    +608    .text\n     +55%    +240   +55%    +240    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n     +16%    +140   +16%    +140    ../../src/modules/flight_mode_manager/tasks/ManualPosition/FlightTaskManualPosition.cpp\n    +6.0%    +124  +6.0%    +124    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.0%     +72  +0.0%     +72    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.8%     +52  +1.8%     +52    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n     +13%     +48   +13%     +48    ../../src/modules/flight_mode_manager/tasks/ManualAltitudeSmoothVel/FlightTaskManualAltitudeSmoothVel.cpp\n    +2.1%     +36  +2.1%     +36    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.3%     +24  +0.3%     +24    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.1%     +24  +0.1%     +24    ../../src/modules/uxrce_dds_client/uxrce_dds_client.cpp\n    +0.4%     +20  +0.4%     +20    ../../src/modules/navigator/mission_block.cpp\n    -0.0%      -4  -0.0%      -4    ../../src/modules/fw_autotune_attitude_control/fw_autotune_attitude_control.cpp\n    -0.2%      -4  -0.2%      -4    ../../src/modules/navigator/mission.cpp\n    -0.9%     -32  -0.9%     -32    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -8.3%    -132  -8.3%    -132    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n  +0.0%      +6  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    +0.8%     +24  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -1.4%     -45  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    -0.9%     -29  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -2.6%      -8  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    +5.0%      +8  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.0%     +16  [ = ]       0    .debug_frame\n  -0.0%    -287  [ = ]       0    .debug_info\n    -0.0%     -16  [ = ]       0    ../../src/drivers/camera_trigger/camera_trigger.cpp\n    -0.0%     -16  [ = ]       0    ../../src/lib/npfg/npfg.cpp\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    -0.0%     -16  [ = ]       0    ../../src/lib/weather_vane/WeatherVane.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/commander/MulticopterThrowLaunch/MulticopterThrowLaunch.cpp\n    +0.1%     +65  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.0%     +41  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/follow_target_estimator/TargetEstimator.cpp\n    +0.0%     +34  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -1.2% -1.06Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +0.1%     +59  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.3%    +216  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.1%     +54  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/simulation/sensor_gps_sim/SensorGpsSim.cpp\n    +0.0%      +5  [ = ]       0    msg/topics_sources/uORBMessageFieldsGenerated.cpp\n    -0.1%     -16  [ = ]       0    msg/topics_sources/vehicle_local_position.cpp\n    +0.0%    +117  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +0.3%    +328  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.0%     -55  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.7%     +74  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.0%      +6  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -2.7%    -176  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -7.0%    -519  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +1.3%     +90  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +1.7%    +134  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.7%     +76  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%     +37  [ = ]       0    ../../src/modules/uxrce_dds_client/uxrce_dds_client.cpp\n    +0.0%    +142  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.0%    +103  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +0.0%      +8  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n    -0.4%      -5  [ = ]       0    task/task_cancelpt.c\n  -0.0% -1.78Ki  [ = ]       0    .debug_loc\n    -0.4%     -33  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -1.5%    -740  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n   -14.6% -1.43Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -14.4% -1.45Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +2.7%    +227  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    -3.5%    -614  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.6%     +44  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.7% +2.09Ki  [ = ]       0    [section .debug_loc]\n    -0.0%     -64  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.0%    +180  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.0%    -183  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +5.4%    +112  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -2.1%    -184  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n   -15.2%    -344  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -11.7%    -288  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +2.7%     +56  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    -4.1%    -160  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +1.1%    +552  [ = ]       0    [section .debug_ranges]\n    +0.0%     +32  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.2%     +48  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +1.5%      +1  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +310  [ = ]       0    .debug_str\n    +0.1%     +14  [ = ]       0    ../../src/drivers/camera_trigger/camera_trigger.cpp\n    +0.1%     +54  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n     +30%    +115  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -0.6%      -6  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.0%     +12  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +0.5%    +110  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +0.0%     +11  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.0%    +136  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    -0.8%      -5  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -6.1%     -50  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n     +11%     +59  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitudeSmoothVel/FlightTaskManualAltitudeSmoothVel.cpp\n     +10%     +50  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualPosition/FlightTaskManualPosition.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n    +0.0%      +3  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +9.2%     +79  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.0%     +96  [ = ]       0    .symtab\n    -1.3%     -16  [ = ]       0    ../../src/drivers/power_monitor/ina228/ina228.cpp\n    -0.4%     -16  [ = ]       0    ../../src/drivers/uavcan/sensors/sensor_bridge.cpp\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +1.7%     +32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -4.0%     -32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n   +10.0%     +32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitudeSmoothVel/FlightTaskManualAltitudeSmoothVel.cpp\n    +8.3%     +32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualPosition/FlightTaskManualPosition.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +0.1%     +80  [ = ]       0    [section .symtab]\n    +4.5%     +32  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -4.7%    -608  [ = ]       0    [Unmapped]\n  -0.0% -1.75Ki  +0.0%    +608    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 608 byte (0.03 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +608  +0.0%    +608    .text\n     +55%    +240   +55%    +240    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n     +16%    +140   +16%    +140    ../../src/modules/flight_mode_manager/tasks/ManualPosition/FlightTaskManualPosition.cpp\n    +6.0%    +124  +6.0%    +124    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.0%     +72  +0.0%     +72    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.8%     +52  +1.8%     +52    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n     +13%     +48   +13%     +48    ../../src/modules/flight_mode_manager/tasks/ManualAltitudeSmoothVel/FlightTaskManualAltitudeSmoothVel.cpp\n    +2.1%     +36  +2.1%     +36    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.3%     +24  +0.3%     +24    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.1%     +24  +0.1%     +24    ../../src/modules/uxrce_dds_client/uxrce_dds_client.cpp\n    +0.4%     +20  +0.4%     +20    ../../src/modules/navigator/mission_block.cpp\n    -0.0%      -4  -0.0%      -4    ../../src/modules/fw_autotune_attitude_control/fw_autotune_attitude_control.cpp\n    -0.2%      -4  -0.2%      -4    ../../src/modules/navigator/mission.cpp\n    -0.9%     -32  -0.9%     -32    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -8.3%    -132  -8.3%    -132    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n  +0.0%      +6  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    +0.8%     +24  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -1.4%     -45  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    -0.9%     -29  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -2.6%      -8  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    +5.0%      +8  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.0%     +16  [ = ]       0    .debug_frame\n  -0.0%    -271  [ = ]       0    .debug_info\n    -0.0%     -16  [ = ]       0    ../../src/drivers/camera_trigger/camera_trigger.cpp\n    -0.0%     -16  [ = ]       0    ../../src/lib/npfg/npfg.cpp\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    -0.0%     -16  [ = ]       0    ../../src/lib/weather_vane/WeatherVane.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/commander/MulticopterThrowLaunch/MulticopterThrowLaunch.cpp\n    +0.1%     +65  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.0%     +41  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/follow_target_estimator/TargetEstimator.cpp\n    +0.0%     +34  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -1.2% -1.06Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +0.1%     +59  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.3%    +216  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.1%     +54  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.0%      +5  [ = ]       0    msg/topics_sources/uORBMessageFieldsGenerated.cpp\n    -0.1%     -16  [ = ]       0    msg/topics_sources/vehicle_local_position.cpp\n    +0.0%    +117  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +0.3%    +328  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.0%     -47  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.7%     +74  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    +0.0%      +6  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -2.7%    -176  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -7.0%    -519  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +1.3%     +90  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.0%      +1  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp\n    +1.7%    +134  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.7%     +76  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%     +37  [ = ]       0    ../../src/modules/uxrce_dds_client/uxrce_dds_client.cpp\n    +0.0%    +142  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.0%    +103  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +0.0%      +8  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n    +0.2%      +2  [ = ]       0    task/task_cancelpt.c\n  -0.0% -1.52Ki  [ = ]       0    .debug_loc\n    -0.4%     -33  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -1.5%    -740  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n   -14.6% -1.43Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -14.4% -1.45Ki  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +2.7%    +227  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.7%    +186  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp\n    -3.5%    -614  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +0.6%     +44  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.7% +2.09Ki  [ = ]       0    [section .debug_loc]\n    +0.0%      +5  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.0%    +180  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.0%    -186  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +5.4%    +112  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -2.1%    -184  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n   -15.2%    -344  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n   -11.7%    -288  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n    +2.7%     +56  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    -4.1%    -160  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp\n    +1.2%    +552  [ = ]       0    [section .debug_ranges]\n    +0.0%     +32  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +1.2%     +48  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    -3.0%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +310  [ = ]       0    .debug_str\n    +0.1%     +14  [ = ]       0    ../../src/drivers/camera_trigger/camera_trigger.cpp\n    +0.1%     +54  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n     +30%    +115  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -0.6%      -6  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp\n    +0.0%     +12  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +0.5%    +110  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n    +0.0%     +11  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.0%    +136  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    -0.8%      -5  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp\n    -6.1%     -50  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n     +11%     +59  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitudeSmoothVel/FlightTaskManualAltitudeSmoothVel.cpp\n     +10%     +50  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualPosition/FlightTaskManualPosition.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n    +0.0%      +3  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n    +9.2%     +79  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  +0.0%     +96  [ = ]       0    .symtab\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +1.7%     +32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    -3.8%     -32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAccelerationSlow/FlightTaskManualAccelerationSlow.cpp\n   +10.0%     +32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualAltitudeSmoothVel/FlightTaskManualAltitudeSmoothVel.cpp\n    +8.3%     +32  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/ManualPosition/FlightTaskManualPosition.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n    +4.5%     +32  [ = ]       0    src/modules/flight_mode_manager/FlightTasks_generated.cpp\n  -0.8%    -608  [ = ]       0    [Unmapped]\n  -0.0% -1.47Ki  +0.0%    +608    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-01-16T09:50:13_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bresch",
          "created_at": "2024-09-11T12:32:35Z",
          "body": "either also set `hagl_max_z = INFINITY` or don't set any of those control limits as the struct is initialized with zeros and that the msg definition says \"set to 0 when limiting not required\".",
          "path": "src/drivers/ins/vectornav/VectorNav.cpp",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-09-11T12:40:55Z",
          "body": "Since we want to have a different behavior depending on the vehicle type, I suggest that the EKF still gives the absolute maximum and that any additional precautions to avoid breaching move to the control side (e.g.: flight task for MC).",
          "path": "src/modules/ekf2/EKF/ekf_helper.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-09-11T12:43:39Z",
          "body": "\"set to 0 when limiting not required\" ? Is that actually true or do we really need to set them to `INFINITY`?",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-09-11T12:45:00Z",
          "body": "what if `hagl_max_z` < `hagl_max_xy`?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-09-11T12:45:57Z",
          "body": "what about `hagl_max_z` ?",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "haumarco",
          "created_at": "2024-09-17T07:42:00Z",
          "body": "would be used in the altitude controller when the max distance was not set before.",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "haumarco",
          "created_at": "2024-09-17T07:42:43Z",
          "body": "IMO infinity is the better default for the max height etc",
          "path": "src/modules/mavlink/mavlink_receiver.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T13:23:25Z",
          "body": "Please don't use the name \"flow\" here; it's just a velocity limit from the estimator.",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T13:40:14Z",
          "body": "could you use https://github.com/PX4/PX4-Autopilot/blob/f9c4c8b22c47b6beba3c119c5e36a525aa57bf41/src/lib/mathlib/math/Functions.hpp#L142-L166 ?",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T13:42:10Z",
          "body": "```suggestion\r\n\t\tif (fabsf(current_vel_constraint - flow_vxy_max) > 0.1f) {\r\n```",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T13:48:48Z",
          "body": "```suggestion\r\n\t\t\t// gradually adjust velocity constraint because good tracking is required for the drag estimation\r\n```\r\n",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T13:50:22Z",
          "body": "This drag, right? https://github.com/PX4/PX4-Autopilot/blob/f9c4c8b22c47b6beba3c119c5e36a525aa57bf41/src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp#L99-L100\r\n\r\nWhats happening if you don't have this slew rate? The StickAcceleration class is supposed to handle dynamic velocity constraints, if this is not the case we should maybe change it there.",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T14:10:34Z",
          "body": "this is \"1 second away from reaching `_max_distance_to_ground`, right? Is this really needed?",
          "path": "src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T14:13:33Z",
          "body": "I don't see where you used `_param_mpc_vel_manual` and `_param_mpc_acc_hor` in `FlightTaskManualAltitude.cpp`",
          "path": "src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "haumarco",
          "created_at": "2024-11-18T08:59:46Z",
          "body": "If we have a velocity which is faster than the new maximum velocity, the velocity setpoint is not tracking the actual velocity anymore. This messes up the drag estimation since good tracking is assumed for the controller.\r\n",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "haumarco",
          "created_at": "2024-11-18T08:59:48Z",
          "body": "while giving manual throttle input the position setpoint is nan, therefore I also do the velocity check",
          "path": "src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "haumarco",
          "created_at": "2024-11-18T09:00:13Z",
          "body": "used them in FlightTaskManualAltitude.cpp",
          "path": "src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-25T08:04:30Z",
          "body": "where? I only see them used in [FlightTaskManualAcceleration.cpp](https://github.com/PX4/PX4-Autopilot/pull/23667/files#diff-8d0af4d9e531c4e5b5042aa541daa75f8c8375bfd4467096c2f186a8a501a549)",
          "path": "src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.hpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-25T08:34:09Z",
          "body": "What about using this: https://github.com/PX4/PX4-Autopilot/blob/e194a52907083783f7e67ff93504016ca1275ce8/src/lib/mathlib/math/TrajMath.hpp#L48-L71 (as used in collision prevention).",
          "path": "src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2025-01-15T14:33:57Z",
          "body": "maybe also check i `hagl_max_xy > FLT_EPSILON` to prevent divide-by-zero or negative numbers (I know that a nan shouldn't pass through the second `if` below, but it's not explicit and we never want to divide by zero).",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 11,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2025-01-15T14:37:58Z",
          "body": "you can set them as `static constexpr float kFactorThreshold = 0.8f` if they are just constants.",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2025-01-15T14:40:59Z",
          "body": "please use 2 different variables for the limit from the estimator and the final limit that includes reduction when approaching the height limit",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2025-01-15T14:55:44Z",
          "body": "The stick acceleration library says that https://github.com/PX4/PX4-Autopilot/blob/f9c4c8b22c47b6beba3c119c5e36a525aa57bf41/src/modules/flight_mode_manager/tasks/Utility/StickAccelerationXY.cpp#L76\r\n\r\nThis issue should then be fixed in the `StickAccelerationXY` library directly. Otherwise the next person using this interface will have to find the bug and manually handle it again.",
          "path": "src/modules/flight_mode_manager/tasks/ManualAcceleration/FlightTaskManualAcceleration.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "2024-09-11T12:46:05Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "haumarco",
          "created_at": "2024-09-17T07:42:00Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "haumarco",
          "created_at": "2024-09-17T07:42:43Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-14T14:16:28Z",
          "body": "Overall good, just a couple of comments",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "haumarco",
          "created_at": "2024-11-18T08:59:46Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "haumarco",
          "created_at": "2024-11-18T08:59:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "haumarco",
          "created_at": "2024-11-18T09:00:14Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-25T08:04:30Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-11-25T08:34:09Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2025-01-15T15:21:14Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2025-01-20T14:46:12Z",
          "body": "Looks good now, thanks!",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "aliyss",
          "created_at": "2025-01-20T16:41:43Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: the controller/estimator interaction and reuse of a single HAGL field allowed the vehicle to exceed the configured max HAGL (losing optical flow) and incorrectly influenced altitude control when other sensors were used. Splitting the HAGL limits into vertical and horizontal fields, clamping altitude below the max by a margin, and reducing horizontal velocity near limits correct boundary handling and improper state transitions so the vehicle maintains a valid local position estimate. This behavior aligns with user expectations that max-height limits are enforced and that HAGL limits do not wrongly affect altitude control using range/baro sensors.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -1026,7 +1026,8 @@ void MissionBlock::updateMaxHaglFailsafe()\n \tconst float target_alt = _navigator->get_position_setpoint_triplet()->current.alt;\n \n \tif (_navigator->get_global_position()->terrain_alt_valid\n-\t    && ((target_alt - _navigator->get_global_position()->terrain_alt) > _navigator->get_local_position()->hagl_max)) {\n+\t    && ((target_alt - _navigator->get_global_position()->terrain_alt)\n+\t\t> math::min(_navigator->get_local_position()->hagl_max_z, _navigator->get_local_position()->hagl_max_xy))) {\n \t\t// Handle case where the altitude setpoint is above the maximum HAGL (height above ground level)\n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Target altitude higher than max HAGL\\t\");\n \t\tevents::send(events::ID(\"navigator_fail_max_hagl\"), events::Log::Error, \"Target altitude higher than max HAGL\");",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/feda360c1475e5e01d75c40fbd1b8c369341dc2e/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::updateMaxHaglFailsafe"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::updateMaxHaglFailsafe"
        ]
      }
    }
  },
  {
    "title": "Enable distance sensor on land in Mode 2",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23664",
    "number": 23664,
    "created_at": "2024-09-10T07:59:07Z",
    "merged": true,
    "merged_at": "2024-09-16T07:11:23Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "### Solved Problem\r\nThere was recently the introduction of the SF1XX_MODE to disable the distance sensor while in Fixed wing for VTOLs. However, it is beneficial to activate the sensor already on the final approach before the VTOL transitions to MC again.\r\n\r\n### Solution\r\n- Add a new uORB topic which can request a mode change for a distance sensor.\r\n- Navigator publish the mode change when on mission landing phase or RTL landing phase\r\n- lightware driver listens to request ans changes enables/disables the sensor in FW mode. in MC mode it is always active.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Enable lightware distance sensor during landing phase while in SFXX_MODE 2\r\n```\r\n\r\n### Test coverage\r\n\r\n\\-\r\n\r\n",
      "issue_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-09-10T07:59:58Z",
          "body": "@sfuhrer still needs bench/flight testing, but you could already have a first look at it.",
          "type": "issue_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-11T14:59:43Z",
          "body": "Tested it on the bench: Setup VTOL SIH with disabling the SIH distance sensor SIH_DISTSNSR_OVR = 11111 and manually starting the lightware driver and setting the mode to 2.\r\n\r\n![Screenshot from 2024-09-11 16-34-33](https://github.com/user-attachments/assets/3f7bcd5a-5920-47db-96b1-dcedc9677cb5)\r\n\r\nTriggering a rtl, the sensor was enabled again when entering the loiter down. Similar results for mission landing.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bresch",
          "created_at": "2024-09-10T08:22:03Z",
          "body": "Why only listen to request from system in FW mode and not always? What are the drawbacks?",
          "path": "src/drivers/distance_sensor/lightware_laser_i2c/parameters.c",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-10T08:41:08Z",
          "body": "Do we even need to keep the VTOL dependency? Would it be enough to only link it to the isLanding state?",
          "path": "src/drivers/distance_sensor/lightware_laser_i2c/parameters.c",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-10T09:34:29Z",
          "body": "Yes, that is a valid point, i mainly did it for backward compatibility. General idea was that it is always enabled for MC mode, irrespective what the request is. For VTOL this is mainly for takeoff and landing. L conditions, is this also ok for MCs? better approach would be to get rid of the vehicle status condition in the driver and let navigator/commander/estimator choose, if it should be enabled of not.\r\nAs @sfuhrer mentioned, it would be even better if the estimator can request enabling the distance sensor if it helps with optical flow. But that would make the PR even bigger, so i would suggest a follow up PR to take care of that. ",
          "path": "src/drivers/distance_sensor/lightware_laser_i2c/parameters.c",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-10T12:46:21Z",
          "body": "Yes a follow-up with that seems okay to me. It's currently a feature that's mainly intended for VTOL, but we can open that up next.",
          "path": "src/drivers/distance_sensor/lightware_laser_i2c/parameters.c",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-11T15:00:44Z",
          "body": "So is the current approach ok? We currently leaving it as is with auto enabled in VTOL mode and shuld change that at some point to make it non VTOL related?",
          "path": "src/drivers/distance_sensor/lightware_laser_i2c/parameters.c",
          "position": 5,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-11T15:06:53Z",
          "body": "\"req\" sounds a lot like \"required\" - how about being more specific with \"request_on_off\"? To make it clear that it's only about on/off, not other obscure \"mode\"",
          "path": "msg/DistanceSensorModeChangeRequest.msg",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-11T15:07:25Z",
          "body": "And then here \"REQUEST_ON\"",
          "path": "msg/DistanceSensorModeChangeRequest.msg",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "2024-09-10T08:22:03Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-10T08:41:08Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-10T09:34:29Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-10T12:46:21Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-11T15:00:44Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-11T15:41:52Z",
          "body": "Looks correct to me, only have cosmetic proposals. ",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-11T16:25:46Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-16T07:04:41Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect conditional/state behavior: the distance sensor was globally disabled in SF1XX_MODE 2 for fixedâ€‘wing VTOLs, which prevented enabling it during landing phases. The change adds a mode-request topic and navigator-driven transitions so the sensor is enabled during landing (final approach/RTL landing), fixing the improper state/conditional handling.",
    "patches": {
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -73,7 +73,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvirtual void on_activation() override;\n \tvirtual void on_active() override;\n \n-\tbool isLanding();\n+\tvirtual bool isLanding();\n \n protected:\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -64,6 +64,7 @@\n #include <uORB/Publication.hpp>\n #include <uORB/Subscription.hpp>\n #include <uORB/SubscriptionInterval.hpp>\n+#include <uORB/topics/distance_sensor_mode_change_request.h>\n #include <uORB/topics/geofence_result.h>\n #include <uORB/topics/gimbal_manager_set_attitude.h>\n #include <uORB/topics/home_position.h>\n@@ -316,6 +317,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tuORB::Publication<vehicle_command_s>\t\t_vehicle_cmd_pub{ORB_ID(vehicle_command)};\n \tuORB::Publication<vehicle_roi_s>\t\t_vehicle_roi_pub{ORB_ID(vehicle_roi)};\n \tuORB::Publication<mode_completed_s> _mode_completed_pub{ORB_ID(mode_completed)};\n+\tuORB::PublicationData<distance_sensor_mode_change_request_s> _distance_sensor_mode_change_request_pub{ORB_ID(distance_sensor_mode_change_request)};\n \n \torb_advert_t\t_mavlink_log_pub{nullptr};\t/**< the uORB advert to send messages over mavlink */\n \n@@ -336,6 +338,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tposition_setpoint_triplet_s\t\t\t_takeoff_triplet{};\t/**< triplet for non-mission direct takeoff command */\n \tvehicle_roi_s\t\t\t\t\t_vroi{};\t\t/**< vehicle ROI */\n \n+\n \tperf_counter_t\t_loop_perf;\t\t\t/**< loop performance counter */\n \n \tGeofence\t_geofence;\t\t\t/**< class that handles the geofence */\n@@ -400,6 +403,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tvoid publish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_t result);\n \n+\tvoid publish_distance_sensor_mode_request();\n+\n \tbool geofence_allows_position(const vehicle_global_position_s &pos);\n \n \tDEFINE_PARAMETERS(",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "patch": "@@ -110,6 +110,11 @@ Navigator::Navigator() :\n \t_mission_sub = orb_subscribe(ORB_ID(mission));\n \t_vehicle_status_sub = orb_subscribe(ORB_ID(vehicle_status));\n \n+\t_distance_sensor_mode_change_request_pub.advertise();\n+\t_distance_sensor_mode_change_request_pub.get().timestamp = hrt_absolute_time();\n+\t_distance_sensor_mode_change_request_pub.get().request_on_off = distance_sensor_mode_change_request_s::REQUEST_OFF;\n+\t_distance_sensor_mode_change_request_pub.update();\n+\n \t// Update the timeout used in mission_block (which can't hold it's own parameters)\n \t_mission.set_payload_deployment_timeout(_param_mis_payload_delivery_timeout.get());\n \n@@ -898,6 +903,8 @@ void Navigator::run()\n \n \t\tpublish_navigator_status();\n \n+\t\tpublish_distance_sensor_mode_request();\n+\n \t\t_geofence.run();\n \n \t\tperf_end(_loop_perf);\n@@ -1447,6 +1454,30 @@ void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n \t_vehicle_cmd_pub.publish(*vcmd);\n }\n \n+void Navigator::publish_distance_sensor_mode_request()\n+{\n+\t// Send request to enable distance sensor when in the landing phase of a mission or RTL\n+\tif (((_navigation_mode == &_rtl) && _rtl.isLanding()) || ((_navigation_mode == &_mission) && _mission.isLanding())) {\n+\n+\t\tif (_distance_sensor_mode_change_request_pub.get().request_on_off !=\n+\t\t    distance_sensor_mode_change_request_s::REQUEST_ON) {\n+\n+\t\t\t_distance_sensor_mode_change_request_pub.get().timestamp = hrt_absolute_time();\n+\t\t\t_distance_sensor_mode_change_request_pub.get().request_on_off =\n+\t\t\t\tdistance_sensor_mode_change_request_s::REQUEST_ON;\n+\t\t\t_distance_sensor_mode_change_request_pub.update();\n+\t\t}\n+\n+\t} else if (_distance_sensor_mode_change_request_pub.get().request_on_off !=\n+\t\t   distance_sensor_mode_change_request_s::REQUEST_OFF) {\n+\n+\t\t_distance_sensor_mode_change_request_pub.get().timestamp = hrt_absolute_time();\n+\t\t_distance_sensor_mode_change_request_pub.get().request_on_off =\n+\t\t\tdistance_sensor_mode_change_request_s::REQUEST_OFF;\n+\t\t_distance_sensor_mode_change_request_pub.update();\n+\t}\n+}\n+\n void Navigator::publish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_t result)\n {\n \tvehicle_command_ack_s command_ack = {};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "patch": "@@ -304,6 +304,28 @@ void RTL::on_active()\n \t}\n }\n \n+bool RTL::isLanding()\n+{\n+\tbool is_landing{false};\n+\n+\tswitch (_rtl_type) {\n+\tcase RtlType::RTL_MISSION_FAST:\n+\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n+\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n+\t\tis_landing = _rtl_mission_type_handle->isLanding();\n+\t\tbreak;\n+\n+\tcase RtlType::RTL_DIRECT:\n+\t\tis_landing = _rtl_direct.isLanding();\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\treturn is_landing;\n+}\n+\n void RTL::setRtlTypeAndDestination()\n {\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -89,6 +89,8 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tvoid updateSafePoints(uint32_t new_safe_point_id) { _initiate_safe_points_updated = true; _safe_points_id = new_safe_point_id; }\n \n+\tbool isLanding();\n+\n private:\n \tenum class DestinationType {\n \t\tDESTINATION_TYPE_HOME,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 22,
        "changes": 79,
        "patch": "@@ -101,10 +101,11 @@ void RtlDirect::on_active()\n \tparameters_update();\n \n \tif (_rtl_state != RTLState::IDLE && is_mission_item_reached_or_completed()) {\n+\t\t_updateRtlState();\n \t\tset_rtl_item();\n \t}\n \n-\tif (_rtl_state != RTLState::IDLE) { //TODO: rename _rtl_state to _rtl_state_next (when in IDLE we're actually in LAND)\n+\tif (_rtl_state != RTLState::IDLE && _rtl_state != RTLState::LAND) {\n \t\t//check for terrain collision and update altitude if needed\n \t\t// note: it may trigger multiple times during a RTL, as every time the altitude set is reset\n \t\tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n@@ -154,6 +155,61 @@ void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s\n \t}\n }\n \n+void RtlDirect::_updateRtlState()\n+{\n+\tRTLState new_state{RTLState::IDLE};\n+\n+\tswitch (_rtl_state) {\n+\tcase RTLState::CLIMBING:\n+\t\tnew_state = RTLState::MOVE_TO_LOITER;\n+\t\tbreak;\n+\n+\tcase RTLState::MOVE_TO_LOITER:\n+\t\tnew_state = RTLState::LOITER_DOWN;\n+\t\tbreak;\n+\n+\tcase RTLState::LOITER_DOWN:\n+\t\tnew_state = RTLState::LOITER_HOLD;\n+\t\tbreak;\n+\n+\tcase RTLState::LOITER_HOLD:\n+\t\tif (_vehicle_status_sub.get().is_vtol\n+\t\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\t\t\tnew_state = RTLState::MOVE_TO_LAND;\n+\n+\t\t} else {\n+\t\t\tnew_state = RTLState::MOVE_TO_LAND_HOVER;\n+\t\t}\n+\n+\t\tbreak;\n+\n+\tcase RTLState::MOVE_TO_LAND:\n+\t\tnew_state = RTLState::TRANSITION_TO_MC;\n+\t\tbreak;\n+\n+\tcase RTLState::TRANSITION_TO_MC:\n+\t\tnew_state = RTLState::MOVE_TO_LAND_HOVER;\n+\t\tbreak;\n+\n+\tcase RTLState::MOVE_TO_LAND_HOVER:\n+\t\tnew_state = RTLState::LAND;\n+\t\tbreak;\n+\n+\tcase RTLState::LAND:\n+\t\tnew_state = RTLState::IDLE;\n+\t\tbreak;\n+\n+\tcase RTLState::IDLE: // Fallthrough\n+\tdefault:\n+\t\tnew_state = RTLState::IDLE;\n+\t\tbreak;\n+\t}\n+\n+\t_rtl_state = new_state;\n+\n+}\n+\n+\n void RtlDirect::set_rtl_item()\n {\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n@@ -174,7 +230,6 @@ void RtlDirect::set_rtl_item()\n \t\t\t};\n \t\t\tsetLoiterToAltMissionItem(_mission_item, pos_yaw_sp, _navigator->get_loiter_radius());\n \n-\t\t\t_rtl_state = RTLState::MOVE_TO_LOITER;\n \t\t\tbreak;\n \t\t}\n \n@@ -197,8 +252,6 @@ void RtlDirect::set_rtl_item()\n \t\t\t\tsetMoveToPositionMissionItem(_mission_item, pos_yaw_sp);\n \t\t\t}\n \n-\t\t\t_rtl_state = RTLState::LOITER_DOWN;\n-\n \t\t\tbreak;\n \t\t}\n \n@@ -224,8 +277,6 @@ void RtlDirect::set_rtl_item()\n \t\t\t// Disable previous setpoint to prevent drift.\n \t\t\tpos_sp_triplet->previous.valid = false;\n \n-\t\t\t_rtl_state = RTLState::LOITER_HOLD;\n-\n \t\t\tbreak;\n \t\t}\n \n@@ -244,14 +295,6 @@ void RtlDirect::set_rtl_item()\n \t\t\t\tevents::send(events::ID(\"rtl_completed_loiter\"), events::Log::Info, \"RTL: completed, loitering\");\n \t\t\t}\n \n-\t\t\tif (_vehicle_status_sub.get().is_vtol\n-\t\t\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n-\t\t\t\t_rtl_state = RTLState::MOVE_TO_LAND;\n-\n-\t\t\t} else {\n-\t\t\t\t_rtl_state = RTLState::MOVE_TO_LAND_HOVER;\n-\t\t\t}\n-\n \t\t\tbreak;\n \t\t}\n \n@@ -274,16 +317,12 @@ void RtlDirect::set_rtl_item()\n \t\t\tpos_sp_triplet->previous.alt = get_absolute_altitude_for_item(_mission_item);\n \t\t\tpos_sp_triplet->previous.valid = true;\n \n-\t\t\t_rtl_state = RTLState::TRANSITION_TO_MC;\n-\n \t\t\tbreak;\n \t\t}\n \n \tcase RTLState::TRANSITION_TO_MC: {\n \t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n \n-\t\t\t_rtl_state = RTLState::MOVE_TO_LAND_HOVER;\n-\n \t\t\tbreak;\n \t\t}\n \n@@ -295,8 +334,6 @@ void RtlDirect::set_rtl_item()\n \t\t\tsetMoveToPositionMissionItem(_mission_item, pos_yaw_sp);\n \t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n \n-\t\t\t_rtl_state = RTLState::LAND;\n-\n \t\t\tbreak;\n \t\t}\n \n@@ -309,8 +346,6 @@ void RtlDirect::set_rtl_item()\n \n \t\t\tstartPrecLand(_mission_item.land_precision);\n \n-\t\t\t_rtl_state = RTLState::IDLE;\n-\n \t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: land at destination\\t\");\n \t\t\tevents::send(events::ID(\"rtl_land_at_destination\"), events::Log::Info, \"RTL: land at destination\");\n \t\t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -103,6 +103,8 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \n \tvoid setRtlPosition(PositionYawSetpoint position, loiter_point_s loiter_pos);\n \n+\tbool isLanding() { return (_rtl_state != RTLState::IDLE) && (_rtl_state >= RTLState::LOITER_DOWN);};\n+\n private:\n \t/**\n \t * @brief Return to launch state machine.\n@@ -121,6 +123,12 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t} _rtl_state{RTLState::IDLE}; /*< Current state in the state machine.*/\n \n private:\n+\t/**\n+\t * @brief Update the RTL state machine.\n+\t *\n+\t */\n+\tvoid _updateRtlState();\n+\n \t/**\n \t * @brief Set the return to launch control setpoint.\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "patch": "@@ -60,6 +60,12 @@ void RtlMissionFastReverse::on_inactive()\n \t\t\t\t   _mission.current_seq : -1;\n }\n \n+void RtlMissionFastReverse::on_inactivation()\n+{\n+\tMissionBase::on_inactivation();\n+\t_in_landing_phase = false;\n+}\n+\n void RtlMissionFastReverse::on_activation()\n {\n \t_home_pos_sub.update();\n@@ -120,6 +126,7 @@ void RtlMissionFastReverse::setActiveMissionItems()\n \t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n \t\t    num_found_items == 0) {\n \t\t\thandleLanding(new_work_item_type);\n+\t\t\t_in_landing_phase = true;\n \n \t\t} else {\n \t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n@@ -131,6 +138,8 @@ void RtlMissionFastReverse::setActiveMissionItems()\n \t\t\t_mission_item.time_inside = 0.0f;\n \n \t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n+\n+\t\t\t_in_landing_phase = false;\n \t\t}\n \n \t\tif (num_found_items > 0) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.h": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -58,6 +58,9 @@ class RtlMissionFastReverse : public RtlBase\n \tvoid on_activation() override;\n \tvoid on_active() override;\n \tvoid on_inactive() override;\n+\tvoid on_inactivation() override;\n+\n+\tbool isLanding() override {return _in_landing_phase;};\n \n \trtl_time_estimate_s calc_rtl_time_estimate() override;\n \n@@ -68,5 +71,7 @@ class RtlMissionFastReverse : public RtlBase\n \n \tint _mission_index_prior_rtl{-1};\n \n+\tbool _in_landing_phase{false};\n+\n \tuORB::SubscriptionData<home_position_s> _home_pos_sub{ORB_ID(home_position)};\t\t/**< home position subscription */\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cf41e291b081db4306ac0b387614c400f8dbb07e/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.h"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirect::setRtlPosition",
        "Navigator::run",
        "RtlMissionFastReverse::on_inactive",
        "isLanding",
        "RtlDirect::set_rtl_item",
        "Navigator::Navigator",
        "RtlDirect::on_active",
        "RTL::on_active",
        "RtlMissionFastReverse::setActiveMissionItems",
        "Navigator::publish_vehicle_cmd"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.h": [
          "isLanding"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_vehicle_cmd",
          "Navigator::run",
          "Navigator::Navigator"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_active"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::setRtlPosition",
          "RtlDirect::on_active",
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::setActiveMissionItems",
          "RtlMissionFastReverse::on_inactive"
        ]
      }
    }
  },
  {
    "title": "MPC: LAND: adapt land logic to consider emergency braking, and vehicle velocity",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23627",
    "number": 23627,
    "created_at": "2024-08-28T07:46:43Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "Claudio-Chies",
      "body": "\r\n\r\n### Solved Problem\r\n![image](https://github.com/user-attachments/assets/53c3d369-0eb0-4fa2-b05b-d5ef18549eaf)\r\nThe https://github.com/PX4/PX4-Autopilot/pull/23546 did not consider the case when we trigger land from Altitude or Manual FlightTask, where the comanded velocity can greatly exceed the velocity possible in FlightTaskAuto.\r\nFor such cases FlightTaskAuto has the emergency braking feature.\r\n\r\nThis PR moves the landing setpoint logic from navigator back to FlightTaskAuto, and is able to adjust the setpoint depending on if EmergencyBraking is active or not.\r\nWhen ... I found that ...\r\n#### Downsides\r\nWhile emergency braking, im forcing the Position of `_position_smoothing` to be the current vehicle position, meaning we are unable to compensate wind. is probably a conercase as wind compensation while emergency braking is not the most important aspect. and emergency braking only triggers above 15 m/s (54 km/h) with default settings.\r\n\r\n\r\n### Changelog Entry\r\n\r\n### Alternatives\r\nWe could also create FlightTaskLand, to take all landing related tasks out of FlightTaskAuto\r\n\r\n### Test coverage\r\n-  Tested in SITL\r\n\r\n### Context\r\n![image](https://github.com/user-attachments/assets/2609a9c0-daff-4d28-96fe-b1044872b944)\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior in landing setpoint generation: landing was computed in the navigator without accounting for FlightTaskAuto's emergency braking and differing vehicle velocities (e.g., when landing from Altitude/Manual). Moving the logic into FlightTaskAuto and adapting setpoints based on emergency braking corrects improper state/commanding and prevents unrealistic commanded velocities, which is a logic error.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "patch": "@@ -54,15 +54,21 @@ Land::on_activation()\n \t_navigator->get_mission_result()->finished = false;\n \t_navigator->set_mission_result_updated();\n \treset_mission_item_reached();\n-\n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \n \tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t_navigator->calculate_breaking_stop(_mission_item.lat, _mission_item.lon);\n+\t\t// set the lat and lon to NAN, as the target setpoint for landing is handeled in FlightTaskAuto, not in the navigator\n+\t\tpos_sp_triplet->current.lat = NAN;\n+\t\tpos_sp_triplet->current.lon = NAN;\n+\t\tpos_sp_triplet->previous.lat = NAN;\n+\t\tpos_sp_triplet->previous.lon = NAN;\n+\t\tpos_sp_triplet->next.lat = NAN;\n+\t\tpos_sp_triplet->next.lon = NAN;\n \t}\n \n-\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\n \tpos_sp_triplet->previous.valid = false;\n \tpos_sp_triplet->next.valid = false;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c47b7b9f50a447528fd9dea0927d51bc2e0cb328/src%2Fmodules%2Fnavigator%2Fland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ]
      }
    }
  },
  {
    "title": "fix: use external precland if available during missions",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23625",
    "number": 23625,
    "created_at": "2024-08-28T00:42:16Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "asimopunov",
      "body": "When using a land mission item and enabling precision land, only the internal px4 precision land mode can be triggered. However, we need a way to use an external precision land mode that replaces the internal one within an uploaded mission. Currently, that is impossible, and the user would have to switch out of mission mode into precision land mode on their own.",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-08-28T15:51:55Z",
          "body": "Where's the description? What is the problem we're solving?",
          "type": "issue_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-28T15:57:39Z",
          "body": "added",
          "type": "issue_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-28T17:03:45Z",
          "body": "> I assume to some extent that's done to support landing and taking off again in the same mission. If you switch mode the mission will not continue anymore.\r\n\r\nGood point. That's something I didn't test. Maybe I can find a way to continue the mission if it broke.\r\n\r\n\r\n> Have you tested that the internal precision land still works or we fail in some cases e.g. does it still do precision land in RTL not just mission?\r\n\r\nYes, that's tested. The expectation is that normal land and internal precland will still work for missions and RTL.",
          "type": "issue_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-29T03:52:13Z",
          "body": "@MaEtUgR \r\n> I'd check what the solution is for e.g. RTL at the end of a mission or switching to hold at the end of a takeoff.\r\n\r\nI'm not sure I understood that part. What's the issue in those cases if the mode switches from mission to precland?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-08-28T15:52:37Z",
          "body": "```suggestion\r\n```",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-08-28T15:59:57Z",
          "body": "So as part of the mission we send a vehicle command to commander such that it switches mode? That's not a nice solution because it basically tells the state machine the user commanded a landing ðŸ¤” ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 38,
          "type": "review_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-28T16:57:47Z",
          "body": "> So as part of the mission we send a vehicle command to commander such that it switches mode? \r\n\r\nYes, the assumption is that you're at the end of the mission or RTL so you can just exit the mode.\r\nIt also tells the user in QGC that they are now in precision land so that's a small bonus.\r\n\r\n> That's not a nice solution because it basically tells the state machine the user commanded a landing\r\n\r\nyea, it's the quick way.\r\n\r\nI think the src id and compid would still be the fmu and dmesg would say from internal command instead of external. I can double check. So we can still know it didn't come from a control station or from any external mavlink command.\r\n",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 38,
          "type": "review_comment"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-28T17:02:16Z",
          "body": "However, it would show up in the ulog the same as a commander precland shell command.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 38,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-08-28T16:23:34Z",
          "body": "Ah I see, so the issue is that the landing within a mission navigator is doing that internally and not switch the mode. I assume to some extent that's done to support landing and taking off again in the same mission. If you switch mode the mission will not continue anymore.\r\n\r\nI'm not generally opposed but I'd check what the solution is for e.g. RTL at the end of a mission or switching to hold at the end of a takeoff. I'd avoid sending a vehicle command to switch mode if there's a nicer solution somewhere else.\r\n\r\nHave you tested that the internal precision land still works or we fail in some cases e.g. does it still do precision land in RTL not just mission?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-28T16:57:47Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "asimopunov",
          "created_at": "2024-08-28T17:02:16Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavioral logic: during mission land items the system always used the internal precisionâ€‘land path and prevented switching to an external precisionâ€‘land mode. That is an improper state/decision (mode selection) causing undesired behavior, so this change corrects a logic error in how landing mode is chosen during missions.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "patch": "@@ -183,10 +183,6 @@ MissionBase::on_inactivation()\n \t_navigator->set_gimbal_neutral(); // point forward\n \t_navigator->release_gimbal_control();\n \n-\tif (_navigator->get_precland()->is_activated()) {\n-\t\t_navigator->get_precland()->on_inactivation();\n-\t}\n-\n \t/* reset so current mission item gets restarted if mission was paused */\n \t_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n \n@@ -357,13 +353,6 @@ MissionBase::on_active()\n \t\tdo_abort_landing();\n \t}\n \n-\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n-\t\t_navigator->get_precland()->on_active();\n-\n-\t} else if (_navigator->get_precland()->is_activated()) {\n-\t\t_navigator->get_precland()->on_inactivation();\n-\t}\n-\n \tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b254f77dc2dc2947992ed809c781cc593a6e231/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 3,
        "changes": 36,
        "patch": "@@ -55,6 +55,32 @@\n \n using matrix::wrap_pi;\n \n+\n+static bool send_vehicle_command(const uint32_t cmd, const float param1 = NAN, const float param2 = NAN,\n+\t\t\t\t const float param3 = NAN,  const float param4 = NAN, const double param5 = static_cast<double>(NAN),\n+\t\t\t\t const double param6 = static_cast<double>(NAN), const float param7 = NAN)\n+{\n+\tvehicle_command_s vcmd{};\n+\tvcmd.command = cmd;\n+\tvcmd.param1 = param1;\n+\tvcmd.param2 = param2;\n+\tvcmd.param3 = param3;\n+\tvcmd.param4 = param4;\n+\tvcmd.param5 = param5;\n+\tvcmd.param6 = param6;\n+\tvcmd.param7 = param7;\n+\n+\tuORB::SubscriptionData<vehicle_status_s> vehicle_status_sub{ORB_ID(vehicle_status)};\n+\tvcmd.source_system = vehicle_status_sub.get().system_id;\n+\tvcmd.target_system = vehicle_status_sub.get().system_id;\n+\tvcmd.source_component = vehicle_status_sub.get().component_id;\n+\tvcmd.target_component = vehicle_status_sub.get().component_id;\n+\n+\tuORB::Publication<vehicle_command_s> vcmd_pub{ORB_ID(vehicle_command)};\n+\tvcmd.timestamp = hrt_absolute_time();\n+\treturn vcmd_pub.publish(vcmd);\n+}\n+\n MissionBlock::MissionBlock(Navigator *navigator, uint8_t navigator_state_id) :\n \tNavigatorMode(navigator, navigator_state_id)\n {\n@@ -1004,12 +1030,16 @@ void MissionBlock::startPrecLand(uint16_t land_precision)\n {\n \tif (_mission_item.land_precision == 1) {\n \t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n-\t\t_navigator->get_precland()->on_activation();\n+\t\tsend_vehicle_command(vehicle_command_s::VEHICLE_CMD_DO_SET_MODE, 1, PX4_CUSTOM_MAIN_MODE_AUTO,\n+\t\t\t\t     PX4_CUSTOM_SUB_MODE_AUTO_PRECLAND);\n \n-\t} else { //_mission_item.land_precision == 2\n+\t} else if(_mission_item.land_precision == 2){\n \t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n-\t\t_navigator->get_precland()->on_activation();\n+\t\tsend_vehicle_command(vehicle_command_s::VEHICLE_CMD_DO_SET_MODE, 1, PX4_CUSTOM_MAIN_MODE_AUTO,\n+\t\t\t\t     PX4_CUSTOM_SUB_MODE_AUTO_PRECLAND);\n \t}\n+\n+\n }\n \n void MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet(mission_item_s mission_item)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b254f77dc2dc2947992ed809c781cc593a6e231/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -53,6 +53,9 @@\n #include <uORB/topics/vehicle_global_position.h>\n #include <uORB/topics/vtol_vehicle_status.h>\n \n+#include <commander/px4_custom_mode.h>\n+#include <uORB/topics/vehicle_command.h>\n+\n // cosine of maximal course error to exit loiter if exit course is enforced (fixed-wing only)\n static constexpr float kCosineExitCourseThreshold = 0.99619f; // cos(5Â°)\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b254f77dc2dc2947992ed809c781cc593a6e231/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "patch": "@@ -63,10 +63,6 @@ RtlDirect::RtlDirect(Navigator *navigator) :\n \n void RtlDirect::on_inactivation()\n {\n-\tif (_navigator->get_precland()->is_activated()) {\n-\t\t_navigator->get_precland()->on_inactivation();\n-\t}\n-\n \t_rtl_state = RTLState::IDLE;\n }\n \n@@ -109,14 +105,6 @@ void RtlDirect::on_active()\n \t\t// note: it may trigger multiple times during a RTL, as every time the altitude set is reset\n \t\tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n \t}\n-\n-\tif (_rtl_state == RTLState::LAND && _param_rtl_pld_md.get() > 0) {\n-\t\t// Need to update the position and type on the current setpoint triplet.\n-\t\t_navigator->get_precland()->on_active();\n-\n-\t} else if (_navigator->get_precland()->is_activated()) {\n-\t\t_navigator->get_precland()->on_inactivation();\n-\t}\n }\n \n void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s loiter_pos)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7b254f77dc2dc2947992ed809c781cc593a6e231/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirect::RtlDirect",
        "MissionBase::on_inactivation",
        "MissionBase::on_active",
        "RtlDirect::on_active",
        "MissionBlock::startPrecLand"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::on_inactivation"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::startPrecLand"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::on_active",
          "RtlDirect::RtlDirect"
        ]
      }
    }
  },
  {
    "title": "navigator : Waypoint acceptance radius usable for all vehicle type",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23605",
    "number": 23605,
    "created_at": "2024-08-23T13:42:35Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "sbtjagu",
      "body": "### Solved Problem\r\nI wanted to make it possible to use the acceptance radius defined by a waypoint for the new ackermann module, and found that there was a condition in navigator module allowing it only for rotary wing vehicles.\r\n\r\n### Solution\r\n- Add a new parameter NAV_USE_WP_RAD\r\n- if parameter NAV_USE_WP_RAD is enabled, use the max between waypoint acceptance radius and NAV_ACC_RAD (NAV_ACC_RAD acting as the minimal acceptance radius usable)\r\n- NAV_USE_WP_RAD disabled by default, and enabled in airframes of rotary wing vehicles to make it works as before.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nNew parameter: NAV_USE_WP_RAD\r\n```\r\n\r\n### Test coverage\r\n- SITL with x500 with NAV_USE_WP_RAD enabled and disabled\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect conditional logic that only allowed waypoint acceptance radii for rotary wing vehicles, which prevented other vehicle types (e.g. ackermann) from using the waypoint radius. The change introduces a configur-able behavior (NAV_USE_WP_RAD) and uses the max of waypoint radius and NAV_ACC_RAD so the acceptance radius is applied correctly while preserving a minimum, fixing the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -332,9 +332,9 @@ MissionBlock::is_mission_item_reached_or_completed()\n \n \t\t\t// We use the acceptance radius of the mission item if it has been set (not NAN)\n \t\t\t// but only for multicopter.\n-\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n-\t\t\t    && PX4_ISFINITE(_mission_item.acceptance_radius) && _mission_item.acceptance_radius > FLT_EPSILON) {\n-\t\t\t\tacceptance_radius = _mission_item.acceptance_radius;\n+\t\t\tif (_navigator->use_waypoint_acceptance_radius() && PX4_ISFINITE(_mission_item.acceptance_radius)\n+\t\t\t    && _mission_item.acceptance_radius > FLT_EPSILON) {\n+\t\t\t\tacceptance_radius = math::max(acceptance_radius, _mission_item.acceptance_radius);\n \t\t\t}\n \n \t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2ffcaff5fbee4b4252ef541a9dc00381e3ffa34d/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -177,6 +177,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tfloat get_loiter_radius() { return _param_nav_loiter_rad.get(); }\n \n+\tbool use_waypoint_acceptance_radius() { return _param_nav_use_wp_rad.get(); }\n+\n \t/**\n \t * Returns the default acceptance radius defined by the parameter\n \t */\n@@ -405,6 +407,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::NAV_LOITER_RAD>)   _param_nav_loiter_rad,\t/**< loiter radius for fixedwing */\n \t\t(ParamFloat<px4::params::NAV_ACC_RAD>)      _param_nav_acc_rad,\t\t/**< acceptance for takeoff */\n+\t\t(ParamInt<px4::params::NAV_USE_WP_RAD>)     _param_nav_use_wp_rad,\t/**< use waypoint acceptance radius */\n \t\t(ParamFloat<px4::params::NAV_FW_ALT_RAD>)   _param_nav_fw_alt_rad,\t/**< acceptance rad for fixedwing alt */\n \t\t(ParamFloat<px4::params::NAV_FW_ALTL_RAD>)\n \t\t_param_nav_fw_altl_rad,\t/**< acceptance rad for fixedwing alt before landing*/",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2ffcaff5fbee4b4252ef541a9dc00381e3ffa34d/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "patch": "@@ -57,7 +57,7 @@ PARAM_DEFINE_FLOAT(NAV_LOITER_RAD, 80.0f);\n /**\n  * Acceptance Radius\n  *\n- * Default acceptance radius, overridden by acceptance radius of waypoint if set.\n+ * Default acceptance radius, can be overridden by acceptance radius of waypoint if NAV_USE_WP_ACC_RAD is enabled.\n  * For fixed wing the npfg switch distance is used for horizontal acceptance.\n  *\n  * @unit m\n@@ -69,6 +69,16 @@ PARAM_DEFINE_FLOAT(NAV_LOITER_RAD, 80.0f);\n  */\n PARAM_DEFINE_FLOAT(NAV_ACC_RAD, 10.0f);\n \n+/**\n+ * Use Waypoint Acceptance Radius\n+ *\n+ * Use the waypoint acceptance radius if it is bigger than the default acceptance radius defined by NAV_ACC_RAD.\n+ *\n+ * @boolean\n+ * @group Mission\n+ */\n+PARAM_DEFINE_INT32(NAV_USE_WP_RAD, 0);\n+\n /**\n  * FW Altitude Acceptance Radius\n  *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2ffcaff5fbee4b4252ef541a9dc00381e3ffa34d/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed",
        "PX4_ISFINITE"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed",
          "PX4_ISFINITE"
        ]
      }
    }
  },
  {
    "title": "Fix force heading to NaN on mission landing approach",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23587",
    "number": 23587,
    "created_at": "2024-08-21T10:50:33Z",
    "merged": true,
    "merged_at": "2024-08-22T10:58:45Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nmake sure to ignore any mission item yaw angle for the landing. Currently only the yaw angle for the final land item is ignored, but not for the part where the AV is moving to the land position. This can result in the AV turning while moving to the land location.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- Force the yaw angle to NaN before the mission item is changed for the land sub state machine\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Force the heading angle to NaN for each mission landing substate \r\n```\r\n\r\n### Alternatives\r\nIf the landing yaw needs to be considered, it should be another specific substate in the land state machine before the descend aligning the heading. Currently it is completely ignored.\r\n\r\n### Test coverage\r\n- Simulation testing\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-21T11:09:59Z",
          "body": "The behavior before:\r\n![Screenshot from 2024-08-21 13-04-48](https://github.com/user-attachments/assets/cc9b50e9-4322-47fe-a00e-a48703c2f486)\r\n\r\nNote that the land yaw value is set in the current position setpoint\r\n\r\nThe behaviour with fix:\r\n![Screenshot from 2024-08-21 13-06-36](https://github.com/user-attachments/assets/f4b07dbb-bda0-40ff-b97a-8ba4aaf93efc)\r\n\r\nNote that the land yaw setpoint is not set anymore.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-21T15:31:36Z",
          "body": "Looks good to me. Need to see though if the CI failure (VTOL mission MAVSDK) is real.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect behavior where a residual mission yaw setpoint was applied during the approach phase, causing the vehicle to rotate while moving to the landing location. Forcing the heading to NaN at the appropriate land substate transition fixes an improper state/variable handling (incorrect setpoint propagation), which is a classic logic error.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "patch": "@@ -566,6 +566,13 @@ void MissionBase::handleLanding(WorkItemType &new_work_item_type, mission_item_s\n \t\t\t\t  (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND) &&\n \t\t\t\t  !_land_detected_sub.get().landed;\n \n+\t/* ignore yaw for landing items */\n+\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n+\t\t* that aligns the vehicle first */\n+\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n+\t\t_mission_item.yaw = NAN;\n+\t}\n+\n \t/* move to land wp as fixed wing */\n \tif (needs_vtol_landing) {\n \t\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n@@ -654,13 +661,6 @@ void MissionBase::handleLanding(WorkItemType &new_work_item_type, mission_item_s\n \t\t\t}\n \t\t}\n \t}\n-\n-\t/* ignore yaw for landing items */\n-\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n-\t\t* that aligns the vehicle first */\n-\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n-\t\t_mission_item.yaw = NAN;\n-\t}\n }\n \n bool MissionBase::position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/03165bf3c72aa7c13052aa54af2bda1b48dd165d/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::handleLanding"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::handleLanding"
        ]
      }
    }
  },
  {
    "title": "Navigator: make sure VTOL transitions in Descend mode are always triggered",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23578",
    "number": 23578,
    "created_at": "2024-08-20T09:13:14Z",
    "merged": true,
    "merged_at": "2024-08-22T12:02:32Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "It previously didn't catch switches to Descend from a manual mode, as both modes have navigation_mode_new=nullptr.\r\n\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-21T15:03:05Z",
          "body": "Do we also need to check that it is not already transitioning? Else the command could be send multiple times until the type is set to ROTARY_WING",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 21,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-21T15:13:46Z",
          "body": "As soon as the transition starts the vehicle type will go to VEHICLE_TYPE_ROTARY_WING, not only when it ends.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 21,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-21T15:28:35Z",
          "body": "Ok, if it is guaranteed, to immediately switch to rotary wing, its should be fine",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 21,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-21T15:03:13Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-21T15:13:46Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-21T15:28:35Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-21T15:28:49Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect state-transition logic: VTOL transitions to Descend were not triggered when switching from manual mode because both modes had navigation_mode_new == nullptr, so the change went undetected. This is a logic error (improper state transition handling) and the PR fixes that condition so transitions are reliably caught.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "patch": "@@ -854,21 +854,19 @@ void Navigator::run()\n \t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n \t\t\t\treset_triplets();\n \t\t\t}\n+\t\t}\n \n-\n-\t\t\t// transition to hover in Descend mode\n-\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n-\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n-\t\t\t    force_vtol()) {\n-\t\t\t\tvehicle_command_s vcmd = {};\n-\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n-\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n-\t\t\t\tpublish_vehicle_cmd(&vcmd);\n-\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n-\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n-\t\t\t\t\t     \"Transition to hover mode and descend\");\n-\t\t\t}\n-\n+\t\t// VTOL: transition to hover in Descend mode if force_vtol() is true\n+\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n+\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n+\t\t    force_vtol()) {\n+\t\t\tvehicle_command_s vcmd = {};\n+\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\t\tpublish_vehicle_cmd(&vcmd);\n+\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n+\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n+\t\t\t\t     \"Transition to hover mode and descend\");\n \t\t}\n \n \t\t_navigation_mode = navigation_mode_new;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/617e45f33415323390d220af02dc4005ceb242ae/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Support straight line mission landings",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23576",
    "number": 23576,
    "created_at": "2024-08-20T07:41:48Z",
    "merged": true,
    "merged_at": "2024-09-10T15:44:24Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nWhen flying Fixed Wings in a space constrained area, it can be difficult to plan the usual orbit type mission landings.\r\nThere might simply not be enough space for the vehicle to orbit while it's descending in altitude.\r\n\r\nOf course, one can just plan a mission with simple waypoints and add a VTOL LAND waypoint at the end. However, there is always the risk that the altitude difference between the waypoints is too big and the vehicle cannot follow the glide-slope, causing it to loiter at the next waypoint in order to reduce altitude further. This behavior is highly undesirable as part of a mission landing, as already explained above.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\nI propose a solution where all simple waypoints AFTER a land stark marker have their altitude acceptance radius set to INFINITY, which will cause the guidance logic to track altitude for these waypoints based on best effort.\r\n\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature\r\nDocumentation: Add documentation for QGC explaining the difference between the two types of landings.\r\n```\r\n\r\n### Test coverage\r\nTested regularly in production but on a much older branch. Only SITL tested on main.\r\n\r\n### Context\r\nAltitude profile for staright line landing. Notice, that for the first waypoints the altitude needs to reached, however, for the last waypoints (landing pattern), the altitude is not reached anymore, but the waypoint is still accepted.\r\n![image](https://github.com/user-attachments/assets/e0e806a3-647a-4807-92a3-802be746ce67)\r\n\r\n",
      "issue_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-20T09:08:01Z",
          "body": "I guess the small bump in altitude after accepting the last waypoint is due to the transition?",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2024-08-25T12:37:11Z",
          "body": "~~I'm trying to wrap my head around this.~~\r\n\r\n~~I do recall (and use to use) straight line landings way back on <1.8? (when you put it back in in 1.04-ish) but that aside, you come in for landing and just plan a path basically and the idea here is that it just follows the path and max descent until we hit the ground but aren't constrained to hitting the WP alts on the path? Is that correct?~~\r\n\r\n~~Is this somewhat similar to how Land mode works (in FW) but just with the benefit of being able to plan a path rather than say land now?~~\r\n\r\nEdit: ya makes sense...",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-29T10:53:57Z",
          "body": "@KonradRudin @sfuhrer I added the fixed wing check as agreed.",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-09-10T13:25:52Z",
          "body": "@sfuhrer @bresch Could you guys please approve?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2024-08-20T08:39:48Z",
          "body": "```suggestion\r\n\t\t\t\talt_acc_rad_m = FLT_MAX;\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-20T15:22:24Z",
          "body": "Then you can delete the `if-else` just above that sets the `sp->acceptance_radius` based on `item.acceptance_radius` if you anyway override everything with NAN",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-22T11:32:16Z",
          "body": "@bresch No, one is the horizontal acceptance radius and the other one is the vertical one.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-22T11:33:52Z",
          "body": "```suggestion\r\n\t\tconst float acc_rad_z =  (PX4_ISFINITE(pos_sp_curr.alt_acceptance_radius) && pos_sp_curr.alt_acceptance_radius > FLT_EPSILON) ? pos_sp_curr.alt_acceptance_radius :\r\n```",
          "path": "src/modules/fw_pos_control/FixedwingPositionControl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-22T13:37:39Z",
          "body": "ooh, I missed the `alt_` prefix, my bad.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 6,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-22T19:08:56Z",
          "body": "I was thinking of how to avoid, needing to replicate the logic here for the mission item, since it is already set in the position setpoint triplet. Here is mi radical thought. In navigator there exists the get_altitude_acceptance_radius. In the navigator you have also access to the position setpoint. So there you could actually ready out the altitude radius in the current position setpoint, and if it is not NaN, just pass it along, else use the default one as calculated in the function as well. Then here you only need to cal the navigator->get_altitude_acceptance_radius function and you do not need to duplicate the logic. Hope this works, not sure yet.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-26T09:18:47Z",
          "body": "Totally agree - @RomanBapst do you see an issue with that?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-26T12:44:10Z",
          "body": "I don't think this is safe. The DO_LAND_START waypoint can be attached to any normal waypoint, which then changes the altitude handling of every following waypoint.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-26T13:39:43Z",
          "body": "@KonradRudin Was wondering if I would not need to add a check here as well if we are already on the mission landing part. ",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-26T13:40:06Z",
          "body": "@sfuhrer Agree, and currently trying out the proposed solution.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-26T13:59:13Z",
          "body": "Yes you actually would need that. When you are below the waypoint, you would anyways need to climb first then it is not important, but when you are way above it, it would not loiter before going to the descend route.",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-26T14:30:51Z",
          "body": "@sfuhrer I don't quite understand. It will actually not change the behavior for the waypoint it's attached to (see definition of isLanding()) but yes, every position waypoint that comes after that. That's what we desire, no?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-26T15:48:11Z",
          "body": "Let's make an example: a MC user flies the drone in a complex environment. As he can't use the normal \"go above and descend\" RTL he plans a mission landing with 3 waypoints and then a land (e.g. following a narrow corridor). To mark the beginning of the RTL he sets a land start marker to the 4th to last waypoint. He expects that the drone will follow these 4 waypoints normally, including normal altitude behavior. \r\nWhat I'm basically going towards: it's not naturally clear that waypoints after the land_start marker have a different altitude behavior.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-27T10:59:25Z",
          "body": "@sfuhrer Does it ever make sense to plan a mission landing for MC? Also, MC does not even use the alt acceptance radius for the triplet. But it's true that navigator would accept the waypoint even if altitude is not reached (usually that does not happen for MC, since it can track any glide slope, but still it's a difference to before.)",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-27T11:21:07Z",
          "body": "@sfuhrer Another idea is to define a new waypoint type which explicity says that altitude should not be enforced. Then the ground station could just use these waypoints and there is not confusion. While planning the mission the user could even select the altitude tracking behavior.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-30T06:42:22Z",
          "body": "```suggestion\r\n\t\t\tfloat alt_acc_rad_m = (PX4_ISFINITE(curr_sp->alt_acceptance_radius) && curr_sp->alt_acceptance_radius > FLT_EPSILON) ? curr_sp->alt_acceptance_radius :\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-30T07:18:03Z",
          "body": "Is there a reason you did not add this directly in the  _navigator->get_altitude_acceptance_radius function? Then you could use it for other items as well. I don't think it would hurt, no?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-30T07:19:07Z",
          "body": "Currently you set this in the mission and direct_misison_land. That means it wont work for RTL mission fast forward. Any reason to not put it in mission base?",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 10,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-09-03T07:36:55Z",
          "body": "@KonradRudin The issue is that after calling the base function, the mission class is the one that actually calculates the triplet. So I cannot do it before, otherwise the triplet will be overridden.",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 10,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-10T11:51:46Z",
          "body": "Only thing left is that now this function is called regularly. Currently it will always call the getNextPositionItems, which is searching through the mission items. It will be blocking if it is called at the start of the mission and the mission contains many items because the land mission items will not be in the cache yet. I already proposed a solution here: https://github.com/PX4/PX4-Autopilot/pull/23664/files#diff-e478a3707c309ee3511e233bef53b84bb5b0de134989aad2c7e332a62aa32a34R372\r\nSince we already know the land_start mission idx, as long as the current index is below, we do not need to check it.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "2024-08-20T08:39:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-20T15:22:33Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-22T11:32:16Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-22T11:33:53Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-22T13:37:39Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-22T19:10:50Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-26T12:46:28Z",
          "body": "I would look into passing an \"disregard altitude acceptance\" flag from the groundstation to PX4 in cases where it should be ignored (e.g. during VTOL_LAND items). I don't think it should apply to every landing sequence.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-26T13:39:43Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-26T13:40:07Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-26T13:59:13Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-26T14:30:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-26T15:48:12Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-27T10:59:25Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-27T11:21:07Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-30T07:19:13Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-09-03T07:36:55Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-10T11:51:52Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-09-10T13:16:32Z",
          "body": "lgtm",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-09-10T15:40:08Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the waypoint acceptance logic (altitude acceptance radius) for straight-line landings so the vehicle no longer loiters trying to meet exact waypoint altitudes. The previous strict altitude-acceptance behavior caused unintended/incorrect mission behavior during landings, and this change corrects that logical flaw.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 35,
        "changes": 42,
        "patch": "@@ -91,41 +91,6 @@ Mission::on_activation()\n \tMissionBase::on_activation();\n }\n \n-bool\n-Mission::isLanding()\n-{\n-\tif (get_land_start_available()) {\n-\t\tstatic constexpr size_t max_num_next_items{1u};\n-\t\tint32_t next_mission_items_index[max_num_next_items];\n-\t\tsize_t num_found_items;\n-\n-\t\tgetNextPositionItems(_mission.land_start_index + 1, next_mission_items_index, num_found_items, max_num_next_items);\n-\n-\t\t// vehicle is currently landing if\n-\t\t//  mission valid, still flying, and in the landing portion of mission (past land start marker)\n-\t\tbool on_landing_stage = (num_found_items > 0U) &&  _mission.current_seq > next_mission_items_index[0U];\n-\n-\t\t// special case: if the land start index is at a LOITER_TO_ALT WP, then we're in the landing sequence already when the\n-\t\t// distance to the WP is below the loiter radius + acceptance.\n-\t\tif ((num_found_items > 0U) && _mission.current_seq == next_mission_items_index[0U]\n-\t\t    && _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n-\t\t\tconst float d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n-\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n-\n-\t\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n-\t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n-\t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n-\t\t\t\t\t_navigator->get_loiter_radius();\n-\n-\t\t\ton_landing_stage = d_current <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs);\n-\t\t}\n-\n-\t\treturn _navigator->get_mission_result()->valid && on_landing_stage;\n-\n-\t} else {\n-\t\treturn false;\n-\t}\n-}\n \n bool\n Mission::set_current_mission_index(uint16_t index)\n@@ -244,6 +209,13 @@ void Mission::setActiveMissionItems()\n \t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t}\n \n+\t\t// prevent fixed wing lateral guidance from loitering at a waypoint as part of a mission landing if the altitude\n+\t\t// is not achieved.\n+\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING && isLanding() &&\n+\t\t    _mission_item.nav_cmd == NAV_CMD_WAYPOINT) {\n+\t\t\tpos_sp_triplet->current.alt_acceptance_radius = FLT_MAX;\n+\t\t}\n+\n \t\t// Allow a rotary wing vehicle to decelerate before reaching a wp with a hold time or a timeout\n \t\t// This is done by setting the position triplet's next position's valid flag to false,\n \t\t// which makes the FlightTask disregard the next position",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -67,7 +67,6 @@ class Mission : public MissionBase\n \tuint16_t get_land_start_index() const { return _mission.land_start_index; }\n \tbool get_land_start_available() const { return hasMissionLandStart(); }\n \n-\tbool isLanding();\n \n private:\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "patch": "@@ -367,6 +367,42 @@ MissionBase::on_active()\n \tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n }\n \n+bool\n+MissionBase::isLanding()\n+{\n+\tif (hasMissionLandStart() && (_mission.current_seq > _mission.land_start_index)) {\n+\t\tstatic constexpr size_t max_num_next_items{1u};\n+\t\tint32_t next_mission_items_index[max_num_next_items];\n+\t\tsize_t num_found_items;\n+\n+\t\tgetNextPositionItems(_mission.land_start_index + 1, next_mission_items_index, num_found_items, max_num_next_items);\n+\n+\t\t// vehicle is currently landing if\n+\t\t//  mission valid, still flying, and in the landing portion of mission (past land start marker)\n+\t\tbool on_landing_stage = (num_found_items > 0U) &&  _mission.current_seq > next_mission_items_index[0U];\n+\n+\t\t// special case: if the land start index is at a LOITER_TO_ALT WP, then we're in the landing sequence already when the\n+\t\t// distance to the WP is below the loiter radius + acceptance.\n+\t\tif ((num_found_items > 0U) && _mission.current_seq == next_mission_items_index[0U]\n+\t\t    && _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n+\t\t\tconst float d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\n+\t\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n+\t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n+\t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n+\t\t\t\t\t_navigator->get_loiter_radius();\n+\n+\t\t\ton_landing_stage = d_current <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs);\n+\t\t}\n+\n+\t\treturn _navigator->get_mission_result()->valid && on_landing_stage;\n+\n+\t} else {\n+\t\treturn false;\n+\t}\n+}\n+\n void MissionBase::update_mission()\n {\n \tif (_mission.count == 0u || !_is_current_planned_mission_item_valid || !isMissionValid()) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -73,6 +73,8 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvirtual void on_activation() override;\n \tvirtual void on_active() override;\n \n+\tbool isLanding();\n+\n protected:\n \n \t/**\n@@ -321,6 +323,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tvoid setMissionIndex(int32_t index);\n \n+\n \tbool _is_current_planned_mission_item_valid{false};\t/**< Flag indicating if the currently loaded mission item is valid*/\n \tbool _mission_has_been_activated{false};\t\t/**< Flag indicating if the mission has been activated*/\n \tbool _mission_checked{false};\t\t\t\t/**< Flag indicating if the mission has been checked by the mission validator*/",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -673,6 +673,10 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \t\tsp->acceptance_radius = _navigator->get_default_acceptance_radius();\n \t}\n \n+\t// by default, FW guidance logic will take alt acceptance from NAV_FW_ALT_RAD, in some special cases\n+\t// we override it after this\n+\tsp->alt_acceptance_radius = NAN;\n+\n \tsp->cruising_speed = _navigator->get_cruising_speed();\n \tsp->cruising_throttle = _navigator->get_cruising_throttle();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "patch": "@@ -1118,9 +1118,14 @@ float Navigator::get_default_acceptance_radius()\n float Navigator::get_altitude_acceptance_radius()\n {\n \tif (get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\n+\t\tconst position_setpoint_s &curr_sp = get_position_setpoint_triplet()->current;\n \t\tconst position_setpoint_s &next_sp = get_position_setpoint_triplet()->next;\n \n-\t\tif (!force_vtol() && next_sp.type == position_setpoint_s::SETPOINT_TYPE_LAND && next_sp.valid) {\n+\t\tif ((PX4_ISFINITE(curr_sp.alt_acceptance_radius) && curr_sp.alt_acceptance_radius > FLT_EPSILON)) {\n+\t\t\treturn curr_sp.alt_acceptance_radius;\n+\n+\t\t} else if (!force_vtol() && next_sp.type == position_setpoint_s::SETPOINT_TYPE_LAND && next_sp.valid) {\n \t\t\t// Use separate (tighter) altitude acceptance for clean altitude starting point before FW landing\n \t\t\treturn _param_nav_fw_altl_rad.get();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -212,6 +212,13 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \t\t}\n \n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\n+\t\t// prevent lateral guidance from loitering at a waypoint as part of a mission landing if the altitude\n+\t\t// is not achieved.\n+\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING && MissionBase::isLanding()\n+\t\t    && _mission_item.nav_cmd == NAV_CMD_WAYPOINT) {\n+\t\t\tpos_sp_triplet->current.alt_acceptance_radius = FLT_MAX;\n+\t\t}\n \t}\n \n \tissue_command(_mission_item);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -168,6 +168,11 @@ void RtlMissionFast::setActiveMissionItems()\n \t\t}\n \n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\n+\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING && isLanding() &&\n+\t\t    _mission_item.nav_cmd == NAV_CMD_WAYPOINT) {\n+\t\t\tpos_sp_triplet->current.alt_acceptance_radius = FLT_MAX;\n+\t\t}\n \t}\n \n \tissue_command(_mission_item);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/147472e86581b2c89e7f6b8c27082b4634165048/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlMissionFast::setActiveMissionItems",
        "Navigator::get_default_acceptance_radius",
        "Mission::on_activation",
        "fabsf",
        "isLanding",
        "Mission::setActiveMissionItems",
        "MissionBase::on_active",
        "RtlDirectMissionLand::setActiveMissionItems",
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "fabsf",
          "Mission::setActiveMissionItems",
          "Mission::on_activation"
        ],
        "src/modules/navigator/mission.h": [
          "isLanding"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_default_acceptance_radius"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast.cpp": [
          "RtlMissionFast::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "Rework 1st waypoint check",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23568",
    "number": 23568,
    "created_at": "2024-08-19T11:16:48Z",
    "merged": true,
    "merged_at": "2024-08-21T07:08:36Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nIn the mission feasibility, it is checked if the 1st waypoint is too far from the current position. This means that the mission feasibility can change during flight if moving further away from the first waypoint. The mission feasibility should not be able to change depending on the current position of the AV.  Especially when a long mission is flown and interrupted, the mission check should make a mission infeasible because the AV did fly away from the fist mission item.\r\n\r\nSince the first waypoint mission check should indicate that potentially an old mission from another location is loaded in PX4 it should not be able to change the feasibility in flight \r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- The 1st waypoint check only generates a warning in QGC, but does not invalidate a mission\r\n- The 1st waypoint check is performed against the home position\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nChange: First waypoint mission check only generates a warning, but mission can still be executed\r\n```\r\n\r\n### Alternatives\r\nThe home position can stil change during a flight and a even better point would be to specifically take a takeoff location which would be constant for an entire flight (AFAIK does not exist yet). Also it can still be argued if the check should make the whole mission infeasible, for simplicity, it was converted to a warning only.\r\n\r\n### Test coverage\r\n- Tested in SITL simulation with the standard VTOL configuration.\r\n  - Upload a valid mission and test mission functionality\r\n  - Reduce MIS_DIST_1WP to 1m and check that watning appears after mission feasibility is calculated again\r\n  - Make sure mission can still be executed even with warning\r\n  - Create a mission close to the vehicle and set MIS_DIST_1WP to barely include the first waypoint\r\n  - Fly away manually\r\n  - Execute mission again, make dure mission can still be flown but a warning is displayed.\r\n\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-19T13:09:53Z",
          "body": "I would add the link to the param in the event:\r\n\r\n/* EVENT\r\n\t\t\t * @description\r\n\t\t\t * <profile name=\"dev\">\r\n\t\t\t * This check can be configured via <param>MIS_DIST_1WP</param> parameter.\r\n\t\t\t * </profile>\r\n\t\t\t */",
          "path": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
          "position": 66,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-19T13:10:08Z",
          "body": "```suggestion\r\n\t\tconst float dist_to_1wp_from_home_pos = get_distance_to_next_waypoint(\r\n```",
          "path": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-19T13:10:57Z",
          "body": "```suggestion\r\n\t\t\t\t\t       \"First waypoint far away from Home: {1m} Correct mission loaded?\", (uint32_t)dist_to_1wp_from_home_pos);\r\n```\r\nI usually write Home with capital H to have it stick out from the sentence and bc it's a given name.",
          "path": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-19T13:11:39Z",
          "body": "There are some CI failures and I have some mini comments, otherwise I fully agree with the approach.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-21T07:08:05Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: the original feasibility check used the vehicle's current position for the 1st-waypoint distance, allowing mission feasibility to change as the vehicle moved. That is an improper state-dependent check; the change to compare against home (and demote it to a warning) corrects the incorrect state transition/condition and prevents feasibility from changing during flight.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 23,
        "changes": 40,
        "patch": "@@ -49,7 +49,6 @@ void FeasibilityChecker::reset()\n \t_mission_validity_failed = false;\n \t_takeoff_failed = false;\n \t_land_pattern_validity_failed = false;\n-\t_distance_first_waypoint_failed = false;\n \t_distance_between_waypoints_failed = false;\n \t_fixed_wing_land_approach_failed = false;\n \t_takeoff_land_available_failed = false;\n@@ -118,12 +117,6 @@ void FeasibilityChecker::updateData()\n \t\t_is_landed = land_detected.landed;\n \t}\n \n-\tif (_vehicle_global_position_sub.updated()) {\n-\t\tvehicle_global_position_s vehicle_global_position = {};\n-\t\t_vehicle_global_position_sub.copy(&vehicle_global_position);\n-\t\t_current_position_lat_lon = matrix::Vector2d(vehicle_global_position.lat, vehicle_global_position.lon);\n-\t}\n-\n \tif (_rtl_status_sub.updated()) {\n \t\trtl_status_s rtl_status = {};\n \t\t_rtl_status_sub.copy(&rtl_status);\n@@ -199,8 +192,8 @@ void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int\n \t\t_distance_between_waypoints_failed = !checkDistancesBetweenWaypoints(mission_item);\n \t}\n \n-\tif (!_distance_first_waypoint_failed) {\n-\t\t_distance_first_waypoint_failed = !checkHorizontalDistanceToFirstWaypoint(mission_item);\n+\tif (!_first_waypoint_found) {\n+\t\tcheckHorizontalDistanceToFirstWaypoint(mission_item);\n \t}\n \n \tif (!_takeoff_failed) {\n@@ -631,31 +624,32 @@ bool FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding()\n bool FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint(mission_item_s &mission_item)\n {\n \tif (_param_mis_dist_1wp > FLT_EPSILON &&\n-\t    (_current_position_lat_lon.isAllFinite()) && !_first_waypoint_found &&\n+\t    (_home_lat_lon.isAllFinite()) &&\n \t    MissionBlock::item_contains_position(mission_item)) {\n \n \t\t_first_waypoint_found = true;\n \n-\t\tfloat dist_to_1wp_from_current_pos = 1e6f;\n-\n-\t\tif (_current_position_lat_lon.isAllFinite()) {\n-\t\t\tdist_to_1wp_from_current_pos = get_distance_to_next_waypoint(\n-\t\t\t\t\t\t\t       mission_item.lat, mission_item.lon,\n-\t\t\t\t\t\t\t       _current_position_lat_lon(0), _current_position_lat_lon(1));\n-\t\t}\n+\t\tconst float dist_to_1wp_from_home_pos = get_distance_to_next_waypoint(\n+\t\t\t\tmission_item.lat, mission_item.lon,\n+\t\t\t\t_home_lat_lon(0), _home_lat_lon(1));\n \n-\t\tif (dist_to_1wp_from_current_pos < _param_mis_dist_1wp) {\n+\t\tif (dist_to_1wp_from_home_pos < _param_mis_dist_1wp) {\n \n \t\t\treturn true;\n \n \t\t} else {\n \t\t\t/* item is too far from current position */\n \t\t\tmavlink_log_critical(_mavlink_log_pub,\n-\t\t\t\t\t     \"First waypoint too far away: %dm, %d max\\t\",\n-\t\t\t\t\t     (int)dist_to_1wp_from_current_pos, (int)_param_mis_dist_1wp);\n-\t\t\tevents::send<uint32_t, uint32_t>(events::ID(\"navigator_mis_first_wp_too_far\"), {events::Log::Error, events::LogInternal::Info},\n-\t\t\t\t\t\t\t \"First waypoint too far away: {1m} (maximum: {2m})\", (uint32_t)dist_to_1wp_from_current_pos,\n-\t\t\t\t\t\t\t (uint32_t)_param_mis_dist_1wp);\n+\t\t\t\t\t     \"First waypoint far away from home: %dm. Correct mission loaded?\\t\",\n+\t\t\t\t\t     (int)dist_to_1wp_from_home_pos);\n+\t\t\t/* EVENT\n+\t\t\t* @description\n+\t\t\t* <profile name=\"dev\">\n+\t\t\t* This check can be configured via <param>MIS_DIST_1WP</param> parameter.\n+\t\t\t* </profile>\n+\t\t\t*/\n+\t\t\tevents::send<uint32_t>(events::ID(\"navigator_mis_first_wp_far\"), {events::Log::Warning, events::LogInternal::Info},\n+\t\t\t\t\t       \"First waypoint far away from Home: {1m} Correct mission loaded?\", (uint32_t)dist_to_1wp_from_home_pos);\n \n \t\t\treturn false;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/f382d6d9219dbf047c873f6eded778058c151462/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -78,7 +78,6 @@ class FeasibilityChecker : public ModuleParams\n \tbool someCheckFailed()\n \t{\n \t\treturn _takeoff_failed ||\n-\t\t       _distance_first_waypoint_failed ||\n \t\t       _distance_between_waypoints_failed ||\n \t\t       _land_pattern_validity_failed ||\n \t\t       _fixed_wing_land_approach_failed ||\n@@ -97,7 +96,6 @@ class FeasibilityChecker : public ModuleParams\n \tuORB::Subscription _home_pos_sub{ORB_ID(home_position)};\n \tuORB::Subscription _status_sub{ORB_ID(vehicle_status)};\n \tuORB::Subscription _land_detector_sub{ORB_ID(vehicle_land_detected)};\n-\tuORB::Subscription _vehicle_global_position_sub{ORB_ID(vehicle_global_position)};\n \tuORB::Subscription _rtl_status_sub{ORB_ID(rtl_status)};\n \n \t// parameters\n@@ -110,14 +108,12 @@ class FeasibilityChecker : public ModuleParams\n \tfloat _home_alt_msl{NAN};\n \tbool _has_vtol_approach{false};\n \tmatrix::Vector2d _home_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n-\tmatrix::Vector2d _current_position_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n \tVehicleType _vehicle_type{VehicleType::RotaryWing};\n \n \t// internal flags to keep track of which checks failed\n \tbool _mission_validity_failed{false};\n \tbool _takeoff_failed{false};\n \tbool _land_pattern_validity_failed{false};\n-\tbool _distance_first_waypoint_failed{false};\n \tbool _distance_between_waypoints_failed{false};\n \tbool _fixed_wing_land_approach_failed{false};\n \tbool _takeoff_land_available_failed{false};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/f382d6d9219dbf047c873f6eded778058c151462/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.hpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityCheckerTest.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityCheckerTest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -170,9 +170,9 @@ TEST_F(FeasibilityCheckerTest, check_dist_first_waypoint)\n \tmission_item.lat = lat_new;\n \tmission_item.lon = lon_new;\n \n-\t// THEN: fail\n+\t// THEN: pass\n \tchecker.processNextItem(mission_item, 0, 1);\n-\tASSERT_EQ(checker.someCheckFailed(), true);\n+\tASSERT_EQ(checker.someCheckFailed(), false);\n \n \t// BUT WHEN: valid current position fist WP 499m away from current\n \tchecker.reset();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/f382d6d9219dbf047c873f6eded778058c151462/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityCheckerTest.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -41,7 +41,6 @@\n  */\n \n #include \"mission_feasibility_checker.h\"\n-#include \"MissionFeasibility/FeasibilityChecker.hpp\"\n \n #include \"mission_block.h\"\n #include \"navigator.h\"",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/f382d6d9219dbf047c873f6eded778058c151462/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding",
        "FeasibilityChecker::updateData",
        "matrix::Vector2d",
        "FeasibilityChecker::reset",
        "FeasibilityChecker::doCommonChecks"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::updateData",
          "matrix::Vector2d",
          "FeasibilityChecker::doCommonChecks",
          "FeasibilityChecker::reset",
          "FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding"
        ],
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": [
          "matrix::Vector2d"
        ]
      }
    }
  },
  {
    "title": "Navigator: Land: Improve it for VTOL by taking breaking distance into account",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23566",
    "number": 23566,
    "created_at": "2024-08-19T07:07:05Z",
    "merged": true,
    "merged_at": "2024-08-22T12:10:36Z",
    "state": "closed",
    "conversation": {
      "author": "Claudio-Chies",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen triggering a Land on a VTOL, the horizontal speed might not be zero after the back transition, resulting in a weird flying back movement, which comes from the fact that the setpoint is only updated until the transition is done, and not until it has come to a stop.\r\n<img src=\"https://github.com/user-attachments/assets/62ffd314-60cf-4ad9-9bb7-044ef6174926\"  width=\"300\" />\r\n<img src=\"https://github.com/user-attachments/assets/138862e5-f633-4b8f-adbe-b642e8f2f345\"  width=\"400\" />\r\n\r\n\r\n\r\n### Solution\r\nI propose we adapt the target landing location location setpoint based on the current velocity, and possible acceleration and jerk in MC mode.\r\n<img src=\"https://github.com/user-attachments/assets/d2b19b23-b963-4d81-a0ef-1932c9c9a861\"  width=\"300\" />\r\n<img src=\"https://github.com/user-attachments/assets/e420e871-36a3-4660-a67a-f3e78ef785ac\"  width=\"400\" />\r\n\r\n### Changelog Entry\r\n```\r\nBugfix: VTOL Landing Location\r\nDocumentation: Landing location for VTOL is where it came to an full halt, and not where backtransition was completed.\r\n```\r\n\r\n\r\n### Test coverage\r\nTested in SITL & on [Hardware](https://review.px4.io/plot_app?log=629ef75e-c257-4a24-912b-527d2f9634e6)\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2024-08-19T07:55:01Z",
          "body": "I can confirm that this caused quite hairy situations when flying our VTOL, (rapid loss of altitude after transitions)",
          "type": "issue_comment"
        },
        {
          "author": "Claudio-Chies",
          "created_at": "2024-08-22T08:43:14Z",
          "body": "Tested on Hardware, seems to work nicely\r\nadded [flight log](https://review.px4.io/plot_app?log=629ef75e-c257-4a24-912b-527d2f9634e6) to PR above",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-19T08:47:25Z",
          "body": "```suggestion\r\n\t\t// create a wp in front of the VTOL while in back-transition, based on MPC settings that will apply in MC phase afterwards\r\n```",
          "path": "src/modules/navigator/land.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-19T08:50:06Z",
          "body": "Seems like the right solution to me. Let's though first test if on real hardware before merging. ",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-22T12:10:28Z",
          "body": "Thanks!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect behavior: landing setpoints were computed at backtransition completion instead of accounting for the vehicle's remaining horizontal velocity and stopping distance, causing unintended movement after transition. The change predicts braking distance (using velocity/acceleration/jerk) and adjusts the landing target accordingly, correcting the program's logical handling of landing state rather than a syntax or runtime error.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "patch": "@@ -86,10 +86,8 @@ Land::on_active()\n \t    _navigator->get_vstatus()->in_transition_mode) {\n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t\t// create a virtual wp 1m in front of the vehicle to track during the backtransition\n-\t\twaypoint_from_heading_and_distance(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t\t\t   _navigator->get_local_position()->heading, 1.f,\n-\t\t\t\t\t\t   &pos_sp_triplet->current.lat, &pos_sp_triplet->current.lon);\n+\t\t// create a wp in front of the VTOL while in back-transition, based on MPC settings that will apply in MC phase afterwards\n+\t\t_navigator->calculate_breaking_stop(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n \n \t\t_navigator->set_position_setpoint_triplet_updated();\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2d62493b88ae0f0e7a48d4d250c29096d687164a/src%2Fmodules%2Fnavigator%2Fland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_active"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ]
      }
    }
  },
  {
    "title": "Global: Align mavlink message level with event message level",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23562",
    "number": 23562,
    "created_at": "2024-08-17T10:18:38Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nMAVLINK message level and EVENT message level are different.\r\n\r\n### Solution\r\n\r\nMake the MAVLINK message level the EVENT message level.\r\n\r\n### Changelog Entry\r\n\r\nNone.\r\n\r\n### Alternatives\r\n\r\nNone.\r\n\r\n### Test coverage\r\n\r\nNone.\r\n\r\n### Context\r\n\r\nNone.",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes an inconsistency between MAVLINK and EVENT message levels that would cause incorrect or unexpected behavior (e.g., differing message filtering/verbosity). Aligning the two levels corrects a logical mismatch in how messages are classified/handled, which fits the definition of a logic error.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "patch": "@@ -247,7 +247,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \n \n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: No home pos, WP %d uses rel alt\\t\", current_index + 1);\n-\t\tevents::send<int16_t>(events::ID(\"navigator_mis_no_home_rel_alt\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send<int16_t>(events::ID(\"navigator_mis_no_home_rel_alt\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t      \"Mission rejected: No home position, waypoint {1} uses relative altitude\",\n \t\t\t\t      current_index + 1);\n \t\treturn false;\n@@ -300,7 +300,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: item %i: unsupported cmd: %d\\t\",\n \t\t\t\t     (int)(current_index + 1),\n \t\t\t\t     (int)mission_item.nav_cmd);\n-\t\tevents::send<uint16_t, uint16_t>(events::ID(\"navigator_mis_unsup_cmd\"), {events::Log::Error, events::LogInternal::Warning},\n+\t\tevents::send<uint16_t, uint16_t>(events::ID(\"navigator_mis_unsup_cmd\"), {events::Log::Critical, events::LogInternal::Warning},\n \t\t\t\t\t\t \"Mission rejected: item {1}: unsupported command: {2}\", current_index + 1, mission_item.nav_cmd);\n \t\treturn false;\n \t}\n@@ -309,7 +309,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \tif ((current_index == 0) && mission_item.nav_cmd == NAV_CMD_LAND && _is_landed) {\n \n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: starts with landing\\t\");\n-\t\tevents::send(events::ID(\"navigator_mis_starts_w_landing\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_mis_starts_w_landing\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Mission rejected: starts with landing\");\n \t\treturn false;\n \t}\n@@ -329,7 +329,7 @@ bool FeasibilityChecker::checkTakeoff(mission_item_s &mission_item)\n \n \t\tif (takeoff_alt < FLT_EPSILON) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Takeoff altitude below home altitude!\\t\");\n-\t\t\tevents::send<float>(events::ID(\"navigator_mis_takeoff_too_low\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send<float>(events::ID(\"navigator_mis_takeoff_too_low\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t    \"Mission rejected: takeoff altitude too low! Minimum: {1:.1m_v}\",\n \t\t\t\t\t    mission_item.altitude_is_relative ? 0.0f : _home_alt_msl);\n \t\t\treturn false;\n@@ -346,7 +346,7 @@ bool FeasibilityChecker::checkTakeoff(mission_item_s &mission_item)\n \n \t\tif (_found_item_with_position) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: takeoff not first waypoint item\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_not_first\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_not_first\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: takeoff is not the first waypoint item\");\n \t\t\treturn false;\n \t\t}\n@@ -401,7 +401,7 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\tif (relative_approach_altitude < FLT_EPSILON) {\n \t\t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t\t     \"Mission rejected: the approach waypoint must be above the landing point.\\t\");\n-\t\t\t\tevents::send(events::ID(\"navigator_mis_approach_wp_below_land\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send(events::ID(\"navigator_mis_approach_wp_below_land\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t     \"Mission rejected: the approach waypoint must be above the landing point\");\n \t\t\t\treturn false;\n \t\t\t}\n@@ -419,7 +419,7 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\t\tif (distance_orbit_center_to_land <= orbit_radius) {\n \t\t\t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t\t\t     \"Mission rejected: the landing point must be outside the orbit radius.\\t\");\n-\t\t\t\t\tevents::send(events::ID(\"navigator_mis_land_wp_inside_orbit_radius\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\t\tevents::send(events::ID(\"navigator_mis_land_wp_inside_orbit_radius\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t     \"Mission rejected: the landing point must be outside the orbit radius\");\n \t\t\t\t\treturn false;\n \t\t\t\t}\n@@ -437,7 +437,7 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\t} else {\n \t\t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t\t     \"Mission rejected: unsupported landing approach entrance waypoint type. Only ORBIT_TO_ALT or WAYPOINT allowed.\\t\");\n-\t\t\t\tevents::send(events::ID(\"navigator_mis_unsupported_landing_approach_wp\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send(events::ID(\"navigator_mis_unsupported_landing_approach_wp\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t     \"Mission rejected: unsupported landing approach entrance waypoint type. Only ORBIT_TO_ALT or WAYPOINT allowed\");\n \t\t\t\treturn false;\n \t\t\t}\n@@ -459,7 +459,7 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t\t     \"Mission rejected: the landing glide slope is steeper than the vehicle setting of %d.%d degrees.\\t\",\n \t\t\t\t\t\t     (int)land_angle_left_of_decimal, (int)land_angle_first_after_decimal);\n-\t\t\t\tevents::send<uint8_t, uint8_t>(events::ID(\"navigator_mis_glide_slope_too_steep\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send<uint8_t, uint8_t>(events::ID(\"navigator_mis_glide_slope_too_steep\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t\t       \"Mission rejected: the landing glide slope is steeper than the vehicle setting of {1}.{2} degrees\",\n \t\t\t\t\t\t\t       land_angle_left_of_decimal, land_angle_first_after_decimal);\n \n@@ -469,7 +469,7 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t\t     \"Reduce the glide slope, lower the entrance altitude %d meters, or increase the landing approach distance %d meters.\\t\",\n \t\t\t\t\t\t     (int)acceptable_entrance_alt, (int)acceptable_landing_dist);\n-\t\t\t\tevents::send<uint32_t, uint32_t>(events::ID(\"navigator_mis_correct_glide_slope\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send<uint32_t, uint32_t>(events::ID(\"navigator_mis_correct_glide_slope\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t\t\t \"Reduce the glide slope, lower the entrance altitude {1} meters, or increase the landing approach distance {2} meters\",\n \t\t\t\t\t\t\t\t acceptable_entrance_alt, acceptable_landing_dist);\n \n@@ -492,7 +492,7 @@ bool FeasibilityChecker::checkLandPatternValidity(mission_item_s &mission_item,\n \tif (mission_item.nav_cmd == NAV_CMD_DO_LAND_START) {\n \t\tif (_do_land_start_index >= 0) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: more than one land start.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_multiple_land\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_multiple_land\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: more than one land start commands\");\n \t\t\treturn false;\n \n@@ -510,7 +510,7 @@ bool FeasibilityChecker::checkLandPatternValidity(mission_item_s &mission_item,\n \n \t\t} else {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: starts with land waypoint.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_starts_w_landing2\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_starts_w_landing2\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: starts with landing\");\n \t\t\treturn false;\n \t\t}\n@@ -519,15 +519,15 @@ bool FeasibilityChecker::checkLandPatternValidity(mission_item_s &mission_item,\n \t\tif (land_start_found && _do_land_start_index < current_index) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t     \"Mission rejected: land start item before RTL item not possible.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_land_before_rtl\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_land_before_rtl\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: land start item before RTL item is not possible\");\n \t\t\treturn false;\n \t\t}\n \t}\n \n \tif (current_index == last_index && land_start_found && (_do_land_start_index > _landing_approach_index)) {\n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: invalid land start.\\t\");\n-\t\tevents::send(events::ID(\"navigator_mis_invalid_land\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_mis_invalid_land\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Mission rejected: invalid land start\");\n \t\treturn false;\n \t}\n@@ -552,7 +552,7 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \n \t\tif (!result) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Takeoff waypoint required.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_missing\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_missing\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: Takeoff waypoint required\");\n \t\t\treturn false;\n \t\t}\n@@ -564,7 +564,7 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \n \t\tif (!result) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Landing waypoint/pattern required.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_land_missing\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_land_missing\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: Landing waypoint/pattern required\");\n \t\t}\n \n@@ -575,7 +575,7 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \n \t\tif (!result) {\n \t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Takeoff or Landing item missing.\\t\");\n-\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_or_land_missing\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_or_land_missing\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t     \"Mission rejected: Takeoff or Landing item missing\");\n \t\t}\n \n@@ -595,7 +595,7 @@ bool FeasibilityChecker::checkTakeoffLandAvailable()\n \n \t\t\tif (!result) {\n \t\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Landing waypoint/pattern required.\");\n-\t\t\t\tevents::send(events::ID(\"feasibility_mis_in_air_landing_req\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send(events::ID(\"feasibility_mis_in_air_landing_req\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t     \"Mission rejected: Landing waypoint/pattern required\");\n \t\t\t}\n \t\t}\n@@ -616,12 +616,12 @@ bool FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding()\n \n \tif (!result && (_has_takeoff)) {\n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Add Landing item or remove Takeoff.\\t\");\n-\t\tevents::send(events::ID(\"navigator_mis_add_land_or_rm_to\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_mis_add_land_or_rm_to\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Mission rejected: Add Landing item or remove Takeoff\");\n \n \t} else if (!result && (_landing_valid)) {\n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Add Takeoff item or remove Landing.\\t\");\n-\t\tevents::send(events::ID(\"navigator_mis_add_to_or_rm_land\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_mis_add_to_or_rm_land\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Mission rejected: Add Takeoff item or remove Landing\");\n \t}\n \n@@ -653,7 +653,7 @@ bool FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint(mission_item_s &\n \t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t     \"First waypoint too far away: %dm, %d max\\t\",\n \t\t\t\t\t     (int)dist_to_1wp_from_current_pos, (int)_param_mis_dist_1wp);\n-\t\t\tevents::send<uint32_t, uint32_t>(events::ID(\"navigator_mis_first_wp_too_far\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send<uint32_t, uint32_t>(events::ID(\"navigator_mis_first_wp_too_far\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t\t \"First waypoint too far away: {1m} (maximum: {2m})\", (uint32_t)dist_to_1wp_from_current_pos,\n \t\t\t\t\t\t\t (uint32_t)_param_mis_dist_1wp);\n \n@@ -688,7 +688,7 @@ bool FeasibilityChecker::checkDistancesBetweenWaypoints(const mission_item_s &mi\n \t\t\tmavlink_log_critical(_mavlink_log_pub,\n \t\t\t\t\t     \"Distance between waypoint and gate too close: %d meters\\t\",\n \t\t\t\t\t     (int)dist_between_waypoints);\n-\t\t\tevents::send<float, float>(events::ID(\"navigator_mis_wp_gate_too_close\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\tevents::send<float, float>(events::ID(\"navigator_mis_wp_gate_too_close\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t   \"Distance between waypoint and gate too close: {1:.3m} (minimum: {2:.3m})\", dist_between_waypoints, 0.05f);\n \n \n@@ -711,7 +711,7 @@ bool FeasibilityChecker::checkItemsFitToVehicleType(const mission_item_s &missio\n \t     || mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION)) {\n \n \t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Mission contains VTOL items but vehicle is not a VTOL\\t\");\n-\t\tevents::send(events::ID(\"navigator_mis_vtol_items\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_mis_vtol_items\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Mission rejected: Mission contains VTOL items but vehicle is not a VTOL\");\n \n \t\treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -502,7 +502,7 @@ Mission::save_mission_state()\n \t\t/* EVENT\n \t\t * @description No mission or storage failure\n \t\t */\n-\t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Error, \"Invalid mission state\");\n+\t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Critical, \"Invalid mission state\");\n \n \t\t/* write modified state only if changed */\n \t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "patch": "@@ -373,12 +373,12 @@ void MissionBase::update_mission()\n \t\tif (_land_detected_sub.get().landed) {\n \t\t\t/* landed, refusing to take off without a mission */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, refusing takeoff\\t\");\n-\t\t\tevents::send(events::ID(\"mission_not_valid_refuse\"), {events::Log::Error, events::LogInternal::Disabled},\n+\t\t\tevents::send(events::ID(\"mission_not_valid_refuse\"), {events::Log::Critical, events::LogInternal::Disabled},\n \t\t\t\t     \"No valid mission available, refusing takeoff\");\n \n \t\t} else {\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, loitering\\t\");\n-\t\t\tevents::send(events::ID(\"mission_not_valid_loiter\"), {events::Log::Error, events::LogInternal::Disabled},\n+\t\t\tevents::send(events::ID(\"mission_not_valid_loiter\"), {events::Log::Critical, events::LogInternal::Disabled},\n \t\t\t\t     \"No valid mission available, loitering\");\n \t\t}\n \n@@ -488,7 +488,7 @@ bool MissionBase::loadCurrentMissionItem()\n \n \tif (!success) {\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission item could not be set.\\t\");\n-\t\tevents::send(events::ID(\"mission_item_set_failed\"), events::Log::Error,\n+\t\tevents::send(events::ID(\"mission_item_set_failed\"), events::Log::Critical,\n \t\t\t     \"Mission item could not be set\");\n \t}\n \n@@ -940,7 +940,7 @@ int MissionBase::getNonJumpItem(int32_t &mission_index, mission_item_s &mission,\n \t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Waypoint could not be read.\\t\");\n-\t\t\tevents::send<uint16_t>(events::ID(\"mission_failed_to_read_wp\"), events::Log::Error,\n+\t\t\tevents::send<uint16_t>(events::ID(\"mission_failed_to_read_wp\"), events::Log::Critical,\n \t\t\t\t\t       \"Waypoint {1} could not be read from storage\", new_mission_index);\n \t\t\treturn PX4_ERROR;\n \t\t}\n@@ -960,7 +960,7 @@ int MissionBase::getNonJumpItem(int32_t &mission_index, mission_item_s &mission,\n \t\t\t\t\tif (!success) {\n \t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the dataman */\n \t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"DO JUMP waypoint could not be written.\\t\");\n-\t\t\t\t\t\tevents::send(events::ID(\"mission_failed_to_write_do_jump\"), events::Log::Error,\n+\t\t\t\t\t\tevents::send(events::ID(\"mission_failed_to_write_do_jump\"), events::Log::Critical,\n \t\t\t\t\t\t\t     \"DO JUMP waypoint could not be written\");\n \t\t\t\t\t\t// Still continue searching for next non jump item.\n \t\t\t\t\t}\n@@ -1138,7 +1138,7 @@ int MissionBase::setMissionToClosestItem(double lat, double lon, float alt, floa\n \t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Could not set mission closest to position.\\t\");\n-\t\t\tevents::send(events::ID(\"mission_failed_set_closest\"), events::Log::Error,\n+\t\t\tevents::send(events::ID(\"mission_failed_set_closest\"), events::Log::Critical,\n \t\t\t\t     \"Could not set mission closest to position\");\n \t\t\treturn PX4_ERROR;\n \t\t}\n@@ -1210,7 +1210,7 @@ void MissionBase::resetMissionJumpCounter()\n \t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission could not reset jump count.\\t\");\n-\t\t\tevents::send(events::ID(\"mission_failed_set_jump_count\"), events::Log::Error,\n+\t\t\tevents::send(events::ID(\"mission_failed_set_jump_count\"), events::Log::Critical,\n \t\t\t\t     \"Mission could not reset jump count\");\n \t\t\tbreak;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -110,7 +110,7 @@ MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission,\n {\n \tif (_navigator->get_geofence().isHomeRequired() && !home_valid) {\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\\t\");\n-\t\tevents::send(events::ID(\"navigator_mis_geofence_no_home\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_mis_geofence_no_home\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Geofence requires a valid home position\");\n \t\treturn false;\n \t}\n@@ -131,7 +131,7 @@ MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission,\n \n \t\t\tif (missionitem.altitude_is_relative && !home_valid) {\n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\\t\");\n-\t\t\t\tevents::send(events::ID(\"navigator_mis_geofence_no_home2\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send(events::ID(\"navigator_mis_geofence_no_home2\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t     \"Geofence requires a valid home position\");\n \t\t\t\treturn false;\n \t\t\t}\n@@ -143,7 +143,7 @@ MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission,\n \t\t\t\t    missionitem.lat, missionitem.lon, missionitem.altitude)) {\n \n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %zu\\t\", i + 1);\n-\t\t\t\tevents::send<int16_t>(events::ID(\"navigator_mis_geofence_violation\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\tevents::send<int16_t>(events::ID(\"navigator_mis_geofence_violation\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t      \"Geofence violation for waypoint {1}\",\n \t\t\t\t\t\t      i + 1);\n \t\t\t\treturn false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -403,7 +403,7 @@ void Navigator::run()\n \n \t\t\t\t} else {\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n-\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t     \"Reposition is outside geofence\");\n \t\t\t\t}\n \n@@ -484,7 +484,7 @@ void Navigator::run()\n \n \t\t\t\t} else {\n \t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n-\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n+\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t\t\t\t     \"Altitude change is outside geofence\");\n \t\t\t\t}\n \n@@ -864,7 +864,7 @@ void Navigator::run()\n \t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n \t\t\t\tpublish_vehicle_cmd(&vcmd);\n \t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n-\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n+\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Info,\n \t\t\t\t\t     \"Transition to hover mode and descend\");\n \t\t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -409,7 +409,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \t\tif (!success) {\n \t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission land item could not be read.\\t\");\n-\t\t\tevents::send(events::ID(\"rtl_failed_to_read_land_item\"), events::Log::Error,\n+\t\t\tevents::send(events::ID(\"rtl_failed_to_read_land_item\"), events::Log::Critical,\n \t\t\t\t     \"Mission land item could not be read\");\n \t\t}\n \n@@ -510,7 +510,7 @@ void RTL::setSafepointAsDestination(PositionYawSetpoint &rtl_position,\n \n \tdefault:\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RTL: unsupported MAV_FRAME\\t\");\n-\t\tevents::send<uint8_t>(events::ID(\"rtl_unsupported_mav_frame\"), events::Log::Error, \"RTL: unsupported MAV_FRAME ({1})\",\n+\t\tevents::send<uint8_t>(events::ID(\"rtl_unsupported_mav_frame\"), events::Log::Critical, \"RTL: unsupported MAV_FRAME ({1})\",\n \t\t\t\t      mission_safe_point.frame);\n \t\tbreak;\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -115,7 +115,7 @@ Takeoff::set_takeoff_position()\n \t\t// If the suggestion is lower than our current alt, let's not go down.\n \t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt;\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Already higher than takeoff altitude\\t\");\n-\t\tevents::send(events::ID(\"navigator_takeoff_already_higher\"), {events::Log::Error, events::LogInternal::Info},\n+\t\tevents::send(events::ID(\"navigator_takeoff_already_higher\"), {events::Log::Critical, events::LogInternal::Info},\n \t\t\t     \"Already higher than takeoff altitude (not descending)\");\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80a31394f1b58267c8844fab1fabe1773bdf5f12/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::save_mission_state",
        "FeasibilityChecker::checkTakeoff",
        "FeasibilityChecker::checkMissionItemValidity",
        "MissionBase::update_mission",
        "Takeoff::set_takeoff_position",
        "FeasibilityChecker::checkFixedWindLandApproach",
        "FeasibilityChecker::checkItemsFitToVehicleType",
        "FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding",
        "MissionBase::getNonJumpItem",
        "RTL::findRtlDestination",
        "Navigator::run",
        "MissionBase::loadCurrentMissionItem",
        "RTL::setSafepointAsDestination",
        "MissionBase::setMissionToClosestItem",
        "FeasibilityChecker::checkLandPatternValidity",
        "FeasibilityChecker::checkTakeoffLandAvailable",
        "MissionBase::resetMissionJumpCounter",
        "MissionFeasibilityChecker::checkMissionAgainstGeofence",
        "FeasibilityChecker::checkDistancesBetweenWaypoints",
        "FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkTakeoff",
          "FeasibilityChecker::checkDistancesBetweenWaypoints",
          "FeasibilityChecker::checkMissionItemValidity",
          "FeasibilityChecker::checkLandPatternValidity",
          "FeasibilityChecker::checkFixedWindLandApproach",
          "FeasibilityChecker::checkItemsFitToVehicleType",
          "FeasibilityChecker::hasMissionBothOrNeitherTakeoffAndLanding",
          "FeasibilityChecker::checkTakeoffLandAvailable",
          "FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::save_mission_state"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::loadCurrentMissionItem",
          "MissionBase::update_mission",
          "MissionBase::resetMissionJumpCounter",
          "MissionBase::setMissionToClosestItem",
          "MissionBase::getNonJumpItem"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionAgainstGeofence"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::setSafepointAsDestination",
          "RTL::findRtlDestination"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "Global: Initialize the message variable",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23560",
    "number": 23560,
    "created_at": "2024-08-16T22:34:04Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nInter-task message variables are being used without initialization.\r\n\r\n### Solution\r\n\r\nInitialize the inter-task message variable.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\nNone\r\n\r\n### Context\r\n\r\nNone",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2024-08-26T19:11:47Z",
          "body": "How about skip PX4Accelerometer/PX4gyroscope? Those ones are published at quite a high rate (kilohertz) and we know every single field is being set.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2024-09-04T22:59:06Z",
          "body": "Can you please discard https://github.com/PX4/PX4-Autopilot/pull/23560/commits/0f64d075f27b0e1f4b52f3860ba082647b4ac926 and https://github.com/PX4/PX4-Autopilot/pull/23560/commits/2eef867a52e2c26bd1db74602d9a42d95ce6c238 and I'll merge the rest?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2024-08-26T19:08:49Z",
          "body": "A lot of this can be unnecessary when we know we're setting every field, but honestly it's probably still better to be safe than sorry.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses use of inter-task message variables without initialization, which can lead to unpredictable/incorrect runtime behavior (wrong outputs or state) even if the program doesn't crash. Initializing these messages prevents logic bugs caused by leftover/garbage data; the reviewer notes some cases may be redundant when all fields are set, but the change prevents unintended behavior and is therefore a logic-fix.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -104,7 +104,7 @@ void Geofence::run()\n \t\t\t_initiate_fence_updated = false;\n \t\t\t_dataman_state\t= DatamanState::Read;\n \n-\t\t\tgeofence_status_s status;\n+\t\t\tgeofence_status_s status{};\n \t\t\tstatus.timestamp = hrt_absolute_time();\n \t\t\tstatus.geofence_id = _opaque_id;\n \t\t\tstatus.status = geofence_status_s::GF_STATUS_LOADING;\n@@ -159,7 +159,7 @@ void Geofence::run()\n \t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n \t\t\t\t_fence_updated = true;\n \n-\t\t\t\tgeofence_status_s status;\n+\t\t\t\tgeofence_status_s status{};\n \t\t\t\tstatus.timestamp = hrt_absolute_time();\n \t\t\t\tstatus.geofence_id = _opaque_id;\n \t\t\t\tstatus.status = geofence_status_s::GF_STATUS_READY;\n@@ -179,7 +179,7 @@ void Geofence::run()\n \t\t\t_updateFence();\n \t\t\t_fence_updated = true;\n \n-\t\t\tgeofence_status_s status;\n+\t\t\tgeofence_status_s status{};\n \t\t\tstatus.timestamp = hrt_absolute_time();\n \t\t\tstatus.geofence_id = _opaque_id;\n \t\t\tstatus.status = geofence_status_s::GF_STATUS_READY;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d7b429f78b0628afd55f49735d02508f1540628c/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::run"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::run"
        ]
      }
    }
  },
  {
    "title": "RTL: cone: never climb more than to RTL_RETURN_ALT",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23558",
    "number": 23558,
    "created_at": "2024-08-16T14:54:36Z",
    "merged": true,
    "merged_at": "2024-08-19T05:51:33Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "This is to prevent that a large NAV_ACC_RAD leads to very high return altitudes.\r\n\r\nAt some point we should reconsider the cone logic, seems unnecessary complicated. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: RTL: cone: never climb more than to RTL_RETURN_ALT\r\n```\r\n",
      "issue_comments": [
        {
          "author": "ryanjAA",
          "created_at": "2024-08-18T19:41:00Z",
          "body": "As a frequent RTL user, Im a big fan of this and the @bresch comment that it's overly complicated.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-08-21T04:40:34Z",
          "body": "> As a frequent RTL user, Im a big fan of this and the @bresch comment that it's overly complicated.\r\n\r\n@ryanjAA Just consider yourself lucky that you didn't have to document it :-( https://docs.px4.io/main/en/flight_modes/return.html#minimum-return-altitude",
          "type": "issue_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2024-08-21T08:35:45Z",
          "body": "@hamishwillee haha so true. You probably understand it better than anyone at this point. I always look at that page and just sigh everytime I have to think about changing the default or need to test it. Writing it would have been way more brutalâ€¦ ðŸ˜¬ ",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-08-22T00:46:18Z",
          "body": "The simple version of the theory is that if there is a more-or-less clear area around your landing target and your return is triggered within this area, then there is no need to ascent to the default return height in order to get safely to the landing point. The cone defines the safe height over the areas around the landing point. If you are above the cone you're safe, so you just fly back at your current height. If you're below the cone you're too low, so you ascend to the intersection with the cone and then return.\r\n\r\nIt kind of makes sense but  I doubt anyone uses it because they wouldn't think about it.\r\nI would use it if there was a 3d visualization tool for setting it that you could apply at the field and see the obstacles.\r\n\r\nI recall a discussion with RomanB about an alternative, defining segments around a VTOL landing point that are know to offer a clear path. Again, that is more likely to be used because AMC has a visualisation tool for it. \r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "2024-08-16T15:37:53Z",
          "body": "Yes, we should maybe review the logic",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect RTL climb behavior where a large NAV_ACC_RAD could cause the cone logic to compute an excessively high return altitude (above RTL_RETURN_ALT). This is a behavioral bug (incorrect state/decision logic) and the change limits the climb, fixing the unintended output of the cone computation.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "patch": "@@ -528,13 +528,14 @@ float RTL::calculate_return_alt_from_cone_half_angle(const PositionYawSetpoint &\n \t// avoid the vehicle touching the ground while still moving horizontally.\n \tconst float return_altitude_min_outside_acceptance_rad_amsl = rtl_position.alt + 2.0f * _param_nav_acc_rad.get();\n \n-\tfloat return_altitude_amsl = rtl_position.alt + _param_rtl_return_alt.get();\n+\tconst float max_return_altitude = rtl_position.alt + _param_rtl_return_alt.get();\n+\n+\tfloat return_altitude_amsl = max_return_altitude;\n \n \tif (destination_dist <= _param_nav_acc_rad.get()) {\n \t\treturn_altitude_amsl = rtl_position.alt + 2.0f * destination_dist;\n \n \t} else {\n-\n \t\tif (destination_dist <= _param_rtl_min_dist.get()) {\n \n \t\t\t// constrain cone half angle to meaningful values. All other cases are already handled above.\n@@ -549,7 +550,7 @@ float RTL::calculate_return_alt_from_cone_half_angle(const PositionYawSetpoint &\n \t\treturn_altitude_amsl = max(return_altitude_amsl, return_altitude_min_outside_acceptance_rad_amsl);\n \t}\n \n-\treturn max(return_altitude_amsl, _global_pos_sub.get().alt);\n+\treturn constrain(return_altitude_amsl, _global_pos_sub.get().alt, max_return_altitude);\n }\n \n void RTL::init_rtl_mission_type()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/cbf5d7116f8f85b38c33fe5df9e8c8e6535392fc/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "max",
        "RTL::calculate_return_alt_from_cone_half_angle"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "max",
          "RTL::calculate_return_alt_from_cone_half_angle"
        ]
      }
    }
  },
  {
    "title": "Landing horizontal velocity compensation / unsteady landing",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23546",
    "number": 23546,
    "created_at": "2024-08-14T14:04:36Z",
    "merged": true,
    "merged_at": "2024-08-19T06:01:43Z",
    "state": "closed",
    "conversation": {
      "author": "Claudio-Chies",
      "body": "### Solved Problem\r\nThere was a problem where triggering Land, while having a forward velocity, the landing algorithm didn't compensate it, meaning the vehicle remained drifting while getting closer to the ground , and in some cases jerking unsteadily\r\n\r\n### Solution\r\ni set the target landing location based on the current velocity, maximum acceleration and jerk. this way the drone is able to compensate the velocity and land smoothly at the target location.\r\n\r\n### Changelog Entry\r\n\r\n- changed the lat and long in the triplet generation process in the navigator to be at a location in front of the vehicle, dependent on its current state.\r\n- set the previous setpoint triplet to be the same as the target one, this way we avoid getting into offtrack mode.\r\n\r\n```\r\nBugfix: Unsteady landing with horizontal velocity\r\nDocumentation: the position set point for landing gets set to a location in front of the vehicle where its able to halt before. greatly improving landing performance when triggering landing while moving\r\n```\r\n\r\n### Test coverage\r\n SITL and on Hardware\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-14T15:27:33Z",
          "body": "@Claudio-Chies looks clean but I need to look at it in more detail. Do you know which change caused this regression (assuming it is a regression)?",
          "type": "issue_comment"
        },
        {
          "author": "Claudio-Chies",
          "created_at": "2024-08-14T15:31:02Z",
          "body": "@sfuhrer Not yet, i can have a look into it.\nI realized just now, that this might enable us zo get rid of the special case for vtol where the landing position is hardcoded 1m infront of the current position.",
          "type": "issue_comment"
        },
        {
          "author": "Claudio-Chies",
          "created_at": "2024-08-15T17:51:08Z",
          "body": "> `_target` is the `_triplet_target` pre-processed by the flight task. The general rule is that we shouldn't use `_triplet_target` in the code and only use `_target` as this is used everywhere else otherwise there will be an inconsistency between the different parts of FlightTaskAuto.\r\n> \r\n> If I understand correctly using `_triplet_target` fixes the issue because it skips `_updateInternalWaypoints`. Could you rather find why `_updateInternalWaypoints` changes it and fix the problem there?\r\n\r\ngood point, didn't know that. so the issue seems that it goes into offtrack mode.\r\nwith the change proposed it avoids offtrack mode by setting the previous triplet to be the same as the target.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-16T13:54:44Z",
          "body": "Why is that actually needed?",
          "path": "src/modules/navigator/land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Claudio-Chies",
          "created_at": "2024-08-16T14:00:01Z",
          "body": "so we cant go into offtrack mode",
          "path": "src/modules/navigator/land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T14:11:30Z",
          "body": "Fixedwing is not the special case here, it's multirotor.\r\n\r\nI would rather have `if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) { // calculate breaking stop` and \"else do the usual stuff\". Otherwise you'll also compute the breaking stop for the rovers/boats/...\r\n\r\n",
          "path": "src/modules/navigator/land.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "2024-08-15T09:30:25Z",
          "body": "`_target` is the `_triplet_target` pre-processed by the flight task. The general rule is that we shouldn't use `_triplet_target` in the code and only use `_target` as this is used everywhere else otherwise there will be an inconsistency between the different parts of FlightTaskAuto.\r\n\r\nIf I understand correctly using `_triplet_target` fixes the issue because it skips `_updateInternalWaypoints`. Could you rather find why `_updateInternalWaypoints` changes it and fix the problem there?",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-16T13:54:44Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "Claudio-Chies",
          "created_at": "2024-08-16T14:00:02Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T14:11:35Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T14:27:12Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-16T14:33:48Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect runtime behavior (unsteady drifting/jerky landing) caused by how the landing setpoint and triplet/state transitions were computed. The change updates the landing target calculation to account for current horizontal velocity and adjusts previous setpoint handling to avoid an offtrack state, which fixes improper state transitions and incorrect algorithmic behavior in the landing logic.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "patch": "@@ -57,8 +57,13 @@ Land::on_activation()\n \n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\tpos_sp_triplet->previous.valid = false;\n+\n+\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t_navigator->calculate_breaking_stop(_mission_item.lat, _mission_item.lon);\n+\t}\n+\n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\tpos_sp_triplet->previous.valid = false;\n \tpos_sp_triplet->next.valid = false;\n \n \t_navigator->set_position_setpoint_triplet_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1f502539ca785ec98601f2a907ad57150e032d59/src%2Fmodules%2Fnavigator%2Fland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ]
      }
    }
  },
  {
    "title": "Add maximum height above ground (HAGL) check to all Navigator modes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23542",
    "number": 23542,
    "created_at": "2024-08-14T12:46:19Z",
    "merged": true,
    "merged_at": "2024-08-16T14:26:20Z",
    "state": "closed",
    "conversation": {
      "author": "bresch",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nThe HAGL navigator failsafe I added in https://github.com/PX4/PX4-Autopilot/pull/23501 should be used in all navigator modes.\r\n\r\n### Solution\r\nCentralize the check instead of adding it to each mode separately.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nAdd maximum height above ground (HAGL) check to all Navigator modes\r\nNew parameter: -\r\nDocumentation: -\r\n```\r\n\r\n### Test coverage\r\n- SITL tests\r\n\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-15T13:09:24Z",
          "body": "```suggestion\r\n\t\t// Handle case where the altitude setpoint is above the maximum HAGL (height above ground level)\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-15T13:13:31Z",
          "body": "```suggestion\r\n\t\tevents::send(events::ID(\"navigator_fail_max_hagl\"), events::Log::Error, \"Target altitude higher than max HAGL\");\r\n```",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T09:05:56Z",
          "body": "Hmm, that's a good example why comments are bad",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T09:09:53Z",
          "body": "thanks",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-15T14:07:57Z",
          "body": "Agree that we should aim for a generic solution and not have them custom for RTL/Takeoff. Some comments from testing in SITL:\r\n- the reporting of the HAGL failsafe is a bit rough. E.g. it says it will switch to Hold when it already is in Hold, and it doesn't apply the timeout\r\n![image](https://github.com/user-attachments/assets/3e5b7c4c-cede-47e2-8d94-c49fdb4fd4de)\r\n- doesn't seem to work with MC Orbit\r\n- RTL wih OF only: why does it 3 times switch into RTL before then going to Land?\r\n![image](https://github.com/user-attachments/assets/1076c700-b6e9-4e2d-b8a8-5636050d36c1)\r\n\r\n",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T09:05:57Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-16T09:09:53Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-16T13:34:48Z",
          "body": "Looks good to me now, the extension to not have the delay when switching to Hold seems correct. For my other comments:\r\n\r\n>doesn't seem to work with MC Orbit\r\n\r\nOkay that is expected and not easy to change, as the Orbit doesn't use the triplet at all\r\n\r\n> RTL wih OF only: why does it 3 times switch into RTL before then going to Land?\r\n\r\nThat was actually the GCS sending the command 3 times.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR centralizes and applies the HAGL (height above ground) failsafe across all Navigator modes, addressing inconsistent/missing failsafe behavior (an incorrect program state transition and missing safety check). Reviewer feedback confirms the change fixes the problematic behavior, with remaining limitations (e.g., Orbit mode) being expected due to different control flow.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "patch": "@@ -1042,3 +1042,29 @@ void MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet(mission_i\n \t\t_mission_item.altitude_is_relative = false;\n \t}\n }\n+\n+void MissionBlock::updateFailsafeChecks()\n+{\n+\tupdateMaxHaglFailsafe();\n+}\n+\n+void MissionBlock::updateMaxHaglFailsafe()\n+{\n+\tconst float target_alt = _navigator->get_position_setpoint_triplet()->current.alt;\n+\n+\tif (_navigator->get_global_position()->terrain_alt_valid\n+\t    && ((target_alt - _navigator->get_global_position()->terrain_alt) > _navigator->get_local_position()->hagl_max)) {\n+\t\t// Handle case where the altitude setpoint is above the maximum HAGL (height above ground level)\n+\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Target altitude higher than max HAGL\\t\");\n+\t\tevents::send(events::ID(\"navigator_fail_max_hagl\"), events::Log::Error, \"Target altitude higher than max HAGL\");\n+\n+\t\t_navigator->trigger_hagl_failsafe(getNavigatorStateId());\n+\n+\t\t// While waiting for a failsafe action from commander, keep the curren position\n+\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n+\n+\t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2cbed691d2c973dd460174e8d0a1ae4d3b065c55/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -145,6 +145,8 @@ class MissionBlock : public NavigatorMode\n \tvoid set_align_mission_item(struct mission_item_s *const mission_item,\n \t\t\t\t    const struct mission_item_s *const mission_item_next) const;\n \n+\tvoid updateFailsafeChecks() override;\n+\n protected:\n \t/**\n \t * @brief heading mode for setting navigation items\n@@ -249,4 +251,8 @@ class MissionBlock : public NavigatorMode\n \tbool _payload_deploy_ack_successful{false};\t// Flag to keep track of whether we received an acknowledgement for a successful payload deployment\n \thrt_abstime _payload_deployed_time{0};\t\t// Last payload deployment start time to handle timeouts\n \tfloat _payload_deploy_timeout_s{0.0f};\t\t// Timeout for payload deployment in Mission class, to prevent endless loop if successful deployment ack is never received\n+\n+private:\n+\tvoid updateMaxHaglFailsafe();\n+\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2cbed691d2c973dd460174e8d0a1ae4d3b065c55/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator_mode.cpp": {
        "filename": "src/modules/navigator/navigator_mode.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -61,6 +61,7 @@ NavigatorMode::run(bool active)\n \t\t} else {\n \t\t\t/* periodic updates when active */\n \t\t\ton_active();\n+\t\t\tupdateFailsafeChecks();\n \t\t}\n \n \t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2cbed691d2c973dd460174e8d0a1ae4d3b065c55/src%2Fmodules%2Fnavigator%2Fnavigator_mode.cpp"
      },
      "src/modules/navigator/navigator_mode.h": {
        "filename": "src/modules/navigator/navigator_mode.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -80,6 +80,8 @@ class NavigatorMode\n \t */\n \tvirtual void on_active();\n \n+\tvirtual void updateFailsafeChecks() {};\n+\n protected:\n \tNavigator *_navigator{nullptr};\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2cbed691d2c973dd460174e8d0a1ae4d3b065c55/src%2Fmodules%2Fnavigator%2Fnavigator_mode.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -283,10 +283,12 @@ void RTL::on_active()\n \tcase RtlType::RTL_MISSION_FAST_REVERSE:\n \tcase RtlType::RTL_DIRECT_MISSION_LAND:\n \t\t_rtl_mission_type_handle->on_active();\n+\t\t_rtl_mission_type_handle->updateFailsafeChecks();\n \t\tbreak;\n \n \tcase RtlType::RTL_DIRECT:\n \t\t_rtl_direct.on_active();\n+\t\t_rtl_direct.updateFailsafeChecks();\n \t\tbreak;\n \n \tdefault:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2cbed691d2c973dd460174e8d0a1ae4d3b065c55/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "patch": "@@ -158,16 +158,6 @@ void RtlDirect::set_rtl_item()\n {\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\tif (_global_pos_sub.get().terrain_alt_valid\n-\t    && ((_rtl_alt - _global_pos_sub.get().terrain_alt) > _navigator->get_local_position()->hagl_max)) {\n-\t\t// Handle case where the RTL altidude is above the maximum HAGL and land in place instead of RTL\n-\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: return alt higher than max HAGL\\t\");\n-\t\tevents::send(events::ID(\"rtl_fail_max_hagl\"), events::Log::Error, \"RTL: return alt higher than max HAGL\");\n-\n-\t\t_navigator->trigger_hagl_failsafe(getNavigatorStateId());\n-\t\t_rtl_state = RTLState::IDLE;\n-\t}\n-\n \tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon,\n \t\t\t\t       _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n \tconst float loiter_altitude = math::min(_land_approach.height_m, _rtl_alt);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2cbed691d2c973dd460174e8d0a1ae4d3b065c55/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet",
        "NavigatorMode::run",
        "RTL::on_active",
        "RtlDirect::set_rtl_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet"
        ],
        "src/modules/navigator/navigator_mode.cpp": [
          "NavigatorMode::run"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_active"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "navigator: Initialize the message variable",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23541",
    "number": 23541,
    "created_at": "2024-08-13T15:21:31Z",
    "merged": true,
    "merged_at": "2024-08-14T01:33:36Z",
    "state": "closed",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nInitialize inter-task message variables.\r\n\r\n### Solution\r\n\r\nDeclare initialization.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\nNone\r\n\r\n### Context\r\n\r\nNone",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2024-08-13T20:50:40Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR explicitly initializes inter-task message variables that were previously left uninitialized. Leaving such variables uninitialized can produce incorrect or inconsistent program state and unpredictable behavior, so adding an explicit initialization corrects a logic bug related to improper state handling.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -104,7 +104,7 @@ void Geofence::run()\n \t\t\t_initiate_fence_updated = false;\n \t\t\t_dataman_state\t= DatamanState::Read;\n \n-\t\t\tgeofence_status_s status;\n+\t\t\tgeofence_status_s status{};\n \t\t\tstatus.timestamp = hrt_absolute_time();\n \t\t\tstatus.geofence_id = _opaque_id;\n \t\t\tstatus.status = geofence_status_s::GF_STATUS_LOADING;\n@@ -159,7 +159,7 @@ void Geofence::run()\n \t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n \t\t\t\t_fence_updated = true;\n \n-\t\t\t\tgeofence_status_s status;\n+\t\t\t\tgeofence_status_s status{};\n \t\t\t\tstatus.timestamp = hrt_absolute_time();\n \t\t\t\tstatus.geofence_id = _opaque_id;\n \t\t\t\tstatus.status = geofence_status_s::GF_STATUS_READY;\n@@ -179,7 +179,7 @@ void Geofence::run()\n \t\t\t_updateFence();\n \t\t\t_fence_updated = true;\n \n-\t\t\tgeofence_status_s status;\n+\t\t\tgeofence_status_s status{};\n \t\t\tstatus.timestamp = hrt_absolute_time();\n \t\t\tstatus.geofence_id = _opaque_id;\n \t\t\tstatus.status = geofence_status_s::GF_STATUS_READY;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c9ca278197109d8ffa647b3440472d6247141e1e/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::run"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::run"
        ]
      }
    }
  },
  {
    "title": "navigator: Align MAVLINK message level with EVENT message level",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23535",
    "number": 23535,
    "created_at": "2024-08-12T05:16:17Z",
    "merged": true,
    "merged_at": "2024-08-12T17:09:23Z",
    "state": "closed",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nMAVLINK message level and EVENT message level are different.\r\n\r\n### Solution\r\n\r\nMatch the EVENT message level to the MAVLINK message level.\r\n\r\n### Changelog Entry\r\n\r\nNone.\r\n\r\n### Alternatives\r\n\r\nNone.\r\n\r\n### Test coverage\r\n\r\nNone.\r\n\r\n### Context\r\n\r\nNone.",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-12T17:09:06Z",
          "body": "thanks for aligning them, seems more correct like that.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes an inconsistency between MAVLINK and EVENT message severity levels, which is a behavioral/logic issue (messages would be classified or handled differently). Aligning the EVENT level to the MAVLINK level corrects unintended incorrect behavior, so this qualifies as a logic error fix.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -648,7 +648,7 @@ Geofence::loadFromFile(const char *filename)\n \n \t} else {\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence: import error\\t\");\n-\t\tevents::send(events::ID(\"navigator_geofence_import_failed\"), events::Log::Error, \"Geofence: import error\");\n+\t\tevents::send(events::ID(\"navigator_geofence_import_failed\"), events::Log::Critical, \"Geofence: import error\");\n \t}\n \n \tupdateFence();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d9022316dc812eba191832ea20ab7542b9f49de0/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::loadFromFile"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::loadFromFile"
        ]
      }
    }
  },
  {
    "title": "navigator: Change IF statement to SWITCH statement",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23534",
    "number": 23534,
    "created_at": "2024-08-12T03:50:47Z",
    "merged": true,
    "merged_at": "2024-08-14T07:40:36Z",
    "state": "closed",
    "conversation": {
      "author": "muramura",
      "body": "### Solved Problem\r\n\r\nClarify each decision value.\r\n\r\nre pr #23065\r\n\r\n### Solution\r\n\r\nChange the IF statement to a SWITCH statement.\r\n\r\n### Changelog Entry\r\n\r\nNone\r\n\r\n### Alternatives\r\n\r\nNone\r\n\r\n### Test coverage\r\n\r\nNone\r\n\r\n### Context\r\n\r\nNone",
      "issue_comments": [
        {
          "author": "dayjaby",
          "created_at": "2024-08-12T07:13:07Z",
          "body": "With these kinds of changes, it's always nice to show or prove what exactly is getting better (or worse). Like did you consider comparing the resulting firmware sizes?\r\n\r\nChecking the assembly results with some similar code (https://gcc.godbolt.org/z/EeW8Tzcb3) against a similar compiler (arm 9.3.0),  I'd argue that the if-solution is actually better. It's not doing multiple comparisons in a row, but some highly efficient bit calculations whereas the switch-solution creates a large lookup table.",
          "type": "issue_comment"
        },
        {
          "author": "muramura",
          "created_at": "2024-08-13T14:58:11Z",
          "body": "@dayjaby san.\r\nIn both the SWITCH and IF statements, the memory size was the same.\r\nThe SWITCH statement uses the same variable for multiple comparison values.\r\nThe IF statement allows for different conditions.\r\nBefore the change, the same variable was used repeatedly in the conditions.\r\nThis is not considered good coding style.\r\n\r\nIPA, an organization in Japan, has published a business-oriented C++ embedded coding style guide.\r\n![Screenshot from 2024-08-14 00-05-35](https://github.com/user-attachments/assets/90356576-86a8-4a5e-9681-9d96070c8da0)\r\n\r\n\r\nAFTER:\r\n[1294/1296] Linking CXX executable px4_fmu-v6xrt_default.elf\r\nMemory region         Used Size  Region Size  %age Used\r\n           flash:     2114556 B      3968 KB     52.04%\r\n            sram:       91756 B      1280 KB      7.00%\r\n            itcm:      209256 B       256 KB     79.82%\r\n            dtcm:         936 B       256 KB      0.36%\r\n\r\nBEFORE:\r\n[1294/1296] Linking CXX executable px4_fmu-v6xrt_default.elf\r\nMemory region         Used Size  Region Size  %age Used\r\n           flash:     2114556 B      3968 KB     52.04%\r\n            sram:       91756 B      1280 KB      7.00%\r\n            itcm:      209256 B       256 KB     79.82%\r\n            dtcm:         936 B       256 KB      0.36%\r\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "bresch",
          "created_at": "2024-08-14T07:39:48Z",
          "body": "```suggestion\r\n\tdefault:  // unknown fence type\r\n```",
          "path": "src/modules/navigator/geofence.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2024-08-13T20:51:24Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-14T07:39:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The change replaces an if-chain with a switch to clarify decision values and coding style; reviewers and author show no change in behavior or memory usage and no tests or bug reports are referenced. This is a stylistic/clarity change rather than a fix to incorrect program behavior, so it does not address a logic error.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 18,
        "changes": 62,
        "patch": "@@ -406,17 +406,25 @@ bool Geofence::checkPointAgainstPolygonCircle(const PolygonInfo &polygon, double\n {\n \tbool checksPass = true;\n \n-\tif (polygon.fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n+\tswitch (polygon.fence_type) {\n+\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n \t\tchecksPass &= insideCircle(polygon, lat, lon, altitude);\n+\t\tbreak;\n \n-\t} else if (polygon.fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n+\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n \t\tchecksPass &= !insideCircle(polygon, lat, lon, altitude);\n+\t\tbreak;\n \n-\t} else if (polygon.fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n+\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n \t\tchecksPass &= insidePolygon(polygon, lat, lon, altitude);\n+\t\tbreak;\n \n-\t} else if (polygon.fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION) {\n+\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n \t\tchecksPass &= !insidePolygon(polygon, lat, lon, altitude);\n+\t\tbreak;\n+\n+\tdefault:  // unknown fence type\n+\t\tbreak;\n \t}\n \n \treturn checksPass;\n@@ -452,12 +460,18 @@ bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (temp_vertex_i.frame != NAV_FRAME_GLOBAL && temp_vertex_i.frame != NAV_FRAME_GLOBAL_INT\n-\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n-\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n+\t\tswitch (temp_vertex_i.frame) {\n+\t\tcase NAV_FRAME_GLOBAL:\n+\t\tcase NAV_FRAME_GLOBAL_INT:\n+\t\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT:\n+\t\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT_INT:\n+\t\t\tbreak;\n+\n+\t\tdefault:\n \t\t\t// TODO: handle different frames\n \t\t\tPX4_ERR(\"Frame type %i not supported\", (int)temp_vertex_i.frame);\n-\t\t\tbreak;\n+\t\t\treturn c;\n+\n \t\t}\n \n \t\tif (((double)temp_vertex_i.lon >= lon) != ((double)temp_vertex_j.lon >= lon) &&\n@@ -482,12 +496,18 @@ bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon,\n \t\treturn false;\n \t}\n \n-\tif (circle_point.frame != NAV_FRAME_GLOBAL && circle_point.frame != NAV_FRAME_GLOBAL_INT\n-\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n-\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n+\tswitch (circle_point.frame) {\n+\tcase NAV_FRAME_GLOBAL:\n+\tcase NAV_FRAME_GLOBAL_INT:\n+\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT:\n+\tcase NAV_FRAME_GLOBAL_RELATIVE_ALT_INT:\n+\t\tbreak;\n+\n+\tdefault:\n \t\t// TODO: handle different frames\n \t\tPX4_ERR(\"Frame type %i not supported\", (int)circle_point.frame);\n \t\treturn false;\n+\n \t}\n \n \tif (!_projection_reference.isInitialized()) {\n@@ -675,20 +695,26 @@ void Geofence::printStatus()\n \tfor (int i = 0; i < _num_polygons; ++i) {\n \t\ttotal_num_vertices += _polygons[i].vertex_count;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n+\t\tswitch (_polygons[i].fence_type) {\n+\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n \t\t\t++num_inclusion_polygons;\n-\t\t}\n+\t\t\tbreak;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION) {\n+\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n \t\t\t++num_exclusion_polygons;\n-\t\t}\n+\t\t\tbreak;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n+\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n \t\t\t++num_inclusion_circles;\n-\t\t}\n+\t\t\tbreak;\n \n-\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n+\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n \t\t\t++num_exclusion_circles;\n+\t\t\tbreak;\n+\n+\t\tdefault:  // unknown fence type\n+\t\t\tbreak;\n+\n \t\t}\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/6967cab375fe80f55e8526d6e6f2f803ab5902a2/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::checkPointAgainstPolygonCircle",
        "Geofence::insidePolygon",
        "Geofence::printStatus",
        "Geofence::insideCircle"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::checkPointAgainstPolygonCircle",
          "Geofence::insidePolygon",
          "Geofence::printStatus",
          "Geofence::insideCircle"
        ]
      }
    }
  },
  {
    "title": "RTL Direct: terrain collision avoidance fix",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23503",
    "number": 23503,
    "created_at": "2024-08-06T22:01:53Z",
    "merged": true,
    "merged_at": "2024-08-08T11:37:36Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nFollowup from https://github.com/PX4/PX4-Autopilot/pull/23429: When in RTLDirect the terrain avoidance check was only done when in Loiter down state. Once this state was passed the altitude setpoint was opened again and the vehicle proceeded descending.\r\n\r\n### Solution\r\n- add publication of NavigatorMissionItem to RTLDirect for logging and easier trouble shooting\r\n- run updateAltToAvoidTerrainCollisionAndRepublishTriplet() in entire RTLDirect except for when state is in IDLE (which is the case then the vehicle is vertically Landing)\r\n\r\n\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-07T13:31:45Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects an incorrect state-based check: terrain-avoidance was only applied in the Loiter down state, allowing the altitude setpoint to be reopened and the vehicle to descend unexpectedly. Expanding updateAltToAvoidTerrainCollisionAndRepublishTriplet() to the entire RTLDirect flow (except IDLE) fixes the improper state/condition handling that caused unintended behavior; publishing NavigatorMissionItem is an added logging aid.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -870,7 +870,6 @@ void MissionBase::publish_navigator_mission_item()\n {\n \tnavigator_mission_item_s navigator_mission_item{};\n \n-\tnavigator_mission_item.instance_count = _navigator->mission_instance_count();\n \tnavigator_mission_item.sequence_current = _mission.current_seq;\n \tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n \tnavigator_mission_item.latitude = _mission_item.lat;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/da214f98897a92638f485b09a5a968dd43949e62/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -249,8 +249,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \torb_advert_t *get_mavlink_log_pub() { return &_mavlink_log_pub; }\n \n-\tint mission_instance_count() const { return _mission_result.mission_id; }\n-\n \tvoid set_mission_failure_heading_timeout();\n \n \tbool get_mission_start_land_available() { return _mission.get_land_start_available(); }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/da214f98897a92638f485b09a5a968dd43949e62/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "patch": "@@ -104,8 +104,9 @@ void RtlDirect::on_active()\n \t\tset_rtl_item();\n \t}\n \n-\tif (_rtl_state == RTLState::LOITER_HOLD) { //TODO: rename _rtl_state to _rtl_state_next\n+\tif (_rtl_state != RTLState::IDLE) { //TODO: rename _rtl_state to _rtl_state_next (when in IDLE we're actually in LAND)\n \t\t//check for terrain collision and update altitude if needed\n+\t\t// note: it may trigger multiple times during a RTL, as every time the altitude set is reset\n \t\tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n \t}\n \n@@ -337,6 +338,8 @@ void RtlDirect::set_rtl_item()\n \t\t\t_navigator->set_position_setpoint_triplet_updated();\n \t\t}\n \t}\n+\n+\tpublish_rtl_direct_navigator_mission_item(); // for logging\n }\n \n RtlDirect::RTLState RtlDirect::getActivationLandState()\n@@ -515,3 +518,32 @@ loiter_point_s RtlDirect::sanitizeLandApproach(loiter_point_s land_approach) con\n \n \treturn sanitized_land_approach;\n }\n+\n+void RtlDirect::publish_rtl_direct_navigator_mission_item()\n+{\n+\tnavigator_mission_item_s navigator_mission_item{};\n+\n+\tnavigator_mission_item.sequence_current = static_cast<uint16_t>(_rtl_state);\n+\tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n+\tnavigator_mission_item.latitude = _mission_item.lat;\n+\tnavigator_mission_item.longitude = _mission_item.lon;\n+\tnavigator_mission_item.altitude = _mission_item.altitude;\n+\n+\tnavigator_mission_item.time_inside = get_time_inside(_mission_item);\n+\tnavigator_mission_item.acceptance_radius = _mission_item.acceptance_radius;\n+\tnavigator_mission_item.loiter_radius = _mission_item.loiter_radius;\n+\tnavigator_mission_item.yaw = _mission_item.yaw;\n+\n+\tnavigator_mission_item.frame = _mission_item.frame;\n+\tnavigator_mission_item.frame = _mission_item.origin;\n+\n+\tnavigator_mission_item.loiter_exit_xtrack = _mission_item.loiter_exit_xtrack;\n+\tnavigator_mission_item.force_heading = _mission_item.force_heading;\n+\tnavigator_mission_item.altitude_is_relative = _mission_item.altitude_is_relative;\n+\tnavigator_mission_item.autocontinue = _mission_item.autocontinue;\n+\tnavigator_mission_item.vtol_back_transition = _mission_item.vtol_back_transition;\n+\n+\tnavigator_mission_item.timestamp = hrt_absolute_time();\n+\n+\t_navigator_mission_item_pub.publish(navigator_mission_item);\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/da214f98897a92638f485b09a5a968dd43949e62/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -47,6 +47,7 @@\n #include <uORB/Subscription.hpp>\n #include <uORB/SubscriptionInterval.hpp>\n #include <uORB/topics/home_position.h>\n+#include <uORB/topics/navigator_mission_item.h>\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/rtl_time_estimate.h>\n #include <uORB/topics/vehicle_global_position.h>\n@@ -137,6 +138,12 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t */\n \tvoid parameters_update();\n \n+\t/**\n+\t * @brief Publish navigator mission item\n+\t *\n+\t */\n+\tvoid publish_rtl_direct_navigator_mission_item();\n+\n \tRTLState getActivationLandState();\n \n \tvoid setLoiterPosition();\n@@ -167,4 +174,5 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \tuORB::SubscriptionData<vehicle_land_detected_s> _land_detected_sub{ORB_ID(vehicle_land_detected)};\t/**< vehicle land detected subscription */\n \tuORB::SubscriptionData<vehicle_status_s> _vehicle_status_sub{ORB_ID(vehicle_status)};\t/**< vehicle status subscription */\n \tuORB::SubscriptionData<wind_s>\t\t_wind_sub{ORB_ID(wind)};\n+\tuORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item}; /**< Navigator mission item publication*/\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/da214f98897a92638f485b09a5a968dd43949e62/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::publish_navigator_mission_item",
        "RtlDirect::set_rtl_item",
        "mission_instance_count",
        "RtlDirect::sanitizeLandApproach",
        "RtlDirect::on_active"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::publish_navigator_mission_item"
        ],
        "src/modules/navigator/navigator.h": [
          "mission_instance_count"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::sanitizeLandApproach",
          "RtlDirect::on_active",
          "RtlDirect::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "RTL: do not RTL if RTL alt is above max HAGL",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23501",
    "number": 23501,
    "created_at": "2024-08-06T11:41:19Z",
    "merged": true,
    "merged_at": "2024-08-14T09:08:02Z",
    "state": "closed",
    "conversation": {
      "author": "bresch",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen using a downward looking sensor for navigation (e.g.: optical flow), the EKF sends a height above ground limit that the vehicle shouldn't exceed to avoid a loss of navigation. Currently, commander/navigator are unaware of this and are allowed to trigger RTL with an altitude higher than the maximum value, leading to a descend. When below the max HAGL, the navigation re-starts and commander tries to RTL again. The vehicle is then stuck in a loop.\r\n\r\n### Solution\r\nRTL shouldn't send the vehicle to an altitude above the mag HAGL. Sending the drone to the max HAGL and then to home is dangerous too, so the best option is to land instead.\r\n\r\nNew uORB topic: `navigator_status` is used to report when a navigator mode fails to execute.\r\nCommander monitors this field and triggers a failsafe if the current navigator mode fails.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\n-\r\nNew parameter: -\r\nDocumentation: -\r\n```\r\n\r\n### Test coverage\r\nsitl with optical flow\r\n",
      "issue_comments": [
        {
          "author": "bresch",
          "created_at": "2024-08-07T14:12:16Z",
          "body": "I will in fact try to do something similar to geofence:\r\n1. Navigator sends a uorb topic with the \"breached\" flag\r\n2. commander/HealthAndArmingChecks subs to that topic and sets a failsafe flag\r\n3. failsafe.cpp gets that flag and switches to land",
          "type": "issue_comment"
        },
        {
          "author": "Drone-Lab",
          "created_at": "2025-04-08T20:32:34Z",
          "body": "Hi! I am unable to reproduce this vulnerability. Do you have a video saved to reproduce the vulnerability?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-07T07:04:38Z",
          "body": "The destination is set to the current position only as long as it is not activated yet. What happens if we are below the hagl altitude on start, but during RTL we fly above because the terrain is now lower?\r\nAs soon as the hagl altitude is exceeded, it goes into failsafe descend and then into RTL again? Are we sure that the setRtlPosition is triggered at least once in between while it is above? If you make the check in the getActivationLandState function, we at least make sure that it is set correctly on activation. And you don't need the   _print_return_alt_higher_than_max_hagl variable",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-09T14:02:25Z",
          "body": "Why do we need to wait half a second here?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 46,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-09T14:35:27Z",
          "body": "ideally, the navigator can propose the action instead of them being hardcoded here. Because depending on the issue, you might want to RTL instead of hold. Also you do not have to make here the distinction between the modes anymore. Would propaply need to set the desired mode in the navigator_failure instead of a boolean. But depending on the amount of work the changes would need, i am also fine with this for now.",
          "path": "src/modules/commander/failsafe/failsafe.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-09T14:41:01Z",
          "body": "You forgot to add the actual file",
          "path": "msg/CMakeLists.txt",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-09T15:09:45Z",
          "body": "Thanks, done",
          "path": "msg/CMakeLists.txt",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-09T15:11:05Z",
          "body": "It's just to at least publish something at a minimum rate even if the status didn't change. If the status got updated it won't wait for 0.5s to publish it.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 46,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-09T15:16:14Z",
          "body": "I thought that the failsafe action should always be chosen by Commander. Navigator should just be the \"follower\" and reports back to Commander, no?",
          "path": "src/modules/commander/failsafe/failsafe.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-12T08:08:39Z",
          "body": "Yeah, you are right, i thought that a nexternal mode can suggest an action, but it looks like not, sorry. Seems you can only defer the failsafe as external mode.",
          "path": "src/modules/commander/failsafe/failsafe.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-08-07T07:19:10Z",
          "body": "For the case when we trigger an RTL where at the beginning the hagl condition (_rtl_alt - terrain > hagl_max) is not true, we would make a normal RTL. When then the terrain changes and the hagl altitude is exceeded, then it would also go into failsafe descend first and then into RTL again, correct? Is there a way to avoid that? Or flying in this situation should always trigger land instead of RTL? An alternative approach would be to enforce that  in navigator rather than in the RTL.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-09T14:43:28Z",
          "body": "",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-09T15:09:45Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-09T15:11:05Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-09T15:16:14Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-12T08:08:39Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-08-12T11:02:51Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: RTL could target an altitude above the EKF-provided max HAGL which caused a descend -> navigation restart -> RTL loop (improper state transitions / boundary handling). The change prevents commanding RTL to an unsafe altitude and instead triggers a failsafe (land) and adds navigator status reporting so the commander can react, correcting the incorrect program behavior.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -42,7 +42,7 @@\n #include \"navigator.h\"\n \n Land::Land(Navigator *navigator) :\n-\tMissionBlock(navigator)\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_LAND)\n {\n }\n \n@@ -93,7 +93,7 @@ Land::on_active()\n \tif (_navigator->get_land_detected()->landed) {\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n-\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_LAND);\n+\t\t_navigator->mode_completed(getNavigatorStateId());\n \t\tset_idle_item(&_mission_item);\n \n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -43,7 +43,7 @@\n #include \"navigator.h\"\n \n Loiter::Loiter(Navigator *navigator) :\n-\tMissionBlock(navigator),\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER),\n \tModuleParams(navigator)\n {\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -65,7 +65,7 @@ using namespace time_literals;\n static constexpr int32_t DEFAULT_MISSION_CACHE_SIZE = 10;\n \n Mission::Mission(Navigator *navigator) :\n-\tMissionBase(navigator, DEFAULT_MISSION_CACHE_SIZE)\n+\tMissionBase(navigator, DEFAULT_MISSION_CACHE_SIZE, vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION)\n {\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -46,8 +46,8 @@\n #include \"mission_feasibility_checker.h\"\n #include \"navigator.h\"\n \n-MissionBase::MissionBase(Navigator *navigator, int32_t dataman_cache_size_signed) :\n-\tMissionBlock(navigator),\n+MissionBase::MissionBase(Navigator *navigator, int32_t dataman_cache_size_signed, uint8_t navigator_state_id) :\n+\tMissionBlock(navigator, navigator_state_id),\n \tModuleParams(navigator),\n \t_dataman_cache_size_signed(dataman_cache_size_signed)\n {\n@@ -465,7 +465,7 @@ MissionBase::set_mission_items()\n \n \tif (set_end_of_mission) {\n \t\tsetEndOfMissionItems();\n-\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION);\n+\t\t_navigator->mode_completed(getNavigatorStateId());\n \t}\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -65,7 +65,7 @@ class Navigator;\n class MissionBase : public MissionBlock, public ModuleParams\n {\n public:\n-\tMissionBase(Navigator *navigator, int32_t dataman_cache_size_signed);\n+\tMissionBase(Navigator *navigator, int32_t dataman_cache_size_signed, uint8_t navigator_state_id);\n \t~MissionBase() override = default;\n \n \tvirtual void on_inactive() override;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -55,8 +55,8 @@\n \n using matrix::wrap_pi;\n \n-MissionBlock::MissionBlock(Navigator *navigator) :\n-\tNavigatorMode(navigator)\n+MissionBlock::MissionBlock(Navigator *navigator, uint8_t navigator_state_id) :\n+\tNavigatorMode(navigator, navigator_state_id)\n {\n \n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -64,7 +64,7 @@ class MissionBlock : public NavigatorMode\n \t/**\n \t * Constructor\n \t */\n-\tMissionBlock(Navigator *navigator);\n+\tMissionBlock(Navigator *navigator, uint8_t navigator_state_id);\n \tvirtual ~MissionBlock() = default;\n \n \tMissionBlock(const MissionBlock &) = delete;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "patch": "@@ -69,6 +69,7 @@\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n #include <uORB/topics/mission_result.h>\n+#include <uORB/topics/navigator_status.h>\n #include <uORB/topics/parameter_update.h>\n #include <uORB/topics/position_controller_landing_status.h>\n #include <uORB/topics/position_controller_status.h>\n@@ -283,8 +284,12 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n \n+\tvoid set_failsafe_status(uint8_t nav_state, bool failsafe);\n+\n \tvoid sendWarningDescentStoppedDueToTerrain();\n \n+\tvoid trigger_hagl_failsafe(uint8_t nav_state);\n+\n private:\n \n \tint _local_pos_sub{-1};\n@@ -305,6 +310,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tuORB::Publication<geofence_result_s>\t\t_geofence_result_pub{ORB_ID(geofence_result)};\n \tuORB::Publication<mission_result_s>\t\t_mission_result_pub{ORB_ID(mission_result)};\n+\tuORB::Publication<navigator_status_s>\t\t_navigator_status_pub{ORB_ID(navigator_status)};\n \tuORB::Publication<position_setpoint_triplet_s>\t_pos_sp_triplet_pub{ORB_ID(position_setpoint_triplet)};\n \tuORB::Publication<vehicle_command_ack_s>\t_vehicle_cmd_ack_pub{ORB_ID(vehicle_command_ack)};\n \tuORB::Publication<vehicle_command_s>\t\t_vehicle_cmd_pub{ORB_ID(vehicle_command)};\n@@ -324,6 +330,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \t// Publications\n \tgeofence_result_s\t\t\t\t_geofence_result{};\n+\tnavigator_status_s\t\t\t\t_navigator_status{};\n \tposition_setpoint_triplet_s\t\t\t_pos_sp_triplet{};\t/**< triplet of position setpoints */\n \tposition_setpoint_triplet_s\t\t\t_reposition_triplet{};\t/**< triplet for non-mission direct position command */\n \tposition_setpoint_triplet_s\t\t\t_takeoff_triplet{};\t/**< triplet for non-mission direct takeoff command */\n@@ -333,7 +340,10 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tGeofence\t_geofence;\t\t\t/**< class that handles the geofence */\n \tGeofenceBreachAvoidance _gf_breach_avoidance;\n-\thrt_abstime _last_geofence_check = 0;\n+\thrt_abstime _last_geofence_check{0};\n+\n+\tbool _navigator_status_updated{false};\n+\thrt_abstime _last_navigator_status_publication{0};\n \n \thrt_abstime _wait_for_vehicle_status_timestamp{0}; /**< If non-zero, wait for vehicle_status update before processing next cmd */\n \n@@ -386,6 +396,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid publish_mission_result();\n \n+\tvoid publish_navigator_status();\n+\n \tvoid publish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_t result);\n \n \tbool geofence_allows_position(const vehicle_global_position_s &pos);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "patch": "@@ -41,6 +41,7 @@\n  * @author Julian Oes <julian@oes.ch>\n  * @author Anton Babushkin <anton.babushkin@me.com>\n  * @author Thomas Gubler <thomasgubler@gmail.com>\n+ * and many more...\n  */\n \n #include \"navigator.h\"\n@@ -897,6 +898,8 @@ void Navigator::run()\n \t\t\tpublish_mission_result();\n \t\t}\n \n+\t\tpublish_navigator_status();\n+\n \t\t_geofence.run();\n \n \t\tperf_end(_loop_perf);\n@@ -1355,6 +1358,40 @@ void Navigator::set_mission_failure_heading_timeout()\n \t}\n }\n \n+void Navigator::trigger_hagl_failsafe(const uint8_t nav_state)\n+{\n+\tif ((_navigator_status.failure != navigator_status_s::FAILURE_HAGL) || _navigator_status.nav_state != nav_state) {\n+\t\t_navigator_status.failure = navigator_status_s::FAILURE_HAGL;\n+\t\t_navigator_status.nav_state = nav_state;\n+\n+\t\t_navigator_status_updated = true;\n+\t}\n+}\n+\n+void Navigator::publish_navigator_status()\n+{\n+\tuint8_t current_nav_state = _vstatus.nav_state;\n+\n+\tif (_navigation_mode != nullptr) {\n+\t\tcurrent_nav_state = _navigation_mode->getNavigatorStateId();\n+\t}\n+\n+\tif (_navigator_status.nav_state != current_nav_state) {\n+\t\t_navigator_status.nav_state = current_nav_state;\n+\t\t_navigator_status.failure = navigator_status_s::FAILURE_NONE;\n+\t\t_navigator_status_updated = true;\n+\t}\n+\n+\tif (_navigator_status_updated\n+\t    || (hrt_elapsed_time(&_last_navigator_status_publication) > 500_ms)) {\n+\t\t_navigator_status.timestamp = hrt_absolute_time();\n+\t\t_navigator_status_pub.publish(_navigator_status);\n+\n+\t\t_navigator_status_updated = false;\n+\t\t_last_navigator_status_publication = hrt_absolute_time();\n+\t}\n+}\n+\n void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n {\n \tvcmd->timestamp = hrt_absolute_time();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_mode.cpp": {
        "filename": "src/modules/navigator/navigator_mode.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -42,8 +42,9 @@\n #include \"navigator_mode.h\"\n #include \"navigator.h\"\n \n-NavigatorMode::NavigatorMode(Navigator *navigator) :\n-\t_navigator(navigator)\n+NavigatorMode::NavigatorMode(Navigator *navigator, uint8_t navigator_state_id) :\n+\t_navigator(navigator),\n+\t_navigator_state_id(navigator_state_id)\n {\n \t/* set initial mission items */\n \ton_inactivation();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fnavigator_mode.cpp"
      },
      "src/modules/navigator/navigator_mode.h": {
        "filename": "src/modules/navigator/navigator_mode.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "patch": "@@ -41,12 +41,14 @@\n \n #pragma once\n \n+#include <cstdint>\n+\n class Navigator;\n \n class NavigatorMode\n {\n public:\n-\tNavigatorMode(Navigator *navigator);\n+\tNavigatorMode(Navigator *navigator, uint8_t navigator_state_id);\n \tvirtual ~NavigatorMode() = default;\n \tNavigatorMode(const NavigatorMode &) = delete;\n \tNavigatorMode &operator=(const NavigatorMode &) = delete;\n@@ -56,6 +58,8 @@ class NavigatorMode\n \n \tbool isActive() {return _active;};\n \n+\tuint8_t getNavigatorStateId() const { return _navigator_state_id; }\n+\n \t/**\n \t * This function is called while the mode is inactive\n \t */\n@@ -81,4 +85,5 @@ class NavigatorMode\n \n private:\n \tbool _active{false};\n+\tuint8_t _navigator_state_id{0};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fnavigator_mode.h"
      },
      "src/modules/navigator/precland.cpp": {
        "filename": "src/modules/navigator/precland.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -62,7 +62,7 @@\n static constexpr const char *LOST_TARGET_ERROR_MESSAGE = \"Lost landing target while landing\";\n \n PrecLand::PrecLand(Navigator *navigator) :\n-\tMissionBlock(navigator),\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND),\n \tModuleParams(navigator)\n {\n \t_handle_param_acceleration_hor = param_find(\"MPC_ACC_HOR\");",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fprecland.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -55,7 +55,7 @@ static constexpr float MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES{10.0f}; // [m] We\n static constexpr float MIN_DIST_THRESHOLD = 2.f;\n \n RTL::RTL(Navigator *navigator) :\n-\tNavigatorMode(navigator),\n+\tNavigatorMode(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_RTL),\n \tModuleParams(navigator),\n \t_rtl_direct(navigator)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl_base.h": {
        "filename": "src/modules/navigator/rtl_base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -46,7 +46,7 @@ class RtlBase : public MissionBase\n {\n public:\n \tRtlBase(Navigator *navigator, int32_t dataman_cache_size_signed):\n-\t\tMissionBase(navigator, dataman_cache_size_signed) {};\n+\t\tMissionBase(navigator, dataman_cache_size_signed, vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {};\n \tvirtual ~RtlBase() = default;\n \n \tvirtual rtl_time_estimate_s calc_rtl_time_estimate() = 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Frtl_base.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "patch": "@@ -51,7 +51,7 @@\n using namespace math;\n \n RtlDirect::RtlDirect(Navigator *navigator) :\n-\tMissionBlock(navigator),\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_RTL),\n \tModuleParams(navigator)\n {\n \t_destination.lat = static_cast<double>(NAN);\n@@ -158,6 +158,16 @@ void RtlDirect::set_rtl_item()\n {\n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n+\tif (_global_pos_sub.get().terrain_alt_valid\n+\t    && ((_rtl_alt - _global_pos_sub.get().terrain_alt) > _navigator->get_local_position()->hagl_max)) {\n+\t\t// Handle case where the RTL altidude is above the maximum HAGL and land in place instead of RTL\n+\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: return alt higher than max HAGL\\t\");\n+\t\tevents::send(events::ID(\"rtl_fail_max_hagl\"), events::Log::Error, \"RTL: return alt higher than max HAGL\");\n+\n+\t\t_navigator->trigger_hagl_failsafe(getNavigatorStateId());\n+\t\t_rtl_state = RTLState::IDLE;\n+\t}\n+\n \tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon,\n \t\t\t\t       _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n \tconst float loiter_altitude = math::min(_land_approach.height_m, _rtl_alt);\n@@ -318,7 +328,7 @@ void RtlDirect::set_rtl_item()\n \n \tcase RTLState::IDLE: {\n \t\t\tset_idle_item(&_mission_item);\n-\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_RTL);\n+\t\t\t_navigator->mode_completed(getNavigatorStateId());\n \t\t\tbreak;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -43,7 +43,7 @@\n #include <px4_platform_common/events.h>\n \n Takeoff::Takeoff(Navigator *navigator) :\n-\tMissionBlock(navigator)\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF)\n {\n }\n \n@@ -68,7 +68,7 @@ Takeoff::on_active()\n \t} else if (is_mission_item_reached_or_completed() && !_navigator->get_mission_result()->finished) {\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n-\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF);\n+\t\t_navigator->mode_completed(getNavigatorStateId());\n \n \t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -43,7 +43,7 @@\n using matrix::wrap_pi;\n \n VtolTakeoff::VtolTakeoff(Navigator *navigator) :\n-\tMissionBlock(navigator),\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF),\n \tModuleParams(navigator)\n {\n }\n@@ -151,7 +151,7 @@ VtolTakeoff::on_active()\n \t\t\t\t// the VTOL takeoff is done\n \t\t\t\t_navigator->get_mission_result()->finished = true;\n \t\t\t\t_navigator->set_mission_result_updated();\n-\t\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF);\n+\t\t\t\t_navigator->mode_completed(getNavigatorStateId());\n \n \t\t\t\tbreak;\n \t\t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1309c0fe77c6d94bdcffd2733209303f65424394/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Land::on_active",
        "Takeoff::on_active",
        "RtlDirect::set_rtl_item",
        "VtolTakeoff::on_active",
        "MissionBase::set_mission_items",
        "Navigator::run",
        "Navigator::set_mission_failure_heading_timeout"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::set_mission_items"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run",
          "Navigator::set_mission_failure_heading_timeout"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Fix: replay the mission cached items only upon reaching resume waypoint",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23484",
    "number": 23484,
    "created_at": "2024-08-02T09:56:37Z",
    "merged": true,
    "merged_at": "2024-08-13T20:20:28Z",
    "state": "closed",
    "conversation": {
      "author": "StefanoColli",
      "body": "### Solved Problem\r\nUpon mission resume (e.g., after a RTL), the gimbal would immediately assume its previous configuration instead of waiting having reached a mission waypoint. \r\nSimilarly the camera would start triggering from take-off instead of from the last reached mission waypoint\r\n\r\n### Solution\r\nStore the index of the last mission item reached before the mission interruption, then replay the cached drone commands only after having reached such mission item\r\n\r\n### Alternatives\r\nWe could also used the existing `_inactivation_index` variable but it has a slightly different meaning and has a different reset behaviour\r\n\r\n### Test coverage\r\n- The gimbal issue has been test in SITL\r\n- The camera issue needs to be flight tested\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-13T09:53:04Z",
          "body": "```suggestion\r\n\t_mission_activation_index = _mission.current_seq;\r\n```\r\nI always try to name variables as descriptive as possible.",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-13T09:55:23Z",
          "body": "I'm not opinionated for one or the other, but when you do the `replayCachedGimbalCameraItems()` you may have the camera not yet correctly configured when the triggering starts. What's the issue with configuring it already when the Mission is resumed, and not only when the vehicle is at the correct position?",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-13T09:56:32Z",
          "body": "```suggestion\r\n\tint _replay_index{-1};\t\t\t\t\t/**< Index of the mission item that will bring the vehicle back to a mission waypoint */\r\n```\r\nLet's stay system agnostic.",
          "path": "src/modules/navigator/mission_base.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-08-13T12:17:55Z",
          "body": "That's a good point, I have split the replay/checks of gimbal commands from the replay/checks of the camera mode. In this way we can replay the camera commands immediately and the gimbal commands later",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-08-13T09:58:18Z",
          "body": "Thanks for your contribution, it works correctly in my simulation. An alternative would be to add a `_work_item_type != WorkItemType::WORK_ITEM_TYPE_CLIMB` after the check for `is_mission_item_reached_or_completed()`, as it's really only the inserted climb mission item that brings the logic out of order. But your proposed solution seems a bit more robust.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-08-13T12:17:56Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-08-13T15:42:11Z",
          "body": "Looks good to me!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes an incorrect program behavior: cached vehicle commands (gimbal position and camera triggers) were being replayed immediately on mission resume instead of waiting until the vehicle reached the last mission waypoint. The change stores and checks the last reached mission-item index, addressing a state/ordering bug (improper state transition/timing) so actions occur at the correct mission point.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 12,
        "changes": 42,
        "patch": "@@ -235,6 +235,7 @@ MissionBase::on_activation()\n \tcheckClimbRequired(_mission.current_seq);\n \tset_mission_items();\n \n+\t_mission_activation_index = _mission.current_seq;\n \t_inactivation_index = -1; // reset\n \n \t// reset cruise speed\n@@ -293,17 +294,27 @@ MissionBase::on_active()\n \t\t_align_heading_necessary = false;\n \t}\n \n-\t// replay gimbal and camera commands immediately after resuming mission\n-\tif (haveCachedGimbalOrCameraItems()) {\n-\t\treplayCachedGimbalCameraItems();\n+\t// Replay camera mode commands immediately upon mission resume\n+\tif (haveCachedCameraModeItems()) {\n+\t\treplayCachedCameraModeItems();\n \t}\n \n-\t// replay trigger commands upon raching the resume waypoint if the trigger relay flag is set\n-\tif (cameraWasTriggering() && is_mission_item_reached_or_completed()) {\n-\t\treplayCachedTriggerItems();\n-\t}\n \n-\treplayCachedSpeedChangeItems();\n+\t// Replay cached mission commands once the last mission waypoint is re-reached after the mission interruption.\n+\t// Each replay function also clears the cached items afterwards\n+\tif (_mission.current_seq > _mission_activation_index) {\n+\t\t// replay gimbal commands\n+\t\tif (haveCachedGimbalItems()) {\n+\t\t\treplayCachedGimbalItems();\n+\t\t}\n+\n+\t\t// replay trigger commands\n+\t\tif (cameraWasTriggering()) {\n+\t\t\treplayCachedTriggerItems();\n+\t\t}\n+\n+\t\treplayCachedSpeedChangeItems();\n+\t}\n \n \t/* lets check if we reached the current mission item */\n \tif (_mission_type != MissionType::MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n@@ -1255,7 +1266,7 @@ void MissionBase::cacheItem(const mission_item_s &mission_item)\n \t}\n }\n \n-void MissionBase::replayCachedGimbalCameraItems()\n+void MissionBase::replayCachedGimbalItems()\n {\n \tif (_last_gimbal_configure_item.nav_cmd > 0) {\n \t\tissue_command(_last_gimbal_configure_item);\n@@ -1266,7 +1277,10 @@ void MissionBase::replayCachedGimbalCameraItems()\n \t\tissue_command(_last_gimbal_control_item);\n \t\t_last_gimbal_control_item = {}; // delete cached item\n \t}\n+}\n \n+void MissionBase::replayCachedCameraModeItems()\n+{\n \tif (_last_camera_mode_item.nav_cmd > 0) {\n \t\tissue_command(_last_camera_mode_item);\n \t\t_last_camera_mode_item = {}; // delete cached item\n@@ -1297,11 +1311,15 @@ void MissionBase::resetItemCache()\n \t_last_camera_trigger_item = {};\n }\n \n-bool MissionBase::haveCachedGimbalOrCameraItems()\n+bool MissionBase::haveCachedGimbalItems()\n {\n \treturn _last_gimbal_configure_item.nav_cmd > 0 ||\n-\t       _last_gimbal_control_item.nav_cmd > 0 ||\n-\t       _last_camera_mode_item.nav_cmd > 0;\n+\t       _last_gimbal_control_item.nav_cmd > 0;\n+}\n+\n+bool MissionBase::haveCachedCameraModeItems()\n+{\n+\treturn _last_camera_mode_item.nav_cmd > 0;\n }\n \n bool MissionBase::cameraWasTriggering()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/276ce01936e5edc7c28c52a8603f7476d1d704d7/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 17,
        "deletions": 4,
        "changes": 21,
        "patch": "@@ -328,6 +328,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tmission_s _mission;\t\t\t\t\t/**< Currently active mission*/\n \tfloat _mission_init_climb_altitude_amsl{NAN}; \t\t/**< altitude AMSL the vehicle will climb to when mission starts */\n \tint _inactivation_index{-1}; // index of mission item at which the mission was paused. Used to resume survey missions at previous waypoint to not lose images.\n+\tint _mission_activation_index{-1};\t\t\t\t\t/**< Index of the mission item that will bring the vehicle back to a mission waypoint */\n \n \tint32_t _load_mission_index{-1}; /**< Mission inted of loaded mission items in dataman cache*/\n \tint32_t _dataman_cache_size_signed; /**< Size of the dataman cache. A negativ value indicates that previous mission items should be loaded, a positiv value the next mission items*/\n@@ -398,9 +399,14 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvoid updateCachedItemsUpToIndex(int end_index);\n \n \t/**\n-\t * @brief Replay the cached gimbal and camera mode items\n+\t * @brief Replay the cached gimbal items\n \t */\n-\tvoid replayCachedGimbalCameraItems();\n+\tvoid replayCachedGimbalItems();\n+\n+\t/**\n+\t * @brief Replay the cached camera mode items\n+\t */\n+\tvoid replayCachedCameraModeItems();\n \n \t/**\n \t * @brief Replay the cached trigger items\n@@ -415,11 +421,18 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvoid replayCachedSpeedChangeItems();\n \n \t/**\n-\t * @brief Check if there are cached gimbal or camera mode items to be replayed\n+\t * @brief Check if there are cached gimbal items to be replayed\n+\t *\n+\t * @return true if there are cached items\n+\t */\n+\tbool haveCachedGimbalItems();\n+\n+\t/**\n+\t * @brief Check if there are cached camera mode items to be replayed\n \t *\n \t * @return true if there are cached items\n \t */\n-\tbool haveCachedGimbalOrCameraItems();\n+\tbool haveCachedCameraModeItems();\n \n \t/**\n \t * @brief Check if the camera was triggering",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/276ce01936e5edc7c28c52a8603f7476d1d704d7/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::cacheItem",
        "haveCachedGimbalOrCameraItems",
        "MissionBase::haveCachedGimbalOrCameraItems",
        "MissionBase::replayCachedGimbalCameraItems",
        "replayCachedGimbalCameraItems",
        "MissionBase::on_active",
        "MissionBase::resetItemCache",
        "MissionBase::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_activation",
          "MissionBase::cacheItem",
          "MissionBase::haveCachedGimbalOrCameraItems",
          "MissionBase::replayCachedGimbalCameraItems",
          "MissionBase::on_active",
          "MissionBase::resetItemCache"
        ],
        "src/modules/navigator/mission_base.h": [
          "haveCachedGimbalOrCameraItems",
          "replayCachedGimbalCameraItems"
        ]
      }
    }
  },
  {
    "title": "EKF2 global position validity",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23474",
    "number": 23474,
    "created_at": "2024-07-31T15:01:13Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "bresch",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\n1. Once in inertial dead-reckoning, the position estimate drifts exponentially and even if a velocity-aiding sensor starts after some time, the global position shouldn't be valid anymore.\r\n2. FW manual position control mode requires a valid global position estimate but internally works using local coordinates. The mode thus cannot run without a GNSS fix or a manual reset despite having a \"valid local position\" (due to airspeed and sideslip fusion).\r\n3. Flying in FW using wind dead-reckoning requires to set the COM_FS_EPH to a really large value as commander would otherwise invalidate the local position validity\r\n4. FW auto takeoff and auto land modes don't require a valid global position to start but the backend can't execute correctly because it relies on a valid global position estimate.\r\n\r\n### Solution\r\n1. Invalidate global position when exceeding maximum the inertial dead-reckoning time (5s). The global position can then be valid again if the local position is valid and that a global position measurement is available (e.g.: GNSS, AGP or manual pos aiding).\r\n2. Make FW manual position work with local coordinates only\r\n3. Generalize the local position \"relaxed\" logic (currently used for optical flow) to work when the local position is obtained from velocity-aided dead reckoning (e.g.: optical flow, ev_vel, airspeed+sideslip)\r\n4. Deny switching to auto takeoff and auto land if global position is invalid. In the future we could also fix the logic to enable it correctly.\r\n\r\nNote that we could publish NANs in the global position fields that are invalid but I wanted to follow the same scheme than in `vehicle_local_position`.\r\n\r\n### Test coverage\r\nSITL tests:\r\nIn FW, start and stop several times GNSS and sideslip fusion. Modes switch correctly.\r\n![Screenshot from 2024-07-31 14-56-28](https://github.com/user-attachments/assets/e94121ec-dae8-41b2-8c73-2f8f2b755d05)\r\n",
      "issue_comments": [
        {
          "author": "Jaeyoung-Lim",
          "created_at": "2024-07-31T15:10:55Z",
          "body": "Yay! This is exactly why I removed global position from the guidance law :grin: Happy to see this finally getting used!",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2024-07-31T15:48:15Z",
          "body": "Really cool @bresch ðŸ‘ ",
          "type": "issue_comment"
        },
        {
          "author": "haumarco",
          "created_at": "2024-08-02T12:04:14Z",
          "body": "Right now, `_NED_origin_initialised` represents if the `global_ref` was set and the local position is valid. If **the** NED origin was initialized should be checked with `_pos_ref.isInitialized()` right? Maybe renaming it to `_NED_origin_valid` would be better, or would it be possible to remove it?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2024-07-31T17:12:01Z",
          "body": "Does this even matter? Couldn't \"relaxed local position validity\" simply be vehicle_local_position.xy_valid? \r\n\r\n",
          "path": "src/modules/commander/HealthAndArmingChecks/checks/estimatorCheck.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-02T06:31:03Z",
          "body": "Good point, I'll check if there is any reason why it should be different",
          "path": "src/modules/commander/HealthAndArmingChecks/checks/estimatorCheck.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-02T09:20:51Z",
          "body": "I think it makes sense. Now \"relaxed\" is just without eph check.",
          "path": "src/modules/commander/HealthAndArmingChecks/checks/estimatorCheck.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2024-07-31T17:12:01Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-02T06:31:03Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2024-08-02T09:20:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect state/validity logic and mode gating. It corrects when the global position validity flag is set (invalidating after inertial dead-reckoning), adjusts control-mode requirements to use local coordinates when appropriate, and prevents mode switches that relied on an incorrectly valid global position, all of which are logic-level errors (improper state transitions and incorrect conditional behavior).",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -1383,6 +1383,8 @@ bool MissionBase::canRunMissionFeasibility()\n {\n \treturn _navigator->home_global_position_valid() && // Need to have a home position checked\n \t       _navigator->get_global_position()->timestamp > 0 && // Need to have a position, for first waypoint check\n+\t       _navigator->get_global_position()->lat_lon_valid &&\n+\t       _navigator->get_global_position()->alt_valid &&\n \t       (_geofence_status_sub.get().timestamp > 0) && // Geofence data must be loaded\n \t       (_geofence_status_sub.get().geofence_id == _mission.geofence_id) &&\n \t       (_geofence_status_sub.get().status == geofence_status_s::GF_STATUS_READY);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/963e54c0519a9634af30a480501f9b68e46f8e1b/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "patch": "@@ -220,6 +220,20 @@ void Navigator::run()\n \t\t/* global position updated */\n \t\tif (_global_pos_sub.updated()) {\n \t\t\t_global_pos_sub.copy(&_global_pos);\n+\n+\t\t\t// Navigator assumes that fields are NAN when not valid\n+\t\t\tif (!_global_pos.lat_lon_valid) {\n+\t\t\t\t_global_pos.lat = static_cast<double>(NAN);\n+\t\t\t\t_global_pos.lon = static_cast<double>(NAN);\n+\t\t\t}\n+\n+\t\t\tif (!_global_pos.alt_valid) {\n+\t\t\t\t_global_pos.alt = NAN;\n+\t\t\t}\n+\n+\t\t\tif (!_global_pos.alt_ellipsoid_valid) {\n+\t\t\t\t_global_pos.alt_ellipsoid = NAN;\n+\t\t\t}\n \t\t}\n \n \t\t/* check for parameter updates */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/963e54c0519a9634af30a480501f9b68e46f8e1b/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::canRunMissionFeasibility",
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::canRunMissionFeasibility"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Navigator: increase stack by 40 bytes",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23437",
    "number": 23437,
    "created_at": "2024-07-22T11:38:58Z",
    "merged": true,
    "merged_at": "2024-07-25T07:22:23Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "We had several vehicles with `Navigator low on stack `warnings (usually only by <20 bytes).",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "bkueng",
          "created_at": "2024-07-25T07:22:18Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR adjusts the Navigator task's stack allocation (increasing it by 40 bytes) to avoid 'low on stack' warnings. That's a resource/configuration change to prevent stack exhaustion, not a correction of incorrect program logic or control flow, so it is not a logic error fix.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -1069,7 +1069,7 @@ int Navigator::task_spawn(int argc, char *argv[])\n \t_task_id = px4_task_spawn_cmd(\"navigator\",\n \t\t\t\t      SCHED_DEFAULT,\n \t\t\t\t      SCHED_PRIORITY_NAVIGATION,\n-\t\t\t\t      PX4_STACK_ADJUSTED(2160),\n+\t\t\t\t      PX4_STACK_ADJUSTED(2200),\n \t\t\t\t      (px4_main_t)&run_trampoline,\n \t\t\t\t      (char *const *)argv);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/929f4d568a0aa1a2f72561c3d5c185e0dea2c21a/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_spawn"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_spawn"
        ]
      }
    }
  },
  {
    "title": "Navigator: add terrain collision avoidance during descents",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23429",
    "number": 23429,
    "created_at": "2024-07-19T09:35:31Z",
    "merged": true,
    "merged_at": "2024-07-30T15:50:54Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Alternative to https://github.com/PX4/PX4-Autopilot/pull/23396. Changes:\r\n- do not exclusively apply terrain collision logic for VTOL in landing phase\r\n- do not allow to increase the altitude setpoint above the current altitude\r\n- implement user feedback\r\n\r\n### Solved Problem\r\nThere are several reasons why during a landing approach (landing with a pattern) a VTOL might fly into terrain.\r\nThe baro bias estimate could not be correct (especially when flying GPS denied) or the user might have not planned the mission correctly.\r\n\r\n### Solution\r\nAvoid flying into terrain using the distance sensor. Enable through the parameter `NAV_MIN_GND_DIST`.\r\nOnly active during commanded descents with vz>0 (to prevent climb-aways), excluding landing and VTOL transitions.\r\nIt changes the altitude setpoint in the triplet to maintain the current altitude and republish the triplet.\r\nWe also change the mission item altitude used for acceptance calculations to prevent getting stuck in a loop.\r\n\r\n### Changelog Entry\r\nFor release notes: \r\n```\r\nFeature: Navigator: add terrain collision avoidance during descents\r\nNew parameter: NAV_MIN_GND_DIST\r\nDocumentation: todo\r\n```\r\n\r\n### Alternatives\r\nHave it more exclusively for VTOL landings: https://github.com/PX4/PX4-Autopilot/pull/23396, though I think this feature would also be helpful for e.g. plane landings (trigger the exit of the loiter down before landing based on distance sensor).\r\n\r\n### Test coverage\r\nSITL tested with VTOLs, planes and MCs, all RTL types and mission landings.\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-07-19T11:57:57Z",
          "body": ">Also would RTL still be usable in that case because the phase where you're descending but not landing yet wouldn't descend right?\r\n\r\nYes correct, I just tested it, it would have the same behavior for MC RTL as for VTOL/Plane RTL: while it is descending (for MC it would be up to RTL_DESCEND_ALT) the terrain collision checks are active. If during this time the distance sensor measurement is wrong (e.g. 1m), it would trigger the \"Terrain collision risk\" warning and adapt the current altitude setpoint to the current altitude. Once above the landing point it will then still set the setpoint type to Land and come down, so beside the warning the user wouldn't notice anything else.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-07-19T11:39:06Z",
          "body": "```suggestion\r\n\tstatic constexpr float kAltitudeDifferenceForDescentCondition = 5.f; // meters threshold\r\n```\r\nSo from 4 meters altitude it's still fine to fly into the ground? This is probably only there to make sure it doesn't trigger (again) if the position estimate is 10cm higher than the triplet (that was already adjusted) ðŸ¤” ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-07-19T12:09:54Z",
          "body": "Yes correct, that was the reason I put it there, and yes, that means if the vehicle is less than 5m vertical distance away from the setpoint it wouldn't trigger the collision prevention. Very random number, I agree. \r\nI've reduced it to 2m to mitigate it slightly. Otherwise, to get rid of the magic threshold, we could only allow the terrain correction once per set triplet (and reset if a new triplet comes in). ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-07-19T11:43:24Z",
          "body": "I think the idea makes sense but the implementation is sadly pretty hacky, I hope it doesn't create too many side effects.\r\n\r\nThe worst one I could currently think off is if you are operating a multicopter, the distance sensor is blocked by the payload, it doesn't descend anymore e.g. could fly into a bridge if the mission would go underneath. Also would RTL still be usable in that case because the phase where you're descending but not landing yet wouldn't descend right?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-07-19T12:09:54Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-07-30T12:34:20Z",
          "body": "As a workaround that's acceptable. I'd try to find a better solution long term.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR corrects incorrect runtime behavior where the navigator could command a descent into terrain (due to baro bias, bad sensor data or mission planning). It changes the altitude-setpoint/mission-item logic (preventing setpoint increases, using distance sensor to hold current altitude and republishing the triplet, and adjusting acceptance checks) to avoid unsafe state transitions during commanded descents, which is a classic logic error fix.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -352,6 +352,8 @@ MissionBase::on_active()\n \t} else if (_navigator->get_precland()->is_activated()) {\n \t\t_navigator->get_precland()->on_inactivation();\n \t}\n+\n+\tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n }\n \n void MissionBase::update_mission()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "patch": "@@ -1011,3 +1011,34 @@ void MissionBlock::startPrecLand(uint16_t land_precision)\n \t\t_navigator->get_precland()->on_activation();\n \t}\n }\n+\n+void MissionBlock::updateAltToAvoidTerrainCollisionAndRepublishTriplet(mission_item_s mission_item)\n+{\n+\t// Avoid flying into terrain using the distance sensor. Enable through the parameter NAV_MIN_GND_DIST.\n+\t// Only active during commanded descents with vz>0 (to prevent climb-aways), excluding landing and VTOL transitions.\n+\t// It changes the altitude setpoint in the triplet to maintain the current altitude and republish the triplet.\n+\t// We also change the mission item altitude used for acceptance calculations to prevent getting stuck in a loop.\n+\n+\t// This threshold is needed to prevent the check from re-triggering due to small altitude over-shoots while\n+\t// tracking the new altitude setpoint.\n+\tstatic constexpr float kAltitudeDifferenceForDescentCondition = 2.f;\n+\n+\n+\tif (_navigator->get_nav_min_gnd_dist_param() > FLT_EPSILON && _mission_item.nav_cmd != NAV_CMD_LAND\n+\t    && _mission_item.nav_cmd != NAV_CMD_VTOL_LAND && _mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION\n+\t    && _navigator->get_local_position()->dist_bottom_valid\n+\t    && _navigator->get_local_position()->dist_bottom < _navigator->get_nav_min_gnd_dist_param()\n+\t    && _navigator->get_local_position()->vz > FLT_EPSILON\n+\t    && _navigator->get_global_position()->alt - get_absolute_altitude_for_item(mission_item) >\n+\t    kAltitudeDifferenceForDescentCondition) {\n+\n+\t\t_navigator->sendWarningDescentStoppedDueToTerrain();\n+\n+\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n+\t\tcurr_sp->alt = _navigator->get_global_position()->alt;\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n+\t\t_mission_item.altitude_is_relative = false;\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -215,6 +215,7 @@ class MissionBlock : public NavigatorMode\n \tvoid setLandMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const;\n \n \tvoid startPrecLand(uint16_t land_precision);\n+\tvoid updateAltToAvoidTerrainCollisionAndRepublishTriplet(mission_item_s mission_item);\n \n \t/**\n \t * @brief Issue a command for mission items with a nav_cmd that specifies an action",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -268,6 +268,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat get_param_mis_takeoff_alt() const { return _param_mis_takeoff_alt.get(); }\n \tfloat get_yaw_timeout() const { return _param_mis_yaw_tmt.get(); }\n \tfloat get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n+\tfloat get_nav_min_gnd_dist_param() const { return _param_nav_min_gnd_dist.get(); }\n \n \tfloat get_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss; }\n \n@@ -284,6 +285,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n \n+\tvoid sendWarningDescentStoppedDueToTerrain();\n+\n private:\n \n \tint _local_pos_sub{-1};\n@@ -402,6 +405,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamFloat<px4::params::NAV_TRAFF_A_VER>)  _param_nav_traff_a_ver,\t/**< avoidance Distance Vertical*/\n \t\t(ParamInt<px4::params::NAV_TRAFF_COLL_T>)   _param_nav_traff_collision_time,\n \t\t(ParamFloat<px4::params::NAV_MIN_LTR_ALT>)   _param_min_ltr_alt,\t/**< minimum altitude in Loiter mode*/\n+\t\t(ParamFloat<px4::params::NAV_MIN_GND_DIST>)\n+\t\t_param_nav_min_gnd_dist,\t/**< minimum distance to ground (Mission and RTL)*/\n \n \t\t// non-navigator parameters: Mission (MIS_*)\n \t\t(ParamFloat<px4::params::MIS_TAKEOFF_ALT>) _param_mis_takeoff_alt,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -1522,6 +1522,13 @@ void Navigator::set_gimbal_neutral()\n \tpublish_vehicle_cmd(&vcmd);\n }\n \n+void Navigator::sendWarningDescentStoppedDueToTerrain()\n+{\n+\tmavlink_log_critical(&_mavlink_log_pub, \"Terrain collision risk, descent is stopped\\t\");\n+\tevents::send(events::ID(\"navigator_terrain_collision_risk\"), events::Log::Critical,\n+\t\t     \"Terrain collision risk, descent is stopped\");\n+}\n+\n int Navigator::print_usage(const char *reason)\n {\n \tif (reason) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "patch": "@@ -187,3 +187,21 @@ PARAM_DEFINE_INT32(NAV_FORCE_VT, 1);\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(NAV_MIN_LTR_ALT, -1.f);\n+\n+/**\n+ * Minimum height above ground during Mission and RTL\n+ *\n+ * Minimum height above ground the vehicle is allowed to descend to during Mission and RTL,\n+ * excluding landing commands.\n+ * Requires a distance sensor to be set up.\n+ * Note: only prevents the vehicle from descending further, but does not force it to climb.\n+ *\n+ * Set to a negative value to disable.\n+ *\n+ * @unit m\n+ * @min -1\n+ * @decimal 1\n+ * @increment 1\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(NAV_MIN_GND_DIST, -1.f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "patch": "@@ -104,6 +104,11 @@ void RtlDirect::on_active()\n \t\tset_rtl_item();\n \t}\n \n+\tif (_rtl_state == RTLState::LOITER_HOLD) { //TODO: rename _rtl_state to _rtl_state_next\n+\t\t//check for terrain collision and update altitude if needed\n+\t\tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n+\t}\n+\n \tif (_rtl_state == RTLState::LAND && _param_rtl_pld_md.get() > 0) {\n \t\t// Need to update the position and type on the current setpoint triplet.\n \t\t_navigator->get_precland()->on_active();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -125,8 +125,7 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \n \t// Climb to altitude\n \tif (_needs_climbing && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n-\t\t// do not use LOITER_TO_ALT for rotary wing mode as it would then always climb to at least MIS_LTRMIN_ALT,\n-\t\t// even if current climb altitude is below (e.g. RTL immediately after take off)\n+\t\t// TODO: check if we also should use NAV_CMD_LOITER_TO_ALT for rotary wing\n \t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/7edb91ee6207c5352126a98fccdde5640251a3af/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::set_gimbal_neutral",
        "MissionBase::on_active",
        "RtlDirect::on_active",
        "MissionBlock::startPrecLand",
        "RtlDirectMissionLand::setActiveMissionItems"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::startPrecLand"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::set_gimbal_neutral"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::on_active"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "Implemented protection against flying into terrain during landing",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23396",
    "number": 23396,
    "created_at": "2024-07-12T14:29:12Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nThere are several reasons why during a landing approach (landing with a pattern) a VTOL might fly into terrain.\r\nThe baro bias estimate could not be correct (especially when flying GPS denied) or the user might have not planned the mission correctly.\r\n\r\n### Solution\r\nAdded parameter which user can set to define minimum distance from terrain during land pattern. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Add option to specify a minimum distance from terrain for VTOL Landings. This includes all landings that use a mission landing pattern.\r\nNew parameter: NAV_VTL_MIN_HGT\r\n```\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-07-15T09:38:15Z",
          "body": "Rebased on main to solve flash CI failures.",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-08-05T06:47:44Z",
          "body": "Replaced by [this PR](https://github.com/PX4/PX4-Autopilot/pull/23429)",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes landing behavior by adding a minimum terrain clearance parameter (NAV_VTL_MIN_HGT) to VTOL landing patterns to prevent descents into terrain when baro bias or mission altitude are incorrect. This fixes incorrect program behavior / unsafe state transitions (a boundary condition / logic bug in the landing algorithm) rather than a syntax or style issue.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 36,
        "changes": 36,
        "patch": "@@ -91,42 +91,6 @@ Mission::on_activation()\n \tMissionBase::on_activation();\n }\n \n-bool\n-Mission::isLanding()\n-{\n-\tif (get_land_start_available()) {\n-\t\tstatic constexpr size_t max_num_next_items{1u};\n-\t\tint32_t next_mission_items_index[max_num_next_items];\n-\t\tsize_t num_found_items;\n-\n-\t\tgetNextPositionItems(_mission.land_start_index + 1, next_mission_items_index, num_found_items, max_num_next_items);\n-\n-\t\t// vehicle is currently landing if\n-\t\t//  mission valid, still flying, and in the landing portion of mission (past land start marker)\n-\t\tbool on_landing_stage = (num_found_items > 0U) &&  _mission.current_seq > next_mission_items_index[0U];\n-\n-\t\t// special case: if the land start index is at a LOITER_TO_ALT WP, then we're in the landing sequence already when the\n-\t\t// distance to the WP is below the loiter radius + acceptance.\n-\t\tif ((num_found_items > 0U) && _mission.current_seq == next_mission_items_index[0U]\n-\t\t    && _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n-\t\t\tconst float d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n-\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n-\n-\t\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n-\t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n-\t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n-\t\t\t\t\t_navigator->get_loiter_radius();\n-\n-\t\t\ton_landing_stage = d_current <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs);\n-\t\t}\n-\n-\t\treturn _navigator->get_mission_result()->valid && on_landing_stage;\n-\n-\t} else {\n-\t\treturn false;\n-\t}\n-}\n-\n bool\n Mission::set_current_mission_index(uint16_t index)\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -67,8 +67,6 @@ class Mission : public MissionBase\n \tuint16_t get_land_start_index() const { return _mission.land_start_index; }\n \tbool get_land_start_available() const { return hasMissionLandStart(); }\n \n-\tbool isLanding();\n-\n private:\n \n \tbool setNextMissionItem() override;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "patch": "@@ -352,6 +352,8 @@ MissionBase::on_active()\n \t} else if (_navigator->get_precland()->is_activated()) {\n \t\t_navigator->get_precland()->on_inactivation();\n \t}\n+\n+\tupdateMinAltDuringVtolLandingAndRepublishTriplet(_mission_item);\n }\n \n void MissionBase::update_mission()\n@@ -1413,3 +1415,41 @@ void MissionBase::updateMissionAltAfterHomeChanged()\n \t\t_home_update_counter = _navigator->get_home_position()->update_count;\n \t}\n }\n+\n+bool\n+MissionBase::isLanding()\n+{\n+\tif (hasMissionLandStart()) {\n+\t\tstatic constexpr size_t max_num_next_items{1u};\n+\t\tint32_t next_mission_items_index[max_num_next_items];\n+\t\tsize_t num_found_items;\n+\n+\t\tgetNextPositionItems(_mission.land_start_index + 1, next_mission_items_index, num_found_items, max_num_next_items);\n+\n+\t\t// vehicle is currently landing if\n+\t\t//  mission valid, still flying, and in the landing portion of mission (past land start marker)\n+\t\tbool on_landing_stage = (num_found_items > 0U) &&  _mission.current_seq > next_mission_items_index[0U];\n+\n+\t\t// special case: if the land start index is at a LOITER_TO_ALT WP, then we're in the landing sequence already when the\n+\t\t// distance to the WP is below the loiter radius + acceptance.\n+\t\tif ((num_found_items > 0U) && _mission.current_seq == next_mission_items_index[0U]\n+\t\t    && _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n+\t\t\tconst float d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n+\n+\t\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n+\t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n+\t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n+\t\t\t\t\t_navigator->get_loiter_radius();\n+\n+\t\t\ton_landing_stage = d_current <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs);\n+\t\t}\n+\n+\n+\n+\t\treturn _navigator->get_mission_result()->valid && on_landing_stage;\n+\n+\t} else {\n+\t\treturn false;\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "patch": "@@ -73,6 +73,8 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tvirtual void on_activation() override;\n \tvirtual void on_active() override;\n \n+\tbool isLanding();\n+\n protected:\n \n \t/**\n@@ -321,6 +323,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \t */\n \tvoid setMissionIndex(int32_t index);\n \n+\n \tbool _is_current_planned_mission_item_valid{false};\t/**< Flag indicating if the currently loaded mission item is valid*/\n \tbool _mission_has_been_activated{false};\t\t/**< Flag indicating if the mission has been activated*/\n \tbool _mission_checked{false};\t\t\t\t/**< Flag indicating if the mission has been checked by the mission validator*/",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "patch": "@@ -55,6 +55,9 @@\n \n using matrix::wrap_pi;\n \n+static constexpr float max_height_correction =\n+\t30.0f; // maximum altitude we can add on top of setpoint to avoid terrain during landing\n+\n MissionBlock::MissionBlock(Navigator *navigator) :\n \tNavigatorMode(navigator)\n {\n@@ -1011,3 +1014,33 @@ void MissionBlock::startPrecLand(uint16_t land_precision)\n \t\t_navigator->get_precland()->on_activation();\n \t}\n }\n+\n+void MissionBlock::updateMinAltDuringVtolLandingAndRepublishTriplet(mission_item_s mission_item)\n+{\n+\t// APX4 Custom start: Whenever we get too close to terrain in fixed wing mode, change the altitude setpoint in the triplet to maintain the\n+\t// minimum distance to terrain and republish the triplet. We only do this when we are executing a landing.\n+\t// We also change the mission item altitude used for acceptance calculations to prevent getting stuck in a loop.\n+\tconst float fw_min_height = _navigator->get_fw_min_height();\n+\n+\tfloat alt_sp_msl = get_absolute_altitude_for_item(mission_item);\n+\n+\tif (fw_min_height > FLT_EPSILON && _navigator->get_vstatus()->is_vtol && _navigator->force_vtol()\n+\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n+\t    && _navigator->get_local_position()->dist_bottom_valid && _navigator->get_local_position()->dist_bottom < fw_min_height\n+\t    && _navigator->get_global_position()->alt > alt_sp_msl && _navigator->isLanding()) {\n+\t\tconst float alt_corrected =  _navigator->get_global_position()->alt + fw_min_height -\n+\t\t\t\t\t     _navigator->get_local_position()->dist_bottom;\n+\n+\t\talt_sp_msl = math::constrain(alt_corrected, alt_sp_msl,\n+\t\t\t\t\t     alt_sp_msl + max_height_correction);\n+\n+\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n+\t\tcurr_sp->alt = alt_sp_msl;\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t\t_mission_item.altitude = alt_sp_msl;\n+\t\t_mission_item.altitude_is_relative = false;\n+\t}\n+\n+\t// APX4 Custom end\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -248,4 +248,6 @@ class MissionBlock : public NavigatorMode\n \tbool _payload_deploy_ack_successful{false};\t// Flag to keep track of whether we received an acknowledgement for a successful payload deployment\n \thrt_abstime _payload_deployed_time{0};\t\t// Last payload deployment start time to handle timeouts\n \tfloat _payload_deploy_timeout_s{0.0f};\t\t// Timeout for payload deployment in Mission class, to prevent endless loop if successful deployment ack is never received\n+\n+\tvoid updateMinAltDuringVtolLandingAndRepublishTriplet(mission_item_s mission_item);\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "patch": "@@ -255,6 +255,11 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool get_mission_start_land_available() { return _mission.get_land_start_available(); }\n \n+\tbool isLanding()\n+\t{\n+\t\treturn (_navigation_mode == &_rtl && _rtl.isLanding()) || (_navigation_mode == &_mission && _mission.isLanding());\n+\t}\n+\n \t// RTL\n \tbool in_rtl_state() const { return _vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_AUTO_RTL; }\n \n@@ -268,6 +273,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat get_param_mis_takeoff_alt() const { return _param_mis_takeoff_alt.get(); }\n \tfloat get_yaw_timeout() const { return _param_mis_yaw_tmt.get(); }\n \tfloat get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n+\tfloat get_fw_min_height() const { return _param_fw_min_height.get(); }\n \n \tfloat get_vtol_back_trans_deceleration() const { return _param_back_trans_dec_mss; }\n \n@@ -408,6 +414,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t(ParamFloat<px4::params::MIS_YAW_TMT>)     _param_mis_yaw_tmt,\n \t\t(ParamFloat<px4::params::MIS_YAW_ERR>)     _param_mis_yaw_err,\n \t\t(ParamFloat<px4::params::MIS_PD_TO>)       _param_mis_payload_delivery_timeout,\n-\t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)  _param_mis_lnd_abrt_alt\n+\t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)  _param_mis_lnd_abrt_alt,\n+\t\t(ParamFloat<px4::params::NAV_VTL_MIN_HGT>)   _param_fw_min_height\n \t)\n-};\n+};\n\\ No newline at end of file",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "patch": "@@ -187,3 +187,20 @@ PARAM_DEFINE_INT32(NAV_FORCE_VT, 1);\n  * @group Mission\n  */\n PARAM_DEFINE_FLOAT(NAV_MIN_LTR_ALT, -1.f);\n+\n+\n+/**\n+ * Minimum height above ground for vtol landings.\n+ *\n+ * Minimum height above ground in fixed wing mode during a vtol landing (mission landing or rtl with landing pattern).\n+ * When the estimated distance to the ground is below this value, the system will\n+ * increase the current altitude setpoint (by max 30m) to maintain this distance.\n+ * Setting the value to 0 will disable the feature.\n+ *\n+ * @unit m\n+ * @min 0\n+ * @decimal 1\n+ * @increment 1\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(NAV_VTL_MIN_HGT, 0.0f);\n\\ No newline at end of file",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "patch": "@@ -712,3 +712,26 @@ land_approaches_s RTL::readVtolLandApproaches(PositionYawSetpoint rtl_position)\n \n \treturn vtol_land_approaches;\n }\n+\n+bool RTL::isLanding()\n+{\n+\tbool is_landing = false;\n+\n+\tswitch (_rtl_type) {\n+\tcase RtlType::RTL_MISSION_FAST: // Fall through\n+\tcase RtlType::RTL_MISSION_FAST_REVERSE: // Fall through\n+\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n+\t\tis_landing = _rtl_mission_type_handle && _rtl_mission_type_handle->isLanding();\n+\t\tbreak;\n+\n+\tcase RtlType::RTL_DIRECT:\n+\t\tis_landing = _rtl_direct.isLoiterindDownOrMovingToTransitionPoint();\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tbreak;\n+\n+\t}\n+\n+\treturn is_landing;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -89,6 +89,8 @@ class RTL : public NavigatorMode, public ModuleParams\n \n \tvoid updateSafePoints(uint32_t new_safe_point_id) { _initiate_safe_points_updated = true; _safe_points_id = new_safe_point_id; }\n \n+\tbool isLanding();\n+\n private:\n \tenum class DestinationType {\n \t\tDESTINATION_TYPE_HOME,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -104,6 +104,8 @@ void RtlDirect::on_active()\n \t\tset_rtl_item();\n \t}\n \n+\tupdateMinAltDuringVtolLandingAndRepublishTriplet(_mission_item);\n+\n \tif (_rtl_state == RTLState::LAND && _param_rtl_pld_md.get() > 0) {\n \t\t// Need to update the position and type on the current setpoint triplet.\n \t\t_navigator->get_precland()->on_active();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -102,6 +102,14 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \n \tvoid setRtlPosition(PositionYawSetpoint position, loiter_point_s loiter_pos);\n \n+\tbool isLoiterindDownOrMovingToTransitionPoint() const\n+\t{\n+\t\t// during the following states the vehicle is loitering down to transition altitude or moving to the\n+\t\t// land waypoint at transition altitude\n+\t\treturn _rtl_state == RTLState::LOITER_HOLD || _rtl_state == RTLState::MOVE_TO_LAND\n+\t\t       || _rtl_state == RTLState::TRANSITION_TO_MC;\n+\t}\n+\n private:\n \t/**\n \t * @brief Return to launch state machine.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e0f40928d95bb6ec908b9576cd462a6b8272b279/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      }
    },
    "modified_functions": {
      "all": [
        "fabsf",
        "isLanding",
        "MissionBase::updateMissionAltAfterHomeChanged",
        "RTL::readVtolLandApproaches",
        "MissionBase::on_active",
        "RtlDirect::on_active",
        "MissionBlock::startPrecLand",
        "Mission::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "fabsf",
          "Mission::on_activation"
        ],
        "src/modules/navigator/mission.h": [
          "isLanding"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::updateMissionAltAfterHomeChanged"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::startPrecLand"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::readVtolLandApproaches"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::on_active"
        ]
      }
    }
  },
  {
    "title": "Add hysteresis to max height above ground failsafe logic",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24132",
    "number": 24132,
    "created_at": "2024-12-19T11:16:36Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nThere was a race condition which happened when transitioning with a VTOL from hover to forward flight, and when we only rely on an optical flow sensor for velocity aiding during the hover phase.\r\nIn this case the estimator was not able to initialize airspeed aiding, before the logic for the maximum height above the ground triggered.\r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\nAdd a hysteresis of 1 second in order to avoid the above described race condition and to avoid short false positives in general.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Fix race condition, which could cause a max height above ground failsafe to be triggered right after a VTOL front transition.\r\n```\r\n\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2024-12-19T11:21:40Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 104 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +104  +0.0%    +104    .text\n    +1.4%     +68  +1.4%     +68    ../../src/modules/navigator/mission_block.cpp\n    +0.3%     +36  +0.3%     +36    ../../src/modules/navigator/navigator_main.cpp\n  +0.0%     +56  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%     +20  [ = ]       0    .debug_frame\n  +0.0% +1.36Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.0%     +10  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +1.3%    +728  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.4%    +540  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/navigator_mode.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +0.0%     +10  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/takeoff.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n  +0.0%    +910  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.5%     +41  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +1.2%     +41  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +1.0%     +41  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    +0.7%     +41  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.2%     +25  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +2.9%    +296  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +1.1%     +41  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%     +36  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.5%     +41  [ = ]       0    ../../src/modules/navigator/navigator_mode.cpp\n    +0.4%     +41  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +0.4%     +41  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.4%     +41  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.6%     +41  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.9%     +41  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.8%     +41  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +1.0%     +41  [ = ]       0    ../../src/modules/navigator/takeoff.cpp\n    +0.9%     +41  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.4%      +4  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +384  [ = ]       0    .debug_loc\n    +1.7%    +138  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +1.0%    +244  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.2%     +15  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -0.5%     -15  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.0%      +2  [ = ]       0    [section .debug_loc]\n  -0.0%     -17  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -0.5%     -16  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +1.2%     +24  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.2%     -16  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -1.5%      -1  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +133  [ = ]       0    .debug_str\n    -0.3%      -9  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.4%      +9  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.2%    +133  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n  -0.6%    -104  [ = ]       0    [Unmapped]\n  +0.0% +2.80Ki  +0.0%    +104    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 120 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +120  +0.0%    +120    .text\n    +1.4%     +68  +1.4%     +68    ../../src/modules/navigator/mission_block.cpp\n    +0.3%     +36  +0.3%     +36    ../../src/modules/navigator/navigator_main.cpp\n    +0.0%     +13  +0.0%     +13    [section .text]\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n  +0.0%     +56  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%     +20  [ = ]       0    .debug_frame\n  +0.0% +1.36Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.0%     +10  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +1.3%    +728  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.4%    +540  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/navigator_mode.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +0.0%     +10  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%      +9  [ = ]       0    ../../src/modules/navigator/takeoff.cpp\n    +0.0%      +8  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n  +0.0%    +910  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.5%     +41  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +1.2%     +41  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +1.0%     +41  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    +0.7%     +41  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.2%     +25  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +2.9%    +296  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +1.1%     +41  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%     +36  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.5%     +41  [ = ]       0    ../../src/modules/navigator/navigator_mode.cpp\n    +0.4%     +41  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +0.4%     +41  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.4%     +41  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.6%     +41  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.9%     +41  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.8%     +41  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +1.0%     +41  [ = ]       0    ../../src/modules/navigator/takeoff.cpp\n    +0.9%     +41  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.4%      +4  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +369  [ = ]       0    .debug_loc\n    +1.7%    +138  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.9%    +229  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.1%     -15  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.2%     +15  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.0%      +2  [ = ]       0    [section .debug_loc]\n  -0.0%     -18  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -0.5%     -16  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +1.2%     +24  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.2%     -16  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -3.0%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +133  [ = ]       0    .debug_str\n    -0.3%      -9  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.4%      +9  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.2%    +133  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n  -0.2%    -120  [ = ]       0    [Unmapped]\n  +0.0% +2.79Ki  +0.0%    +120    TOTAL\n\n  ```\n</details>\n\n**Updated: _2024-12-19T11:21:40_**",
          "type": "issue_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-12-19T14:03:08Z",
          "body": "The estimator only starts fusing airspeed while in fixedwing and since the vehicle is considered a multirotor during front transition, there will always be that gap. I would suggest that we instead allow fusing airspeed in all modes (but keeping the minimum airspeed threshold)",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses a race condition in the failsafe logic (a timing/state issue) that could spuriously trigger a max-height-above-ground failsafe during VTOL front transition. Adding a 1s hysteresis prevents the incorrect/short-lived state change (a classic logic error), even though a reviewer suggested an alternative mitigation (allowing airspeed fusion earlier).",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "patch": "@@ -1023,10 +1023,19 @@ void MissionBlock::updateFailsafeChecks()\n \n void MissionBlock::updateMaxHaglFailsafe()\n {\n+\n+\tif (!_navigator->get_position_setpoint_triplet()->current.valid ||\n+\t    !_navigator->get_global_position()->terrain_alt_valid ||\n+\t    !PX4_ISFINITE(_navigator->get_local_position()->hagl_max)) {\n+\t\t_navigator->update_and_get_terrain_alt_exceeded_state(false, hrt_absolute_time());\n+\t\treturn;\n+\t}\n+\n \tconst float target_alt = _navigator->get_position_setpoint_triplet()->current.alt;\n+\tconst bool exceeded = (target_alt - _navigator->get_global_position()->terrain_alt) >\n+\t\t\t      _navigator->get_local_position()->hagl_max;\n \n-\tif (_navigator->get_global_position()->terrain_alt_valid\n-\t    && ((target_alt - _navigator->get_global_position()->terrain_alt) > _navigator->get_local_position()->hagl_max)) {\n+\tif (_navigator->update_and_get_terrain_alt_exceeded_state(exceeded, hrt_absolute_time())) {\n \t\t// Handle case where the altitude setpoint is above the maximum HAGL (height above ground level)\n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Target altitude higher than max HAGL\\t\");\n \t\tevents::send(events::ID(\"navigator_fail_max_hagl\"), events::Log::Error, \"Target altitude higher than max HAGL\");",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ba6f3f1548781ecb045e72212232f75645c8c9d2/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -59,6 +59,7 @@\n \n #include <lib/adsb/AdsbConflict.h>\n #include <lib/perf/perf_counter.h>\n+#include <lib/hysteresis/hysteresis.h>\n #include <px4_platform_common/module.h>\n #include <px4_platform_common/module_params.h>\n #include <uORB/Publication.hpp>\n@@ -240,6 +241,12 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid set_cruising_throttle(float throttle = NAN) { _mission_throttle = throttle; }\n \n+\tbool update_and_get_terrain_alt_exceeded_state(bool exceeded, hrt_abstime now)\n+\t{\n+\t\t_max_terrain_alt_exceeded_hyst.set_state_and_update(exceeded, now);\n+\t\treturn _max_terrain_alt_exceeded_hyst.get_state();\n+\t}\n+\n \t/**\n \t * Get if the yaw acceptance is required at the current mission item\n \t *\n@@ -385,6 +392,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool _is_capturing_images{false}; // keep track if we need to stop capturing images\n \n+\tsystemlib::Hysteresis _max_terrain_alt_exceeded_hyst{false};\n \n \t// update subscriptions\n \tvoid params_update();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ba6f3f1548781ecb045e72212232f75645c8c9d2/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::updateFailsafeChecks"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::updateFailsafeChecks"
        ]
      }
    }
  },
  {
    "title": "Make ADSB handling in Navigator optional to save flash",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24131",
    "number": 24131,
    "created_at": "2024-12-19T06:27:51Z",
    "merged": true,
    "merged_at": "2024-12-19T14:30:34Z",
    "state": "closed",
    "conversation": {
      "author": "MaEtUgR",
      "body": "### Solved Problem\r\nWhen reviewing https://github.com/PX4/PX4-Autopilot/pull/24127 I had the idea to make this logic optional since I'm assuming it's rare to have an ADSB transponder attached to a racer board with constrained flash.\r\n\r\n### Solution\r\nLike with the `CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF` I made this feature of Navigator optional, enabled it by default but removed it from some flash constrained boards.\r\n\r\n### Changelog Entry\r\n```\r\nMake ADSB handling in Navigator optional to save flash\r\n```\r\n\r\n### Alternatives\r\nThe not-so-nice part is that the ADSB related uORB and MAVLink messages and drivers are completely separate.\r\n\r\n### Test coverage\r\nThe Kakute F7 build fits in flash again with this change.",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-12-19T10:42:16Z",
          "body": "Yes, sorry it was the style check because on Mac I wasn't able to install this super old version of astyle from homebrew ðŸ™„ ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-12-19T08:34:46Z",
          "body": "I fully agree with the approach, that's a low hanging fruit for constrained boards.\r\nAt least one CI test failure is real, can you have a look?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-12-19T13:17:50Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR makes ADS-B handling in the Navigator optional to reduce flash usage on constrained boards â€” a build/configuration optimization rather than a fix to incorrect program logic. It changes what gets compiled in for size reasons and does not correct a wrong conditional, state transition, algorithm, or runtime behavior, so it is not a logic error fix.",
    "patches": {
      "src/modules/navigator/Kconfig": {
        "filename": "src/modules/navigator/Kconfig",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -19,3 +19,11 @@ menuconfig MODE_NAVIGATOR_VTOL_TAKEOFF\n \t\tAdd VTOL takeoff mode to enable support for MAV_CMD_NAV_VTOL_TAKEOFF.\n \t\tThe VTOL takes off in MC mode and transition to FW. The mode ends with\n \t\tan infinite loiter\n+\n+menuconfig NAVIGATOR_ADSB\n+\tbool \"Include traffic reporting and avoidance\"\n+\tdefault y\n+\tdepends on MODULES_NAVIGATOR\n+\t---help---\n+\t\tAdd support for acting on ADSB transponder_report or ADSB_VEHICLE MAVLink messages.\n+\t\tActions are warnings, Loiter, Land and RTL without climb.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac36e5858b277826d87365cc151ca9c88ecb89b4/src%2Fmodules%2Fnavigator%2FKconfig"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "patch": "@@ -57,8 +57,11 @@\n \n #include \"GeofenceBreachAvoidance/geofence_breach_avoidance.h\"\n \n+#if CONFIG_NAVIGATOR_ADSB\n #include <lib/adsb/AdsbConflict.h>\n+#endif // CONFIG_NAVIGATOR_ADSB\n #include <lib/perf/perf_counter.h>\n+#include <px4_platform_common/events.h>\n #include <px4_platform_common/module.h>\n #include <px4_platform_common/module_params.h>\n #include <uORB/Publication.hpp>\n@@ -136,14 +139,14 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t */\n \tvoid publish_vehicle_cmd(vehicle_command_s *vcmd);\n \n+#if CONFIG_NAVIGATOR_ADSB\n \t/**\n \t * Check nearby traffic for potential collisions\n \t */\n \tvoid check_traffic();\n-\n \tvoid take_traffic_conflict_action();\n-\n \tvoid run_fake_traffic();\n+#endif // CONFIG_NAVIGATOR_ADSB\n \n \t/**\n \t * Setters\n@@ -365,7 +368,10 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tLand\t\t_land;\t\t\t/**< class for handling land commands */\n \tPrecLand\t_precland;\t\t\t/**< class for handling precision land commands */\n \tRTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */\n+#if CONFIG_NAVIGATOR_ADSB\n \tAdsbConflict \t_adsb_conflict;\t\t\t/**< class that handles ADSB conflict avoidance */\n+\ttraffic_buffer_s _traffic_buffer{};\n+#endif // CONFIG_NAVIGATOR_ADSB\n \n \tNavigatorMode *_navigation_mode{nullptr};\t/**< abstract pointer to current navigation mode class */\n \tNavigatorMode *_navigation_mode_array[NAVIGATOR_MODE_ARRAY_SIZE] {};\t/**< array of navigation modes */\n@@ -381,8 +387,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tfloat _cruising_speed_current_mode{-1.0f};\n \tfloat _mission_throttle{NAN};\n \n-\ttraffic_buffer_s _traffic_buffer{};\n-\n \tbool _is_capturing_images{false}; // keep track if we need to stop capturing images\n \n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac36e5858b277826d87365cc151ca9c88ecb89b4/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "patch": "@@ -52,7 +52,6 @@\n #include <dataman_client/DatamanClient.hpp>\n #include <drivers/drv_hrt.h>\n #include <lib/geo/geo.h>\n-#include <lib/adsb/AdsbConflict.h>\n #include <lib/mathlib/mathlib.h>\n #include <px4_platform_common/px4_config.h>\n #include <px4_platform_common/defines.h>\n@@ -143,9 +142,11 @@ void Navigator::params_update()\n \t}\n \n \t_mission.set_command_timeout(_param_mis_command_tout.get());\n+#if CONFIG_NAVIGATOR_ADSB\n \t_adsb_conflict.set_conflict_detection_params(_param_nav_traff_a_hor_ct.get(),\n \t\t\t_param_nav_traff_a_ver.get(),\n \t\t\t_param_nav_traff_collision_time.get(), _param_nav_traff_avoid.get());\n+#endif // CONFIG_NAVIGATOR_ADSB\n }\n \n void Navigator::run()\n@@ -752,8 +753,10 @@ void Navigator::run()\n \t\t\t}\n \t\t}\n \n+#if CONFIG_NAVIGATOR_ADSB\n \t\t/* Check for traffic */\n \t\tcheck_traffic();\n+#endif // CONFIG_NAVIGATOR_ADSB\n \n \t\t/* Check geofence violation */\n \t\tgeofence_breach_check();\n@@ -1222,6 +1225,7 @@ void Navigator::load_fence_from_file(const char *filename)\n \t_geofence.loadFromFile(filename);\n }\n \n+#if CONFIG_NAVIGATOR_ADSB\n void Navigator::take_traffic_conflict_action()\n {\n \n@@ -1251,12 +1255,10 @@ void Navigator::take_traffic_conflict_action()\n \n \t\t}\n \t}\n-\n }\n \n void Navigator::run_fake_traffic()\n {\n-\n \t_adsb_conflict.run_fake_traffic(get_global_position()->lat, get_global_position()->lon,\n \t\t\t\t\tget_global_position()->alt);\n }\n@@ -1283,6 +1285,7 @@ void Navigator::check_traffic()\n \n \t_adsb_conflict.remove_expired_conflicts();\n }\n+#endif // CONFIG_NAVIGATOR_ADSB\n \n bool Navigator::abort_landing()\n {\n@@ -1325,11 +1328,14 @@ int Navigator::custom_command(int argc, char *argv[])\n \t\tget_instance()->load_fence_from_file(GEOFENCE_FILENAME);\n \t\treturn 0;\n \n+#if CONFIG_NAVIGATOR_ADSB\n+\n \t} else if (!strcmp(argv[0], \"fake_traffic\")) {\n \n \t\tget_instance()->run_fake_traffic();\n \n \t\treturn 0;\n+#endif // CONFIG_NAVIGATOR_ADSB\n \t}\n \n \treturn print_usage(\"unknown command\");",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac36e5858b277826d87365cc151ca9c88ecb89b4/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::take_traffic_conflict_action",
        "Navigator::check_traffic",
        "Navigator::run",
        "Navigator::params_update",
        "Navigator::load_fence_from_file",
        "Navigator::custom_command"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::take_traffic_conflict_action",
          "Navigator::check_traffic",
          "Navigator::run",
          "Navigator::custom_command",
          "Navigator::params_update",
          "Navigator::load_fence_from_file"
        ]
      }
    }
  },
  {
    "title": "Navigator: Set altitude acceptance radius to infinity when moving to land point after transition",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24115",
    "number": 24115,
    "created_at": "2024-12-16T12:49:06Z",
    "merged": true,
    "merged_at": "2024-12-20T08:21:33Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nAfter a VTOL backtransition the vehicle might not be close enough to the land point and thus needs to move horizontally.\r\nIt can happened that during this process the vehicle loses altitude and thus reaches the land point without being within the acceptance radius of the land point. In cases of strong wind or depleted batteries, it might not be possible for the vehicle to climb into the acceptance radius. However, this is also unnecessary, as the goal is eventually to descend.\r\n\r\n\r\n### Solution\r\nSet the altitude acceptance radius to infinity when we are moving to the land point after the backtransition.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix XYZ\r\nNew parameter: XYZ_Z\r\nDocumentation: Need to clarify page ... / done, read docs.px4.io/...\r\n```\r\n\r\n### Alternatives\r\nWe could also ...\r\n\r\n### Test coverage\r\n- Unit/integration test: ...\r\n- Simulation/hardware testing logs: https://review.px4.io/\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2024-12-16T12:54:09Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 176 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +176  +0.0%    +176    .text\n    +3.1%     +56  +3.1%     +56    ../../src/modules/navigator/mission.cpp\n    +0.4%     +40  +0.4%     +40    ../../src/modules/navigator/navigator_main.cpp\n    +3.1%     +36  +3.1%     +36    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +1.8%     +32  +1.8%     +32    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.0%      +5  +0.0%      +5    [section .text]\n    +0.6%      +4  +0.6%      +4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n  +0.0%    +124  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    +0.6%     +18  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +1.5%     +50  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%    +201  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.1%     +34  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.0%     +53  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.0%      -4  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.1%     +98  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.0%     +24  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  +0.0%    +179  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%     +18  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.3%     +65  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.1%     +13  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.9%     +62  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.9%     +48  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.2%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +281  [ = ]       0    .debug_loc\n    +1.6%     +60  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.3%     +78  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.6%     +54  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.3%     +19  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +2.0%     +70  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  +0.0%     +25  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +1.2%      +8  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.3%     +24  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.2%     +24  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -3.7%     -24  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +1.5%      +1  [ = ]       0    task/task_cancelpt.c\n  +0.0%     +50  [ = ]       0    .debug_str\n    +7.0%     +50  [ = ]       0    ../../src/modules/navigator/mission.cpp\n  -1.0%    -176  [ = ]       0    [Unmapped]\n  +0.0%    +852  +0.0%    +176    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 168 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +168  +0.0%    +168    .text\n    +3.1%     +56  +3.1%     +56    ../../src/modules/navigator/mission.cpp\n    +0.4%     +40  +0.4%     +40    ../../src/modules/navigator/navigator_main.cpp\n    +3.1%     +36  +3.1%     +36    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +1.8%     +32  +1.8%     +32    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.6%      +4  +0.6%      +4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  +0.0%    +124  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    +0.6%     +18  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +1.5%     +50  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%    +201  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.1%     +34  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.0%     +53  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.0%      -4  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.1%     +98  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.0%     +24  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  +0.0%    +179  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%     +18  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.3%     +65  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.1%     +13  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.9%     +62  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.9%     +48  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.2%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +280  [ = ]       0    .debug_loc\n    +1.6%     +60  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.2%     +62  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.6%     +54  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.5%     +34  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +2.0%     +70  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  +0.0%     +22  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +1.2%      +8  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.3%     +24  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.2%     +24  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -3.7%     -24  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -3.0%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0%     +50  [ = ]       0    .debug_str\n    +7.0%     +50  [ = ]       0    ../../src/modules/navigator/mission.cpp\n  -0.2%    -168  [ = ]       0    [Unmapped]\n  +0.0%    +848  +0.0%    +168    TOTAL\n\n  ```\n</details>\n\n**Updated: _2024-12-20T06:59:46_**",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-12-20T06:49:53Z",
          "body": "@sfuhrer I tested this in SITL for all three cases by deliberately making the vehicle overshoot the transition and by adding a hack which increases the altitude setpoint of the land point, once the transition is finished.\r\nI was able to compare behavior with and without the fix.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-12-17T14:43:45Z",
          "body": "This would now also set it to infinity for MCs. I guess you would need an additional check that it is a vtol?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-12-17T15:50:04Z",
          "body": "THis is the same for the RTL mission and rtl mission reverse.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-12-19T11:31:15Z",
          "body": "@KonradRudin No, because those work item types are only used for VTOL.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-12-19T14:17:01Z",
          "body": "@RomanBapst are you sure? In [here](https://github.com/PX4/PX4-Autopilot/blob/f57ebfb8388366fa190fd4c8564ef62738d69cc3/src/modules/navigator/mission_base.cpp#L652) it also can come if not a VTOL no?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 9,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-12-19T14:23:45Z",
          "body": "the pos_ctrl_status.altitude_acceptance field seems to be only set in [collision avoidance](https://github.com/PX4/PX4-Autopilot/pull/10413), so I don't see a problem here.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 11,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-12-20T06:48:08Z",
          "body": "@sfuhrer Yes, you are right, that was indeed the case. I added the checks now.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 9,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-12-17T15:50:08Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-12-19T11:31:15Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-12-19T14:25:37Z",
          "body": "I agree with the logic, just need to double check the one comment. \r\nHow extensive did you SITL test it?",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2024-12-20T06:48:08Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-12-20T08:20:54Z",
          "body": "Thanks!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes the altitude acceptance condition that was causing incorrect operational behavior (the vehicle being prevented from moving to the land point because it failed an altitude acceptance check). This is a logic-level state/condition error (improper acceptance-condition logic) and the change corrects the program's behavior rather than a syntax/style issue; reviewer comments and SITL testing support this fix.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "patch": "@@ -211,8 +211,14 @@ void Mission::setActiveMissionItems()\n \n \t\t// prevent fixed wing lateral guidance from loitering at a waypoint as part of a mission landing if the altitude\n \t\t// is not achieved.\n-\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING && isLanding() &&\n-\t\t    _mission_item.nav_cmd == NAV_CMD_WAYPOINT) {\n+\t\tconst bool fw_on_mission_landing = _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n+\t\t\t\t\t\t   && isLanding() &&\n+\t\t\t\t\t\t   _mission_item.nav_cmd == NAV_CMD_WAYPOINT;\n+\t\tconst bool mc_landing_after_transition = _vehicle_status_sub.get().vehicle_type ==\n+\t\t\t\tvehicle_status_s::VEHICLE_TYPE_ROTARY_WING && _vehicle_status_sub.get().is_vtol &&\n+\t\t\t\tnew_work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND;\n+\n+\t\tif (fw_on_mission_landing || mc_landing_after_transition) {\n \t\t\tpos_sp_triplet->current.alt_acceptance_radius = FLT_MAX;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b9b82ecce7b69a9d3ad993ebbda8a0dd89fe08e7/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "patch": "@@ -1145,8 +1145,13 @@ float Navigator::get_altitude_acceptance_radius()\n \n \t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n \n-\t\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)\n-\t\t    && pos_ctrl_status.altitude_acceptance > alt_acceptance_radius) {\n+\t\tconst position_setpoint_s &curr_sp = get_position_setpoint_triplet()->current;\n+\n+\t\tif (PX4_ISFINITE(curr_sp.alt_acceptance_radius) && curr_sp.alt_acceptance_radius > FLT_EPSILON) {\n+\t\t\talt_acceptance_radius = curr_sp.alt_acceptance_radius;\n+\n+\t\t} else if ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)\n+\t\t\t   && pos_ctrl_status.altitude_acceptance > alt_acceptance_radius) {\n \t\t\talt_acceptance_radius = pos_ctrl_status.altitude_acceptance;\n \t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b9b82ecce7b69a9d3ad993ebbda8a0dd89fe08e7/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -355,6 +355,7 @@ void RtlDirect::set_rtl_item()\n \t\t\tpos_yaw_sp.alt = loiter_altitude;\n \t\t\tpos_yaw_sp.yaw = !_param_wv_en.get() ? _destination.yaw : NAN; // set final yaw if weather vane is disabled\n \n+\t\t\taltitude_acceptance_radius = FLT_MAX;\n \t\t\tsetMoveToPositionMissionItem(_mission_item, pos_yaw_sp);\n \t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b9b82ecce7b69a9d3ad993ebbda8a0dd89fe08e7/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "patch": "@@ -215,8 +215,14 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \n \t\t// prevent lateral guidance from loitering at a waypoint as part of a mission landing if the altitude\n \t\t// is not achieved.\n-\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING && MissionBase::isLanding()\n-\t\t    && _mission_item.nav_cmd == NAV_CMD_WAYPOINT) {\n+\t\tconst bool fw_on_mission_landing = _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n+\t\t\t\t\t\t   && isLanding() &&\n+\t\t\t\t\t\t   _mission_item.nav_cmd == NAV_CMD_WAYPOINT;\n+\t\tconst bool mc_landing_after_transition = _vehicle_status_sub.get().vehicle_type ==\n+\t\t\t\tvehicle_status_s::VEHICLE_TYPE_ROTARY_WING && _vehicle_status_sub.get().is_vtol &&\n+\t\t\t\tnew_work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND;\n+\n+\t\tif (fw_on_mission_landing || mc_landing_after_transition) {\n \t\t\tpos_sp_triplet->current.alt_acceptance_radius = FLT_MAX;\n \t\t}\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b9b82ecce7b69a9d3ad993ebbda8a0dd89fe08e7/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -155,6 +155,13 @@ void RtlMissionFastReverse::setActiveMissionItems()\n \t\t}\n \n \t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t\tconst bool mc_landing_after_transition = _vehicle_status_sub.get().vehicle_type ==\n+\t\t\t\tvehicle_status_s::VEHICLE_TYPE_ROTARY_WING && _vehicle_status_sub.get().is_vtol &&\n+\t\t\t\tnew_work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND;\n+\n+\t\tif (mc_landing_after_transition) {\n+\t\t\tpos_sp_triplet->current.alt_acceptance_radius = FLT_MAX;\n+\t\t}\n \t}\n \n \tissue_command(_mission_item);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b9b82ecce7b69a9d3ad993ebbda8a0dd89fe08e7/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::get_altitude_acceptance_radius",
        "Mission::setActiveMissionItems",
        "RtlDirect::set_rtl_item",
        "RtlDirectMissionLand::setActiveMissionItems",
        "RtlMissionFastReverse::setActiveMissionItems",
        "MissionBase::isLanding"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::setActiveMissionItems"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_altitude_acceptance_radius"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::setActiveMissionItems",
          "MissionBase::isLanding"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "Mission: Replay gimbal cached items before reaching mission waypoint",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24085",
    "number": 24085,
    "created_at": "2024-12-09T17:47:13Z",
    "merged": true,
    "merged_at": "2024-12-10T08:20:53Z",
    "state": "closed",
    "conversation": {
      "author": "riccardo-mengoli",
      "body": "\r\n\r\n<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nWhen flying patterns, photos are sometimes taken while the gimbal is pitching up or down.\r\n\r\n### Solution\r\nTo address this, we orient the gimbal before reaching the mission waypoint, allowing more time to complete the action. Additionally, we verify if the vehicle is climbing to avoid orienting the gimbal while on the ground.\r\n\r\n### Test coverage\r\nTested in SITL.\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-12-10T08:20:09Z",
          "body": "This is a follow-up to https://github.com/PX4/PX4-Autopilot/pull/23484. There we went a bit too far with replaying the gimbal commands too late, this is now improved with the work here.\r\n\r\nLooks reasonable to me and I couldn't break it in SITL testing. ",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect timing/sequence logic that caused gimbal commands to be replayed too late, resulting in photos taken while the gimbal was still moving. The change adjusts when cached gimbal items are applied (before reaching the waypoint) and adds a climb-state check to avoid inappropriate orientation on the ground, addressing a state/timing-related bug.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "patch": "@@ -299,15 +299,14 @@ MissionBase::on_active()\n \t\treplayCachedCameraModeItems();\n \t}\n \n+\t// Replay cached gimbal commands immediately upon mission resume, but only after the vehicle has reached the final target altitude\n+\tif (haveCachedGimbalItems() && _work_item_type != WorkItemType::WORK_ITEM_TYPE_CLIMB) {\n+\t\treplayCachedGimbalItems();\n+\t}\n \n \t// Replay cached mission commands once the last mission waypoint is re-reached after the mission interruption.\n \t// Each replay function also clears the cached items afterwards\n \tif (_mission.current_seq > _mission_activation_index) {\n-\t\t// replay gimbal commands\n-\t\tif (haveCachedGimbalItems()) {\n-\t\t\treplayCachedGimbalItems();\n-\t\t}\n-\n \t\t// replay trigger commands\n \t\tif (cameraWasTriggering()) {\n \t\t\treplayCachedTriggerItems();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/80b6b71b7bc56f50589a63603c1a00301aabca07/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_active"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active"
        ]
      }
    }
  },
  {
    "title": "Use VehicleCommand specified heading for VTOL transition",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24040",
    "number": 24040,
    "created_at": "2024-11-26T16:12:02Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "JacopoPan",
      "body": "### Solved Problem\r\nI wanted to use `VEHICLE_CMD_NAV_VTOL_TAKEOFF`'s `param2` to specify heading as in the [MAVLINK Common Message Set](https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_VTOL_TAKEOFF) in this example [here](https://github.com/JacopoPan/px4-fw-aerobatics/blob/5726ef624bdb37608f82b8d0348b757851165a95/vtol_example/px4whisperer.py#L312-L322) but, in my understanding, PX4's `vtol_takeoff.cpp` defaults to the direction of the next waypoint in the mission\r\n```\r\nself.send_vehicle_command(\r\n                        84, # VEHICLE_CMD_NAV_VTOL_TAKEOFF\r\n                        param2=3.0, # takeoff mode 3: specified (custom PX4 only)\r\n                        param4=yaw, # unused heading https://docs.px4.io/main/en/flight_modes_vtol/mission.html\r\n                        # MAV_CMD_NAV_VTOL_TAKEOFF.param2 is ignored, heading to the next wp is used for the transition heading.\r\n                        # Custom PX4 fix in navigator_main.cpp and vtol_takeoff.cpp circumvents this\r\n                        param5=self.home_lat,\r\n                        param6=self.home_lon,\r\n                        param7=self.home_alt + alt,\r\n                        conf=0\r\n                        )\r\n```\r\n\r\n### Solution\r\nI added some naive logic to use the heading specified in `param4` if and only if `param2` is set to 3, it could be extended to be fully compliant with [`VTOL_TRANSITION_HEADING`](https://mavlink.io/en/messages/common.html#VTOL_TRANSITION_HEADING)\r\n\r\n### Test coverage\r\n- A complete Python-based SITL example is in https://github.com/JacopoPan/px4-fw-aerobatics/tree/main\r\n- I tested successfully in hardware applying the change to 1.14.3 on a 6X autopilot and sending the vehicle command with uDDS/ROS2 in C++ (will update with the flight logs soon)",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes how the VTOL transition heading is chosen: previously the code ignored the VehicleCommand's param2/param4 and used the next waypoint heading, producing incorrect behavior when a specific heading was requested. The change corrects the decision logic to use the provided heading when param2==3, which fixes an incorrect state/behavior selection (a logic bug).",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "patch": "@@ -651,6 +651,12 @@ void Navigator::run()\n \n \t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n \n+\t\t\t\tfloat epsilon = 1e-6f;\n+\t\t\t\tif (std::fabs(cmd.param2 - 3.0f) < epsilon) { // Specified transition direction\n+\t\t\t\t\tPX4_WARN(\"[Navigator::run] setTransitionDirecton from cmd.param4\");\n+\t\t\t\t\t_vtol_takeoff.setTransitionDirection(cmd.param4);\n+\t\t\t\t}\n+\n \t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n \t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/327c88eaa2135d876fa5165f94528bd8f2d61d05/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "patch": "@@ -71,8 +71,13 @@ VtolTakeoff::on_active()\n \t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat,\n-\t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n+\t\t\t\tif (std::isnan(_transition_direction_deg)) {\n+\t\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_navigator->get_home_position()->lat,\n+\t\t\t\t\t\t\t_navigator->get_home_position()->lon, _loiter_location(0), _loiter_location(1)));\n+\t\t\t\t} else {\n+\t\t\t\t\tPX4_WARN(\"[VtolTakeoff] Transition direction from Command\");\n+\t\t\t\t\t_mission_item.yaw = wrap_pi(math::radians(_transition_direction_deg));\n+\t\t\t\t}\n \t\t\t\t_mission_item.force_heading = true;\n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/327c88eaa2135d876fa5165f94528bd8f2d61d05/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      },
      "src/modules/navigator/vtol_takeoff.h": {
        "filename": "src/modules/navigator/vtol_takeoff.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -55,6 +55,7 @@ class VtolTakeoff : public MissionBlock, public ModuleParams\n \tvoid on_active() override;\n \n \tvoid setTransitionAltitudeAbsolute(const float alt_amsl) {_transition_alt_amsl = alt_amsl; }\n+\tvoid setTransitionDirection(const float tran_bear) {_transition_direction_deg = tran_bear; }\n \n \tvoid setLoiterLocation(matrix::Vector2d loiter_location) { _loiter_location = loiter_location; }\n \tvoid setLoiterHeight(const float height_m) { _loiter_height = height_m; }\n@@ -72,6 +73,7 @@ class VtolTakeoff : public MissionBlock, public ModuleParams\n \tfloat _transition_alt_amsl{0.f};\t// absolute altitude at which vehicle will transition to forward flight\n \tmatrix::Vector2d _loiter_location;\n \tfloat _loiter_height{0};\n+\tfloat _transition_direction_deg{NAN};\n \n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::VTO_LOITER_ALT>) _param_loiter_alt",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/327c88eaa2135d876fa5165f94528bd8f2d61d05/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.h"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run",
        "VtolTakeoff::on_active"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Navigator: add optional delay after gimbal mission items",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23960",
    "number": 23960,
    "created_at": "2024-11-18T09:48:57Z",
    "merged": true,
    "merged_at": "2024-11-28T19:23:36Z",
    "state": "closed",
    "conversation": {
      "author": "StefanoColli",
      "body": "### Solved Problem\r\nIn a mission with a move gimbal item followed by a take picture item, the picture is taken while the gimbal is still moving\r\n\r\n### Solution\r\nAfter a `CMD_DO_GIMBAL_MANAGER_PITCHYAW` wait for a timeout before resuming the mission to be sure that the gimbal reached the desired orientation. \r\nSince we already have `CMD_DO_WINCH` and `NAV_CMD_DO_GRIPPER` following a similar pattern, we defined a common timeout parameter (`MIS_COMMAND_TOUT`) for these 3 mission items. Furthermore, we unified the logic handling such mission items simplifying the navigator code.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nRemoved parameter: MIS_PD_TO (substituted by MIS_COMMAND_TOUT)\r\nNew parameter: MIS_COMMAND_TOUT\r\n```\r\n### Test coverage\r\n- SITL testing\r\n",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T14:54:00Z",
          "body": "@StefanoColli FYI I'm currently reviewing this pr and have quite some suggestions for simplifications. I can push them after I'm finished, just want to make sure we're not changing the same things at the same time.",
          "type": "issue_comment"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T16:43:54Z",
          "body": "Nice work, the code is much tidier now! In simulation it still behaves as expected. ðŸ‘ðŸ» ",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-21T18:21:41Z",
          "body": "Sorry for the delay we're still testing the solution. We could merge without the default timeout and then set accordingly after the testing.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-12-11T01:17:01Z",
          "body": "@StefanoColli Removal of `MIS_PD_TO` has created docs errors in these docs:\r\n\r\n- https://docs.px4.io/main/en/flying/package_delivery_mission.md\r\n- https://docs.px4.io/main/en/peripherals/gripper.md\r\n\r\nCan you please fix them up? Also note comment from @sfuhrer here: https://github.com/PX4/PX4-Autopilot/pull/23960#pullrequestreview-2442441532 - which boils down to \"where else should the information be added\"?\r\nIf you can create a PR with the changes I will review.\r\n\r\nIt may sound trite, but there is no point adding any feature if you don't document it, because it will not get used.\r\n\r\nFWIW I am not certain about this change. The time taken for a winch to spool might be very significantly different to the time for a gimbal to align. If you have a setup with both then you're slowing your mission by however long the longer delay is. \r\nPerhaps not that big a deal.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-12-12T05:52:46Z",
          "body": "OK, added fixes to docs for this in https://github.com/PX4/PX4-user_guide/pull/3495 - would appreciate review",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-11-18T12:08:21Z",
          "body": "Could we come up with a reasonable default that applies for most gimbals, or are the times they need to move actually so far apart that a default doesn't make any sense?\r\nOn the gimbal you tested with: to what value would you set it?",
          "path": "src/modules/navigator/mission_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-11-18T12:12:02Z",
          "body": "```suggestion\r\n\t\t\tconst float gimbal_command_elasped_time_s = (now - _gimbal_command_time) * 1E-6f;\r\n```\r\nYou can use `hrt_elapsed_time()`. \r\nE.g. `if (hrt_elapsed_time(_gimbal_command_time) > _gimbal_wait_time * 1_s)`",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T12:51:05Z",
          "body": "I believe that the best default value is to keep it as 0 since such delay prevents any other mission item to be executed in that time slot. I don't know if it is a desirable default behavior. \r\nI tested it on a simulated gimbal with 3 seconds, but I don't know if gimbals have a 'standard' rate speed we can use to find a default value for the delay. Furthermore the delay depends also on the max angle the gimbal have to move and thus on the specific mission.     ",
          "path": "src/modules/navigator/mission_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T13:02:54Z",
          "body": "I used that form to be consistent with the `NAV_CMD_DO_WINCH` and `NAV_CMD_DO_GRIPPER` cases: https://github.com/PX4/PX4-Autopilot/blob/385fa260602476a1700d6a69ccd4c287d0558276/src/modules/navigator/mission_block.cpp#L176\r\nShould I correct them all?",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T14:54:34Z",
          "body": "I changed all of them.",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T14:56:29Z",
          "body": "Ideally we'd actually chaeck if the gimal reached the attitude it was commanded. Since I assume that's not the scope of this implementation I'd suggest a reasonable default according to our tests and following up with a gimbal state based solution.",
          "path": "src/modules/navigator/mission_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T15:49:30Z",
          "body": "Thanks!",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T16:28:03Z",
          "body": "Now that we have a common timeout value for winch, gripper and gimbal, it is even more difficult to find a reasonable default value. At this point I would use 5.0 which was the default for `MIS_PD_TO`   ",
          "path": "src/modules/navigator/mission_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T16:58:40Z",
          "body": "@sfuhrer Isn't this way of timeout condition better because of unsigned wrapping? ðŸ¤” ",
          "path": "src/modules/navigator/mission_block.cpp",
          "position": 60,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2024-11-18T12:18:35Z",
          "body": "Makes sense to me, assuming we do not get feedback from the gimbal and thus cannot know when its position is reached, so we need to assume \"worst case\".\r\n\r\nPlease think about how to recommend users to tune it and open a PR against docs.px4 with these instructions. \r\nE.g. in the [gimbal docs](https://docs.px4.io/main/en/advanced/gimbal_control.html#gimbal-configuration).",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T12:51:05Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T13:02:54Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T14:54:34Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T14:56:29Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T15:33:07Z",
          "body": "I suggested quite some changes ðŸ™ˆ\r\n@StefanoColli Could you check if my suggestions make sense and if ti still works as expected in your testing? ðŸ˜‡ ",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T15:49:30Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "StefanoColli",
          "created_at": "2024-11-18T16:28:03Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-18T16:58:41Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-11-28T19:23:27Z",
          "body": "I disabled the timeout by default again since we couldn't confirm how long it should be. We can add a sensible default value later if we see what works for most setups.\r\n\r\nFrom my side this is a good iteration and with all the simplifications it doesn't add any ballast.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a timing/state bug where the mission resumed immediately after a gimbal move, causing the subsequent take-picture item to run while the gimbal was still moving (a race/timing/state-transition error). The change adds an optional wait (and unifies handling via MIS_COMMAND_TOUT) so the mission only continues after a safe timeout, correcting the incorrect behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 78,
        "changes": 116,
        "patch": "@@ -81,7 +81,6 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tcase NAV_CMD_DO_CONTROL_VIDEO:\n \tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n \tcase NAV_CMD_DO_MOUNT_CONTROL:\n-\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n \tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n \tcase NAV_CMD_DO_SET_ROI:\n \tcase NAV_CMD_DO_SET_ROI_LOCATION:\n@@ -142,40 +141,14 @@ MissionBlock::is_mission_item_reached_or_completed()\n \n \t\tbreak;\n \n-\tcase NAV_CMD_DO_WINCH: {\n-\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) *\n-\t\t\t\t\t1E-6f; // TODO: Add proper microseconds_to_seconds function\n-\n-\t\t\tif (_payload_deploy_ack_successful) {\n-\t\t\t\tPX4_DEBUG(\"Winch Deploy Ack received! Resuming mission\");\n-\t\t\t\treturn true;\n-\n-\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n-\t\t\t\tPX4_DEBUG(\"Winch Deploy Timed out, resuming mission!\");\n-\t\t\t\treturn true;\n-\n-\t\t\t}\n-\n-\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n-\t\t\treturn false;\n+\tcase NAV_CMD_DO_WINCH:\n+\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n+\tcase NAV_CMD_DO_GRIPPER:\n+\t\tif (now > _timestamp_command_timeout + (_command_timeout * 1_s)) {\n+\t\t\treturn true;\n \t\t}\n \n-\tcase NAV_CMD_DO_GRIPPER: {\n-\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) * 1E-6f;\n-\n-\t\t\tif (_payload_deploy_ack_successful) {\n-\t\t\t\tPX4_DEBUG(\"Gripper Deploy Ack received! Resuming mission\");\n-\t\t\t\treturn true;\n-\n-\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n-\t\t\t\tPX4_DEBUG(\"Gripper Deploy Timed out, resuming mission!\");\n-\t\t\t\treturn true;\n-\n-\t\t\t}\n-\n-\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n-\t\t\treturn false;\n-\t\t}\n+\t\treturn false; // Still waiting\n \n \tdefault:\n \t\t/* do nothing, this is a 3D waypoint */\n@@ -445,7 +418,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \n \t\t/* check if the MAV was long enough inside the waypoint orbit */\n \t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n-\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n+\t\t    (now >= (hrt_abstime)(get_time_inside(_mission_item) * 1_s) + _time_wp_reached)) {\n \t\t\ttime_inside_reached = true;\n \t\t}\n \n@@ -549,53 +522,37 @@ MissionBlock::issue_command(const mission_item_s &item)\n \t\treturn;\n \t}\n \n-\tif (item.nav_cmd == NAV_CMD_DO_WINCH ||\n-\t    item.nav_cmd == NAV_CMD_DO_GRIPPER) {\n-\t\t// Initiate Payload Deployment\n-\t\tvehicle_command_s vcmd = {};\n-\t\tvcmd.command = item.nav_cmd;\n-\t\tvcmd.param1 = item.params[0];\n-\t\tvcmd.param2 = item.params[1];\n-\t\tvcmd.param3 = item.params[2];\n-\t\tvcmd.param4 = item.params[3];\n-\t\tvcmd.param5 = static_cast<double>(item.params[4]);\n-\t\tvcmd.param6 = static_cast<double>(item.params[5]);\n-\t\t_navigator->publish_vehicle_cmd(&vcmd);\n-\n-\t\t// Reset payload deploy flag & data to get ready to receive deployment ack result\n-\t\t_payload_deploy_ack_successful = false;\n-\t\t_payload_deployed_time = hrt_absolute_time();\n-\n-\t} else {\n+\t// This is to support legacy DO_MOUNT_CONTROL as part of a mission.\n+\tif (item.nav_cmd == NAV_CMD_DO_MOUNT_CONTROL) {\n+\t\t_navigator->acquire_gimbal_control();\n+\t}\n \n-\t\t// This is to support legacy DO_MOUNT_CONTROL as part of a mission.\n-\t\tif (item.nav_cmd == NAV_CMD_DO_MOUNT_CONTROL) {\n-\t\t\t_navigator->acquire_gimbal_control();\n+\t// Mission item's NAV_CMD enums directly map to the according vehicle command\n+\t// So set the raw value directly (MAV_FRAME_MISSION mission item)\n+\tvehicle_command_s vcmd = {};\n+\tvcmd.command = item.nav_cmd;\n+\tvcmd.param1 = item.params[0];\n+\tvcmd.param2 = item.params[1];\n+\tvcmd.param3 = item.params[2];\n+\tvcmd.param4 = item.params[3];\n+\tvcmd.param5 = static_cast<double>(item.params[4]);\n+\tvcmd.param6 = static_cast<double>(item.params[5]);\n+\tvcmd.param7 = item.params[6];\n+\n+\tif (item.nav_cmd == NAV_CMD_DO_SET_ROI_LOCATION) {\n+\t\t// We need to send out the ROI location that was parsed potentially with double precision to lat/lon because mission item parameters 5 and 6 only have float precision\n+\t\tvcmd.param5 = item.lat;\n+\t\tvcmd.param6 = item.lon;\n+\n+\t\tif (item.altitude_is_relative) {\n+\t\t\tvcmd.param7 = item.altitude + _navigator->get_home_position()->alt;\n \t\t}\n+\t}\n \n-\t\t// Mission item's NAV_CMD enums directly map to the according vehicle command\n-\t\t// So set the raw value directly (MAV_FRAME_MISSION mission item)\n-\t\tvehicle_command_s vcmd = {};\n-\t\tvcmd.command = item.nav_cmd;\n-\t\tvcmd.param1 = item.params[0];\n-\t\tvcmd.param2 = item.params[1];\n-\t\tvcmd.param3 = item.params[2];\n-\t\tvcmd.param4 = item.params[3];\n-\t\tvcmd.param5 = static_cast<double>(item.params[4]);\n-\t\tvcmd.param6 = static_cast<double>(item.params[5]);\n-\t\tvcmd.param7 = item.params[6];\n-\n-\t\tif (item.nav_cmd == NAV_CMD_DO_SET_ROI_LOCATION) {\n-\t\t\t// We need to send out the ROI location that was parsed potentially with double precision to lat/lon because mission item parameters 5 and 6 only have float precision\n-\t\t\tvcmd.param5 = item.lat;\n-\t\t\tvcmd.param6 = item.lon;\n-\n-\t\t\tif (item.altitude_is_relative) {\n-\t\t\t\tvcmd.param7 = item.altitude + _navigator->get_home_position()->alt;\n-\t\t\t}\n-\t\t}\n+\t_navigator->publish_vehicle_cmd(&vcmd);\n \n-\t\t_navigator->publish_vehicle_cmd(&vcmd);\n+\tif (item_has_timeout(item)) {\n+\t\t_timestamp_command_timeout = hrt_absolute_time();\n \t}\n }\n \n@@ -619,10 +576,13 @@ MissionBlock::get_time_inside(const mission_item_s &item) const\n // and shouldn't have a timeout defined as it is a DO_* command. It should rather be defined as CONDITION_GRIPPER\n // or so, and have a function named 'item_is_conditional'\n // Reference: https://mavlink.io/en/services/mission.html#mavlink_commands\n+// A similar condition applies to DO_GIMBAL_MANAGER_PITCHYAW\n bool\n MissionBlock::item_has_timeout(const mission_item_s &item)\n {\n-\treturn item.nav_cmd == NAV_CMD_DO_WINCH || item.nav_cmd == NAV_CMD_DO_GRIPPER;\n+\treturn item.nav_cmd == NAV_CMD_DO_WINCH ||\n+\t       item.nav_cmd == NAV_CMD_DO_GRIPPER ||\n+\t       item.nav_cmd == NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW;\n }\n \n bool",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b1f47bdd9bc4c7f0d2866f7e12bce9245d03e0d/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 6,
        "deletions": 27,
        "changes": 33,
        "patch": "@@ -108,30 +108,11 @@ class MissionBlock : public NavigatorMode\n \tstatic bool item_contains_marker(const mission_item_s &item);\n \n \t/**\n-\t * @brief Set the payload deployment successful flag object\n+\t * Set the item_has_timeout() command timeout\n \t *\n-\t * Function is accessed in Navigator (navigator_main.cpp) to flag when a successful\n-\t * payload deployment ack command has been received. Which in turn allows the mission item\n-\t * to continue to the next in the 'is_mission_item_reached_or_completed' function below\n+\t * @param timeout Timeout in seconds\n \t */\n-\tvoid set_payload_depolyment_successful_flag(bool payload_deploy_result)\n-\t{\n-\t\t_payload_deploy_ack_successful = payload_deploy_result;\n-\t}\n-\n-\t/**\n-\t * @brief Set the payload deployment timeout\n-\t *\n-\t * Accessed in Navigator to set the appropriate timeout to wait for while waiting for a successful\n-\t * payload delivery acknowledgement. If the payload deployment takes longer than timeout, mission will\n-\t * continue into the next item automatically.\n-\t *\n-\t * @param timeout_s Timeout in seconds\n-\t */\n-\tvoid set_payload_deployment_timeout(const float timeout_s)\n-\t{\n-\t\t_payload_deploy_timeout_s = timeout_s;\n-\t}\n+\tvoid set_command_timeout(const float timeout) { _command_timeout = timeout; }\n \n \t/**\n \t * Copies position from setpoint if valid, otherwise copies current position\n@@ -247,12 +228,10 @@ class MissionBlock : public NavigatorMode\n \n \thrt_abstime _time_wp_reached{0};\n \n-\t/* Payload Deploy internal states are used by two NAV_CMDs: DO_WINCH and DO_GRIPPER */\n-\tbool _payload_deploy_ack_successful{false};\t// Flag to keep track of whether we received an acknowledgement for a successful payload deployment\n-\thrt_abstime _payload_deployed_time{0};\t\t// Last payload deployment start time to handle timeouts\n-\tfloat _payload_deploy_timeout_s{0.0f};\t\t// Timeout for payload deployment in Mission class, to prevent endless loop if successful deployment ack is never received\n+\t// Mission items that have a timeout to allow the payload e.g. gripper, winch, gimbal executing the command see item_has_timeout()\n+\thrt_abstime _timestamp_command_timeout{0}; ///< Timestamp when the current item_has_timeout() command was started\n+\tfloat _command_timeout{0.f}; ///< Time in seconds any item_has_timeout() command should be waited for before continuing the mission\n \n private:\n \tvoid updateMaxHaglFailsafe();\n-\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b1f47bdd9bc4c7f0d2866f7e12bce9245d03e0d/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "patch": "@@ -132,17 +132,6 @@ PARAM_DEFINE_FLOAT(MIS_YAW_TMT, -1.0f);\n  */\n PARAM_DEFINE_FLOAT(MIS_YAW_ERR, 12.0f);\n \n-/**\n- * Timeout for a successful payload deployment acknowledgement\n- *\n- * @unit s\n- * @min 0\n- * @decimal 1\n- * @increment 1\n- * @group Mission\n- */\n-PARAM_DEFINE_FLOAT(MIS_PD_TO, 5.0f);\n-\n /**\n  * Landing abort min altitude\n  *\n@@ -155,3 +144,21 @@ PARAM_DEFINE_FLOAT(MIS_PD_TO, 5.0f);\n  * @group Mission\n  */\n PARAM_DEFINE_INT32(MIS_LND_ABRT_ALT, 30);\n+\n+/**\n+ * Timeout to allow the payload to execute the mission command\n+ *\n+ * Ensure:\n+ *   gripper: NAV_CMD_DO_GRIPPER\n+ *     has released before continuing mission.\n+ *   winch: CMD_DO_WINCH\n+ *     has delivered before continuing mission.\n+ *   gimbal: CMD_DO_GIMBAL_MANAGER_PITCHYAW\n+ *     has reached the commanded orientation before beginning to take pictures.\n+ *\n+ * @unit s\n+ * @min 0\n+ * @decimal 1\n+ * @group Mission\n+ */\n+PARAM_DEFINE_FLOAT(MIS_COMMAND_TOUT, 0.f);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b1f47bdd9bc4c7f0d2866f7e12bce9245d03e0d/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "patch": "@@ -424,10 +424,10 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t\t_param_nav_min_gnd_dist,\t/**< minimum distance to ground (Mission and RTL)*/\n \n \t\t// non-navigator parameters: Mission (MIS_*)\n-\t\t(ParamFloat<px4::params::MIS_TAKEOFF_ALT>) _param_mis_takeoff_alt,\n-\t\t(ParamFloat<px4::params::MIS_YAW_TMT>)     _param_mis_yaw_tmt,\n-\t\t(ParamFloat<px4::params::MIS_YAW_ERR>)     _param_mis_yaw_err,\n-\t\t(ParamFloat<px4::params::MIS_PD_TO>)       _param_mis_payload_delivery_timeout,\n-\t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)  _param_mis_lnd_abrt_alt\n+\t\t(ParamFloat<px4::params::MIS_TAKEOFF_ALT>)    _param_mis_takeoff_alt,\n+\t\t(ParamFloat<px4::params::MIS_YAW_TMT>)        _param_mis_yaw_tmt,\n+\t\t(ParamFloat<px4::params::MIS_YAW_ERR>)        _param_mis_yaw_err,\n+\t\t(ParamInt<px4::params::MIS_LND_ABRT_ALT>)     _param_mis_lnd_abrt_alt,\n+\t\t(ParamFloat<px4::params::MIS_COMMAND_TOUT>) _param_mis_command_tout\n \t)\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b1f47bdd9bc4c7f0d2866f7e12bce9245d03e0d/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "patch": "@@ -115,13 +115,6 @@ Navigator::Navigator() :\n \t_distance_sensor_mode_change_request_pub.get().request_on_off = distance_sensor_mode_change_request_s::REQUEST_OFF;\n \t_distance_sensor_mode_change_request_pub.update();\n \n-\t// Update the timeout used in mission_block (which can't hold it's own parameters)\n-\t_mission.set_payload_deployment_timeout(_param_mis_payload_delivery_timeout.get());\n-\n-\t_adsb_conflict.set_conflict_detection_params(_param_nav_traff_a_hor_ct.get(),\n-\t\t\t_param_nav_traff_a_ver.get(),\n-\t\t\t_param_nav_traff_collision_time.get(), _param_nav_traff_avoid.get());\n-\n \treset_triplets();\n }\n \n@@ -149,7 +142,10 @@ void Navigator::params_update()\n \t\tparam_get(_handle_mpc_acc_hor, &_param_mpc_acc_hor);\n \t}\n \n-\t_mission.set_payload_deployment_timeout(_param_mis_payload_delivery_timeout.get());\n+\t_mission.set_command_timeout(_param_mis_command_tout.get());\n+\t_adsb_conflict.set_conflict_detection_params(_param_nav_traff_a_hor_ct.get(),\n+\t\t\t_param_nav_traff_a_ver.get(),\n+\t\t\t_param_nav_traff_collision_time.get(), _param_nav_traff_avoid.get());\n }\n \n void Navigator::run()\n@@ -1267,9 +1263,7 @@ void Navigator::run_fake_traffic()\n \n void Navigator::check_traffic()\n {\n-\n \tif (_traffic_sub.updated()) {\n-\n \t\t_traffic_sub.copy(&_adsb_conflict._transponder_report);\n \n \t\tuint16_t required_flags = transponder_report_s::PX4_ADSB_FLAGS_VALID_COORDS |\n@@ -1288,7 +1282,6 @@ void Navigator::check_traffic()\n \t}\n \n \t_adsb_conflict.remove_expired_conflicts();\n-\n }\n \n bool Navigator::abort_landing()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4b1f47bdd9bc4c7f0d2866f7e12bce9245d03e0d/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::check_traffic",
        "MissionBlock::get_time_inside",
        "Navigator::run_fake_traffic",
        "set_payload_depolyment_successful_flag",
        "MissionBlock::issue_command",
        "MissionBlock::is_mission_item_reached_or_completed",
        "Navigator",
        "Navigator::Navigator",
        "set_payload_deployment_timeout",
        "Navigator::params_update"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command",
          "MissionBlock::is_mission_item_reached_or_completed",
          "MissionBlock::get_time_inside"
        ],
        "src/modules/navigator/mission_block.h": [
          "set_payload_deployment_timeout",
          "set_payload_depolyment_successful_flag",
          "Navigator"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::check_traffic",
          "Navigator::params_update",
          "Navigator::run_fake_traffic",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "Navigator: RTL: Enable precision landing for all RTL types but only start if enabled",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23907",
    "number": 23907,
    "created_at": "2024-11-07T16:30:41Z",
    "merged": true,
    "merged_at": "2025-01-08T08:31:55Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\n- Found by chance that precision landing is always started atm in RTL direct. It doesn't have any negative effect currently from why I see but still seems wrong.\r\n- No precision landing possible in RTL_TYPE=2 and no mission landing planned (RtlMissionFastReverse)\r\n\r\n### Solution\r\n- Check for the setting of `RTL_PLD_MD` and only `startPrecLand()` if precision landing is enabled, plus harden `startPrecLand()` to not do anything if not precision landing is not enabled.\r\n- check `RTL_PLD_MD` in RtlMissionFastReverse and execute precision landing if set accordingly (similar logic as in RtlDirect)\r\n\r\n### Changelog Entry\r\nFor release notes: \r\n```\r\nBugfix: Navigator: RTL_direct: onyl start precision land if param is set to enabled\r\nBugfix: Navigator: RTL: use precision landing if enabled in param RTL_PLD_MD also for reverse mission RTL\r\n```\r\n\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-11-12T10:28:07Z",
          "body": "@KonradRudin I added support for precision landing in RTL reverse, see acf2875dcd5bb800b028d107b401edb7871170d4",
          "type": "issue_comment"
        },
        {
          "author": "github-actions[bot]",
          "created_at": "2025-01-06T07:36:32Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 72 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +72  +0.0%     +72    .text\n    +7.1%     +84  +7.1%     +84    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%     +25  +0.0%     +25    ROMFS/nsh_romfsimg.c\n    +0.1%      +4  +0.1%      +4    ../../src/modules/navigator/mission_block.cpp\n    +0.0%      +4  +0.0%      +4    [section .text]\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n    -0.6%      -4  -0.6%      -4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    -0.6%     -44  -0.6%     -44    ../../src/modules/navigator/mission_base.cpp\n  +0.0%     +53  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    -0.4%     -14  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +0.3%      +7  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -0.4%     -14  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.3%     -10  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.7%     +21  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.7%     +21  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.5%     -14  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n  +0.0%      +8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +6.5%     +16  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%     -20  [ = ]       0    .debug_frame\n  -0.0% -4.12Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    -0.5%    -334  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    -0.6%    -333  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -0.6%    -433  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.7%    -688  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.1%     -48  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.2%    -331  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.4%    -333  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    -0.4%    -349  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    -0.4%    -333  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -0.5%    -430  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -0.6%    -431  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.2%    +165  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.6%    -334  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n  -0.0%     -45  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.4%     +30  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +0.7%     +30  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -1.2%     -68  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.7%    -103  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.1%     -10  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%     +30  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.3%     +30  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    -0.9%     -83  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -1.0%     -68  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -1.4%     -68  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +4.4%    +229  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.6%     +30  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.1%      +1  [ = ]       0    task/task_cancelpt.c\n  -0.0%    -341  [ = ]       0    .debug_loc\n    -3.8%    -143  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -2.6%    -364  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +0.0%      +2  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.1%     -16  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -2.0%    -128  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -4.7%    -143  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n     +13%    +451  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%    -288  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n   -12.6%     -88  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -4.1%    -144  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -7.7%     -88  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n   -12.9%     -88  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n     +21%    +128  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%    -879  [ = ]       0    .debug_str\n    -2.9%     -22  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.8%     -74  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -1.4%    -783  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n  -0.5%      -1  [ = ]       0    .shstrtab\n  +0.0%    +101  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n     +14%    +101  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n  +0.0%     +48  [ = ]       0    .symtab\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +8.8%     +48  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n  -0.4%     -72  [ = ]       0    [Unmapped]\n  -0.0% -5.45Ki  +0.0%     +72    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 64 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +64  +0.0%     +64    .text\n    +7.1%     +84  +7.1%     +84    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%     +25  +0.0%     +25    ROMFS/nsh_romfsimg.c\n    +0.1%      +4  +0.1%      +4    ../../src/modules/navigator/mission_block.cpp\n    -0.0%      -1  -0.0%      -1    [section .text]\n    -0.6%      -4  -0.6%      -4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    -0.6%     -44  -0.6%     -44    ../../src/modules/navigator/mission_base.cpp\n  +0.0%     +53  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    -0.4%     -14  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +0.3%      +7  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -0.4%     -14  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.3%     -10  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.7%     +21  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.7%     +21  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.5%     -14  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n  +0.0%      +8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +6.5%     +16  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%     -20  [ = ]       0    .debug_frame\n  -0.0% -4.12Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    -0.5%    -334  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    -0.6%    -333  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -0.6%    -433  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.7%    -688  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.1%     -48  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.3%    -331  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.4%    -333  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    -0.4%    -349  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    -0.4%    -333  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -0.5%    -430  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -0.7%    -431  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.2%    +165  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.6%    -334  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n  -0.0%     -45  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.4%     +30  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +0.7%     +30  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -1.2%     -68  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.7%    -103  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.1%     -10  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%     +30  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +0.3%     +30  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    -0.9%     -83  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -1.0%     -68  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -1.4%     -68  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +4.4%    +229  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.6%     +30  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.1%      +1  [ = ]       0    task/task_cancelpt.c\n  -0.0%    -340  [ = ]       0    .debug_loc\n    -3.8%    -143  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -2.6%    -364  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +0.0%      +2  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -2.2%    -143  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -4.7%    -143  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n     +13%    +451  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%    -289  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n   -12.6%     -88  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -4.1%    -144  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -7.7%     -88  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n   -12.9%     -88  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n     +21%    +128  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -1.5%      -1  [ = ]       0    task/task_cancelpt.c\n  -0.0%    -867  [ = ]       0    .debug_str\n    -2.9%     -22  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.8%     -73  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -1.4%    -772  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n  -0.5%      -1  [ = ]       0    .shstrtab\n  +0.0%    +101  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n     +14%    +101  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n  +0.0%     +48  [ = ]       0    .symtab\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +8.8%     +48  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n  -0.1%     -64  [ = ]       0    [Unmapped]\n  -0.0% -5.44Ki  +0.0%     +64    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-01-06T07:36:31_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-11-11T11:41:11Z",
          "body": "How does it work with the RTL. Is the precision land request still in the mission item or is it in the RTL_PLD_MD parameter (or do you need to consider both? and or or?)",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-11-11T12:53:13Z",
          "body": "Even thinking about it more, the _mission_item.land_precision is not set in the RTL direct",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 14,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-11-11T13:01:28Z",
          "body": "Depends. \r\n\r\nIf you set the `RTL_TYPE`=2 and set the Precision land mode flag in the [mavlink mission item LAND](https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_LAND)  and then trigger an RTL, the precision_land navigator mode will be executed and the drone lands on the marker if it finds one. So the same outcome as with `RTL_TYPE`=0 (direct RTL to Home) and `RTL_PLD_MD` set to 1 or 2.\r\n\r\nI think where it's not working atm though is RTL_TYPE=2 but then don't plan a mission landing. It will then return via the flown mission path and tries to land at the takeoff position. For precision landing to work we'd need to check `RTL_PLD_MD` in the `rtl_mission_fast_reverse`. \r\n\r\nhttps://github.com/user-attachments/assets/21df6358-191a-4f02-b607-5e468bb51014\r\n\r\n",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 14,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-11-11T11:41:18Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-11-11T12:53:13Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-11-11T13:01:28Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2025-01-08T07:33:25Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect conditional behavior: precision-landing was being started unconditionally in some RTL modes and not considered for RTL reverse, causing unintended behavior. The changes gate startPrecLand() on the RTL_PLD_MD setting and harden the start routine, fixing an improper conditional/state transition logic bug.",
    "patches": {
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -483,8 +483,8 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tmission_item_s _last_camera_trigger_item {};\n \tmission_item_s _last_speed_change_item {};\n \n-\tDEFINE_PARAMETERS(\n-\t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n+\tDEFINE_PARAMETERS_CUSTOM_PARENT(\n+\t\tModuleParams,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n \t)\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ab49dfed7afe882a5fbe754bc96c81fee919a2e5/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -978,7 +978,7 @@ void MissionBlock::startPrecLand(uint16_t land_precision)\n \t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n \t\t_navigator->get_precland()->on_activation();\n \n-\t} else { //_mission_item.land_precision == 2\n+\t} else if (_mission_item.land_precision == 2) {\n \t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n \t\t_navigator->get_precland()->on_activation();\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ab49dfed7afe882a5fbe754bc96c81fee919a2e5/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -110,7 +110,7 @@ void RtlDirect::on_active()\n \t\tupdateAltToAvoidTerrainCollisionAndRepublishTriplet(_mission_item);\n \t}\n \n-\tif (_rtl_state == RTLState::LAND && _param_rtl_pld_md.get() > 0) {\n+\tif (_rtl_state == RTLState::LAND && _mission_item.land_precision > 0) {\n \t\t// Need to update the position and type on the current setpoint triplet.\n \t\t_navigator->get_precland()->on_active();\n \n@@ -369,7 +369,9 @@ void RtlDirect::set_rtl_item()\n \n \t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n \n-\t\t\tstartPrecLand(_mission_item.land_precision);\n+\t\t\tif (_mission_item.land_precision > 0) {\n+\t\t\t\tstartPrecLand(_mission_item.land_precision);\n+\t\t\t}\n \n \t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: land at destination\\t\");\n \t\t\tevents::send(events::ID(\"rtl_land_at_destination\"), events::Log::Info, \"RTL: land at destination\");",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ab49dfed7afe882a5fbe754bc96c81fee919a2e5/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -269,6 +269,13 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t\t_mission_item.altitude = _home_pos_sub.get().alt;\n \t\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n+\n+\t\t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n+\n+\t\t\t\tif (_mission_item.land_precision > 0) {\n+\t\t\t\t\tstartPrecLand(_mission_item.land_precision);\n+\t\t\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ab49dfed7afe882a5fbe754bc96c81fee919a2e5/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.h": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -74,4 +74,8 @@ class RtlMissionFastReverse : public RtlBase\n \tbool _in_landing_phase{false};\n \n \tuORB::SubscriptionData<home_position_s> _home_pos_sub{ORB_ID(home_position)};\t\t/**< home position subscription */\n+\tDEFINE_PARAMETERS_CUSTOM_PARENT(\n+\t\tRtlBase,\n+\t\t(ParamInt<px4::params::RTL_PLD_MD>)       _param_rtl_pld_md\n+\t)\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ab49dfed7afe882a5fbe754bc96c81fee919a2e5/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.h"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -139,6 +139,7 @@ PARAM_DEFINE_INT32(RTL_CONE_ANG, 45);\n  * RTL precision land mode\n  *\n  * Use precision landing when doing an RTL landing phase.\n+ * This setting does not apply for RTL destinations planned as part of a mission.\n  *\n  * @value 0 No precision landing\n  * @value 1 Opportunistic precision landing",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ab49dfed7afe882a5fbe754bc96c81fee919a2e5/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::startPrecLand",
        "RtlDirect::on_active",
        "RtlMissionFastReverse::handleLanding",
        "RtlDirect::set_rtl_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::startPrecLand"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::on_active",
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::handleLanding"
        ]
      }
    }
  },
  {
    "title": "Mission validity checks: make clear that MIS_DIST_1WP only warns, not invalidates",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23873",
    "number": 23873,
    "created_at": "2024-10-31T13:17:48Z",
    "merged": true,
    "merged_at": "2024-11-01T15:19:20Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n\r\n### Solved Problem\r\nParam description outdated since https://github.com/PX4/PX4-Autopilot/pull/23568.\r\n\r\n### Solution\r\nMake clear that it only warns but doesn't have effect on mission validity.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nImprovement: Mission validity checks: make clear that MIS_DIST_1WP only warns, not invalidates\r\n```\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-11-01T15:07:53Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR updates an outdated parameter description to clarify that MIS_DIST_1WP only emits warnings and does not invalidate a mission. This is a documentation/description clarification rather than a change to program logic or state, so it does not fix a logic error in the code.",
    "patches": {
      "src/modules/navigator/mission_params.c": {
        "filename": "src/modules/navigator/mission_params.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "patch": "@@ -74,15 +74,15 @@ PARAM_DEFINE_FLOAT(MIS_TAKEOFF_ALT, 2.5f);\n PARAM_DEFINE_INT32(MIS_TKO_LAND_REQ, 0);\n \n /**\n- * Maximal horizontal distance from current position to first waypoint\n+ * Maximal horizontal distance from Home to first waypoint\n  *\n- * Failsafe check to prevent running mission stored from previous flight at a new takeoff location.\n- * Set a value of zero or less to disable. The mission will not be started if the current\n- * waypoint is more distant than MIS_DIST_1WP from the current position.\n+ * There will be a warning message if the current waypoint is more distant than MIS_DIST_1WP from Home.\n+ * Has no effect on mission validity.\n+ * Set a value of zero or less to disable.\n  *\n  * @unit m\n  * @min -1\n- * @max 10000\n+ * @max 100000\n  * @decimal 1\n  * @increment 100\n  * @group Mission",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/08c4c1ca808cb97fecc6f297f91340b638f68e66/src%2Fmodules%2Fnavigator%2Fmission_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Reload mission for RTL_TYPE 2",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23855",
    "number": 23855,
    "created_at": "2024-10-25T14:21:03Z",
    "merged": true,
    "merged_at": "2024-11-05T04:20:00Z",
    "state": "closed",
    "conversation": {
      "author": "potaito",
      "body": "### Solved Problem\r\nWhen uploading missions to be flown with RTL_TYPE=2 as a return path, PX4 sometimes claims there is no mission when RTL is triggered:\r\n\r\n```\r\n# WARN  [navigator] No valid mission available, loitering\t\r\n# ERROR [dataman_client] readSync failed! status=3, item=2, index=4294967295, length=56\r\n# WARN  [navigator] Mission item could not be set.\t\r\n# WARN  [navigator] No valid mission available, loitering\t\r\n```\r\n\r\n### Solution\r\n\r\nTurns out that when these specific RTL handlers are initialized, they don't initialize their mission member variable. Because of that the RTL handlers essentially work with an empty mission where the index is -1, hence the dataman error.\r\n\r\nThe solution is to load the existing mission after initializing the handlers. I decided to pass the variables via constructor to contain the logic of obtaining the mission from the uORB queue all in rtl.cpp. This way the information flow is more visible in my opinion.\r\n\r\n```\r\nswitch (new_rtl_mission_type) {\r\n\tcase RtlType::RTL_DIRECT_MISSION_LAND:\r\n\t\t_rtl_mission_type_handle = new RtlDirectMissionLand(_navigator);\r\n\t\t_set_rtl_mission_type = RtlType::RTL_DIRECT_MISSION_LAND;\r\n\t\t// RTL type is either direct or mission land have to set it later.\r\n\t\tbreak;\r\n\r\n\tcase RtlType::RTL_MISSION_FAST:\r\n\t\t_rtl_mission_type_handle = new RtlMissionFast(_navigator, new_mission);\r\n\t\t_set_rtl_mission_type = RtlType::RTL_MISSION_FAST;\r\n\t\t_rtl_type = RtlType::RTL_MISSION_FAST;\r\n\t\tbreak;\r\n\r\n\tcase RtlType::RTL_MISSION_FAST_REVERSE:\r\n\t\t_rtl_mission_type_handle = new RtlMissionFastReverse(_navigator, new_mission);\r\n\t\t_set_rtl_mission_type = RtlType::RTL_MISSION_FAST_REVERSE;\r\n\t\t_rtl_type = RtlType::RTL_MISSION_FAST_REVERSE;\r\n\t\tbreak;\r\n```\r\n\r\n### Changelog Entry\r\n\r\nFor release notes:\r\n```\r\nBugfix: \"No valid mission available\" error with RTL_TYPE=2 \r\nNew parameter: -\r\nDocumentation: -\r\n```\r\n\r\n### Test coverage\r\n\r\nTested with SITL where mission 1 is executed, mission 2 uploaded and then RTL triggered.\r\n\r\nBug on main branch: https://logs.px4.io/plot_app?log=6af3f82a-ec03-4f8e-95d7-f949697ecd00\r\nFix from this PR: https://logs.px4.io/plot_app?log=03c990f1-0601-4142-8a9b-f6b42b9cc1ef\r\n",
      "issue_comments": [
        {
          "author": "potaito",
          "created_at": "2024-10-25T14:21:47Z",
          "body": "@KonradRudin could you take a look? :pray: ",
          "type": "issue_comment"
        },
        {
          "author": "potaito",
          "created_at": "2024-11-05T16:01:18Z",
          "body": "Thanks @dakejahl :grin: ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2024-11-05T04:18:54Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes an incorrect program state: RTL handlers were left with an uninitialized/empty mission (index -1) which produced wrong runtime behaviour and dataman read errors. The change explicitly loads/passes the mission into the RTL handler during initialization, correcting the improper state transition and eliminating the erroneous 'No valid mission available' behavior.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -585,6 +585,8 @@ void RTL::init_rtl_mission_type()\n \t\t_set_rtl_mission_type = RtlType::NONE;\n \t}\n \n+\tmission_s new_mission = _mission_sub.get();\n+\n \tswitch (new_rtl_mission_type) {\n \tcase RtlType::RTL_DIRECT_MISSION_LAND:\n \t\t_rtl_mission_type_handle = new RtlDirectMissionLand(_navigator);\n@@ -593,13 +595,13 @@ void RTL::init_rtl_mission_type()\n \t\tbreak;\n \n \tcase RtlType::RTL_MISSION_FAST:\n-\t\t_rtl_mission_type_handle = new RtlMissionFast(_navigator);\n+\t\t_rtl_mission_type_handle = new RtlMissionFast(_navigator, new_mission);\n \t\t_set_rtl_mission_type = RtlType::RTL_MISSION_FAST;\n \t\t_rtl_type = RtlType::RTL_MISSION_FAST;\n \t\tbreak;\n \n \tcase RtlType::RTL_MISSION_FAST_REVERSE:\n-\t\t_rtl_mission_type_handle = new RtlMissionFastReverse(_navigator);\n+\t\t_rtl_mission_type_handle = new RtlMissionFastReverse(_navigator, new_mission);\n \t\t_set_rtl_mission_type = RtlType::RTL_MISSION_FAST_REVERSE;\n \t\t_rtl_type = RtlType::RTL_MISSION_FAST_REVERSE;\n \t\tbreak;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9b3e267c3a2e38888d719f0662a066598829bf69/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -46,10 +46,10 @@\n \n static constexpr int32_t DEFAULT_MISSION_FAST_CACHE_SIZE = 5;\n \n-RtlMissionFast::RtlMissionFast(Navigator *navigator) :\n+RtlMissionFast::RtlMissionFast(Navigator *navigator, mission_s mission) :\n \tRtlBase(navigator, DEFAULT_MISSION_FAST_CACHE_SIZE)\n {\n-\n+\t_mission = mission;\n }\n \n void RtlMissionFast::on_inactive()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9b3e267c3a2e38888d719f0662a066598829bf69/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.cpp"
      },
      "src/modules/navigator/rtl_mission_fast.h": {
        "filename": "src/modules/navigator/rtl_mission_fast.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -52,7 +52,7 @@ class Navigator;\n class RtlMissionFast : public RtlBase\n {\n public:\n-\tRtlMissionFast(Navigator *navigator);\n+\tRtlMissionFast(Navigator *navigator, mission_s mission);\n \t~RtlMissionFast() = default;\n \n \tvoid on_activation() override;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9b3e267c3a2e38888d719f0662a066598829bf69/src%2Fmodules%2Fnavigator%2Frtl_mission_fast.h"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -46,10 +46,10 @@\n \n static constexpr int32_t DEFAULT_MISSION_FAST_REVERSE_CACHE_SIZE = 5;\n \n-RtlMissionFastReverse::RtlMissionFastReverse(Navigator *navigator) :\n+RtlMissionFastReverse::RtlMissionFastReverse(Navigator *navigator, mission_s mission) :\n \tRtlBase(navigator, -DEFAULT_MISSION_FAST_REVERSE_CACHE_SIZE)\n {\n-\n+\t_mission = mission;\n }\n \n void RtlMissionFastReverse::on_inactive()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9b3e267c3a2e38888d719f0662a066598829bf69/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.h": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -52,7 +52,7 @@ class Navigator;\n class RtlMissionFastReverse : public RtlBase\n {\n public:\n-\tRtlMissionFastReverse(Navigator *navigator);\n+\tRtlMissionFastReverse(Navigator *navigator, mission_s mission);\n \t~RtlMissionFastReverse() = default;\n \n \tvoid on_activation() override;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/9b3e267c3a2e38888d719f0662a066598829bf69/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.h"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::init_rtl_mission_type"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::init_rtl_mission_type"
        ]
      }
    }
  },
  {
    "title": "Navigator: land: fix when flying without global position estimate",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23853",
    "number": 23853,
    "created_at": "2024-10-25T12:02:35Z",
    "merged": true,
    "merged_at": "2024-10-31T12:34:45Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Port of https://github.com/PX4/PX4-Autopilot/pull/23845\r\n\r\nI only ported the first commit, as the other two are not direct bug fixes.",
      "issue_comments": [
        {
          "author": "DronecodeBot",
          "created_at": "2024-11-08T08:36:05Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/land-mode-always-land-to-x-0-y-0/33742/6\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-31T12:34:37Z",
          "body": "Thanks for backporting ðŸ‘ ",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect landing behavior when no global position estimate is available (e.g., landing to coordinates 0,0). That is a logic bug caused by improper handling/assumption of a missing global position, and the change corrects the program's unintended behavior rather than a syntax or style issue.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "patch": "@@ -827,8 +827,15 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \titem->nav_cmd = NAV_CMD_LAND;\n \n \t// set land item to current position\n-\titem->lat = _navigator->get_global_position()->lat;\n-\titem->lon = _navigator->get_global_position()->lon;\n+\tif (_navigator->get_local_position()->xy_global) {\n+\t\titem->lat = _navigator->get_global_position()->lat;\n+\t\titem->lon = _navigator->get_global_position()->lon;\n+\n+\t} else {\n+\t\titem->lat = (double)NAN;\n+\t\titem->lon = (double)NAN;\n+\t}\n+\n \titem->yaw = NAN;\n \n \titem->altitude = 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/83e0f479bdb2d6cc610c059647616d0cc4db7167/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_land_item"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_land_item"
        ]
      }
    }
  },
  {
    "title": "Navigator: land: fix when flying without global position estimate",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23845",
    "number": 23845,
    "created_at": "2024-10-23T13:52:48Z",
    "merged": true,
    "merged_at": "2024-10-25T11:56:20Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nFixes https://github.com/PX4/PX4-Autopilot/issues/21524\r\nFixes https://github.com/PX4/PX4-Autopilot/issues/23773\r\nProposes a partial alternative to https://github.com/PX4/PX4-Autopilot/pull/23839\r\n\r\nLand without global position estimate (e.g. GNSS-denied without manually initialized position) was broken since https://github.com/PX4/PX4-Autopilot/pull/21036/commits/efc8c167acd57ca175b9f2eea795b750227263b3. Instead of landing at the current spot it flew to (0/0).\r\n\r\n### Solution\r\nSet lat/lon fields of triplet to NAN if global position is not valid. Further I disable the [breaking distance calculation](https://github.com/PX4/PX4-Autopilot/pull/23546) in this case, as it's requiring global position. Will be anyway removed from Navigator with https://github.com/PX4/PX4-Autopilot/pull/23678.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Navigator: land: fix when flying without global position estimate\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\nSITL tested.\r\n\r\n### Context\r\nLand without global position only works with MC vehicles, FW requires global position. \r\n",
      "issue_comments": [
        {
          "author": "ptrindade96",
          "created_at": "2024-10-24T13:07:26Z",
          "body": "Hi @sfuhrer. It would be nice if you could backport this to v1.14, since the same issue occurs with that version.\r\n\r\nYou can take a look in [this discussion](https://discuss.px4.io/t/auto-land-going-to-the-origin-with-optical-flow/40767).",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2024-10-24T13:09:07Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/auto-land-going-to-the-origin-with-optical-flow/40767/3\n",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T18:12:38Z",
          "body": "> It would be nice if you could backport this to v1.14, since the same issue occurs with that version.\r\n\r\nWe usually only do point releases on the last stable but it's maybe worth a backport if people are struggling...",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-25T12:02:58Z",
          "body": "> Hi @sfuhrer. It would be nice if you could backport this to v1.14, since the same issue occurs with that version.\r\n> \r\n> You can take a look in [this discussion](https://discuss.px4.io/t/auto-land-going-to-the-origin-with-optical-flow/40767).\r\n\r\nI don't think there are any more 1.14 releases planned, as we now have 1.15 out already. I will thus port it to the 1.15 branch. ",
          "type": "issue_comment"
        },
        {
          "author": "duguguang",
          "created_at": "2024-10-30T07:15:39Z",
          "body": "how about the takeoff command?",
          "type": "issue_comment"
        },
        {
          "author": "ptrindade96",
          "created_at": "2024-10-30T09:02:34Z",
          "body": "> > Hi @sfuhrer. It would be nice if you could backport this to v1.14, since the same issue occurs with that version.\r\n> > You can take a look in [this discussion](https://discuss.px4.io/t/auto-land-going-to-the-origin-with-optical-flow/40767).\r\n> \r\n> I don't think there are any more 1.14 releases planned, as we now have 1.15 out already. I will thus port it to the 1.15 branch.\r\n\r\nThat's ok, at least for me it makes no difference. Thanks for your help Silvan.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-30T09:29:17Z",
          "body": "> how about the takeoff command?\r\n\r\nGood point. I've re-opened https://github.com/PX4/PX4-Autopilot/issues/21524.",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2024-11-08T08:36:04Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/land-mode-always-land-to-x-0-y-0/33742/6\n",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T17:39:18Z",
          "body": "This should also be done further down in the file after the VTOL transition then.",
          "path": "src/modules/navigator/land.cpp",
          "position": 7,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T18:09:33Z",
          "body": "Done in ea98e1d\r\nShould be correct right @sfuhrer ? otherwise a VTOL after backtransitioning in land wouldn't do it correctly still.",
          "path": "src/modules/navigator/land.cpp",
          "position": 7,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-25T11:48:17Z",
          "body": "Yes correct, though a VTOL couldn't fly with local position only in fixed-wing in the first place. Still, doesn't hurt to add this guard.",
          "path": "src/modules/navigator/land.cpp",
          "position": 7,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "AlexisTM",
          "created_at": "2024-10-24T06:55:44Z",
          "body": "I tested it in simulation and it properly lands in position without a GPS\r\n",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T17:39:18Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T18:09:33Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T18:11:40Z",
          "body": "Sorry I blew up your pr with the last naming refactoring commit but the breaking functions haunted me ðŸ˜‡ Feel free to change it again or I can also make a separate pr.",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-25T11:48:17Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect runtime behavior where the vehicle would fly to (0,0) when no global position was available, which is a logic bug (incorrect handling of invalid/global-position state). The change makes lat/lon NAN when global position is invalid and disables the global-position-dependent breaking-distance calculation, restoring the intended landing behavior.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "patch": "@@ -58,8 +58,9 @@ Land::on_activation()\n \t/* convert mission item to current setpoint */\n \tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t_navigator->calculate_breaking_stop(_mission_item.lat, _mission_item.lon);\n+\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n+\t    && _navigator->get_local_position()->xy_global) { // only execute if global position is valid\n+\t\t_navigator->preproject_stop_point(_mission_item.lat, _mission_item.lon);\n \t}\n \n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n@@ -82,13 +83,13 @@ void\n Land::on_active()\n {\n \t/* for VTOL update landing location during back transition */\n-\tif (_navigator->get_vstatus()->is_vtol &&\n-\t    _navigator->get_vstatus()->in_transition_mode) {\n+\tif (_navigator->get_vstatus()->is_vtol\n+\t    && _navigator->get_vstatus()->in_transition_mode\n+\t    && _navigator->get_local_position()->xy_global) {\n \t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t\t// create a wp in front of the VTOL while in back-transition, based on MPC settings that will apply in MC phase afterwards\n-\t\t_navigator->calculate_breaking_stop(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n-\n+\t\t_navigator->preproject_stop_point(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n \t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1543bc0c06c2efa40f8fce97b3b4ba54a3d00bb1/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/loiter.cpp": {
        "filename": "src/modules/navigator/loiter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -109,7 +109,7 @@ Loiter::set_loiter_position()\n \t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n \n \t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n+\t\t\tsetLoiterItemFromCurrentPositionWithBraking(&_mission_item);\n \n \t\t} else {\n \t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1543bc0c06c2efa40f8fce97b3b4ba54a3d00bb1/src%2Fmodules%2Fnavigator%2Floiter.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "patch": "@@ -772,11 +772,11 @@ MissionBlock::setLoiterItemFromCurrentPosition(struct mission_item_s *item)\n }\n \n void\n-MissionBlock::setLoiterItemFromCurrentPositionWithBreaking(struct mission_item_s *item)\n+MissionBlock::setLoiterItemFromCurrentPositionWithBraking(struct mission_item_s *item)\n {\n \tsetLoiterItemCommonFields(item);\n \n-\t_navigator->calculate_breaking_stop(item->lat, item->lon);\n+\t_navigator->preproject_stop_point(item->lat, item->lon);\n \n \titem->altitude = _navigator->get_global_position()->alt;\n \titem->loiter_radius = _navigator->get_loiter_radius();\n@@ -832,8 +832,15 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \titem->nav_cmd = NAV_CMD_LAND;\n \n \t// set land item to current position\n-\titem->lat = _navigator->get_global_position()->lat;\n-\titem->lon = _navigator->get_global_position()->lon;\n+\tif (_navigator->get_local_position()->xy_global) {\n+\t\titem->lat = _navigator->get_global_position()->lat;\n+\t\titem->lon = _navigator->get_global_position()->lon;\n+\n+\t} else {\n+\t\titem->lat = (double)NAN;\n+\t\titem->lon = (double)NAN;\n+\t}\n+\n \titem->yaw = NAN;\n \n \titem->altitude = 0;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1543bc0c06c2efa40f8fce97b3b4ba54a3d00bb1/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_block.h": {
        "filename": "src/modules/navigator/mission_block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -183,7 +183,7 @@ class MissionBlock : public NavigatorMode\n \tvoid setLoiterItemFromCurrentPositionSetpoint(struct mission_item_s *item);\n \n \tvoid setLoiterItemFromCurrentPosition(struct mission_item_s *item);\n-\tvoid setLoiterItemFromCurrentPositionWithBreaking(struct mission_item_s *item);\n+\tvoid setLoiterItemFromCurrentPositionWithBraking(struct mission_item_s *item);\n \n \tvoid setLoiterItemCommonFields(struct mission_item_s *item);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1543bc0c06c2efa40f8fce97b3b4ba54a3d00bb1/src%2Fmodules%2Fnavigator%2Fmission_block.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -278,7 +278,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \tvoid release_gimbal_control();\n \tvoid set_gimbal_neutral();\n \n-\tvoid calculate_breaking_stop(double &lat, double &lon);\n+\tvoid preproject_stop_point(double &lat, double &lon);\n \n \tvoid stop_capturing_images();\n \tvoid disable_camera_trigger();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1543bc0c06c2efa40f8fce97b3b4ba54a3d00bb1/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -356,7 +356,7 @@ void Navigator::run()\n \t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n \t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n \n-\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n+\t\t\t\t\t\t\tpreproject_stop_point(rep->current.lat, rep->current.lon);\n \n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n@@ -467,7 +467,7 @@ void Navigator::run()\n \t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n \t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n \n-\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n+\t\t\t\t\t\tpreproject_stop_point(rep->current.lat, rep->current.lon);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n@@ -1588,7 +1588,7 @@ bool Navigator::geofence_allows_position(const vehicle_global_position_s &pos)\n \treturn true;\n }\n \n-void Navigator::calculate_breaking_stop(double &lat, double &lon)\n+void Navigator::preproject_stop_point(double &lat, double &lon)\n {\n \t// For multirotors we need to account for the braking distance, otherwise the vehicle will overshoot and go back\n \tconst float course_over_ground = atan2f(_local_pos.vy, _local_pos.vx);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1543bc0c06c2efa40f8fce97b3b4ba54a3d00bb1/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::calculate_breaking_stop",
        "MissionBlock::setLoiterItemFromCurrentPosition",
        "Navigator::run",
        "Navigator::geofence_allows_position",
        "Land::on_activation",
        "Land::on_active",
        "calculate_breaking_stop",
        "MissionBlock::set_land_item",
        "setLoiterItemFromCurrentPositionWithBreaking",
        "Loiter::set_loiter_position"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation",
          "Land::on_active"
        ],
        "src/modules/navigator/loiter.cpp": [
          "Loiter::set_loiter_position"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_land_item",
          "MissionBlock::setLoiterItemFromCurrentPosition"
        ],
        "src/modules/navigator/mission_block.h": [
          "setLoiterItemFromCurrentPositionWithBreaking"
        ],
        "src/modules/navigator/navigator.h": [
          "calculate_breaking_stop"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::calculate_breaking_stop",
          "Navigator::run",
          "Navigator::geofence_allows_position"
        ]
      }
    }
  },
  {
    "title": "Navigator: Failsafe: Add descend mode as a failsafe.",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23839",
    "number": 23839,
    "created_at": "2024-10-22T12:14:02Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AlexisTM",
      "body": "The land mode supposes we have a GPS causing issues when flying with a local position (such as mocap or vision)\r\nThis adds the alternative to use the descend mode.\r\n\r\n### Solved Problem\r\nWhen working on local position systems such as a vision localization, the land mode doesn't fit the need when the localization is failing as we want a way to land safely. The only alternative is terminate.\r\n\r\n~Furthermore, the current Land mode supposes the use of GPS which is not present using vision/flow/mocap, making the drone try to land at (0,0) with a heading of 0Â°, which is not the expectation.~\r\n\r\n~Fixes #23773~\r\n~Fixes #21524~\r\nFixed by https://github.com/PX4/PX4-Autopilot/pull/23845\r\n\r\n### Solution\r\n- Add the use of Descend mode for all failsafe actions\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Failsafe modes now include the descend mode\r\n```\r\n\r\n### Testing\r\n\r\nTested in simulation\r\n\r\n### Alternatives\r\nCrashlanding with terminate\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2024-10-22T14:44:39Z",
          "body": "I think https://github.com/PX4/PX4-Autopilot/pull/23580 already fixes your issue. There I changed the state machine logic such that \"Land\" failsafe action is always triggered, even if the mode requirements for \"Land\" are not met. It then instantly falls-back to Descend.",
          "type": "issue_comment"
        },
        {
          "author": "AlexisTM",
          "created_at": "2024-10-22T15:18:21Z",
          "body": "Unlike the bug you fixed where you couldn't enter land mode, we actually enter but want the Descent behavior instead. \r\n\r\nThere are two other problems we encounter:\r\n- The land mode succeeds as we do have a proper local position, but it tries to go to (0,0) instead of landing in position. That is likely a bug.\r\n- Even when the land mode works properly, and we have a valid local position, that local position could be unstable due to vision input, especially when developing said vision software. So we do **not** want to rely on the position at all for the emergencies.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-23T08:24:52Z",
          "body": ">we actually enter but want the Descent behavior instead.\r\n\r\nDescent mode is intended to be a fall-back mode only, not intended to be a mode that a user can actively switch into. With this PR you would change that, so let's make sure that we really need it before rushing it in.\r\n\r\n>The land mode succeeds as we do have a proper local position, but it tries to go to (0,0) instead of landing in position. That is likely a bug.\r\n\r\nThat definitely sounds like a bug. I think I was able to reproduce it by triggering RC loss failsafe to Land with gazebo classic iris_opt_flow. Let's focus on fixing that. Could you look into it?\r\n\r\n>Even when the land mode works properly, and we have a valid local position, that local position could be unstable due to vision input, especially when developing said vision software. So we do not want to rely on the position at all for the emergencies.\r\n\r\nBut unstable local position estimation poses a big safety hazard not only in the failsafe modes but also in normal modes such as Position and Hold, no? Shouldn't we focus on improving the rejection on bad position estimates? If we have a reliable way of detecting bad position/velocity estimates we can leave the failsafe actions at Land, and only fall back to Descend in emergencies.  ",
          "type": "issue_comment"
        },
        {
          "author": "AlexisTM",
          "created_at": "2024-10-23T09:04:28Z",
          "body": "I will try to reproduce it in simulation.\r\n\r\nI agree an unstable local position is a very bad problem that has to be fixed, but it is sadly a fact we have to work with during the development for vision systems. \r\n\r\n> Descent mode is intended to be a fall-back mode only, not intended to be a mode that a user can actively switch into. With this PR you would change that, so let's make sure that we really need it before rushing it in.\r\n\r\nThose are the failsafe and not an actively switched to task. In any case where we work on the localization system, this is way safer than the Land mode.",
          "type": "issue_comment"
        },
        {
          "author": "AlexisTM",
          "created_at": "2024-10-23T09:42:10Z",
          "body": "@sfuhrer It is reproducible in simulation. I do not have Gazebo classic, but managed it with Gazebo with minor fixes. (the gazebo models default parameters are not yet valid)\r\n\r\nhttps://review.px4.io/plot_app?log=af6f8332-e2ee-4dd1-91cb-f5cd1ba02099\r\n\r\nReproduce with `make px4_sitl gz_x500_vision`\r\n\r\n- Change the parameters (with QGC, as the defaults not valid in the model)\r\n```\r\nNAV_RCL_ACT Land Mode\r\nSENS_EN_SIMGPS 0\r\nEKF2_EV_DELAY 5\r\nEKF2_EV_CTRL 15 (select all)\r\nEKF2_HGT_REF 3 (select vision)\r\nEKF2_GPS_CTRL 0 \r\n```\r\n- Restart simulation\r\n- Takeoff with QGC\r\n- Move away from (0,0) with the virtual joysticks\r\n- Quit QGC to trigger landing ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-23T13:53:13Z",
          "body": "@AlexisTM can you check out https://github.com/PX4/PX4-Autopilot/pull/23845?",
          "type": "issue_comment"
        },
        {
          "author": "AlexisTM",
          "created_at": "2024-10-24T07:08:39Z",
          "body": "> @AlexisTM can you check out #23845?\r\n\r\nThis solves the land mode with a proper local position but no global position.\r\n\r\nIs there a reason for which we wouldn't want the descend mode in the failsafe? ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-25T12:12:29Z",
          "body": ">Is there a reason for which we wouldn't want the descend mode in the failsafe?\r\n\r\nWe don't like adding features to mainline PX4 that are only in extreme corner cases. Plus as I mentioned above, \"Descend\" is not intended to be a flight mode that the user can actively switch into, it's only meant to go to this mode as a fall-back if \"Land\" is not available. \r\n\r\n>I agree an unstable local position is a very bad problem that has to be fixed, but it is sadly a fact we have to work with during the development for vision systems.\r\n\r\nBut during development you certainly have also manual control capabilities no? Or what do you do when you test an auto mode and the Navigation gets unstable? You switch to a manual mode no?\r\nI would focus on making the detection of \"bad local position estimation\" more reliable. If local position is declared invalid while in \"Land\", the system already automatically switches to Descend. Do you have a specific log file where the local position wasn't estimated accurately enough to land in Land mode, but was not declared invalid?",
          "type": "issue_comment"
        },
        {
          "author": "AlexisTM",
          "created_at": "2024-10-28T13:11:39Z",
          "body": "The current way has been to use the manual mode. Yet, people working on the computer vision part are *not* pilots. As this is flying indoor, there is a very small margin of error to recover the drone.\r\nI do not have a log for a failure to detect invalidity in the data from the land mode as the land mode was unusable indoor until your last PR.\r\n\r\nWe will keep this local for our fork for now.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses incorrect failsafe behaviour: Land assumes a GPS/global position and can command a return-to-(0,0)/wrong setpoint (or rely on unstable local position) instead of a safe descent. That is a logic error (improper state/assumption about available position sources), and switching failsafe actions to Descend avoids relying on invalid position estimates.",
    "patches": {
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -57,6 +57,7 @@\n  * @value 3 Return mode\n  * @value 4 Terminate\n  * @value 5 Land mode\n+ * @value 6 Descend mode\n  * @group Geofence\n  */\n PARAM_DEFINE_INT32(GF_ACTION, 2);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/2fad6ba5b87ab0afff027d5493dc5b118846ad58/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Add descend mode as a failsafe.",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23838",
    "number": 23838,
    "created_at": "2024-10-22T09:45:38Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "AlexisTM",
      "body": "The land mode supposes we have a GPS causing issues when flying with a local position (such as mocap or vision)\r\nThis adds the alternative to use the descend mode.\r\n\r\n### Solved Problem\r\nWhen working on local position systems such as a vision localization, the land mode doesn't fit the need when the localization is failing as we want a way to land.\r\n\r\nFurthermore, the current Land mode supposes the use of GPS which is not present using vision/flow/mocap, making the drone try to land at (0,0) with a heading of 0Â°, which is not the expectation.\r\n\r\nFixes #23773\r\nFixes #21524\r\n\r\n### Solution\r\n- Add the use of Descend mode for all failsafe actions\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Failsafe modes now include the descend mode\r\n```\r\n\r\n### Alternatives\r\nThere could be an automatic demotion from Land to Descend\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "AlexisTM",
          "created_at": "2024-10-22T12:38:16Z",
          "body": "(Small messup happened in this branch)",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic bug in failsafe mode selection: Land assumed a global GPS/localization and caused unintended behavior (landing toward 0,0 with heading 0Â°) when using local-only positioning (vision/mocap). Changing failsafes to use Descend corrects the incorrect assumption/state transition and prevents the undesired landing behavior.",
    "patches": {
      "src/modules/navigator/geofence_params.c": {
        "filename": "src/modules/navigator/geofence_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -57,6 +57,7 @@\n  * @value 3 Return mode\n  * @value 4 Terminate\n  * @value 5 Land mode\n+ * @value 6 Descend mode\n  * @group Geofence\n  */\n PARAM_DEFINE_INT32(GF_ACTION, 2);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/316c9c572190220bf3a81a8755178590825fade1/src%2Fmodules%2Fnavigator%2Fgeofence_params.c"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "RTL: fix RTL time estimation of MC landing phase",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23807",
    "number": 23807,
    "created_at": "2024-10-12T18:24:15Z",
    "merged": true,
    "merged_at": "2024-10-24T15:22:19Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nThe RTL time estimate increases while in the last phase of a MC RTL.\r\n```\r\ntime_estimate: 29.370251\r\ntime_estimate: 28.087288\r\nINFO  [navigator] RTL: land at destination\r\ntime_estimate: 28.194275\r\ntime_estimate: 29.103222\r\ntime_estimate: 30.055092\r\n```\r\n\r\n### Solution\r\nIssues found:\r\n- `isActive()` actually isn't from the rlt mode but from mission (rtl direct doesn't inherit from rtl but from mission). Thus [this condition](https://github.com/PX4/PX4-Autopilot/blob/dbba9adb14b5210498287168396333d57ffb2fb9/src/modules/navigator/rtl_direct.cpp#L429) is always invalid, leading to always pick the `getActivationLandState()` instead of current altitude.\r\n- `isActive()` is also used in another part of rtl_direct. I don't think it caused issues but I remove the check here, as I don't see how it would be necessary\r\n- the loiter_altitude used for [the calculation the remaining time when already being in the last phase](https://github.com/PX4/PX4-Autopilot/blob/dbba9adb14b5210498287168396333d57ffb2fb9/src/modules/navigator/rtl_direct.cpp#L530C25-L530C41) is set to `RTL_DESCEND_ALT`, and it is wrongly assumed that 1) vehicle starts this last LAND phase really only at this altitude and 2) that in this phase it sinks with `MPC_LAND_SPEED` all the way. Instead the sink speed is only reduced when in the last few meters of the landing, as is linked to distance sensor data usually. For the sake of simplicity I removed the distinction between land and sink speed, as I don't think it really matters. The RTL time estimate will anyway always be a few seconds off, and if we want to change that we need to feed in distance sensor data etc. Not worth IMO. IF we remove the distinction then the still wrong assumption of \"LAND phase starting below RTL_DESCEND_ALTITUDE\" . \r\n\r\nMaybe https://github.com/PX4/PX4-Autopilot/pull/23689 introduced some of the issues, or at least surfaced the bugs.\r\n\r\n### Changelog Entry\r\nFor release notes: \r\n```\r\nBugfix: RTL: fix RTL time estimation of MC landing phase\r\n```\r\n\r\n\r\n### Test coverage\r\nRTL direct tested in SITL (multicopter).\r\n",
      "issue_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-23T12:07:06Z",
          "body": "I quickly checked the original issue I reported\r\nbefore:\r\n![grafik](https://github.com/user-attachments/assets/eced035f-3de5-478b-bd69-251a00571c6a)\r\nand after:\r\n![grafik](https://github.com/user-attachments/assets/39a9eecc-5b88-49f8-aabb-16fc2d49acb9)\r\nit's fixed ðŸ‘Œ\r\nI'm reading through the code ðŸ‘€ ",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "KonradRudin",
          "created_at": "2024-10-21T11:50:05Z",
          "body": "I think we should still make this check as you should not be able to update the position anymore when the RTL is already triggered, no?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-10-21T11:51:53Z",
          "body": "isActive does not come from the mission, but from the navigator_mode, which rtl_direct inherits. However, it is not correctly set, since the navigator_mode run function is not triggered. Maybe it would be better to change the rtl.cpp function to call the run function instead of the on_active function directly.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-22T08:15:26Z",
          "body": "What's the problem with my proposal? Seems simpler anyway..",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-22T08:22:42Z",
          "body": "`setRtlPosition() `is called inside `setRtlTypeAndDestination()`, which in turn is only called in:\r\n- `RTL::on_inactive()`\r\n- `RTL::on_activation()`\r\n-` RTL::parameters_update() && !RTL::isActive()`\r\n\r\nI don't see how `isActive()` can be already true in the moment of any of these calls.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-10-22T08:27:43Z",
          "body": "We wanted to not alter it anymore when it is activated. One use case when it is triggered due to low battery, you don't want to change to a location further away. You can still actively override it and change the location then. Also for situation when you change the home position to your position periodically when you move, you want to have the ability to step aside when it RTLs without it following anymore",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-23T12:13:05Z",
          "body": "```suggestion\r\n\tvoid setVehicleType(uint8_t vehicle_type) { _vehicle_type = vehicle_type; };\r\n```",
          "path": "src/lib/rtl/rtl_time_estimator.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-23T12:27:06Z",
          "body": "This is probably accurate in the \"normal\" case but doesn't it break the case where you RTL as multi-copter with a VTOL? Or does it automatically forward transition anyways now?",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-23T12:29:57Z",
          "body": "The `make px4_sitl sihsim_xvert` tips over on takeoff ðŸ˜¬",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-23T14:00:17Z",
          "body": "Yes let's tell the time estimator the correct current vehicle type, not FW if(VTOL).",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:01:17Z",
          "body": "```suggestion\r\n```",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:01:23Z",
          "body": "```suggestion\r\n```",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:28:19Z",
          "body": "There's no guarantee `_rtl_mission_type_handle` exists. Only use pointers if really necessary ðŸ‘€ ",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:32:01Z",
          "body": "I fixed this one but there might be more corner cases. It's playing with fire on a drone ðŸ˜¬ ",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:32:42Z",
          "body": "929cf0f",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:32:48Z",
          "body": "929cf0f",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:33:02Z",
          "body": "c8ade38",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:36:51Z",
          "body": "The only remaining one after your change is when it's a VTOL and you land it hardcodes rotary wing:\r\nhttps://github.com/PX4/PX4-Autopilot/blob/c8ade38ea593b0015e9c8d935e4a4e3b282d25ee/src/modules/navigator/rtl_direct.cpp#L540-L542\r\nI rely on you knowing that this is correct and needed.",
          "path": "src/modules/navigator/rtl_direct_mission_land.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:37:06Z",
          "body": "929cf0f",
          "path": "src/lib/rtl/rtl_time_estimator.h",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "KonradRudin",
          "created_at": "2024-10-21T11:52:05Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-22T08:22:46Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2024-10-22T08:27:43Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-23T12:27:29Z",
          "body": "Looks like a good improvement.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-23T12:29:57Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2024-10-23T14:00:17Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:32:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:32:42Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:32:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:33:02Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:36:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:37:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2024-10-24T09:39:10Z",
          "body": "I don't see anything obviously wrong anymore but to be honest I can also not verify the entire structure. The cyclomatic complexity with all these extra cases and states is too high for me to check every case that changes.",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes logic errors that produced incorrect RTL time estimates: an incorrect use of isActive() (from mission, not RTL) made a conditional always invalid and caused the wrong altitude/state to be used, and incorrect assumptions about when the LAND phase starts and sink-speed handling produced wrong timing calculations. The changes remove the invalid check and simplify the speed/altitude assumptions, addressing the unintended behavior.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 41,
        "changes": 71,
        "patch": "@@ -59,6 +59,7 @@ RTL::RTL(Navigator *navigator) :\n \tModuleParams(navigator),\n \t_rtl_direct(navigator)\n {\n+\t_rtl_direct.initialize();\n }\n \n void RTL::updateDatamanCache()\n@@ -157,24 +158,6 @@ void RTL::updateDatamanCache()\n \t_dataman_cache_landItem.update();\n }\n \n-void RTL::on_inactivation()\n-{\n-\tswitch (_rtl_type) {\n-\tcase RtlType::RTL_MISSION_FAST: // Fall through\n-\tcase RtlType::RTL_MISSION_FAST_REVERSE: // Fall through\n-\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n-\t\t_rtl_mission_type_handle->on_inactivation();\n-\t\tbreak;\n-\n-\tcase RtlType::RTL_DIRECT:\n-\t\t_rtl_direct.on_inactivation();\n-\t\tbreak;\n-\n-\tdefault:\n-\t\tbreak;\n-\t}\n-}\n-\n void RTL::on_inactive()\n {\n \t_global_pos_sub.update();\n@@ -187,21 +170,12 @@ void RTL::on_inactive()\n \n \tparameters_update();\n \n-\tswitch (_rtl_type) {\n-\tcase RtlType::RTL_MISSION_FAST:\n-\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n-\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n-\t\t_rtl_mission_type_handle->on_inactive();\n-\t\tbreak;\n-\n-\tcase RtlType::RTL_DIRECT:\n-\t\t_rtl_direct.on_inactive();\n-\t\tbreak;\n-\n-\tdefault:\n-\t\tbreak;\n+\tif (_rtl_mission_type_handle) {\n+\t\t_rtl_mission_type_handle->run(false);\n \t}\n \n+\t_rtl_direct.run(false);\n+\n \t// Limit inactive calculation to 0.5Hz\n \thrt_abstime now{hrt_absolute_time()};\n \n@@ -230,7 +204,10 @@ void RTL::publishRemainingTimeEstimate()\n \t\tcase RtlType::RTL_DIRECT_MISSION_LAND:\n \t\tcase RtlType::RTL_MISSION_FAST:\n \t\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n-\t\t\testimated_time = _rtl_mission_type_handle->calc_rtl_time_estimate();\n+\t\t\tif (_rtl_mission_type_handle) {\n+\t\t\t\testimated_time = _rtl_mission_type_handle->calc_rtl_time_estimate();\n+\t\t\t}\n+\n \t\t\tbreak;\n \n \t\tdefault:\n@@ -250,12 +227,10 @@ void RTL::on_activation()\n \tcase RtlType::RTL_MISSION_FAST: // Fall through\n \tcase RtlType::RTL_MISSION_FAST_REVERSE:\n \t\t_rtl_mission_type_handle->setReturnAltMin(_enforce_rtl_alt);\n-\t\t_rtl_mission_type_handle->on_activation();\n \t\tbreak;\n \n \tcase RtlType::RTL_DIRECT:\n \t\t_rtl_direct.setReturnAltMin(_enforce_rtl_alt);\n-\t\t_rtl_direct.on_activation();\n \t\tbreak;\n \n \tdefault:\n@@ -279,16 +254,23 @@ void RTL::on_active()\n \tupdateDatamanCache();\n \n \tswitch (_rtl_type) {\n-\tcase RtlType::RTL_MISSION_FAST:\n-\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n+\tcase RtlType::RTL_MISSION_FAST: // Fall through\n+\tcase RtlType::RTL_MISSION_FAST_REVERSE: // Fall through\n \tcase RtlType::RTL_DIRECT_MISSION_LAND:\n-\t\t_rtl_mission_type_handle->on_active();\n-\t\t_rtl_mission_type_handle->updateFailsafeChecks();\n+\t\tif (_rtl_mission_type_handle) {\n+\t\t\t_rtl_mission_type_handle->run(true);\n+\t\t}\n+\n+\t\t_rtl_direct.run(false);\n \t\tbreak;\n \n \tcase RtlType::RTL_DIRECT:\n-\t\t_rtl_direct.on_active();\n-\t\t_rtl_direct.updateFailsafeChecks();\n+\t\t_rtl_direct.run(true);\n+\n+\t\tif (_rtl_mission_type_handle) {\n+\t\t\t_rtl_mission_type_handle->run(false);\n+\t\t}\n+\n \t\tbreak;\n \n \tdefault:\n@@ -312,7 +294,10 @@ bool RTL::isLanding()\n \tcase RtlType::RTL_MISSION_FAST:\n \tcase RtlType::RTL_MISSION_FAST_REVERSE:\n \tcase RtlType::RTL_DIRECT_MISSION_LAND:\n-\t\tis_landing = _rtl_mission_type_handle->isLanding();\n+\t\tif (_rtl_mission_type_handle) {\n+\t\t\tis_landing = _rtl_mission_type_handle->isLanding();\n+\t\t}\n+\n \t\tbreak;\n \n \tcase RtlType::RTL_DIRECT:\n@@ -622,6 +607,10 @@ void RTL::init_rtl_mission_type()\n \tdefault:\n \t\tbreak;\n \t}\n+\n+\tif (_rtl_mission_type_handle) {\n+\t\t_rtl_mission_type_handle->initialize();\n+\t}\n }\n \n void RTL::parameters_update()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/70dbf02b23f98c7f199305dbc238b3c3e2a75e70/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -78,7 +78,6 @@ class RTL : public NavigatorMode, public ModuleParams\n \t\tRTL_MISSION_FAST_REVERSE,\n \t};\n \n-\tvoid on_inactivation() override;\n \tvoid on_inactive() override;\n \tvoid on_activation() override;\n \tvoid on_active() override;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/70dbf02b23f98c7f199305dbc238b3c3e2a75e70/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 6,
        "changes": 25,
        "patch": "@@ -73,7 +73,6 @@ void RtlDirect::on_inactivation()\n void RtlDirect::on_activation()\n {\n \t_global_pos_sub.update();\n-\t_land_detected_sub.update();\n \t_vehicle_status_sub.update();\n \n \tparameters_update();\n@@ -120,6 +119,12 @@ void RtlDirect::on_active()\n \t}\n }\n \n+void RtlDirect::on_inactive()\n+{\n+\t_global_pos_sub.update();\n+\t_vehicle_status_sub.update();\n+}\n+\n void RtlDirect::setRtlPosition(PositionYawSetpoint rtl_position, loiter_point_s loiter_pos)\n {\n \t_home_pos_sub.update();\n@@ -421,7 +426,7 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n {\n \t_global_pos_sub.update();\n \t_rtl_time_estimator.update();\n-\n+\t_rtl_time_estimator.setVehicleType(_vehicle_status_sub.get().vehicle_type);\n \t_rtl_time_estimator.reset();\n \n \tRTLState start_state_for_estimate;\n@@ -455,8 +460,13 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\t\t\tmatrix::Vector2f direction{};\n \t\t\t\tget_vector_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_approach.lat,\n \t\t\t\t\t\t\t    land_approach.lon, &direction(0), &direction(1));\n-\t\t\t\t_rtl_time_estimator.addDistance(get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon,\n-\t\t\t\t\t\t\t\tland_approach.lat, land_approach.lon), direction, 0.f);\n+\t\t\t\tfloat move_to_land_dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_approach.lat, land_approach.lon)};\n+\n+\t\t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\t\t\t\t\tmove_to_land_dist = max(0.f, move_to_land_dist - land_approach.loiter_radius_m);\n+\t\t\t\t}\n+\n+\t\t\t\t_rtl_time_estimator.addDistance(move_to_land_dist, direction, 0.f);\n \t\t\t}\n \n \t\t// FALLTHROUGH\n@@ -527,7 +537,11 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\t\t\t\tinitial_altitude = loiter_altitude;\n \t\t\t\t}\n \n-\t\t\t\t_rtl_time_estimator.addDescendMCLand(_destination.alt - initial_altitude);\n+\t\t\t\tif (_vehicle_status_sub.get().is_vtol) {\n+\t\t\t\t\t_rtl_time_estimator.setVehicleType(vehicle_status_s::VEHICLE_TYPE_ROTARY_WING);\n+\t\t\t\t}\n+\n+\t\t\t\t_rtl_time_estimator.addVertDistance(_destination.alt - initial_altitude);\n \t\t\t}\n \n \t\t\tbreak;\n@@ -560,7 +574,6 @@ loiter_point_s RtlDirect::sanitizeLandApproach(loiter_point_s land_approach) con\n \tif (!PX4_ISFINITE(land_approach.lat) || !PX4_ISFINITE(land_approach.lon)) {\n \t\tsanitized_land_approach.lat = _destination.lat;\n \t\tsanitized_land_approach.lon = _destination.lon;\n-\n \t}\n \n \tif (!PX4_ISFINITE(land_approach.height_m)) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/70dbf02b23f98c7f199305dbc238b3c3e2a75e70/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "patch": "@@ -91,6 +91,13 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t */\n \tvoid on_active() override;\n \n+\t/**\n+\t * @brief on inactive\n+\t * Poll required topics also when incative for rtl time estimate.\n+\t *\n+\t */\n+\tvoid on_inactive() override;\n+\n \t/**\n \t * @brief Calculate the estimated time needed to return to launch.\n \t *",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/70dbf02b23f98c7f199305dbc238b3c3e2a75e70/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 10,
        "changes": 34,
        "patch": "@@ -239,6 +239,7 @@ void RtlDirectMissionLand::setActiveMissionItems()\n rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n {\n \t_rtl_time_estimator.update();\n+\t_rtl_time_estimator.setVehicleType(_vehicle_status_sub.get().vehicle_type);\n \t_rtl_time_estimator.reset();\n \n \tif (_mission.count > 0 && hasMissionLandStart()) {\n@@ -247,7 +248,7 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \n \t\tif (isActive()) {\n \t\t\tstart_item_index = math::max(_mission.current_seq, _mission.land_start_index);\n-\t\t\tis_in_climbing_submode = _needs_climbing;\n+\t\t\tis_in_climbing_submode = _work_item_type == WorkItemType::WORK_ITEM_TYPE_CLIMB;\n \n \t\t} else {\n \t\t\tstart_item_index = _mission.land_start_index;\n@@ -305,7 +306,12 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n \n \t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat,\n+\t\t\t\t\t\t\t\t\t next_position_mission_item.lon);\n+\n+\t\t\t\t\t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\t\t\t\t\t\t\t\thor_dist = math::max(0.f, hor_dist - next_position_mission_item.loiter_radius);\n+\t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction, 0.f);\n \n@@ -321,7 +327,12 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n \n \t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat,\n+\t\t\t\t\t\t\t\t\t next_position_mission_item.lon);\n+\n+\t\t\t\t\t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\t\t\t\t\t\t\t\thor_dist = math::max(0.f, hor_dist - next_position_mission_item.loiter_radius);\n+\t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction, 0.f);\n \n@@ -339,23 +350,26 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n \t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n \n-\t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\t\t\t\t\t\t\tconst float hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n+\t\t\t\t\t\t\t\t\t       hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n \n \t\t\t\t\t\t\t// For fixed wing, add diagonal line\n \t\t\t\t\t\t\tif ((_vehicle_status_sub.get().vehicle_type != vehicle_status_s::VEHICLE_TYPE_FIXED_WING)\n \t\t\t\t\t\t\t    && (!_vehicle_status_sub.get().is_vtol)) {\n \n-\n \t\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction,\n \t\t\t\t\t\t\t\t\t\t\t\tget_absolute_altitude_for_item(next_position_mission_item) - altitude_at_calculation_point);\n \n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t// For VTOL, Rotary, go there horizontally first, then land\n \t\t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction, 0.f);\n \n-\t\t\t\t\t\t\t\t_rtl_time_estimator.addDescendMCLand(get_absolute_altitude_for_item(next_position_mission_item) -\n-\t\t\t\t\t\t\t\t\t\t\t\t     altitude_at_calculation_point);\n+\t\t\t\t\t\t\t\tif (_vehicle_status_sub.get().is_vtol) {\n+\t\t\t\t\t\t\t\t\t_rtl_time_estimator.setVehicleType(vehicle_status_s::VEHICLE_TYPE_ROTARY_WING);\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t_rtl_time_estimator.addVertDistance(get_absolute_altitude_for_item(next_position_mission_item) -\n+\t\t\t\t\t\t\t\t\t\t\t\t    altitude_at_calculation_point);\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tbreak;\n@@ -367,8 +381,8 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n \t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n \n-\t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\t\t\t\t\t\t\tconst float hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n+\t\t\t\t\t\t\t\t\t       hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n \n \t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction,\n \t\t\t\t\t\t\t\t\t\t\tget_absolute_altitude_for_item(next_position_mission_item) - altitude_at_calculation_point);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/70dbf02b23f98c7f199305dbc238b3c3e2a75e70/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirectMissionLand::calc_rtl_time_estimate",
        "RTL::publishRemainingTimeEstimate",
        "RtlDirect::on_inactivation",
        "RtlDirect::sanitizeLandApproach",
        "RTL::init_rtl_mission_type",
        "RtlDirect::calc_rtl_time_estimate",
        "RTL::on_inactive",
        "RTL::updateDatamanCache",
        "RTL::RTL",
        "on_inactivation",
        "RTL::on_inactivation",
        "RTL::on_activation",
        "RtlDirect::on_active",
        "RtlDirectMissionLand::setActiveMissionItems",
        "RTL::on_active",
        "RTL::isLanding"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::publishRemainingTimeEstimate",
          "RTL::init_rtl_mission_type",
          "RTL::on_inactive",
          "RTL::updateDatamanCache",
          "RTL::RTL",
          "RTL::on_inactivation",
          "RTL::on_activation",
          "RTL::on_active",
          "RTL::isLanding"
        ],
        "src/modules/navigator/rtl.h": [
          "on_inactivation"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::sanitizeLandApproach",
          "RtlDirect::on_active",
          "RtlDirect::calc_rtl_time_estimate",
          "RtlDirect::on_inactivation"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::calc_rtl_time_estimate",
          "RtlDirectMissionLand::setActiveMissionItems"
        ]
      }
    }
  },
  {
    "title": "Add fixed-wing takeoff mode without lateral navigation requirement",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23797",
    "number": 23797,
    "created_at": "2024-10-10T10:12:21Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nGNSS and magnetometer sensors are susceptible to disturbances on the ground. With bad heading and position estimation, the auto takeoff mode doesn't work reliably, which can lead to crashes or failsafe actions being executed. The current navigation loss failsafe for fixed-wings is Descend, which is dangerous to trigger while still being close to the ground. \r\n\r\n\r\n### Solution\r\nAdd a new flight mode `Takeoff without navigation`. It is currently only implemented for fixed-wing vehicles (even only for non-runway takeoff ones), and keeps most of the normal fixed-wing takeoff behavior with one big difference: instead of doing lateral guidance to fly to a takeoff waypoint or to keep course of ground constant, this new mode simply commands a 0Â° roll setpoint until the takeoff altitude is reached.\r\nAfter reaching the takeoff altitude the flight mode automatically switches to Hold (Loiter).\r\n\r\nThis mode is also used to fall-back to from the normal Takeoff mode should during the takeoff procedure the navigation become invalid. It then proceeds with climbing, and gives the pilot more time to take over.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: Add fixed-wing takeoff mode without lateral navigation requirement\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\nIn progress\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "ryanjAA",
          "created_at": "2024-10-12T02:09:55Z",
          "body": "Pretty cool :) ",
          "type": "issue_comment"
        },
        {
          "author": "Sayshara",
          "created_at": "2024-12-15T20:24:20Z",
          "body": "Any news about merging this one? Yesterday during takeoff lost GNSS data for 1 sec and the autopilot switched to descend mode and crashed to the ground. This kind of fallback would be a lifesaver.",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-15T11:24:00Z",
          "body": "Replaced by https://github.com/PX4/PX4-Autopilot/pull/25083",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects incorrect runtime behavior (improper failsafe/error handling and state transition) during fixedâ€‘wing takeoff when navigation is lost. Previously a navigation loss could trigger a 'Descend' failsafe near ground (unsafe); the new mode changes the control logic to maintain level roll and climb to safe altitude, which is a logical fix to unintended/destructive behavior.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -47,6 +47,7 @@ set(NAVIGATOR_SOURCES\n \trtl_mission_fast.cpp\n \trtl_mission_fast_reverse.cpp\n \ttakeoff.cpp\n+\ttakeoff_no_nav.cpp\n \tland.cpp\n \tprecland.cpp\n \tmission_feasibility_checker.cpp",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d63fd7c6271e43377efc3947dd7ca5e17ad7bd4f/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -49,6 +49,7 @@\n #include \"navigator_mode.h\"\n #include \"rtl.h\"\n #include \"takeoff.h\"\n+#include \"takeoff_no_nav.h\"\n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n #include \"vtol_takeoff.h\"\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n@@ -92,7 +93,7 @@ using namespace time_literals;\n /**\n  * Number of navigation modes that need on_active/on_inactive calls\n  */\n-#define NAVIGATOR_MODE_ARRAY_SIZE 8\n+#define NAVIGATOR_MODE_ARRAY_SIZE 9\n \n class Navigator : public ModuleBase<Navigator>, public ModuleParams\n {\n@@ -362,6 +363,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \tVtolTakeoff\t_vtol_takeoff;\t\t\t/**< class for handling VEHICLE_CMD_NAV_VTOL_TAKEOFF command */\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n+\tTakeoffNoNav\t_takeoff_no_nav;\t\t/**< class for handling takeoff commands without navigation */\n \tLand\t\t_land;\t\t\t/**< class for handling land commands */\n \tPrecLand\t_precland;\t\t\t/**< class for handling precision land commands */\n \tRTL \t\t_rtl;\t\t\t\t/**< class that handles RTL */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d63fd7c6271e43377efc3947dd7ca5e17ad7bd4f/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 4,
        "changes": 16,
        "patch": "@@ -79,6 +79,7 @@ Navigator::Navigator() :\n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \t_vtol_takeoff(this),\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n+\t_takeoff_no_nav(this),\n \t_land(this),\n \t_precland(this),\n \t_rtl(this)\n@@ -92,6 +93,8 @@ Navigator::Navigator() :\n \t_navigation_mode_array[5] = &_precland;\n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \t_navigation_mode_array[6] = &_vtol_takeoff;\n+\t_navigation_mode_array[7] = &_takeoff_no_nav;\n+\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \n \t/* iterate through navigation modes and initialize _mission_item for each */\n@@ -806,6 +809,11 @@ void Navigator::run()\n \t\t\tbreak;\n #endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n \n+\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF_NO_NAV:\n+\t\t\t_pos_sp_triplet_published_invalid_once = false;\n+\t\t\tnavigation_mode_new = &_takeoff_no_nav;\n+\t\t\tbreak;\n+\n \t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n \t\t\t_pos_sp_triplet_published_invalid_once = false;\n \t\t\tnavigation_mode_new = &_land;\n@@ -830,10 +838,10 @@ void Navigator::run()\n \t\t\tbreak;\n \t\t}\n \n-\t\t// Do not execute any state machine while we are disarmed\n-\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n-\t\t\tnavigation_mode_new = nullptr;\n-\t\t}\n+\t\t// // Do not execute any state machine while we are disarmed\n+\t\t// if (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n+\t\t// \tnavigation_mode_new = nullptr;\n+\t\t// }\n \n \t\t/* we have a new navigation mode: reset triplet */\n \t\tif (_navigation_mode != navigation_mode_new) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d63fd7c6271e43377efc3947dd7ca5e17ad7bd4f/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/takeoff_no_nav.cpp": {
        "filename": "src/modules/navigator/takeoff_no_nav.cpp",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "patch": "@@ -0,0 +1,110 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2024 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file takeoff_no_nav.cpp\n+ *\n+ * Helper class to do a takeoff without lateral navigation\n+ *\n+ */\n+\n+#include \"takeoff_no_nav.h\"\n+#include \"navigator.h\" //TODO remove?\n+\n+TakeoffNoNav::TakeoffNoNav(Navigator *navigator) :\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF_NO_NAV)\n+{\n+}\n+\n+void TakeoffNoNav::on_activation()\n+{\n+\t_navigator->reset_cruising_speed();\n+\t_navigator->set_cruising_throttle();\n+\tset_takeoff_position();\n+}\n+\n+void TakeoffNoNav::on_active()\n+{\n+\tif (_local_altitude_at_takeoff - _navigator->get_local_position()->z > _navigator->get_param_mis_takeoff_alt()) {\n+\t\t// Takeoff done - reset any potentially valid reposition triplet which was not handled.\n+\t\t// We do this to avoid random loiter locations after switching to loiter mode after this.\n+\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n+\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n+\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n+\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n+\n+\t\t_navigator->get_mission_result()->finished = true;\n+\t\t_navigator->set_mission_result_updated();\n+\t\t_navigator->mode_completed(getNavigatorStateId());\n+\t}\n+}\n+\n+void TakeoffNoNav::set_takeoff_position()\n+{\n+\t// for now only support takeoff to MIS_TAKEOFF_ALT //TODO add mavlink interface\n+\n+\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t_local_altitude_at_takeoff = _navigator->get_local_position()->z;\n+\n+\tconst float takeoff_altitude_amsl = _navigator->get_global_position()->alt + _navigator->get_param_mis_takeoff_alt();\n+\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n+\t\t\t \"Using default takeoff altitude: %.1f m\\t\", (double)_navigator->get_param_mis_takeoff_alt());\n+\n+\tevents::send<float>(events::ID(\"navigator_takeoff_no_nav_default_alt\"), {events::Log::Info, events::LogInternal::Info},\n+\t\t\t    \"Using default takeoff altitude: {1:.2m}\",\n+\t\t\t    _navigator->get_param_mis_takeoff_alt());\n+\n+\t_navigator->get_mission_result()->finished = false;\n+\t_navigator->set_mission_result_updated();\n+\n+\tpos_sp_triplet->current.lat = NAN;\n+\tpos_sp_triplet->current.lon = NAN;\n+\tpos_sp_triplet->current.alt =\n+\t\ttakeoff_altitude_amsl; // need to think about how to interface with the controller without global position\n+\tpos_sp_triplet->current.yaw = NAN;\n+\tpos_sp_triplet->current.loiter_radius = NAN;\n+\tpos_sp_triplet->current.loiter_direction_counter_clockwise = NAN;\n+\tpos_sp_triplet->current.acceptance_radius = NAN;\n+\tpos_sp_triplet->current.alt_acceptance_radius = NAN;\n+\tpos_sp_triplet->current.cruising_speed = NAN;\n+\tpos_sp_triplet->current.cruising_throttle = NAN;\n+\tpos_sp_triplet->current.gliding_enabled = false;\n+\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n+\tpos_sp_triplet->current.valid = true;\n+\tpos_sp_triplet->current.timestamp = hrt_absolute_time();\n+\n+\tpos_sp_triplet->previous.valid = false;\n+\tpos_sp_triplet->next.valid = false;\n+\n+\t_navigator->set_position_setpoint_triplet_updated();\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d63fd7c6271e43377efc3947dd7ca5e17ad7bd4f/src%2Fmodules%2Fnavigator%2Ftakeoff_no_nav.cpp"
      },
      "src/modules/navigator/takeoff_no_nav.h": {
        "filename": "src/modules/navigator/takeoff_no_nav.h",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "patch": "@@ -0,0 +1,61 @@\n+/***************************************************************************\n+ *\n+ *   Copyright (c) 2024 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+/**\n+ * @file takeoff_no_nav.h\n+ *\n+ * Helper class to do a takeoff without lateral navigation\n+ *\n+ */\n+\n+#pragma once\n+\n+#include \"navigator_mode.h\"\n+#include \"mission_block.h\"\n+\n+#include <lib/mathlib/mathlib.h>\n+\n+#include <px4_platform_common/module_params.h>\n+class TakeoffNoNav : public MissionBlock\n+{\n+public:\n+\tTakeoffNoNav(Navigator *navigator);\n+\t~TakeoffNoNav() = default;\n+\n+\tvoid on_activation() override;\n+\tvoid on_active() override;\n+\n+private:\n+\n+\tvoid set_takeoff_position();\n+\tfloat _local_altitude_at_takeoff{0.f};\n+};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d63fd7c6271e43377efc3947dd7ca5e17ad7bd4f/src%2Fmodules%2Fnavigator%2Ftakeoff_no_nav.h"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run",
        "Navigator::Navigator"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run",
          "Navigator::Navigator"
        ]
      }
    }
  },
  {
    "title": "geo: remove dependency on drv_hrt time driver",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/23775",
    "number": 23775,
    "created_at": "2024-10-04T12:49:35Z",
    "merged": true,
    "merged_at": "2024-10-07T12:24:18Z",
    "state": "closed",
    "conversation": {
      "author": "MaEtUgR",
      "body": "### Solved Problem\r\n@bresch asked me how to write a unit test for the geo library when it depends on the timing driver drv_hrt.\r\n\r\n### Solution\r\nMy answer to this is to simply remove the dependency. It's a minor convenience thing for clients such that they don't need to provide their timestamp.\r\n\r\n### Changelog Entry\r\n```\r\nChore: free geo library from drv_hrt dependency to enable unit testing\r\n```\r\n\r\n### Test coverage\r\nRefactoring that builds SITL, let's see if there's any NuttX target driver that uses geo ðŸ‘€ ",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2024-10-04T16:41:07Z",
          "body": "The time isn't actually used for anything internally, you could keep it as an optional parameter `uint64_t timestamp = 0`. ",
          "type": "issue_comment"
        },
        {
          "author": "bresch",
          "created_at": "2024-10-07T09:50:17Z",
          "body": "- Made the timestamp an optional parameter\r\n- Remove its use in local position estimator as already handled separately\r\n- Remove its use where ref is only used locally and timestamp is not important",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "2024-10-07T09:47:57Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR removes an unused dependency and makes the timestamp an optional parameter to enable unit testing; comments state the time value wasn't used internally. It is a refactor/cleanup for testability, not a fix for incorrect program logic or behavior.",
    "patches": {
      "src/modules/navigator/geofence.cpp": {
        "filename": "src/modules/navigator/geofence.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -511,7 +511,7 @@ bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon,\n \t}\n \n \tif (!_projection_reference.isInitialized()) {\n-\t\t_projection_reference.initReference(lat, lon);\n+\t\t_projection_reference.initReference(lat, lon, hrt_absolute_time());\n \t}\n \n \tfloat x1, y1, x2, y2;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/12a0667957bb12e6db040f0b64af5ce3c8b5b145/src%2Fmodules%2Fnavigator%2Fgeofence.cpp"
      },
      "src/modules/navigator/precland.cpp": {
        "filename": "src/modules/navigator/precland.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -81,7 +81,7 @@ PrecLand::on_activation()\n \tvehicle_local_position_s *vehicle_local_position = _navigator->get_local_position();\n \n \tif (!_map_ref.isInitialized()) {\n-\t\t_map_ref.initReference(vehicle_local_position->ref_lat, vehicle_local_position->ref_lon);\n+\t\t_map_ref.initReference(vehicle_local_position->ref_lat, vehicle_local_position->ref_lon, hrt_absolute_time());\n \t}\n \n \tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/12a0667957bb12e6db040f0b64af5ce3c8b5b145/src%2Fmodules%2Fnavigator%2Fprecland.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Geofence::insideCircle",
        "PrecLand::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/geofence.cpp": [
          "Geofence::insideCircle"
        ],
        "src/modules/navigator/precland.cpp": [
          "PrecLand::on_activation"
        ]
      }
    }
  },
  {
    "title": "Compress MissionItems",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24377",
    "number": 24377,
    "created_at": "2025-02-20T16:54:00Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "alexcekay",
      "body": "### Solved Problem\r\nAs MissionItems can be stored in RAM now, we face storage problems with larger missions.\r\n\r\n\r\n### Solution\r\nThe struct `mission_item_s` is optimized for speed in the sense that it stores information redundant, i.e. the values received from MAVLINK as `int/float` and the \"working copy\" as `double`. The following optimizations are possible:\r\n1. Simple optimizations, by moving `do_jump_mission_index`, `do_jump_repeat_count`, `do_jump_current_count`, `vertex_count` and `land_precision` into the main union. This is possible as they are set to `param1/param2` so a storage outside of the union is not needed\r\n2. Not storing the \"working copy\" `lat` and `lon` in `mission_item_s` anymore. This is a space-time tradeoff as it causes an additional condition + double multiplication at every access\r\n\r\nWith both optimizations it is possible to save **24 byte** per MissionItem.\r\n\r\n### Open points\r\n- [ ] Do functional testing\r\n- [ ] Measure performance impact\r\n- [ ] Backwards compatibility\r\n\r\n### Alternatives\r\nOne possible alternative is two have different MissionItems for storage and working. Then the one for working could still contain doubles, while the storage one would only contain the `int32` representation. This however would need bigger changes as the MissionItems are currently used throughout the code in many different scenarios.\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-02-20T17:00:01Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 1568 byte (0.08 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.1% +1.53Ki  +0.1% +1.53Ki    .text\n     +11%    +536   +11%    +536    ../../src/modules/navigator/mission_block.cpp\n    +9.8%    +180  +9.8%    +180    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n     +20%    +172   +20%    +172    ../../src/modules/navigator/vtol_takeoff.cpp\n    +7.4%    +140  +7.4%    +140    ../../src/modules/navigator/mission.cpp\n     +36%    +132   +36%    +132    ../../src/modules/navigator/land.cpp\n    +2.6%    +112  +2.6%    +112    ../../src/modules/navigator/rtl.cpp\n    +2.8%    +104  +2.8%    +104    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.9%     +68  +0.9%     +68    ../../src/modules/navigator/mission_base.cpp\n    +5.0%     +64  +5.0%     +64    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +7.1%     +48  +7.1%     +48    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +1.4%     +48  +1.4%     +48    ../../src/modules/navigator/rtl_direct.cpp\n    -0.2%      -4  -0.2%      -4    ../../src/modules/simulation/sensor_gps_sim/SensorGpsSim.cpp\n    -0.3%      -8  -0.3%      -8    ../../src/lib/dataman_client/DatamanClient.cpp\n    -0.0%      -8  -0.0%      -8    src/modules/mavlink/modules__mavlink_unity.cpp\n    -1.9%     -16  -1.9%     -16    ../../src/modules/navigator/rtl_mission_fast.cpp\n  +0.0%    +499  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    +8.4%    +159  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +0.4%     +12  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +2.3%     +68  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +2.2%     +74  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.7%     +24  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.8%     +24  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +3.5%     +98  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    -0.2%     -16  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.0%     +72  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +6.7%     +16  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +2.7%     +16  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +5.4%     +16  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +4.4%     +16  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +5.7%     +16  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n  +0.1%    +260  [ = ]       0    .debug_frame\n  +0.0% +9.23Ki  [ = ]       0    .debug_info\n    -0.4%     -89  [ = ]       0    ../../src/lib/dataman_client/DatamanClient.cpp\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +1.3%    +685  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.0%     +15  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +2.8%    +972  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +0.9%    +635  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.6%    +597  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +3.4% +1.86Ki  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.7%    +277  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.0%      +2  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.0%      -5  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +0.7%    +633  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +1.0%    +777  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +1.1%    +927  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.2%    +161  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.6%    +426  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +1.9% +1.08Ki  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.1%    +432  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.1% +3.40Ki  [ = ]       0    .debug_line\n    +0.4%     +17  [ = ]       0    ../../src/lib/dataman_client/DatamanClient.cpp\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +1.5%    +114  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +6.3%    +206  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +7.0%    +400  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.8%    +124  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n     +11% +1.11Ki  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +3.2%    +122  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.1%     +29  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.4%    +154  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.9%     +78  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +4.3%    +284  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +3.6%    +198  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +7.3%    +343  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.2%    +304  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n    -0.5%      -6  [ = ]       0    task/task_cancelpt.c\n  +0.1% +2.84Ki  [ = ]       0    .debug_loc\n    +1.4%     +57  [ = ]       0    ../../src/lib/dataman_client/DatamanClient.cpp\n    -0.0%      -3  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n     +20%    +114  [ = ]       0    ../../src/modules/navigator/land.cpp\n     +10%    +369  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.6%     -82  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n     +18% +1.38Ki  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%      +1  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.3%     +66  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.4%     -56  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.7%     +68  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +4.6%    +290  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +4.7%    +184  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n     +13%    +320  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.0%      +2  [ = ]       0    [section .debug_loc]\n    +0.1%    +173  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.2% +2.02Ki  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +1.4%     +24  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n     +76%    +152  [ = ]       0    ../../src/modules/navigator/land.cpp\n     +55%    +336  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.7%     +24  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n     +28%    +576  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n     +50%    +128  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.4%     +32  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +2.3%     +48  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n     +11%    +112  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n     +24%    +184  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n     +37%    +288  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.4%    +176  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n    +1.5%      +1  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +184  [ = ]       0    .debug_str\n    +0.1%    +184  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.0%     +36  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    -0.8%      -2  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -0.4%      -2  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +2.2%     +59  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.2%      -6  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.2%      -2  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    -0.1%      -1  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -0.3%      -2  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -0.5%      -2  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    -0.4%      -3  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.8%      -3  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n  +0.0%    +192  [ = ]       0    .symtab\n    +1.9%     +16  [ = ]       0    ../../src/drivers/distance_sensor/tf02pro/TF02PRO.cpp\n    -0.1%     -16  [ = ]       0    ../../src/drivers/uavcan/uavcan_main.cpp\n    +9.1%     +16  [ = ]       0    ../../src/lib/drivers/magnetometer/PX4Magnetometer.cpp\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    -4.2%     -16  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    +2.9%     +16  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +3.9%     +96  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +5.6%     +80  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.5%     -16  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.5%     +16  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +1.8%     +16  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -3.8%     -16  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +3.6%     +16  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n    -0.0%     -16  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  -8.2% -1.53Ki  [ = ]       0    [Unmapped]\n  +0.0% +18.7Ki  +0.1% +1.53Ki    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 1576 byte (0.08 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.1% +1.54Ki  +0.1% +1.54Ki    .text\n     +11%    +536   +11%    +536    ../../src/modules/navigator/mission_block.cpp\n    +9.8%    +180  +9.8%    +180    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n     +20%    +172   +20%    +172    ../../src/modules/navigator/vtol_takeoff.cpp\n    +7.4%    +140  +7.4%    +140    ../../src/modules/navigator/mission.cpp\n     +36%    +132   +36%    +132    ../../src/modules/navigator/land.cpp\n    +2.6%    +112  +2.6%    +112    ../../src/modules/navigator/rtl.cpp\n    +2.8%    +104  +2.8%    +104    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.9%     +68  +0.9%     +68    ../../src/modules/navigator/mission_base.cpp\n    +5.0%     +64  +5.0%     +64    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +7.1%     +48  +7.1%     +48    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +1.4%     +48  +1.4%     +48    ../../src/modules/navigator/rtl_direct.cpp\n    +0.1%      +4  +0.1%      +4    ../../src/modules/temperature_compensation/TemperatureCompensationModule.cpp\n    -0.3%      -8  -0.3%      -8    ../../src/lib/dataman_client/DatamanClient.cpp\n    -0.0%      -8  -0.0%      -8    src/modules/mavlink/modules__mavlink_unity.cpp\n    -1.9%     -16  -1.9%     -16    ../../src/modules/navigator/rtl_mission_fast.cpp\n  +0.0%    +499  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    +8.4%    +159  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +0.4%     +12  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +2.3%     +68  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +2.2%     +74  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.7%     +24  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.8%     +24  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +3.5%     +98  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    -0.2%     -16  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.0%     +72  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +6.7%     +16  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +2.7%     +16  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +5.4%     +16  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +4.4%     +16  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +5.7%     +16  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n  +0.1%    +260  [ = ]       0    .debug_frame\n  +0.0% +9.23Ki  [ = ]       0    .debug_info\n    -0.4%     -89  [ = ]       0    ../../src/lib/dataman_client/DatamanClient.cpp\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +1.3%    +685  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.0%     +15  [ = ]       0    ../../src/modules/navigator/geofence.cpp\n    +2.8%    +972  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +1.0%    +635  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.6%    +597  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +3.5% +1.86Ki  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.7%    +277  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.0%      +2  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.0%      -5  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    +0.7%    +633  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +1.0%    +777  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +1.1%    +927  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +0.2%    +161  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +0.6%    +426  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +2.0% +1.08Ki  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.1%    +432  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.1% +3.41Ki  [ = ]       0    .debug_line\n    +0.4%     +17  [ = ]       0    ../../src/lib/dataman_client/DatamanClient.cpp\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +1.5%    +114  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +6.3%    +206  [ = ]       0    ../../src/modules/navigator/land.cpp\n    +7.0%    +400  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.8%    +124  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n     +11% +1.11Ki  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +3.2%    +122  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.1%     +29  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.4%    +154  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.9%     +78  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +4.3%    +284  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    +3.6%    +198  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +7.3%    +343  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.2%    +304  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n    +0.2%      +2  [ = ]       0    task/task_cancelpt.c\n  +0.1% +2.80Ki  [ = ]       0    .debug_loc\n    +1.4%     +57  [ = ]       0    ../../src/lib/dataman_client/DatamanClient.cpp\n    -0.0%      -3  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n     +20%    +114  [ = ]       0    ../../src/modules/navigator/land.cpp\n     +10%    +369  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    -0.6%     -82  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n     +18% +1.38Ki  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%      +1  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%     +51  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.4%     -56  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    +0.7%     +68  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +4.9%    +305  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -0.5%     -15  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +4.7%    +184  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n     +13%    +320  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.0%      +2  [ = ]       0    [section .debug_loc]\n    +0.1%    +143  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.2% +2.02Ki  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +1.4%     +24  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n     +76%    +152  [ = ]       0    ../../src/modules/navigator/land.cpp\n     +55%    +336  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +0.7%     +24  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n     +28%    +576  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n     +50%    +128  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.4%     +32  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +2.3%     +48  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n     +11%    +112  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n     +24%    +184  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n     +37%    +288  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.4%    +176  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n    -3.0%      -2  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +184  [ = ]       0    .debug_str\n    +0.1%    +184  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  +0.0%     +36  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    -0.8%      -2  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    -0.4%      -2  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +2.2%     +59  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.2%      -6  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.2%      -2  [ = ]       0    ../../src/modules/navigator/precland.cpp\n    -0.1%      -1  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -0.3%      -2  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -0.5%      -2  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    -0.4%      -3  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.8%      -3  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n  +0.0%    +192  [ = ]       0    .symtab\n    +1.9%     +16  [ = ]       0    ../../src/drivers/distance_sensor/tf02pro/TF02PRO.cpp\n    +8.3%     +16  [ = ]       0    ../../src/lib/drivers/magnetometer/PX4Magnetometer.cpp\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    -4.2%     -16  [ = ]       0    ../../src/modules/navigator/loiter.cpp\n    +2.9%     +16  [ = ]       0    ../../src/modules/navigator/mission.cpp\n    +3.9%     +96  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +5.6%     +80  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.5%     -16  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +1.8%     +16  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -4.0%     -16  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast.cpp\n    +3.6%     +16  [ = ]       0    ../../src/modules/navigator/vtol_takeoff.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n    -0.0%     -16  [ = ]       0    src/modules/mavlink/modules__mavlink_unity.cpp\n  -2.0% -1.54Ki  [ = ]       0    [Unmapped]\n  +0.0% +18.7Ki  +0.1% +1.54Ki    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-02-20T17:44:13_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR is a memory/layout optimization that reduces redundant storage in mission_item_s to save RAM. It focuses on space/time tradeoffs and struct packing (removing duplicate 'working copy' fields) rather than correcting incorrect behavior, state transitions, or algorithmic output, so it does not appear to address a logic bug.",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "patch": "@@ -402,8 +402,8 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\t\t// assume this is a fixed-wing landing pattern with orbit to alt followed\n \t\t\t\t// by tangent exit to landing approach and touchdown at landing waypoint\n \n-\t\t\t\tconst float distance_orbit_center_to_land = get_distance_to_next_waypoint(_mission_item_previous.lat,\n-\t\t\t\t\t\t_mission_item_previous.lon, mission_item.lat, mission_item.lon);\n+\t\t\t\tconst float distance_orbit_center_to_land = get_distance_to_next_waypoint(_mission_item_previous.getLat(),\n+\t\t\t\t\t\t_mission_item_previous.getLon(), mission_item.getLat(), mission_item.getLon());\n \t\t\t\tconst float orbit_radius = fabsf(_mission_item_previous.loiter_radius);\n \n \t\t\t\tif (distance_orbit_center_to_land <= orbit_radius) {\n@@ -420,8 +420,9 @@ bool FeasibilityChecker::checkFixedWindLandApproach(mission_item_s &mission_item\n \t\t\t} else if (_mission_item_previous.nav_cmd == NAV_CMD_WAYPOINT) {\n \t\t\t\t// approaching directly from waypoint position\n \n-\t\t\t\tconst float waypoint_distance = get_distance_to_next_waypoint(_mission_item_previous.lat, _mission_item_previous.lon,\n-\t\t\t\t\t\t\t\tmission_item.lat, mission_item.lon);\n+\t\t\t\tconst float waypoint_distance = get_distance_to_next_waypoint(_mission_item_previous.getLat(),\n+\t\t\t\t\t\t\t\t_mission_item_previous.getLon(),\n+\t\t\t\t\t\t\t\tmission_item.getLat(), mission_item.getLon());\n \t\t\t\tlanding_approach_distance = waypoint_distance;\n \n \t\t\t} else {\n@@ -627,7 +628,7 @@ bool FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint(mission_item_s &\n \t\t_first_waypoint_found = true;\n \n \t\tconst float dist_to_1wp_from_home_pos = get_distance_to_next_waypoint(\n-\t\t\t\tmission_item.lat, mission_item.lon,\n+\t\t\t\tmission_item.getLat(), mission_item.getLon(),\n \t\t\t\t_home_lat_lon(0), _home_lat_lon(1));\n \n \t\tif (dist_to_1wp_from_home_pos < _param_mis_dist_1wp) {\n@@ -666,7 +667,7 @@ bool FeasibilityChecker::checkDistancesBetweenWaypoints(const mission_item_s &mi\n \tif (PX4_ISFINITE(_last_lat) && PX4_ISFINITE(_last_lon)) {\n \t\t/* check distance from current position to item */\n \t\tconst float dist_between_waypoints = get_distance_to_next_waypoint(\n-\t\t\t\tmission_item.lat, mission_item.lon,\n+\t\t\t\tmission_item.getLat(), mission_item.getLon(),\n \t\t\t\t_last_lat, _last_lon);\n \n \n@@ -687,8 +688,8 @@ bool FeasibilityChecker::checkDistancesBetweenWaypoints(const mission_item_s &mi\n \t\t}\n \t}\n \n-\t_last_lat = mission_item.lat;\n-\t_last_lon = mission_item.lon;\n+\t_last_lat = mission_item.getLat();\n+\t_last_lon = mission_item.getLon();\n \t_last_cmd = mission_item.nav_cmd;\n \n \t/* We ran through all waypoints and have not found any distances between waypoints that are too far. */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityCheckerTest.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityCheckerTest.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "patch": "@@ -167,8 +167,8 @@ TEST_F(FeasibilityCheckerTest, check_dist_first_waypoint)\n \tchecker.publishLanded(true);\n \tchecker.publishCurrentPosition(0, 0);\n \twaypoint_from_heading_and_distance(0, 0, 0, 501, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \n \t// THEN: pass\n \tchecker.processNextItem(mission_item, 0, 1);\n@@ -179,8 +179,8 @@ TEST_F(FeasibilityCheckerTest, check_dist_first_waypoint)\n \tchecker.publishLanded(true);\n \tchecker.publishCurrentPosition(0, 0);\n \twaypoint_from_heading_and_distance(0, 0, 0, 499, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \n \t// THEN: pass\n \tchecker.processNextItem(mission_item, 0, 1);\n@@ -289,9 +289,9 @@ TEST_F(FeasibilityCheckerTest, fixed_wing_land_approach)\n \tchecker.processNextItem(mission_item, 0, 2);\n \n \tdouble lat_new, lon_new;\n-\twaypoint_from_heading_and_distance(mission_item.lat, mission_item.lon, 0, 99, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\twaypoint_from_heading_and_distance(mission_item.getLat(), mission_item.getLon(), 0, 99, &lat_new, &lon_new);\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \tmission_item.nav_cmd = NAV_CMD_LAND;\n \tmission_item.altitude = 40;\n \n@@ -310,9 +310,9 @@ TEST_F(FeasibilityCheckerTest, fixed_wing_land_approach)\n \n \tchecker.processNextItem(mission_item, 0, 2);\n \n-\twaypoint_from_heading_and_distance(mission_item.lat, mission_item.lon, 0, 99, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\twaypoint_from_heading_and_distance(mission_item.getLat(), mission_item.getLon(), 0, 99, &lat_new, &lon_new);\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \tmission_item.nav_cmd = NAV_CMD_LAND;\n \tmission_item.altitude = 40;\n \n@@ -331,9 +331,9 @@ TEST_F(FeasibilityCheckerTest, fixed_wing_land_approach)\n \n \tchecker.processNextItem(mission_item, 0, 2);\n \n-\twaypoint_from_heading_and_distance(mission_item.lat, mission_item.lon, 0, 1, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\twaypoint_from_heading_and_distance(mission_item.getLat(), mission_item.getLon(), 0, 1, &lat_new, &lon_new);\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \tmission_item.nav_cmd = NAV_CMD_LAND;\n \tmission_item.altitude = 40;\n \n@@ -352,9 +352,9 @@ TEST_F(FeasibilityCheckerTest, fixed_wing_land_approach)\n \n \tchecker.processNextItem(mission_item, 0, 2);\n \n-\twaypoint_from_heading_and_distance(mission_item.lat, mission_item.lon, 0, 1, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\twaypoint_from_heading_and_distance(mission_item.getLat(), mission_item.getLon(), 0, 1, &lat_new, &lon_new);\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \tmission_item.nav_cmd = NAV_CMD_LAND;\n \tmission_item.altitude = 40;\n \n@@ -409,9 +409,9 @@ TEST_F(FeasibilityCheckerTest, fixed_wing_landing)\n \tmission_item.nav_cmd = NAV_CMD_LAND;\n \tmission_item.altitude = 0;\n \tdouble lat_new, lon_new;\n-\twaypoint_from_heading_and_distance(mission_item.lat, mission_item.lon, 0, 200, &lat_new, &lon_new);\n-\tmission_item.lat = lat_new;\n-\tmission_item.lon = lon_new;\n+\twaypoint_from_heading_and_distance(mission_item.getLat(), mission_item.getLon(), 0, 200, &lat_new, &lon_new);\n+\tmission_item.setLatEncoded(lat_new);\n+\tmission_item.setLonEncoded(lon_new);\n \tchecker.processNextItem(mission_item, 1, 3);\n \n \tmission_item.nav_cmd = NAV_CMD_DO_LAND_START;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityCheckerTest.cpp"
      },
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "patch": "@@ -60,7 +60,11 @@ Land::on_activation()\n \n \tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n \t    && _navigator->get_local_position()->xy_global) { // only execute if global position is valid\n-\t\t_navigator->preproject_stop_point(_mission_item.lat, _mission_item.lon);\n+\t\tdouble lat = _mission_item.getLat();\n+\t\tdouble lon = _mission_item.getLon();\n+\t\t_navigator->preproject_stop_point(lat, lon);\n+\t\t_mission_item.setLatEncoded(lat);\n+\t\t_mission_item.setLonEncoded(lon);\n \t}\n \n \tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -140,7 +140,7 @@ Mission::do_need_move_to_takeoff()\n \tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n \t    && _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF) {\n \n-\t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.getLat(), _mission_item.getLon(),\n \t\t\t\t  _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n \n \t\treturn d_current > _navigator->get_acceptance_radius();\n@@ -317,8 +317,8 @@ void Mission::handleTakeoff(WorkItemType &new_work_item_type, mission_item_s nex\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n \t\t}\n \n-\t\t_mission_item.lat = _global_pos_sub.get().lat;\n-\t\t_mission_item.lon = _global_pos_sub.get().lon;\n+\t\t_mission_item.setLatEncoded(_global_pos_sub.get().lat);\n+\t\t_mission_item.setLonEncoded(_global_pos_sub.get().lon);\n \t\t_mission_item.yaw = NAN; // FlightTaskAuto handles yaw directly\n \t\t_mission_item.altitude = _mission_init_climb_altitude_amsl;\n \t\t_mission_item.altitude_is_relative = false;\n@@ -365,15 +365,15 @@ void Mission::handleTakeoff(WorkItemType &new_work_item_type, mission_item_s nex\n \t\t/* set yaw setpoint to heading of VTOL_TAKEOFF wp against current position */\n \t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n \t\t\t\t\t    _global_pos_sub.get().lat, _global_pos_sub.get().lon,\n-\t\t\t\t\t    _mission_item.lat, _mission_item.lon);\n+\t\t\t\t\t    _mission_item.getLat(), _mission_item.getLon());\n \n \t\t_mission_item.force_heading = true;\n \n \t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING;\n \n \t\t/* set position setpoint to current while aligning */\n-\t\t_mission_item.lat = _global_pos_sub.get().lat;\n-\t\t_mission_item.lon = _global_pos_sub.get().lon;\n+\t\t_mission_item.setLatEncoded(_global_pos_sub.get().lat);\n+\t\t_mission_item.setLonEncoded(_global_pos_sub.get().lon);\n \t}\n \n \t/* heading is aligned now, prepare transition */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "patch": "@@ -280,8 +280,8 @@ MissionBase::on_active()\n \t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_position_mission_item), sizeof(next_position_mission_item), MAX_DATAMAN_LOAD_WAIT);\n \n \t\t\tif (success) {\n-\t\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n-\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon));\n+\t\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.getLat(), _mission_item.getLon(),\n+\t\t\t\t\t\t\t\t    next_position_mission_item.getLat(), next_position_mission_item.getLon()));\n \t\t\t\t_mission_item.force_heading = true; // note: doesn't have effect in fixed-wing mode\n \t\t\t}\n \t\t}\n@@ -384,7 +384,7 @@ MissionBase::isLanding()\n \t\t// distance to the WP is below the loiter radius + acceptance.\n \t\tif ((num_found_items > 0U) && _mission.current_seq == next_mission_items_index[0U]\n \t\t    && _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n-\t\t\tconst float d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\t\t\tconst float d_current = get_distance_to_next_waypoint(_mission_item.getLat(), _mission_item.getLon(),\n \t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n \n \t\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n@@ -581,7 +581,7 @@ MissionBase::set_mission_result()\n \n bool MissionBase::do_need_move_to_item()\n {\n-\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n+\tfloat d_current = get_distance_to_next_waypoint(_mission_item.getLat(), _mission_item.getLon(),\n \t\t\t  _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n \n \treturn d_current > _navigator->get_acceptance_radius();\n@@ -905,8 +905,8 @@ MissionBase::do_abort_landing()\n \tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n \tvcmd.param1 = -1;\n \tvcmd.param2 = 1;\n-\tvcmd.param5 = _mission_item.lat;\n-\tvcmd.param6 = _mission_item.lon;\n+\tvcmd.param5 = _mission_item.getLat();\n+\tvcmd.param6 = _mission_item.getLon();\n \tvcmd.param7 = alt_sp;\n \n \t_navigator->publish_vehicle_cmd(&vcmd);\n@@ -918,8 +918,8 @@ void MissionBase::publish_navigator_mission_item()\n \n \tnavigator_mission_item.sequence_current = _mission.current_seq;\n \tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n-\tnavigator_mission_item.latitude = _mission_item.lat;\n-\tnavigator_mission_item.longitude = _mission_item.lon;\n+\tnavigator_mission_item.latitude = _mission_item.getLat();\n+\tnavigator_mission_item.longitude = _mission_item.getLon();\n \tnavigator_mission_item.altitude = _mission_item.altitude;\n \n \tnavigator_mission_item.time_inside = get_time_inside(_mission_item);\n@@ -1183,7 +1183,7 @@ int MissionBase::setMissionToClosestItem(double lat, double lon, float alt, floa\n \t\t\tif (!((mission.nav_cmd == NAV_CMD_LAND) &&\n \t\t\t      (vehicle_status.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) &&\n \t\t\t      (!vehicle_status.is_vtol))) {\n-\t\t\t\tfloat dist = get_distance_to_point_global_wgs84(mission.lat, mission.lon,\n+\t\t\t\tfloat dist = get_distance_to_point_global_wgs84(mission.getLat(), mission.getLon(),\n \t\t\t\t\t\tMissionBlock::get_absolute_altitude_for_item(mission, home_alt),\n \t\t\t\t\t\tlat,\n \t\t\t\t\t\tlon,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 35,
        "changes": 76,
        "patch": "@@ -169,7 +169,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n \t\t\t\t_navigator->get_loiter_radius();\n \n-\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n+\t\tdist = get_distance_to_point_global_wgs84(_mission_item.getLat(), _mission_item.getLon(), mission_item_altitude_amsl,\n \t\t\t\t_navigator->get_global_position()->lat,\n \t\t\t\t_navigator->get_global_position()->lon,\n \t\t\t\t_navigator->get_global_position()->alt,\n@@ -247,7 +247,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\tdist_xy = -1.0f;\n \t\t\t\tdist_z = -1.0f;\n \n-\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n+\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.getLat(), _mission_item.getLon(), curr_sp->alt,\n \t\t\t\t\t\t_navigator->get_global_position()->lat,\n \t\t\t\t\t\t_navigator->get_global_position()->lon,\n \t\t\t\t\t\t_navigator->get_global_position()->alt,\n@@ -280,7 +280,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\tif (curr_sp->valid) {\n \n \t\t\t\t// location of gate (mission item)\n-\t\t\t\tMapProjection ref_pos{_mission_item.lat, _mission_item.lon};\n+\t\t\t\tMapProjection ref_pos{_mission_item.getLat(), _mission_item.getLon()};\n \n \t\t\t\t// current setpoint\n \t\t\t\tmatrix::Vector2f gate_to_curr_sp = ref_pos.project(curr_sp->lat, curr_sp->lon);\n@@ -541,8 +541,8 @@ MissionBlock::issue_command(const mission_item_s &item)\n \n \tif (item.nav_cmd == NAV_CMD_DO_SET_ROI_LOCATION) {\n \t\t// We need to send out the ROI location that was parsed potentially with double precision to lat/lon because mission item parameters 5 and 6 only have float precision\n-\t\tvcmd.param5 = item.lat;\n-\t\tvcmd.param6 = item.lon;\n+\t\tvcmd.param5 = item.getLat();\n+\t\tvcmd.param6 = item.getLon();\n \n \t\tif (item.altitude_is_relative) {\n \t\t\tvcmd.param7 = item.altitude + _navigator->get_home_position()->alt;\n@@ -618,8 +618,8 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \t\treturn false;\n \t}\n \n-\tsp->lat = item.lat;\n-\tsp->lon = item.lon;\n+\tsp->lat = item.getLat();\n+\tsp->lon = item.getLon();\n \tsp->alt = get_absolute_altitude_for_item(item);\n \tsp->yaw = item.yaw;\n \tsp->loiter_radius = (fabsf(item.loiter_radius) > FLT_EPSILON) ? fabsf(item.loiter_radius) :\n@@ -702,8 +702,8 @@ MissionBlock::setLoiterItemFromCurrentPositionSetpoint(struct mission_item_s *it\n \n \tconst position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\titem->lat = pos_sp_triplet->current.lat;\n-\titem->lon = pos_sp_triplet->current.lon;\n+\titem->setLatEncoded(pos_sp_triplet->current.lat);\n+\titem->setLonEncoded(pos_sp_triplet->current.lon);\n \titem->altitude = pos_sp_triplet->current.alt;\n \titem->loiter_radius = pos_sp_triplet->current.loiter_direction_counter_clockwise ?\n \t\t\t      -pos_sp_triplet->current.loiter_radius : pos_sp_triplet->current.loiter_radius;\n@@ -715,8 +715,8 @@ MissionBlock::setLoiterItemFromCurrentPosition(struct mission_item_s *item)\n {\n \tsetLoiterItemCommonFields(item);\n \n-\titem->lat = _navigator->get_global_position()->lat;\n-\titem->lon = _navigator->get_global_position()->lon;\n+\titem->setLatEncoded(_navigator->get_global_position()->lat);\n+\titem->setLonEncoded(_navigator->get_global_position()->lon);\n \n \t// check if minimum loiter altitude is specified, and enforce it if so\n \tfloat loiter_altitude_amsl = _navigator->get_global_position()->alt;\n@@ -736,7 +736,11 @@ MissionBlock::setLoiterItemFromCurrentPositionWithBraking(struct mission_item_s\n {\n \tsetLoiterItemCommonFields(item);\n \n-\t_navigator->preproject_stop_point(item->lat, item->lon);\n+\tdouble lat = item->getLat();\n+\tdouble lon = item->getLon();\n+\t_navigator->preproject_stop_point(lat, lon);\n+\titem->setLatEncoded(lat);\n+\titem->setLonEncoded(lon);\n \n \titem->altitude = _navigator->get_global_position()->alt;\n \titem->loiter_radius = _navigator->get_loiter_radius();\n@@ -762,8 +766,8 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float abs_altitude)\n \titem->nav_cmd = NAV_CMD_TAKEOFF;\n \n \t/* use current position */\n-\titem->lat = _navigator->get_global_position()->lat;\n-\titem->lon = _navigator->get_global_position()->lon;\n+\titem->setLatEncoded(_navigator->get_global_position()->lat);\n+\titem->setLonEncoded(_navigator->get_global_position()->lon);\n \titem->yaw = NAN;\n \n \titem->altitude = abs_altitude;\n@@ -793,12 +797,13 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \n \t// set land item to current position\n \tif (_navigator->get_local_position()->xy_global) {\n-\t\titem->lat = _navigator->get_global_position()->lat;\n-\t\titem->lon = _navigator->get_global_position()->lon;\n+\t\titem->setLatEncoded(_navigator->get_global_position()->lat);\n+\t\titem->setLonEncoded(_navigator->get_global_position()->lon);\n \n \t} else {\n-\t\titem->lat = (double)NAN;\n-\t\titem->lon = (double)NAN;\n+\t\titem->___lat_float = NAN;\n+\t\titem->___lon_float = NAN;\n+\t\titem->int_encoded = false;\n \t}\n \n \titem->yaw = NAN;\n@@ -816,8 +821,8 @@ void\n MissionBlock::set_idle_item(struct mission_item_s *item)\n {\n \titem->nav_cmd = NAV_CMD_IDLE;\n-\titem->lat = _navigator->get_home_position()->lat;\n-\titem->lon = _navigator->get_home_position()->lon;\n+\titem->setLatEncoded(_navigator->get_home_position()->lat);\n+\titem->setLonEncoded(_navigator->get_home_position()->lon);\n \titem->altitude_is_relative = false;\n \titem->altitude = _navigator->get_home_position()->alt;\n \titem->yaw = NAN;\n@@ -859,13 +864,13 @@ MissionBlock::copy_position_if_valid(struct mission_item_s *const mission_item,\n \t\t\t\t     const struct position_setpoint_s *const setpoint) const\n {\n \tif (setpoint->valid && setpoint->type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n-\t\tmission_item->lat = setpoint->lat;\n-\t\tmission_item->lon = setpoint->lon;\n+\t\tmission_item->setLatEncoded(setpoint->lat);\n+\t\tmission_item->setLonEncoded(setpoint->lon);\n \t\tmission_item->altitude = setpoint->alt;\n \n \t} else {\n-\t\tmission_item->lat = _navigator->get_global_position()->lat;\n-\t\tmission_item->lon = _navigator->get_global_position()->lon;\n+\t\tmission_item->setLatEncoded(_navigator->get_global_position()->lat);\n+\t\tmission_item->setLonEncoded(_navigator->get_global_position()->lon);\n \t\tmission_item->altitude = _navigator->get_global_position()->alt;\n \t}\n \n@@ -883,15 +888,16 @@ MissionBlock::set_align_mission_item(struct mission_item_s *const mission_item,\n \tmission_item->time_inside = 0.0f;\n \tmission_item->yaw = get_bearing_to_next_waypoint(\n \t\t\t\t    _navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n-\t\t\t\t    mission_item_next->lat, mission_item_next->lon);\n+\t\t\t\t    mission_item_next->getLat(), mission_item_next->getLon());\n \tmission_item->force_heading = true;\n }\n \n void\n MissionBlock::initialize()\n {\n-\t_mission_item.lat = (double)NAN;\n-\t_mission_item.lon = (double)NAN;\n+\t_mission_item.___lat_float = NAN;\n+\t_mission_item.___lon_float = NAN;\n+\t_mission_item.int_encoded = false;\n \t_mission_item.yaw = NAN;\n \t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n \t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n@@ -904,8 +910,8 @@ void MissionBlock::setLoiterToAltMissionItem(mission_item_s &item, const Positio\n \t\tfloat loiter_radius) const\n {\n \titem.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n-\titem.lat = pos_yaw_sp.lat;\n-\titem.lon = pos_yaw_sp.lon;\n+\titem.setLatEncoded(pos_yaw_sp.lat);\n+\titem.setLonEncoded(pos_yaw_sp.lon);\n \titem.altitude = pos_yaw_sp.alt;\n \titem.altitude_is_relative = false;\n \titem.yaw = pos_yaw_sp.yaw;\n@@ -929,8 +935,8 @@ void MissionBlock::setLoiterHoldMissionItem(mission_item_s &item, const Position\n \t\titem.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n \t}\n \n-\titem.lat = pos_yaw_sp.lat;\n-\titem.lon = pos_yaw_sp.lon;\n+\titem.setLatEncoded(pos_yaw_sp.lat);\n+\titem.setLonEncoded(pos_yaw_sp.lon);\n \titem.altitude = pos_yaw_sp.alt;\n \titem.altitude_is_relative = false;\n \n@@ -946,8 +952,8 @@ void MissionBlock::setLoiterHoldMissionItem(mission_item_s &item, const Position\n void MissionBlock::setMoveToPositionMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const\n {\n \titem.nav_cmd = NAV_CMD_WAYPOINT;\n-\titem.lat = pos_yaw_sp.lat;\n-\titem.lon = pos_yaw_sp.lon;\n+\titem.setLatEncoded(pos_yaw_sp.lat);\n+\titem.setLonEncoded(pos_yaw_sp.lon);\n \titem.altitude = pos_yaw_sp.alt;\n \titem.altitude_is_relative = false;\n \n@@ -962,8 +968,8 @@ void MissionBlock::setMoveToPositionMissionItem(mission_item_s &item, const Posi\n void MissionBlock::setLandMissionItem(mission_item_s &item, const PositionYawSetpoint &pos_yaw_sp) const\n {\n \titem.nav_cmd = NAV_CMD_LAND;\n-\titem.lat = pos_yaw_sp.lat;\n-\titem.lon = pos_yaw_sp.lon;\n+\titem.setLatEncoded(pos_yaw_sp.lat);\n+\titem.setLonEncoded(pos_yaw_sp.lon);\n \titem.altitude = pos_yaw_sp.alt;\n \titem.yaw = pos_yaw_sp.yaw;\n \titem.acceptance_radius = _navigator->get_acceptance_radius();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -139,7 +139,7 @@ MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission,\n \t\t\tmissionitem.altitude = missionitem.altitude_is_relative ? missionitem.altitude + home_alt : missionitem.altitude;\n \n \t\t\tif (MissionBlock::item_contains_position(missionitem) && !_navigator->get_geofence().checkPointAgainstAllGeofences(\n-\t\t\t\t    missionitem.lat, missionitem.lon, missionitem.altitude)) {\n+\t\t\t\t    missionitem.getLat(), missionitem.getLon(), missionitem.altitude)) {\n \n \t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %zu\\t\", i + 1);\n \t\t\t\tevents::send<int16_t>(events::ID(\"navigator_mis_geofence_violation\"), {events::Log::Error, events::LogInternal::Info},",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 58,
        "deletions": 19,
        "changes": 77,
        "patch": "@@ -43,9 +43,14 @@\n \n #pragma once\n \n+#include <math.h>\n #include <stdint.h>\n #include <stdbool.h>\n \n+#if !defined(__STDC_IEC_559__) && !defined(__GCC_IEC_559)\n+#  error \"Non standard float implementation does not guarantee 32-bit floats\"\n+#endif\n+\n #if defined(MEMORY_CONSTRAINED_SYSTEM)\n #  define NUM_MISSIONS_SUPPORTED 50\n #elif defined(__PX4_POSIX)\n@@ -144,9 +149,6 @@ enum NAV_FRAME {\n  * possibility of unaligned memory accesses.\n  */\n struct mission_item_s {\n-\tdouble lat;\t\t\t\t\t/**< latitude in degrees\t\t\t\t*/\n-\tdouble lon;\t\t\t\t\t/**< longitude in degrees\t\t\t\t*/\n-\n \t// Union to support both Mission Item categories in MAVLink such as:\n \t// 1. With Global coordinate (param5 ~ 7 corresponds to lat, lon and altitude)\n \t// 2. Without global coordinate (when frame = MAV_FRAME_MISSION)\n@@ -159,29 +161,35 @@ struct mission_item_s {\n \t\t\tunion {\n \t\t\t\tfloat time_inside;\t\t/**< time that the MAV should stay inside the radius before advancing in seconds */\n \t\t\t\tfloat circle_radius;\t\t/**< geofence circle radius in meters (only used for NAV_CMD_NAV_FENCE_CIRCLE*) */\n+\t\t\t\tint16_t do_jump_mission_index;\t/**< index where the do jump will go to                 */\n+\t\t\t\tuint16_t vertex_count;\t\t/**< Polygon vertex count (geofence)\t*/\n+\t\t\t};\n+\t\t\tunion {\n+\t\t\t\tfloat acceptance_radius;\t/**< default radius in which the mission is accepted as reached in meters */\n+\t\t\t\tuint16_t do_jump_repeat_count;\t/**< how many times do jump needs to be done            */\n+\t\t\t\tuint16_t land_precision;\t/**< Defines if landing should be precise: 0 = normal landing, 1 = opportunistic precision landing, 2 = required precision landing (with search)\t*/\n+\t\t\t};\n+\t\t\tunion {\n+\t\t\t\tfloat loiter_radius;\t\t/**< loiter radius in meters, 0 for a VTOL to hover, negative for counter-clockwise */\n+\t\t\t\tuint16_t do_jump_current_count;\t/**< count how many times the jump has been done\t*/\n \t\t\t};\n-\t\t\tfloat acceptance_radius;\t\t/**< default radius in which the mission is accepted as reached in meters */\n-\t\t\tfloat loiter_radius;\t\t\t/**< loiter radius in meters, 0 for a VTOL to hover, negative for counter-clockwise */\n \t\t\tfloat yaw;\t\t\t\t/**< in radians NED -PI..+PI, NAN means don't change yaw\t\t*/\n-\t\t\tfloat ___lat_float;\t\t\t/**< padding */\n-\t\t\tfloat ___lon_float;\t\t\t/**< padding */\n+\t\t\tunion {\n+\t\t\t\tint32_t ___lat_int;\t\t/**< Latitude stored as int32 */\n+\t\t\t\tfloat ___lat_float;\t\t/**< Latitude stored as float */\n+\t\t\t};\n+\t\t\tunion {\n+\t\t\t\tint32_t ___lon_int;\t\t/**< Longitude stored as int32 */\n+\t\t\t\tfloat ___lon_float;\t\t/**< Longitude stored as float */\n+\t\t\t};\n \t\t\tfloat altitude;\t\t\t\t/**< altitude in meters\t(AMSL)\t\t\t*/\n \t\t};\n \n \t\t// Non-Navigation command parameters (implicit)\n \t\tfloat params[7];\t\t\t\t/**< array to store mission command values with no global coordinates (frame = MAV_FRAME_MISSION) */\n \t};\n \n-\tuint16_t nav_cmd;\t\t\t\t/**< navigation command\t\t\t\t\t*/\n-\n-\tint16_t do_jump_mission_index;\t\t\t/**< index where the do jump will go to                 */\n-\tuint16_t do_jump_repeat_count;\t\t\t/**< how many times do jump needs to be done            */\n-\n-\tunion {\n-\t\tuint16_t do_jump_current_count;\t\t\t/**< count how many times the jump has been done\t*/\n-\t\tuint16_t vertex_count;\t\t\t\t/**< Polygon vertex count (geofence)\t*/\n-\t\tuint16_t land_precision;\t\t\t/**< Defines if landing should be precise: 0 = normal landing, 1 = opportunistic precision landing, 2 = required precision landing (with search)\t*/\n-\t};\n+\tuint16_t nav_cmd;\t\t\t\t\t/**< navigation command\t\t\t\t\t*/\n \n \tstruct {\n \t\tuint16_t frame : 4,\t\t\t\t/**< mission frame */\n@@ -191,10 +199,41 @@ struct mission_item_s {\n \t\t\t altitude_is_relative : 1,\t\t/**< true if altitude is relative from start point\t*/\n \t\t\t autocontinue : 1,\t\t\t/**< true if next waypoint should follow after this one */\n \t\t\t vtol_back_transition : 1,\t\t/**< part of the vtol back transition sequence */\n-\t\t\t _padding0 : 4;\t\t\t\t/**< padding remaining unused bits  */\n+\t\t\t int_encoded : 1,\t\t\t/**< specifies if latitude/longitude are encoded as int32 */\n+\t\t\t _padding0 : 3;\t\t\t\t/**< padding remaining unused bits  */\n \t};\n \n-\tuint8_t _padding1[2];\t\t\t\t/**< padding struct size to alignment boundary  */\n+\tvoid setLatEncoded(const double lat)\n+\t{\n+\t\t___lat_int = lat * 1e7;\n+\t\tint_encoded = true;\n+\t}\n+\n+\tvoid setLonEncoded(const double lon)\n+\t{\n+\t\t___lon_int = lon * 1e7;\n+\t\tint_encoded = true;\n+\t}\n+\n+\tdouble getLat() const\n+\t{\n+\t\tif (int_encoded) {\n+\t\t\treturn ((double)___lat_int) * 1e-7;\n+\n+\t\t} else {\n+\t\t\treturn (double)___lat_float;\n+\t\t}\n+\t}\n+\n+\tdouble getLon() const\n+\t{\n+\t\tif (int_encoded) {\n+\t\t\treturn ((double)___lon_int) * 1e-7;\n+\n+\t\t} else {\n+\t\t\treturn (double)___lon_float;\n+\t\t}\n+\t}\n };\n \n /**",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "patch": "@@ -422,7 +422,7 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \t\t\t\t     \"Mission land item could not be read\");\n \t\t}\n \n-\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_mission_item.lat, land_mission_item.lon)};\n+\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_mission_item.getLat(), land_mission_item.getLon())};\n \n \t\tif ((dist + MIN_DIST_THRESHOLD) < min_dist) {\n \t\t\tif (_param_rtl_type.get() != 0) {\n@@ -456,10 +456,10 @@ void RTL::findRtlDestination(DestinationType &destination_type, PositionYawSetpo\n \n \t\t\t// Ignore safepoints which are too close to the homepoint\n \t\t\tconst float dist_to_home = get_distance_to_next_waypoint(_home_pos_sub.get().lat, _home_pos_sub.get().lon,\n-\t\t\t\t\t\t   mission_safe_point.lat, mission_safe_point.lon);\n+\t\t\t\t\t\t   mission_safe_point.getLat(), mission_safe_point.getLon());\n \n \t\t\tif (mission_safe_point.nav_cmd == NAV_CMD_RALLY_POINT && dist_to_home > MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n-\t\t\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, mission_safe_point.lat, mission_safe_point.lon)};\n+\t\t\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, mission_safe_point.getLat(), mission_safe_point.getLon())};\n \n \t\t\t\tPositionYawSetpoint safepoint_position;\n \t\t\t\tsetSafepointAsDestination(safepoint_position, mission_safe_point);\n@@ -492,8 +492,8 @@ void RTL::setLandPosAsDestination(PositionYawSetpoint &rtl_position, mission_ite\n {\n \trtl_position.alt = land_mission_item.altitude_is_relative ?\tland_mission_item.altitude +\n \t\t\t   _home_pos_sub.get().alt : land_mission_item.altitude;\n-\trtl_position.lat = land_mission_item.lat;\n-\trtl_position.lon = land_mission_item.lon;\n+\trtl_position.lat = land_mission_item.getLat();\n+\trtl_position.lon = land_mission_item.getLon();\n \trtl_position.yaw = _home_pos_sub.get().yaw;\n }\n \n@@ -504,15 +504,15 @@ void RTL::setSafepointAsDestination(PositionYawSetpoint &rtl_position,\n \t// TODO: handle all possible mission_safe_point.frame cases\n \tswitch (mission_safe_point.frame) {\n \tcase 0: // MAV_FRAME_GLOBAL\n-\t\trtl_position.lat = mission_safe_point.lat;\n-\t\trtl_position.lon = mission_safe_point.lon;\n+\t\trtl_position.lat = mission_safe_point.getLat();\n+\t\trtl_position.lon = mission_safe_point.getLon();\n \t\trtl_position.alt = mission_safe_point.altitude;\n \t\trtl_position.yaw = _home_pos_sub.get().yaw;;\n \t\tbreak;\n \n \tcase 3: // MAV_FRAME_GLOBAL_RELATIVE_ALT\n-\t\trtl_position.lat = mission_safe_point.lat;\n-\t\trtl_position.lon = mission_safe_point.lon;\n+\t\trtl_position.lat = mission_safe_point.getLat();\n+\t\trtl_position.lon = mission_safe_point.getLon();\n \t\trtl_position.alt = mission_safe_point.altitude + _home_pos_sub.get().alt; // alt of safe point is rel to home\n \t\trtl_position.yaw = _home_pos_sub.get().yaw;;\n \t\tbreak;\n@@ -705,20 +705,21 @@ land_approaches_s RTL::readVtolLandApproaches(PositionYawSetpoint rtl_position)\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tconst float dist_to_safepoint = get_distance_to_next_waypoint(mission_item.lat, mission_item.lon, rtl_position.lat,\n+\t\t\tconst float dist_to_safepoint = get_distance_to_next_waypoint(mission_item.getLat(), mission_item.getLon(),\n+\t\t\t\t\t\t\trtl_position.lat,\n \t\t\t\t\t\t\trtl_position.lon);\n \n \t\t\tif (dist_to_safepoint < MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n \t\t\t\tfoundHomeLandApproaches = true;\n-\t\t\t\tvtol_land_approaches.land_location_lat_lon = matrix::Vector2d(mission_item.lat, mission_item.lon);\n+\t\t\t\tvtol_land_approaches.land_location_lat_lon = matrix::Vector2d(mission_item.getLat(), mission_item.getLon());\n \t\t\t}\n \n \t\t\tsector_counter = 0;\n \t\t}\n \n \t\tif (foundHomeLandApproaches && mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n-\t\t\tvtol_land_approaches.approaches[sector_counter].lat = mission_item.lat;\n-\t\t\tvtol_land_approaches.approaches[sector_counter].lon = mission_item.lon;\n+\t\t\tvtol_land_approaches.approaches[sector_counter].lat = mission_item.getLat();\n+\t\t\tvtol_land_approaches.approaches[sector_counter].lon = mission_item.getLon();\n \t\t\tvtol_land_approaches.approaches[sector_counter].height_m = MissionBlock::get_absolute_altitude_for_item(mission_item,\n \t\t\t\t\t_home_pos_sub.get().alt);\n \t\t\tvtol_land_approaches.approaches[sector_counter].loiter_radius_m = mission_item.loiter_radius;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -596,8 +596,8 @@ void RtlDirect::publish_rtl_direct_navigator_mission_item()\n \n \tnavigator_mission_item.sequence_current = static_cast<uint16_t>(_rtl_state);\n \tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n-\tnavigator_mission_item.latitude = _mission_item.lat;\n-\tnavigator_mission_item.longitude = _mission_item.lon;\n+\tnavigator_mission_item.latitude = _mission_item.getLat();\n+\tnavigator_mission_item.longitude = _mission_item.getLon();\n \tnavigator_mission_item.altitude = _mission_item.altitude;\n \n \tnavigator_mission_item.time_inside = get_time_inside(_mission_item);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "patch": "@@ -133,8 +133,8 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n \t\t}\n \n-\t\t_mission_item.lat = _global_pos_sub.get().lat;\n-\t\t_mission_item.lon = _global_pos_sub.get().lon;\n+\t\t_mission_item.setLatEncoded(_global_pos_sub.get().lat);\n+\t\t_mission_item.setLonEncoded(_global_pos_sub.get().lon);\n \t\t_mission_item.altitude = _rtl_alt;\n \t\t_mission_item.altitude_is_relative = false;\n \n@@ -309,11 +309,11 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\t// Go to loiter\n \t\t\t\t\t\t\tmatrix::Vector2f direction{};\n \t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n-\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.getLat(), next_position_mission_item.getLon(), &direction(0), &direction(1));\n \n \t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat,\n-\t\t\t\t\t\t\t\t\t next_position_mission_item.lon);\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.getLat(),\n+\t\t\t\t\t\t\t\t\t next_position_mission_item.getLon());\n \n \t\t\t\t\t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n \t\t\t\t\t\t\t\thor_dist = math::max(0.f, hor_dist - next_position_mission_item.loiter_radius);\n@@ -330,11 +330,11 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\t// Go to point horizontally\n \t\t\t\t\t\t\tmatrix::Vector2f direction{};\n \t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n-\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.getLat(), next_position_mission_item.getLon(), &direction(0), &direction(1));\n \n \t\t\t\t\t\t\tfloat hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.lat,\n-\t\t\t\t\t\t\t\t\t next_position_mission_item.lon);\n+\t\t\t\t\t\t\t\t\t hor_position_at_calculation_point(1), next_position_mission_item.getLat(),\n+\t\t\t\t\t\t\t\t\t next_position_mission_item.getLon());\n \n \t\t\t\t\t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n \t\t\t\t\t\t\t\thor_dist = math::max(0.f, hor_dist - next_position_mission_item.loiter_radius);\n@@ -354,10 +354,10 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \n \t\t\t\t\t\t\tmatrix::Vector2f direction{};\n \t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n-\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.getLat(), next_position_mission_item.getLon(), &direction(0), &direction(1));\n \n \t\t\t\t\t\t\tconst float hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t       hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\t\t\t\t\t\t\t\t\t       hor_position_at_calculation_point(1), next_position_mission_item.getLat(), next_position_mission_item.getLon());\n \n \t\t\t\t\t\t\t// For fixed wing, add diagonal line\n \t\t\t\t\t\t\tif ((_vehicle_status_sub.get().vehicle_type != vehicle_status_s::VEHICLE_TYPE_FIXED_WING)\n@@ -385,10 +385,10 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t\t\t// Default assume can go to the location directly\n \t\t\t\t\t\t\tmatrix::Vector2f direction{};\n \t\t\t\t\t\t\tget_vector_to_next_waypoint(hor_position_at_calculation_point(0), hor_position_at_calculation_point(1),\n-\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon, &direction(0), &direction(1));\n+\t\t\t\t\t\t\t\t\t\t    next_position_mission_item.getLat(), next_position_mission_item.getLon(), &direction(0), &direction(1));\n \n \t\t\t\t\t\t\tconst float hor_dist = get_distance_to_next_waypoint(hor_position_at_calculation_point(0),\n-\t\t\t\t\t\t\t\t\t       hor_position_at_calculation_point(1), next_position_mission_item.lat, next_position_mission_item.lon);\n+\t\t\t\t\t\t\t\t\t       hor_position_at_calculation_point(1), next_position_mission_item.getLat(), next_position_mission_item.getLon());\n \n \t\t\t\t\t\t\t_rtl_time_estimator.addDistance(hor_dist, direction,\n \t\t\t\t\t\t\t\t\t\t\tget_absolute_altitude_for_item(next_position_mission_item) - altitude_at_calculation_point);\n@@ -397,8 +397,8 @@ rtl_time_estimate_s RtlDirectMissionLand::calc_rtl_time_estimate()\n \t\t\t\t\t}\n \n \t\t\t\t\tstart_item_index = next_mission_item_index + 1;\n-\t\t\t\t\thor_position_at_calculation_point(0) = next_position_mission_item.lat;\n-\t\t\t\t\thor_position_at_calculation_point(1) = next_position_mission_item.lon;\n+\t\t\t\t\thor_position_at_calculation_point(0) = next_position_mission_item.getLat();\n+\t\t\t\t\thor_position_at_calculation_point(1) = next_position_mission_item.getLon();\n \t\t\t\t\taltitude_at_calculation_point = get_absolute_altitude_for_item(next_position_mission_item);\n \n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -216,8 +216,8 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n \t\t\t\t}\n \n-\t\t\t\t_mission_item.lat = _home_pos_sub.get().lat;\n-\t\t\t\t_mission_item.lon = _home_pos_sub.get().lon;\n+\t\t\t\t_mission_item.setLatEncoded(_home_pos_sub.get().lat);\n+\t\t\t\t_mission_item.setLonEncoded(_home_pos_sub.get().lon);\n \t\t\t\t_mission_item.altitude = altitude;\n \t\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n@@ -247,8 +247,8 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t    _work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND ||\n \t\t\t    _work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION)) {\n \t\t\t_mission_item.nav_cmd = NAV_CMD_LAND;\n-\t\t\t_mission_item.lat = _home_pos_sub.get().lat;\n-\t\t\t_mission_item.lon = _home_pos_sub.get().lon;\n+\t\t\t_mission_item.setLatEncoded(_home_pos_sub.get().lat);\n+\t\t\t_mission_item.setLonEncoded(_home_pos_sub.get().lon);\n \t\t\t_mission_item.yaw = NAN;\n \n \t\t\tif ((_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -71,8 +71,8 @@ VtolTakeoff::on_active()\n \t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n \t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n-\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat,\n-\t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n+\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.getLat(),\n+\t\t\t\t\t\t\t    _mission_item.getLon(), _loiter_location(0), _loiter_location(1)));\n \t\t\t\t_mission_item.force_heading = true;\n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n@@ -86,8 +86,8 @@ VtolTakeoff::on_active()\n \t\tcase vtol_takeoff_state::ALIGN_HEADING: {\n \n \t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n-\t\t\t\t_mission_item.lat = _loiter_location(0);\n-\t\t\t\t_mission_item.lon = _loiter_location(1);\n+\t\t\t\t_mission_item.setLatEncoded(_loiter_location(0));\n+\t\t\t\t_mission_item.setLonEncoded(_loiter_location(1));\n \t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n \n@@ -127,8 +127,8 @@ VtolTakeoff::on_active()\n \t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n \t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n \n-\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n-\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n+\t\t\t\t_mission_item.setLatEncoded(pos_sp_triplet->current.lat);\n+\t\t\t\t_mission_item.setLonEncoded(pos_sp_triplet->current.lon);\n \n \t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n \n@@ -172,8 +172,8 @@ VtolTakeoff::set_takeoff_position()\n \n \t_takeoff_alt_msl = _navigator->get_global_position()->alt;\n \n-\t_mission_item.lat = _navigator->get_global_position()->lat;\n-\t_mission_item.lon = _navigator->get_global_position()->lon;\n+\t_mission_item.setLatEncoded(_navigator->get_global_position()->lat);\n+\t_mission_item.setLonEncoded(_navigator->get_global_position()->lon);\n \n \t_navigator->get_mission_result()->finished = false;\n \t_navigator->set_mission_result_updated();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/06521d394875a5391691a8cd112a6d4cb8cab9cf/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_idle_item",
        "MissionBlock::set_align_mission_item",
        "RTL::setLandPosAsDestination",
        "Mission::handleTakeoff",
        "MissionBlock::setLoiterToAltMissionItem",
        "MissionBase::set_mission_result",
        "VtolTakeoff::set_takeoff_position",
        "MissionBase::do_abort_landing",
        "Mission::do_need_move_to_takeoff",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::setLoiterItemFromCurrentPositionSetpoint",
        "RtlDirectMissionLand::calc_rtl_time_estimate",
        "MissionBlock::setLoiterItemFromCurrentPosition",
        "RtlMissionFastReverse::handleLanding",
        "RTL::setSafepointAsDestination",
        "MissionBase::setMissionToClosestItem",
        "Land::on_activation",
        "MissionBlock::issue_command",
        "RtlDirectMissionLand::setActiveMissionItems",
        "MissionBlock::is_mission_item_reached_or_completed",
        "MissionBlock::setLoiterItemFromCurrentPositionWithBraking",
        "FeasibilityChecker::checkDistancesBetweenWaypoints",
        "MissionBase::publish_navigator_mission_item",
        "matrix::Vector2d",
        "MissionBlock::setMoveToPositionMissionItem",
        "VtolTakeoff::on_active",
        "RtlDirect::publish_rtl_direct_navigator_mission_item",
        "MissionBlock::set_takeoff_item",
        "MissionBlock::set_land_item",
        "FeasibilityChecker::checkFixedWindLandApproach",
        "MissionBase::on_active",
        "RTL::readVtolLandApproaches",
        "RTL::findRtlDestination",
        "MissionBlock::copy_position_if_valid",
        "matrix::wrap_pi",
        "MissionBlock::setLoiterHoldMissionItem",
        "MissionFeasibilityChecker::checkMissionAgainstGeofence",
        "MissionBase::isLanding",
        "FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkFixedWindLandApproach",
          "FeasibilityChecker::checkDistancesBetweenWaypoints",
          "FeasibilityChecker::checkHorizontalDistanceToFirstWaypoint"
        ],
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ],
        "src/modules/navigator/mission.cpp": [
          "Mission::do_need_move_to_takeoff",
          "Mission::handleTakeoff"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::publish_navigator_mission_item",
          "MissionBase::do_abort_landing",
          "matrix::wrap_pi",
          "MissionBase::set_mission_result",
          "MissionBase::on_active",
          "MissionBase::setMissionToClosestItem",
          "MissionBase::isLanding"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_idle_item",
          "MissionBlock::set_align_mission_item",
          "MissionBlock::setLoiterItemFromCurrentPositionWithBraking",
          "MissionBlock::setLoiterItemFromCurrentPosition",
          "MissionBlock::setMoveToPositionMissionItem",
          "MissionBlock::copy_position_if_valid",
          "MissionBlock::set_takeoff_item",
          "MissionBlock::issue_command",
          "MissionBlock::setLoiterToAltMissionItem",
          "MissionBlock::set_land_item",
          "MissionBlock::setLoiterHoldMissionItem",
          "MissionBlock::is_mission_item_reached_or_completed",
          "MissionBlock::mission_item_to_position_setpoint",
          "MissionBlock::setLoiterItemFromCurrentPositionSetpoint"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionAgainstGeofence"
        ],
        "src/modules/navigator/rtl.cpp": [
          "matrix::Vector2d",
          "RTL::setLandPosAsDestination",
          "RTL::setSafepointAsDestination",
          "RTL::readVtolLandApproaches",
          "RTL::findRtlDestination"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::publish_rtl_direct_navigator_mission_item"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::calc_rtl_time_estimate",
          "RtlDirectMissionLand::setActiveMissionItems"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::handleLanding"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::set_takeoff_position",
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "navigator: loiter: allow without global position",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24335",
    "number": 24335,
    "created_at": "2025-02-13T21:24:15Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "dakejahl",
      "body": "User is flying with VIO and optical flow (no GPS). When manual control is lost they want the vehicle to go into HOLD mode.\r\n\r\n@afwilkin ",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-02-13T21:29:39Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 56 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +56  +0.0%     +56    .text\n    +0.7%     +36  +0.7%     +36    ../../src/modules/navigator/mission_block.cpp\n    +0.0%     +13  +0.0%     +13    [section .text]\n    +0.2%      +4  +0.2%      +4    ../../src/modules/navigator/mission.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n  +0.0%     +56  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%      +4  [ = ]       0    .debug_frame\n  +0.0%     +23  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.0%     +27  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n  +0.0%     +25  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    -0.1%      -1  [ = ]       0    ../../src/modules/commander/ModeUtil/mode_requirements.cpp\n    +0.5%     +52  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    -0.1%      -1  [ = ]       0    task/task_cancelpt.c\n  -0.0%      -8  [ = ]       0    .debug_loc\n    -0.1%      -8  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n  -0.0%      -8  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n  -0.3%     -56  [ = ]       0    [Unmapped]\n  +0.0%     +84  +0.0%     +56    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 56 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +56  +0.0%     +56    .text\n    +0.7%     +36  +0.7%     +36    ../../src/modules/navigator/mission_block.cpp\n    +0.0%     +13  +0.0%     +13    [section .text]\n    +0.2%      +4  +0.2%      +4    ../../src/modules/navigator/mission.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n  +0.0%     +56  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%      +4  [ = ]       0    .debug_frame\n  +0.0%     +23  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.0%     +27  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n  +0.0%     +33  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    -0.1%      -1  [ = ]       0    ../../src/modules/commander/ModeUtil/mode_requirements.cpp\n    +0.5%     +52  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.6%      +7  [ = ]       0    task/task_cancelpt.c\n  -0.0%      -8  [ = ]       0    .debug_loc\n    -0.1%      -8  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n  -0.0%      -8  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n  -0.1%     -56  [ = ]       0    [Unmapped]\n  +0.0%     +92  +0.0%     +56    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-02-21T21:18:10_**",
          "type": "issue_comment"
        },
        {
          "author": "dakejahl",
          "created_at": "2025-02-14T19:58:02Z",
          "body": "It doesn't failsafe, it stays in HOLD mode.\r\n\r\nI just took a look through FlightTaskAuto and tested with some printf debugging, it succesfully makes it into the state switch/case\r\n```\r\nWaypointType::loiter\r\n```\r\nalthough I'm not sure if it should... I would expect _evaluateGlobalReference() to fail, but it doesn't. \r\n\r\nI opened this for @afwilkin as a quick and dirty solution for their needs. The painful but correct way to do this would be to explicitly allow both Navigator and FlightTaskAuto to use local position if there is a flow/VIO system providing a solid estimate. To expand on this I think all of those sub-modes inside of Navigator should be moved to FlightTasks and all of the airframe specific logic in Navigator should be refactored into their own files/functions. I know we've talked about doing in the past, it's a daunting task.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "bresch",
          "created_at": "2025-02-14T08:45:25Z",
          "body": "I understand the motivation and we should allow this, but how do you achieve this with this PR? Switch into hold, produce NAN setpoints, and the controllers will failsafe because of those NANs ?",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes navigator/mission logic so loiter/HOLD is allowed without a global (GPS) fix when local VIO/optical flow position is available â€” addressing an incorrect state transition/behavior where the vehicle wouldn't enter HOLD as the user expected. The discussion shows this was producing unintended mode behavior and the change is a logic-level decision (though reviewers note potential side-effects like NaN setpoints that need careful handling).",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "patch": "@@ -736,11 +736,21 @@ MissionBlock::setLoiterItemFromCurrentPositionWithBraking(struct mission_item_s\n {\n \tsetLoiterItemCommonFields(item);\n \n-\t_navigator->preproject_stop_point(item->lat, item->lon);\n+\tauto global = _navigator->get_global_position();\n \n-\titem->altitude = _navigator->get_global_position()->alt;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n-\titem->yaw = NAN;\n+\tif (global->lat_lon_valid && global->alt_valid) {\n+\t\t_navigator->preproject_stop_point(item->lat, item->lon);\n+\t\titem->altitude = global->alt;\n+\t\titem->loiter_radius = _navigator->get_loiter_radius();\n+\t\titem->yaw = NAN;\n+\n+\t} else {\n+\t\titem->lat = (double)NAN;\n+\t\titem->lon = (double)NAN;\n+\t\titem->altitude = NAN;\n+\t\titem->loiter_radius = NAN;\n+\t\titem->yaw = NAN;\n+\t}\n }\n \n void",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0be38ef4249be6869cfb33c1f660451d18bcd473/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::setLoiterItemFromCurrentPositionWithBraking"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::setLoiterItemFromCurrentPositionWithBraking"
        ]
      }
    }
  },
  {
    "title": "Introduce boat vehicle type",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24310",
    "number": 24310,
    "created_at": "2025-02-10T10:17:04Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "TomasTwardzik",
      "body": "# Motivation \nDecoupling boat and rover to exists as separate entities within Navigator and Commander modules. Despite similarities, this should lead to more legible, self documented code.  In the future, this also allows to make changes separately, without risking introducing unwanted behavior to other platforms.\n\n## Discovered Problem\nRover can be armed with high throttle, which is a significant risk.\n\n## Solution\nBoth Rover and Boat now require throttle stick near center to be armed.\n\n## Changelog Entry\n\nFor release notes:\n`VehickeStatus.msg` -> new vehicle type VEHICLE_TYPE_BOAT\n`Navigator module` -> boat explicitely mimics rover behavior, instead of relying on vehicle_type being VEHICLE_TYPE_ROVER\nControl Allocator's `module.yaml` -> Adding new airframe types for boats (Singe, Twin engine and Differential)\n`commander_helper` -> adding distinct separation for boat and rover instead of generic ground vehicle\n`Commander` -> adding method for throttle near center detection, adding, adding mission override for boats, adding dedicated arm checks for rover and boats\n\n\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-02-10T10:22:12Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 304 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +304  +0.0%    +304    .text\n    +0.1%    +111  +0.1%    +111    ROMFS/nsh_romfsimg.c\n    +0.5%    +104  +0.5%    +104    ../../src/modules/commander/Commander.cpp\n    +0.0%     +46  +0.0%     +46    [section .text]\n    +2.4%     +28  +2.4%     +28    ../../src/modules/commander/commander_helper.cpp\n    +0.1%      +4  +0.1%      +4    ../../src/modules/commander/accelerometer_calibration.cpp\n    +0.2%      +4  +0.2%      +4    ../../src/modules/navigator/mission.cpp\n    +0.1%      +4  +0.1%      +4    ../../src/modules/navigator/mission_block.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n  +0.0%     +56  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%      +8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +7.4%     +16  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n  +0.0%     +28  [ = ]       0    .debug_frame\n  +0.0% +1.37Ki  [ = ]       0    .debug_info\n    +0.0%     +13  [ = ]       0    ../../src/drivers/distance_sensor/lightware_laser_i2c/lightware_laser_i2c.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/osd/msp_osd/msp_osd.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/osd/msp_osd/uorb_to_msp.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/px4io/px4io.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/rc/crsf_rc/CrsfRc.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/rc/dsm_rc/DsmRc.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/rc_input/RCInput.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/rc_input/crsf_telemetry.cpp\n    +0.1%     +13  [ = ]       0    ../../src/drivers/telemetry/frsky_telemetry/frsky_data.cpp\n    +0.1%     +13  [ = ]       0    ../../src/drivers/telemetry/frsky_telemetry/sPort_data.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/uavcan/remoteid.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/uavcan/uavcan_main.cpp\n    +0.0%     +13  [ = ]       0    ../../src/lib/avoidance/ObstacleAvoidance.cpp\n    +0.0%     +13  [ = ]       0    ../../src/lib/battery/battery.cpp\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.0%     +13  [ = ]       0    ../../src/modules/airspeed_selector/airspeed_selector_main.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/battery_status/analog_battery.cpp\n    +0.0%     +79  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/HealthAndArmingChecks.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/accelerometerCheck.cpp\n   -100.0% +1.07Ki  [ = ]       0    [76 Others]\n  +0.0%    +190  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%    +109  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +2.3%     +56  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.3%     +31  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%     +19  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n  +0.0%     +92  [ = ]       0    .debug_loc\n    -0.1%     -15  [ = ]       0    ../../src/drivers/px4io/px4io.cpp\n    +0.1%     +15  [ = ]       0    ../../src/drivers/uavcan/remoteid.cpp\n    -0.0%     -13  [ = ]       0    ../../src/drivers/uavcan/uavcan_main.cpp\n    +0.0%      +3  [ = ]       0    ../../src/drivers/uavcan/uavcan_servers.cpp\n    +0.1%     +15  [ = ]       0    ../../src/lib/battery/battery.cpp\n    +0.1%     +58  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +0.0%      +1  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/externalChecks.cpp\n    +0.0%     +15  [ = ]       0    ../../src/modules/commander/accelerometer_calibration.cpp\n    +1.2%     +15  [ = ]       0    ../../src/modules/commander/airspeed_calibration.cpp\n    -0.7%     -15  [ = ]       0    ../../src/modules/commander/baro_calibration.cpp\n    +6.7%     +74  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    -0.1%     -15  [ = ]       0    ../../src/modules/commander/mag_calibration.cpp\n    +0.0%     +15  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp\n    +0.0%      +3  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    -0.1%     -15  [ = ]       0    ../../src/modules/fw_att_control/FixedwingAttitudeControl.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +0.0%     +15  [ = ]       0    ../../src/modules/fw_rate_control/FixedwingRateControl.cpp\n    -0.3%     -15  [ = ]       0    ../../src/modules/land_detector/FixedwingLandDetector.cpp\n    -0.2%     -15  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    -0.2%     -15  [ = ]       0    ../../src/modules/vtol_att_control/vtol_att_control_main.cpp\n   -100.0%      -3  [ = ]       0    [2 Others]\n  +0.0%      +9  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -0.1%      -8  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +8.0%     +16  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.4%      +8  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +1.6%      +1  [ = ]       0    task/task_cancelpt.c\n  +0.0%    +135  [ = ]       0    .debug_str\n    +0.3%     +18  [ = ]       0    ../../src/drivers/distance_sensor/lightware_laser_i2c/lightware_laser_i2c.cpp\n    +0.1%    +117  [ = ]       0    ../../src/modules/commander/Commander.cpp\n  -1.4%      -3  [ = ]       0    .shstrtab\n  +0.0%     +75  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n     +10%     +75  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n  +0.0%     +64  [ = ]       0    .symtab\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +4.7%     +64  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n  -2.7%    -304  [ = ]       0    [Unmapped]\n  +0.0% +2.01Ki  +0.0%    +304    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 336 byte (0.02 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +336  +0.0%    +336    .text\n    +0.1%    +155  +0.1%    +155    ROMFS/nsh_romfsimg.c\n    +0.5%    +104  +0.5%    +104    ../../src/modules/commander/Commander.cpp\n    +0.0%     +37  +0.0%     +37    [section .text]\n    +2.4%     +28  +2.4%     +28    ../../src/modules/commander/commander_helper.cpp\n    +0.1%      +4  +0.1%      +4    ../../src/modules/commander/accelerometer_calibration.cpp\n    +0.2%      +4  +0.2%      +4    ../../src/modules/navigator/mission.cpp\n    +0.1%      +4  +0.1%      +4    ../../src/modules/navigator/mission_block.cpp\n  +0.0%     +56  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%      +8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +7.4%     +16  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n  +0.0%     +28  [ = ]       0    .debug_frame\n  +0.0% +1.33Ki  [ = ]       0    .debug_info\n    +0.0%     +13  [ = ]       0    ../../src/drivers/distance_sensor/lightware_laser_i2c/lightware_laser_i2c.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/osd/msp_osd/msp_osd.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/osd/msp_osd/uorb_to_msp.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/px4io/px4io.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/rc_input/RCInput.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/rc_input/crsf_telemetry.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/uavcan/remoteid.cpp\n    +0.0%     +13  [ = ]       0    ../../src/drivers/uavcan/uavcan_main.cpp\n    +0.0%     +13  [ = ]       0    ../../src/lib/avoidance/ObstacleAvoidance.cpp\n    +0.0%     +13  [ = ]       0    ../../src/lib/battery/battery.cpp\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.0%     +13  [ = ]       0    ../../src/modules/airspeed_selector/airspeed_selector_main.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/battery_status/analog_battery.cpp\n    +0.0%     +79  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/HealthAndArmingChecks.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/accelerometerCheck.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/airspeedCheck.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/armPermissionCheck.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/baroCheck.cpp\n    +0.0%     +13  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/batteryCheck.cpp\n   -100.0% +1.03Ki  [ = ]       0    [73 Others]\n  +0.0%    +189  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.3%    +109  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +2.3%     +56  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.3%     +31  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n    +0.1%     +19  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    -0.1%      -1  [ = ]       0    task/task_cancelpt.c\n  -0.0%     -79  [ = ]       0    .debug_loc\n    -0.0%     -15  [ = ]       0    ../../src/drivers/uavcan/uavcan_main.cpp\n    +0.0%     +14  [ = ]       0    ../../src/drivers/uavcan/uavcan_servers.cpp\n    +0.1%     +43  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    -0.2%     -15  [ = ]       0    ../../src/modules/commander/HealthAndArmingChecks/checks/batteryCheck.cpp\n    -1.2%     -15  [ = ]       0    ../../src/modules/commander/airspeed_calibration.cpp\n    +0.7%     +15  [ = ]       0    ../../src/modules/commander/baro_calibration.cpp\n    +6.7%     +74  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.1%     +15  [ = ]       0    ../../src/modules/commander/mag_calibration.cpp\n    -0.2%     -15  [ = ]       0    ../../src/modules/flight_mode_manager/FlightModeManager.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/flight_mode_manager/tasks/AutoFollowTarget/FlightTaskAutoFollowTarget.cpp\n    -0.0%     -16  [ = ]       0    ../../src/modules/fw_autotune_attitude_control/fw_autotune_attitude_control.cpp\n    -0.0%     -15  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    -0.1%     -15  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    -0.1%     -15  [ = ]       0    ../../src/modules/navigator/rtl.cpp\n    -0.2%     -15  [ = ]       0    ../../src/modules/navigator/rtl_direct_mission_land.cpp\n    -0.0%     -66  [ = ]       0    [section .debug_loc]\n    -0.0%     -22  [ = ]       0    src/modules/ekf2/modules__ekf2_unity.cpp\n  +0.0%      +8  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -0.1%      -8  [ = ]       0    ../../src/modules/commander/Commander.cpp\n    +8.0%     +16  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.4%      +8  [ = ]       0    ../../src/modules/navigator/mission_block.cpp\n  +0.0%    +135  [ = ]       0    .debug_str\n    +0.3%     +18  [ = ]       0    ../../src/drivers/distance_sensor/lightware_laser_i2c/lightware_laser_i2c.cpp\n    +0.1%    +117  [ = ]       0    ../../src/modules/commander/Commander.cpp\n  +0.0%     +64  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n     +10%     +75  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.0%     +21  [ = ]       0    [section .strtab]\n  +0.0%     +64  [ = ]       0    .symtab\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +4.7%     +64  [ = ]       0    ../../src/modules/commander/commander_helper.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n  -0.5%    -336  [ = ]       0    [Unmapped]\n  +0.0% +1.79Ki  +0.0%    +336    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-02-12T10:15:53_**",
          "type": "issue_comment"
        },
        {
          "author": "Pedro-Roque",
          "created_at": "2025-02-10T22:19:15Z",
          "body": "@TomasTwardzik can you update with latest main changes through rebase?\r\n\r\n@MaEtUgR do these changes require further action on the rover type?",
          "type": "issue_comment"
        },
        {
          "author": "DronecodeBot",
          "created_at": "2025-02-19T14:48:48Z",
          "body": "This pull request has been mentioned on **Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink**. There might be relevant details there:\n\nhttps://discuss.px4.io/t/px4-sync-q-a-feb-19-2025/43827/1\n",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-04T13:12:03Z",
          "body": "@TomasTwardzik please rebase on main (e.g. https://github.com/PX4/PX4-Autopilot/pull/24367 came in now), and remove the CA_* params for now (until boat controllers are added).",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2025-02-19T13:28:41Z",
          "body": "Before we introduce the new type type here, let's discuss the meaning of this field, see https://github.com/PX4/PX4-Autopilot/pull/24367",
          "path": "msg/versioned/VehicleStatus.msg",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-02-19T13:30:21Z",
          "body": "We should align that with rover I guess? For both types a negative throttle is possible and thus the check against center makes more sense.",
          "path": "src/modules/commander/Commander.hpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-02-19T13:31:26Z",
          "body": "Does it make sense to introduce these new options for the allocation without implementing them?\r\n",
          "path": "src/modules/control_allocator/module.yaml",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "Pedro-Roque",
          "created_at": "2025-02-19T16:46:51Z",
          "body": "This came up on a dev call. The idea is to have a centralized definition for airframes, and for now this might be the best place...",
          "path": "src/modules/control_allocator/module.yaml",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "TomasTwardzik",
          "created_at": "2025-02-20T08:28:48Z",
          "body": "I agree with the points made. As is it currently stands, the code is a bit confusing what is what and these changes should clear it up.",
          "path": "msg/versioned/VehicleStatus.msg",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "TomasTwardzik",
          "created_at": "2025-02-20T08:36:43Z",
          "body": "This is already done, I saw it as a bug fix, see:\r\nhttps://github.com/PX4/PX4-Autopilot/blob/e907fb0aa21bb6170b087b0af6349c6611710403/src/modules/commander/Commander.cpp#L587-L595",
          "path": "src/modules/commander/Commander.hpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "TomasTwardzik",
          "created_at": "2025-02-20T08:38:49Z",
          "body": "I am okay to remove for now.",
          "path": "src/modules/control_allocator/module.yaml",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-02-19T13:31:26Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-02-19T13:37:17Z",
          "body": "Thanks for kicking off this discussion!",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "Pedro-Roque",
          "created_at": "2025-02-19T16:46:51Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "TomasTwardzik",
          "created_at": "2025-02-20T08:28:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "TomasTwardzik",
          "created_at": "2025-02-20T08:36:44Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "TomasTwardzik",
          "created_at": "2025-02-20T08:38:49Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect arming behavior (a logic bug): previously rovers could be armed with high throttle which is unsafe. The change introduces explicit boat/rover arming checks and requires throttle-stick-near-center for both vehicle types, correcting the improper arming condition and preventing unintended dangerous behavior.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -206,8 +206,9 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t\t\t_waypoint_position_reached = true;\n \t\t\t}\n \n-\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n-\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n+\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF &&\n+\t\t\t   (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER\n+\t\t\t    || _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_BOAT)) {\n \t\t\t// Accept takeoff waypoint to be reached if the distance in 2D plane is within acceptance radius\n \t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n \t\t\t\t_waypoint_position_reached = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d230215368911111084646f14300598466070337/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -1137,7 +1137,8 @@ float Navigator::get_altitude_acceptance_radius()\n \t\t\treturn _param_nav_fw_alt_rad.get();\n \t\t}\n \n-\t} else if (get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n+\t} else if (get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER\n+\t\t   || get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_BOAT) {\n \t\treturn INFINITY;\n \n \t} else {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d230215368911111084646f14300598466070337/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::get_altitude_acceptance_radius",
        "MissionBlock::is_mission_item_reached_or_completed"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::get_altitude_acceptance_radius"
        ]
      }
    }
  },
  {
    "title": "Refactor: create gimbal library",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24291",
    "number": 24291,
    "created_at": "2025-02-04T10:34:06Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "Perrrewi",
      "body": "### Solved Problem\r\nCreating a library to avoid several implementations of gimbal control\r\n\r\n### Solution\r\nDepends on\r\n- [ ] https://github.com/PX4/PX4-Autopilot/pull/24242\r\n\r\n\r\n\r\n### Test coverage\r\n- tbd\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR is a refactor to create a shared gimbal library to avoid duplicate implementations, with no mention of fixing incorrect behavior, failing conditions, or a specific bug. There are no comments or test details indicating it corrects a logic flaw, so this appears to be a structural/maintenance change rather than a logic error fix.",
    "patches": {
      "src/modules/navigator/CMakeLists.txt": {
        "filename": "src/modules/navigator/CMakeLists.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -70,4 +70,5 @@ px4_add_module(\n \t\tmotion_planning\n \t\tmission_feasibility_checker\n \t\trtl_time_estimator\n+\t\tgimbal_control\n \t)",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2FCMakeLists.txt"
      },
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -73,9 +73,9 @@ Land::on_activation()\n \t_navigator->reset_cruising_speed();\n \n \t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n-\t_navigator->acquire_gimbal_control();\n-\t_navigator->set_gimbal_neutral();\n-\t_navigator->release_gimbal_control();\n+\t_navigator->_gimbal_control.acquireGimbalControlIfNeeded();\n+\t_navigator->_gimbal_control.setNeutral();\n+\t_navigator->_gimbal_control.releaseGimbalControlIfNeeded();\n \n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "patch": "@@ -180,8 +180,9 @@ MissionBase::on_inactivation()\n \t_navigator->disable_camera_trigger();\n \n \t_navigator->stop_capturing_images();\n-\t_navigator->set_gimbal_neutral(); // point forward\n-\t_navigator->release_gimbal_control();\n+\t_navigator->_gimbal_control.acquireGimbalControlIfNeeded();\n+\t_navigator->_gimbal_control.setNeutral(); // point forward\n+\t_navigator->_gimbal_control.releaseGimbalControlIfNeeded();\n \n \tif (_navigator->get_precland()->is_activated()) {\n \t\t_navigator->get_precland()->on_inactivation();\n@@ -683,9 +684,9 @@ void MissionBase::handleLanding(WorkItemType &new_work_item_type, mission_item_s\n \t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n \n \t\t\t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n-\t\t\t_navigator->acquire_gimbal_control();\n-\t\t\t_navigator->set_gimbal_neutral();\n-\t\t\t_navigator->release_gimbal_control();\n+\t\t\t_navigator->_gimbal_control.acquireGimbalControlIfNeeded();\n+\t\t\t_navigator->_gimbal_control.setNeutral();\n+\t\t\t_navigator->_gimbal_control.releaseGimbalControlIfNeeded();\n \n \t\t} else {\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -524,7 +524,7 @@ MissionBlock::issue_command(const mission_item_s &item)\n \n \t// This is to support legacy DO_MOUNT_CONTROL as part of a mission.\n \tif (item.nav_cmd == NAV_CMD_DO_MOUNT_CONTROL) {\n-\t\t_navigator->acquire_gimbal_control();\n+\t\t_navigator->_gimbal_control.acquireGimbalControlIfNeeded();\n \t}\n \n \t// Mission item's NAV_CMD enums directly map to the according vehicle command",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "patch": "@@ -60,6 +60,7 @@\n #if CONFIG_NAVIGATOR_ADSB\n #include <lib/adsb/AdsbConflict.h>\n #endif // CONFIG_NAVIGATOR_ADSB\n+#include <lib/gimbal_control/Gimbal.hpp>\n #include <lib/perf/perf_counter.h>\n #include <px4_platform_common/events.h>\n #include <px4_platform_common/module.h>\n@@ -277,9 +278,7 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tbool force_vtol();\n \n-\tvoid acquire_gimbal_control();\n-\tvoid release_gimbal_control();\n-\tvoid set_gimbal_neutral();\n+\tGimbal _gimbal_control{this};\n \n \tvoid preproject_stop_point(double &lat, double &lon);\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 35,
        "changes": 35,
        "patch": "@@ -1543,29 +1543,6 @@ void Navigator::publish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_\n \t_vehicle_cmd_ack_pub.publish(command_ack);\n }\n \n-void Navigator::acquire_gimbal_control()\n-{\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_CONFIGURE;\n-\tvcmd.param1 = _vstatus.system_id;\n-\tvcmd.param2 = _vstatus.component_id;\n-\tvcmd.param3 = -1.0f; // Leave unchanged.\n-\tvcmd.param4 = -1.0f; // Leave unchanged.\n-\tpublish_vehicle_cmd(&vcmd);\n-}\n-\n-void Navigator::release_gimbal_control()\n-{\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_CONFIGURE;\n-\tvcmd.param1 = -3.0f; // Remove control if it had it.\n-\tvcmd.param2 = -3.0f; // Remove control if it had it.\n-\tvcmd.param3 = -1.0f; // Leave unchanged.\n-\tvcmd.param4 = -1.0f; // Leave unchanged.\n-\tpublish_vehicle_cmd(&vcmd);\n-}\n-\n-\n void\n Navigator::stop_capturing_images()\n {\n@@ -1629,18 +1606,6 @@ void Navigator::disable_camera_trigger()\n \tpublish_vehicle_cmd(&cmd);\n }\n \n-void Navigator::set_gimbal_neutral()\n-{\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_PITCHYAW;\n-\tvcmd.param1 = NAN;\n-\tvcmd.param2 = NAN;\n-\tvcmd.param3 = NAN;\n-\tvcmd.param4 = NAN;\n-\tvcmd.param5 = gimbal_manager_set_attitude_s::GIMBAL_MANAGER_FLAGS_NEUTRAL;\n-\tpublish_vehicle_cmd(&vcmd);\n-}\n-\n void Navigator::sendWarningDescentStoppedDueToTerrain()\n {\n \tmavlink_log_critical(&_mavlink_log_pub, \"Terrain collision risk, descent is stopped\\t\");",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -238,9 +238,9 @@ void RTL::on_activation()\n \t}\n \n \t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n-\t_navigator->acquire_gimbal_control();\n-\t_navigator->set_gimbal_neutral();\n-\t_navigator->release_gimbal_control();\n+\t_navigator->_gimbal_control.acquireGimbalControlIfNeeded();\n+\t_navigator->_gimbal_control.setNeutral();\n+\t_navigator->_gimbal_control.releaseGimbalControlIfNeeded();\n }\n \n void RTL::on_active()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/032929c5c937bf806481348f4a3fbdeb14ff1361/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_inactivation",
        "Navigator::release_gimbal_control",
        "Navigator::acquire_gimbal_control",
        "Land::on_activation",
        "MissionBlock::issue_command",
        "set_gimbal_neutral",
        "Navigator::publish_vehicle_command_ack",
        "acquire_gimbal_control",
        "RTL::on_activation",
        "Navigator::set_gimbal_neutral",
        "Navigator::disable_camera_trigger",
        "release_gimbal_control",
        "MissionBase::handleLanding"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_activation"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_inactivation",
          "MissionBase::handleLanding"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command"
        ],
        "src/modules/navigator/navigator.h": [
          "set_gimbal_neutral",
          "acquire_gimbal_control",
          "release_gimbal_control"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::release_gimbal_control",
          "Navigator::acquire_gimbal_control",
          "Navigator::publish_vehicle_command_ack",
          "Navigator::set_gimbal_neutral",
          "Navigator::disable_camera_trigger"
        ],
        "src/modules/navigator/rtl.cpp": [
          "RTL::on_activation"
        ]
      }
    }
  },
  {
    "title": "Navigator: remove custom \"FLT_EPSILONs\"",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24253",
    "number": 24253,
    "created_at": "2025-01-24T17:43:52Z",
    "merged": true,
    "merged_at": "2025-01-29T14:42:51Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nNot a specific problem, but noticed that in the Navigator we in two cases use 0.001 instead of FLT_EPSILON to compare a float to zero. \r\n\r\nOriginal contributions:\r\n- [to compare the loiter radius setpoint to zero](https://github.com/PX4/PX4-Autopilot/commit/590f00f56089cf6afa62b7f4df07527c014da559)\r\n- [acceptance radius comparison to zero](https://github.com/PX4/PX4-Autopilot/pull/20171)\r\n\r\n### Solution\r\nConsistently use x > FLT_EPSILON for floating point comparisons against 0.\r\n\r\nIn there any risk in these fields somehow being e.g. 0.00001? Because then >FLT_EPSILON will now be true, while previously it was false. ",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2025-01-27T04:07:49Z",
          "body": "If anything we might want to reject an impossibly small loiter radius in the first place.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2025-01-27T04:07:55Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2025-01-29T14:42:42Z",
          "body": "Looks safe ðŸ‘ ",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR replaces an arbitrary 0.001 threshold with FLT_EPSILON for zero-comparisons, which is a consistency/precision change rather than a fix for a reported incorrect behavior. No specific incorrect output or state transition was described; this is a behavioral change that could alter handling of very small non-zero values rather than correcting a documented logic bug.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -622,11 +622,11 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tsp->lon = item.lon;\n \tsp->alt = get_absolute_altitude_for_item(item);\n \tsp->yaw = item.yaw;\n-\tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n+\tsp->loiter_radius = (fabsf(item.loiter_radius) > FLT_EPSILON) ? fabsf(item.loiter_radius) :\n \t\t\t    _navigator->get_loiter_radius();\n \tsp->loiter_direction_counter_clockwise = item.loiter_radius < 0;\n \n-\tif (item.acceptance_radius > 0.001f && PX4_ISFINITE(item.acceptance_radius)) {\n+\tif (item.acceptance_radius > FLT_EPSILON && PX4_ISFINITE(item.acceptance_radius)) {\n \t\t// if the mission item has a specified acceptance radius, overwrite the default one from parameters\n \t\tsp->acceptance_radius = item.acceptance_radius;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bb395e3ce3fdc676b8535633a8d1b09702e56034/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -56,8 +56,6 @@\n #  define NUM_MISSIONS_SUPPORTED 500\n #endif\n \n-#define NAV_EPSILON_POSITION\t0.001f\t/**< Anything smaller than this is considered zero */\n-\n /* compatible to mavlink MAV_CMD */\n enum NAV_CMD {\n \tNAV_CMD_IDLE = 0,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bb395e3ce3fdc676b8535633a8d1b09702e56034/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::mission_item_to_position_setpoint"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::mission_item_to_position_setpoint"
        ]
      }
    }
  },
  {
    "title": "Navigator/boards: introduce RAM_CONSTRAINED_SYSTEM for reduced mission length",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24252",
    "number": 24252,
    "created_at": "2025-01-24T14:32:16Z",
    "merged": true,
    "merged_at": "2025-03-20T10:45:26Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nThe current limit of mission items is quite low. For large survey missions it's possible to exceed the limit of 500. This limit was introduce when the ability to store [missions on RAM was added](https://github.com/PX4/PX4-Autopilot/pull/18827), as RAM is much more limited than the SDcard in terms of available storage space, and a full RAM leads to a hard-fault. \r\n\r\n### Solution\r\nAdd `#define RAM_CONSTRAINED_SYSTEM` to specify if a board has a constrained RAM space, in which case the limit is left at 500. If that define is not set then open up the limit to 1000 (arbitrary number). \r\n\r\nSide question: is MEMORY_CONSTRAINED_SYSTEM even set anywhere?\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nImprovement: Navigator/boards: introduce `#define RAM_CONSTRAINED_SYSTEM` for reduced mission length\r\n```\r\n\r\n### Alternatives\r\n@MaEtUgR mentioned that we could consider reducing the amount of data such a mission write needs, at least if stored on RAM. Binding the max mission size to `SYS_DM_BACKEND` is likely not feasible. \r\n\r\nThis is just an initial draft PR to kick off some discussion, I didn't go through all the boards and labeled them correctly with `RAM_CONSTRAINED_SYSTEM`.\r\n",
      "issue_comments": [
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2025-01-24T15:20:36Z",
          "body": "How about making it a Kconfig symbol with a help text explaining what it does?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-01-27T13:24:42Z",
          "body": "@dagar @PetervdPerk-NXP thanks for the inputs, I made a kconfig option now. \r\nFor now I left it by default to be constrained to 500, and raise it for boards with more RAM (>1kb) to 1000 (I likely missed some boards). We could also flip it around and by default have it at 1000, and lower it for boards with RAM <1kb. Thoughts?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-04T09:01:38Z",
          "body": "@dagar @PetervdPerk-NXP @MaEtUgR what's you're thought on this PR, can we get it in like that?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-19T16:25:36Z",
          "body": "> LGTM in the future we could simplify this if more cases occurs by using the kconfig `default if` syntax\r\n> \r\n> Example from zephyr kconfig\r\n> \r\n> ```\r\n>  config SHELL_STACK_SIZE \r\n>  \tint \"Shell thread stack size\" \r\n>  \tdefault 3168 if OPENTHREAD_SHELL \r\n>  \tdefault 3072 if 64BIT \r\n>  \tdefault 2048 if MULTITHREADING \r\n>  \tdefault 0 if !MULTITHREADING \r\n> ```\r\n\r\n@PetervdPerk-NXP that sounds interesting, which if() could we use to find boards with a certain RAM size?",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-19T16:32:31Z",
          "body": "I've rebased and cleaned up the commits otherwise, so this would be good to go unless we want to include https://github.com/PX4/PX4-Autopilot/pull/24252#pullrequestreview-2699009430.",
          "type": "issue_comment"
        },
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2025-03-19T16:41:57Z",
          "body": "> > LGTM in the future we could simplify this if more cases occurs by using the kconfig `default if` syntax\r\n> > Example from zephyr kconfig\r\n> > ```\r\n> >  config SHELL_STACK_SIZE \r\n> >  \tint \"Shell thread stack size\" \r\n> >  \tdefault 3168 if OPENTHREAD_SHELL \r\n> >  \tdefault 3072 if 64BIT \r\n> >  \tdefault 2048 if MULTITHREADING \r\n> >  \tdefault 0 if !MULTITHREADING \r\n> > ```\r\n> \r\n> @PetervdPerk-NXP that sounds interesting, which if() could we use to find boards with a certain RAM size?\r\n\r\nI was thinking about defining certain device classes. ",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-19T17:05:28Z",
          "body": "@PetervdPerk-NXP was wondering if you could help me with the [one CI failure](https://github.com/PX4/PX4-Autopilot/actions/runs/13951772111/job/39052979953?pr=24252) we now get here..\r\n`nxp_mr-canhubk3_default` fails as the only board due to `CONFIG_NUM_MISSION_ITMES_SUPPORTED' was not declared in this scope`.",
          "type": "issue_comment"
        },
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2025-03-19T18:23:41Z",
          "body": "Looks to be a dependency issue your kconfig symbol `NUM_MISSION_ITMES_SUPPORTED` depends on navigator, however the `nxp_mr-canhubk3_default` doesn't have navigator enabled. \r\n\r\nI just enabled navigator on the k3 target by default, I think CI should succeed now.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "MaEtUgR",
          "created_at": "2025-03-19T15:02:34Z",
          "body": "```suggestion\r\n\t\tThis limit always applies if mission items are stored on the SD card or in RAM. It should be set\r\n\t\tadequately per boards such that if the items are stored in RAM they still fit the available memory.\r\n\t\tThe runtime parameter to configure the storage option is `SYS_DM_BACKEND`.\r\n```",
          "path": "src/modules/navigator/Kconfig",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2025-01-27T04:03:50Z",
          "body": "We don't need a generic \"RAM_CONSTRAINED_SYSTEM\", we can simply do a real kconfig level `NUM_MISSIONS_SUPPORTED` for navigator/dataman.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2025-03-19T15:05:58Z",
          "body": "Removing the strange hardcoded profiles makes sense anyways. Also having it configurable per board is probably a necessary evil to accommodate for low RAM chips but still not be limited for big missions.\r\n\r\nI'd suggest to clearly distinguish between where the items are stored but that's a more involved change.\r\n\r\nI have some minor suggestions for the help text. Feel free to mix what you consider understandable.",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2025-03-19T15:34:25Z",
          "body": "LGTM in the future we could simplify this if more cases occurs by using the kconfig `default if` syntax\r\n\r\nExample from zephyr kconfig\r\n```\r\n config SHELL_STACK_SIZE \r\n \tint \"Shell thread stack size\" \r\n \tdefault 3168 if OPENTHREAD_SHELL \r\n \tdefault 3072 if 64BIT \r\n \tdefault 2048 if MULTITHREADING \r\n \tdefault 0 if !MULTITHREADING \r\n```",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "PetervdPerk-NXP",
          "created_at": "2025-03-19T16:54:47Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR corrects an incorrect/unexpected behavior by removing an unnecessarily low hardcoded mission-item limit for boards with sufficient RAM and making the limit configurable per-board via Kconfig. This is primarily a configuration/behavior fix (adjusting program limits based on system RAM) rather than a syntax or style change, so it addresses an unintended operational constraint rather than a purely cosmetic change.",
    "patches": {
      "src/modules/navigator/Kconfig": {
        "filename": "src/modules/navigator/Kconfig",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "patch": "@@ -27,3 +27,12 @@ menuconfig NAVIGATOR_ADSB\n \t---help---\n \t\tAdd support for acting on ADSB transponder_report or ADSB_VEHICLE MAVLink messages.\n \t\tActions are warnings, Loiter, Land and RTL without climb.\n+\n+menuconfig NUM_MISSION_ITMES_SUPPORTED\n+\tint \"Maximum number of mission items\"\n+\tdefault 500\n+\tdepends on MODULES_NAVIGATOR\n+\t---help---\n+\t\tThis limit always applies if mission items are stored on the SD card or in RAM. It should be set\n+\t\tadequately per boards such that if the items are stored in RAM they still fit the available memory.\n+\t\tThe runtime parameter to configure the storage option is `SYS_DM_BACKEND`.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fa4bd962750169d142836e64c7a422b26d3b35fc/src%2Fmodules%2Fnavigator%2FKconfig"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "patch": "@@ -46,16 +46,6 @@\n #include <stdint.h>\n #include <stdbool.h>\n \n-#if defined(MEMORY_CONSTRAINED_SYSTEM)\n-#  define NUM_MISSIONS_SUPPORTED 50\n-#elif defined(__PX4_POSIX)\n-#  define NUM_MISSIONS_SUPPORTED (UINT16_MAX-1) // This is allocated as needed.\n-#elif defined(RAM_BASED_MISSIONS)\n-#  define NUM_MISSIONS_SUPPORTED 500\n-#else\n-#  define NUM_MISSIONS_SUPPORTED 500\n-#endif\n-\n /* compatible to mavlink MAV_CMD */\n enum NAV_CMD {\n \tNAV_CMD_IDLE = 0,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/fa4bd962750169d142836e64c7a422b26d3b35fc/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Mission feasibility checks: make adding new check less error prone",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24241",
    "number": 24241,
    "created_at": "2025-01-22T08:34:03Z",
    "merged": true,
    "merged_at": "2025-01-22T15:56:31Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nWhen someone adds a new check he might forget to add the flag to the `someChecksFailed` method.\r\n\r\n\r\n\r\n### Solution\r\nUse a bitfield to make the method independent from individual booleans. \r\n\r\n\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\nSITL\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-01-22T08:41:19Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 56 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +56  +0.0%     +56    .text\n    +1.9%     +68  +1.9%     +68    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.0%     +13  +0.0%     +13    [section .text]\n    +0.1%      +4  +0.1%      +4    ../../src/lib/adsb/AdsbConflict.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n    -4.5%     -32  -4.5%     -32    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  +0.0%     +33  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    -0.9%     -23  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%    +209  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.2%     +83  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.1%     +84  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +0.1%     +46  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  -0.0%     -34  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.4%     +33  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    -1.0%     -37  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    -0.4%      -5  [ = ]       0    task/task_cancelpt.c\n  -0.0%     -10  [ = ]       0    .debug_loc\n    -0.1%     -15  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.4%      +5  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  -0.0%     -11  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -4.5%      -3  [ = ]       0    task/task_cancelpt.c\n  +0.0%      +9  [ = ]       0    .debug_str\n    +0.1%      +9  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n  -0.5%     -56  [ = ]       0    [Unmapped]\n  +0.0%    +188  +0.0%     +56    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 56 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +56  +0.0%     +56    .text\n    +1.9%     +68  +1.9%     +68    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.0%     +13  +0.0%     +13    [section .text]\n    +0.1%      +4  +0.1%      +4    ../../src/lib/adsb/AdsbConflict.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n    -4.5%     -32  -4.5%     -32    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  +0.0%     +33  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    -0.9%     -23  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  -0.0%      -8  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n  +0.0%    +209  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n    +0.2%     +83  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    +0.1%     +84  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n    +0.1%     +46  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  -0.0%     -26  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n    +0.4%     +33  [ = ]       0    ../../src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp\n    -1.0%     -37  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.3%      +3  [ = ]       0    task/task_cancelpt.c\n  +0.0%      +5  [ = ]       0    .debug_loc\n    +0.4%      +5  [ = ]       0    ../../src/modules/navigator/mission_feasibility_checker.cpp\n  -0.0%      -6  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n    +3.1%      +2  [ = ]       0    task/task_cancelpt.c\n  +0.0%      +9  [ = ]       0    .debug_str\n    +0.1%      +9  [ = ]       0    ../../src/modules/navigator/mission_base.cpp\n  -0.1%     -56  [ = ]       0    [Unmapped]\n  +0.0%    +216  +0.0%     +56    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-01-22T11:09:14_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2025-01-22T09:18:59Z",
          "body": "```suggestion\r\n\t\tuint16_t value {0};\r\n```",
          "path": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-01-22T09:27:48Z",
          "body": "Makes sense, less error prone like that.",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-01-22T15:56:20Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error. The previous implementation required manually checking multiple boolean flags in someChecksFailed, which could be forgotten when adding new checks and lead to incorrect feasibility results. Replacing those separate booleans with a bitfield centralizes the check aggregation and prevents missed conditions (incorrect conditional/state aggregation).",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 22,
        "changes": 39,
        "patch": "@@ -46,12 +46,7 @@ FeasibilityChecker::FeasibilityChecker() :\n \n void FeasibilityChecker::reset()\n {\n-\t_mission_validity_failed = false;\n-\t_takeoff_failed = false;\n-\t_land_pattern_validity_failed = false;\n-\t_distance_between_waypoints_failed = false;\n-\t_fixed_wing_land_approach_failed = false;\n-\t_takeoff_land_available_failed = false;\n+\t_checks_failed.value = 0;\n \n \t_found_item_with_position = false;\n \t_has_vtol_takeoff = false;\n@@ -155,11 +150,11 @@ bool FeasibilityChecker::processNextItem(mission_item_s &mission_item, const int\n \t\tupdateData();\n \t}\n \n-\tif (!_mission_validity_failed) {\n-\t\t_mission_validity_failed = !checkMissionItemValidity(mission_item, current_index);\n+\tif (!_checks_failed.flags.mission_validity_failed) {\n+\t\t_checks_failed.flags.mission_validity_failed = !checkMissionItemValidity(mission_item, current_index);\n \t}\n \n-\tif (_mission_validity_failed) {\n+\tif (_checks_failed.flags.mission_validity_failed) {\n \t\t// if a mission item is not valid then abort the other checks\n \t\treturn false;\n \t}\n@@ -177,7 +172,7 @@ bool FeasibilityChecker::processNextItem(mission_item_s &mission_item, const int\n \t}\n \n \tif (current_index == total_count - 1) {\n-\t\t_takeoff_land_available_failed = !checkTakeoffLandAvailable();\n+\t\t_checks_failed.flags.takeoff_land_available_failed = !checkTakeoffLandAvailable();\n \t}\n \n \t_mission_item_previous = mission_item;\n@@ -188,39 +183,39 @@ bool FeasibilityChecker::processNextItem(mission_item_s &mission_item, const int\n void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int current_index)\n {\n \n-\tif (!_distance_between_waypoints_failed) {\n-\t\t_distance_between_waypoints_failed = !checkDistancesBetweenWaypoints(mission_item);\n+\tif (!_checks_failed.flags.distance_between_waypoints_failed) {\n+\t\t_checks_failed.flags.distance_between_waypoints_failed = !checkDistancesBetweenWaypoints(mission_item);\n \t}\n \n \tif (!_first_waypoint_found) {\n \t\tcheckHorizontalDistanceToFirstWaypoint(mission_item);\n \t}\n \n-\tif (!_takeoff_failed) {\n-\t\t_takeoff_failed = !checkTakeoff(mission_item);\n+\tif (!_checks_failed.flags.takeoff_failed) {\n+\t\t_checks_failed.flags.takeoff_failed = !checkTakeoff(mission_item);\n \t}\n \n-\tif (!_items_fit_to_vehicle_type_failed) {\n-\t\t_items_fit_to_vehicle_type_failed = !checkItemsFitToVehicleType(mission_item);\n+\tif (!_checks_failed.flags.items_fit_to_vehicle_type_failed) {\n+\t\t_checks_failed.flags.items_fit_to_vehicle_type_failed = !checkItemsFitToVehicleType(mission_item);\n \t}\n }\n \n void FeasibilityChecker::doVtolChecks(mission_item_s &mission_item, const int current_index, const int last_index)\n {\n-\tif (!_land_pattern_validity_failed) {\n-\t\t_land_pattern_validity_failed = !checkLandPatternValidity(mission_item, current_index, last_index);\n+\tif (!_checks_failed.flags.land_pattern_validity_failed) {\n+\t\t_checks_failed.flags.land_pattern_validity_failed = !checkLandPatternValidity(mission_item, current_index, last_index);\n \t}\n \n }\n \n void FeasibilityChecker::doFixedWingChecks(mission_item_s &mission_item, const int current_index, const int last_index)\n {\n-\tif (!_land_pattern_validity_failed) {\n-\t\t_land_pattern_validity_failed = !checkLandPatternValidity(mission_item, current_index, last_index);\n+\tif (!_checks_failed.flags.land_pattern_validity_failed) {\n+\t\t_checks_failed.flags.land_pattern_validity_failed = !checkLandPatternValidity(mission_item, current_index, last_index);\n \t}\n \n-\tif (!_fixed_wing_land_approach_failed) {\n-\t\t_fixed_wing_land_approach_failed = !checkFixedWindLandApproach(mission_item, current_index);\n+\tif (!_checks_failed.flags.fixed_wing_land_approach_failed) {\n+\t\t_checks_failed.flags.fixed_wing_land_approach_failed = !checkFixedWindLandApproach(mission_item, current_index);\n \t}\n \n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eeb0b9f259ce7337a20ae090a804f89fa30a1b5a/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.hpp",
        "status": "modified",
        "additions": 13,
        "deletions": 14,
        "changes": 27,
        "patch": "@@ -77,12 +77,7 @@ class FeasibilityChecker : public ModuleParams\n \t*/\n \tbool someCheckFailed()\n \t{\n-\t\treturn _takeoff_failed ||\n-\t\t       _distance_between_waypoints_failed ||\n-\t\t       _land_pattern_validity_failed ||\n-\t\t       _fixed_wing_land_approach_failed ||\n-\t\t       _mission_validity_failed ||\n-\t\t       _takeoff_land_available_failed;\n+\t\treturn _checks_failed.value != 0;\n \t}\n \n \t/**\n@@ -110,14 +105,18 @@ class FeasibilityChecker : public ModuleParams\n \tmatrix::Vector2d _home_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n \tVehicleType _vehicle_type{VehicleType::RotaryWing};\n \n-\t// internal flags to keep track of which checks failed\n-\tbool _mission_validity_failed{false};\n-\tbool _takeoff_failed{false};\n-\tbool _land_pattern_validity_failed{false};\n-\tbool _distance_between_waypoints_failed{false};\n-\tbool _fixed_wing_land_approach_failed{false};\n-\tbool _takeoff_land_available_failed{false};\n-\tbool _items_fit_to_vehicle_type_failed{false};\n+\tunion checks_failed_u {\n+\t\tstruct {\n+\t\t\tbool mission_validity_failed : 1;\n+\t\t\tbool takeoff_failed : 1;\n+\t\t\tbool land_pattern_validity_failed : 1;\n+\t\t\tbool distance_between_waypoints_failed : 1;\n+\t\t\tbool fixed_wing_land_approach_failed : 1;\n+\t\t\tbool takeoff_land_available_failed : 1;\n+\t\t\tbool items_fit_to_vehicle_type_failed : 1;\n+\t\t} flags;\n+\t\tuint16_t value {0};\n+\t} _checks_failed{};\n \n \t// internal checkTakeoff related variables\n \tbool _found_item_with_position{false};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/eeb0b9f259ce7337a20ae090a804f89fa30a1b5a/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.hpp"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::FeasibilityChecker",
        "FeasibilityChecker::processNextItem"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::FeasibilityChecker",
          "FeasibilityChecker::processNextItem"
        ]
      }
    }
  },
  {
    "title": "VTOL Takeoff: use vehicle altitude instead of Home for altitude setpoint calculation",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24236",
    "number": 24236,
    "created_at": "2025-01-21T14:01:18Z",
    "merged": true,
    "merged_at": "2025-01-22T11:03:19Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "### Solved Problem\r\nThe VTOL takeoff navigation mode was using the home altitude to calculate the climbout altitude. However, the vehicle does not necessarily need to be at the home point at the time it takes off and thus, the ground alatitude and the home altitude could be very different.\r\n\r\nIn fact, if the ground altitude at the home position is much lower than the ground altitude at the takeoff point, then the vehicle would fly into the ground after the transition.\r\n\r\n### Solution\r\nStore the current altitude before takeoff and use that as reference for the climbout altitude.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix XYZ\r\nNew parameter: XYZ_Z\r\nDocumentation: Need to clarify page ... / done, read docs.px4.io/...\r\n```\r\n\r\n### Alternatives\r\n\r\n\r\n### Test coverage\r\nSITL\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-01-22T09:45:10Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR corrects a logic bug where the climbout altitude was computed from the home altitude instead of the vehicle's actual takeoff altitude, producing incorrect altitude setpoints when the vehicle wasn't at home. Switching to storing and using the current pre-takeoff altitude fixes an incorrect reference/state that could lead to unsafe behavior (e.g., flying into the ground).",
    "patches": {
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -118,7 +118,7 @@ VtolTakeoff::on_active()\n \t\t\t\t_mission_item.time_inside = 1.f;\n \t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n \t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n-\t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n+\t\t\t\t_mission_item.altitude = _takeoff_alt_msl + _param_loiter_alt.get();\n \n \t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n \t\t\t\tpos_sp_triplet->current.lat = _loiter_location(0);\n@@ -170,6 +170,8 @@ VtolTakeoff::set_takeoff_position()\n \t// set current mission item to takeoff\n \tset_takeoff_item(&_mission_item, _transition_alt_amsl);\n \n+\t_takeoff_alt_msl = _navigator->get_global_position()->alt;\n+\n \t_mission_item.lat = _navigator->get_global_position()->lat;\n \t_mission_item.lon = _navigator->get_global_position()->lon;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/df9ac21404d5c6ac08a370a52d80af16e167b3b2/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      },
      "src/modules/navigator/vtol_takeoff.h": {
        "filename": "src/modules/navigator/vtol_takeoff.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -70,6 +70,7 @@ class VtolTakeoff : public MissionBlock, public ModuleParams\n \t} _takeoff_state;\n \n \tfloat _transition_alt_amsl{0.f};\t// absolute altitude at which vehicle will transition to forward flight\n+\tfloat _takeoff_alt_msl{0.f};\n \tmatrix::Vector2d _loiter_location;\n \tfloat _loiter_height{0};\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/df9ac21404d5c6ac08a370a52d80af16e167b3b2/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.h"
      }
    },
    "modified_functions": {
      "all": [
        "VtolTakeoff::set_takeoff_position",
        "VtolTakeoff::on_active"
      ],
      "by_file": {
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::set_takeoff_position",
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Cleanup: Navigator: Vehicle command refactor, FlightTaskAuto: parameter clarification",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24764",
    "number": 24764,
    "created_at": "2025-04-25T09:35:39Z",
    "merged": true,
    "merged_at": "2025-04-25T13:32:47Z",
    "state": "closed",
    "conversation": {
      "author": "MaEtUgR",
      "body": "### Solved Problem\r\nWhile looking into what would be necessary to command the gimbal back to neutral automatically very close to ground I found that the internal interface for that is not as straight forward as I hoped and instead it's necessary to go through a complicated MAVLink protocol dance in every spot within PX4 that wants to do that.\r\n\r\nAs part of studying that I came across these pieces which I really at least want to refactor for clarity to enable further improvements.\r\n\r\n### Solution\r\n- Flight Task Auto crawl speed is not compliant with the parameter naming convention (1. commit)\r\n- More clear `MPC_LAND_ALT3` parameter description\r\n- Make navigator function `publish_vehicle_cmd` consume a reference instead of a pointer and rename it to `publish_vehicle_command`.\r\n- Follow convention to name messages to publish according to the message name instead of some cryptic abbrevated version.\r\n- Explicitly write float/double literals\r\n\r\nDocumentation I only adjusted the english version. There seem to be multiple different english versions in other language subdirectories, I still don't understand why such outdated non-translated versions exist.\r\n\r\n### Changelog Entry\r\n```\r\nCleanup: Navigator: Vehicle command refactor, FlightTaskAuto: parameter clarification\r\n```\r\n\r\n### Test coverage\r\nIt's refactoring except for the reference instead of pointer but if the previous version was ever called with a `nullptr` it would have hardfaulted.\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-04-25T12:24:46Z",
          "body": "No flaws found\n<!-- Sticky Pull Request Commentflaws -->",
          "type": "issue_comment"
        },
        {
          "author": "MaEtUgR",
          "created_at": "2025-04-25T12:35:35Z",
          "body": "@sfuhrer Thanks for having a look. According to your request I split the individual changes into separate commits. Please let me know if there's anything else I should address ðŸ™",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-04-25T13:30:10Z",
          "body": "Thanks for the extreme diligence in updating all the docs as well!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR is primarily refactoring and documentation/parameter-clarification: renames, API change from pointer to reference, parameter description updates and formatting changes. There is no indication it corrects incorrect program behavior or state transitions; the pointer->reference change improves safety (prevents potential hardfault) but addresses a crash/safety issue rather than a logic error.",
    "patches": {
      "src/modules/navigator/land.cpp": {
        "filename": "src/modules/navigator/land.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "patch": "@@ -109,17 +109,16 @@ Land::on_active()\n \tif (_navigator->abort_landing()) {\n \n \t\t// send reposition cmd to get out of land mode (will loiter at current position and altitude)\n-\t\tvehicle_command_s vcmd = {};\n-\n-\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n-\t\tvcmd.param1 = -1;\n-\t\tvcmd.param2 = 1;\n-\t\tvcmd.param5 = _navigator->get_global_position()->lat;\n-\t\tvcmd.param6 = _navigator->get_global_position()->lon;\n+\t\tvehicle_command_s vehicle_command{};\n+\t\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n+\t\tvehicle_command.param1 = -1.f; // Default speed\n+\t\tvehicle_command.param2 = 1.f; // Modes should switch, not setting this is unsupported\n+\t\tvehicle_command.param5 = _navigator->get_global_position()->lat;\n+\t\tvehicle_command.param6 = _navigator->get_global_position()->lon;\n \t\t// as we don't know the landing point altitude assume the worst case (abort at 0m above ground),\n \t\t// and thus always climb MIS_LND_ABRT_ALT\n-\t\tvcmd.param7 = _navigator->get_global_position()->alt + _navigator->get_landing_abort_min_alt();\n+\t\tvehicle_command.param7 = _navigator->get_global_position()->alt + _navigator->get_landing_abort_min_alt();\n \n-\t\t_navigator->publish_vehicle_cmd(&vcmd);\n+\t\t_navigator->publish_vehicle_command(vehicle_command);\n \t}\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2de5d746924b62120cd182895fe06e344e8b7ba/src%2Fmodules%2Fnavigator%2Fland.cpp"
      },
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "patch": "@@ -915,16 +915,14 @@ MissionBase::do_abort_landing()\n \t}\n \n \t// send reposition cmd to get out of mission\n-\tvehicle_command_s vcmd = {};\n-\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n-\tvcmd.param1 = -1;\n-\tvcmd.param2 = 1;\n-\tvcmd.param5 = _mission_item.lat;\n-\tvcmd.param6 = _mission_item.lon;\n-\tvcmd.param7 = alt_sp;\n-\n-\t_navigator->publish_vehicle_cmd(&vcmd);\n+\tvehicle_command_s vehicle_command{};\n+\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n+\tvehicle_command.param1 = -1.f; // Default speed\n+\tvehicle_command.param2 = 1.f; // Modes should switch, not setting this is unsupported\n+\tvehicle_command.param5 = _mission_item.lat;\n+\tvehicle_command.param6 = _mission_item.lon;\n+\tvehicle_command.param7 = alt_sp;\n+\t_navigator->publish_vehicle_command(vehicle_command);\n }\n \n void MissionBase::publish_navigator_mission_item()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2de5d746924b62120cd182895fe06e344e8b7ba/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "patch": "@@ -529,27 +529,27 @@ MissionBlock::issue_command(const mission_item_s &item)\n \n \t// Mission item's NAV_CMD enums directly map to the according vehicle command\n \t// So set the raw value directly (MAV_FRAME_MISSION mission item)\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = item.nav_cmd;\n-\tvcmd.param1 = item.params[0];\n-\tvcmd.param2 = item.params[1];\n-\tvcmd.param3 = item.params[2];\n-\tvcmd.param4 = item.params[3];\n-\tvcmd.param5 = static_cast<double>(item.params[4]);\n-\tvcmd.param6 = static_cast<double>(item.params[5]);\n-\tvcmd.param7 = item.params[6];\n+\tvehicle_command_s vehicle_command{};\n+\tvehicle_command.command = item.nav_cmd;\n+\tvehicle_command.param1 = item.params[0];\n+\tvehicle_command.param2 = item.params[1];\n+\tvehicle_command.param3 = item.params[2];\n+\tvehicle_command.param4 = item.params[3];\n+\tvehicle_command.param5 = static_cast<double>(item.params[4]);\n+\tvehicle_command.param6 = static_cast<double>(item.params[5]);\n+\tvehicle_command.param7 = item.params[6];\n \n \tif (item.nav_cmd == NAV_CMD_DO_SET_ROI_LOCATION) {\n \t\t// We need to send out the ROI location that was parsed potentially with double precision to lat/lon because mission item parameters 5 and 6 only have float precision\n-\t\tvcmd.param5 = item.lat;\n-\t\tvcmd.param6 = item.lon;\n+\t\tvehicle_command.param5 = item.lat;\n+\t\tvehicle_command.param6 = item.lon;\n \n \t\tif (item.altitude_is_relative) {\n-\t\t\tvcmd.param7 = item.altitude + _navigator->get_home_position()->alt;\n+\t\t\tvehicle_command.param7 = item.altitude + _navigator->get_home_position()->alt;\n \t\t}\n \t}\n \n-\t_navigator->publish_vehicle_cmd(&vcmd);\n+\t_navigator->publish_vehicle_command(vehicle_command);\n \n \tif (item_has_timeout(item)) {\n \t\t_timestamp_command_timeout = hrt_absolute_time();\n@@ -781,11 +781,11 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \t/* VTOL transition to RW before landing */\n \tif (_navigator->force_vtol()) {\n \n-\t\tvehicle_command_s vcmd = {};\n-\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n-\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n-\t\tvcmd.param2 = 0.0f;\n-\t\t_navigator->publish_vehicle_cmd(&vcmd);\n+\t\tvehicle_command_s vehicle_command{};\n+\t\tvehicle_command.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\tvehicle_command.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\tvehicle_command.param2 = 0.f; // normal unforced transition\n+\t\t_navigator->publish_vehicle_command(vehicle_command);\n \t}\n \n \t/* set the land item */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2de5d746924b62120cd182895fe06e344e8b7ba/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -132,12 +132,12 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \t/**\n \t * @brief Publish a given specified vehicle command\n \t *\n-\t * Sets the target_component of the vehicle command accordingly depending on the\n-\t * vehicle command value (e.g. For Camera control, sets target system component id)\n+\t * Fill in timestamp, source and target IDs.\n+\t * target_component special handling (e.g. For Camera control, set camera ID)\n \t *\n-\t * @param vcmd Vehicle command to execute\n+\t * @param vehicle_command Vehicle command to publish\n \t */\n-\tvoid publish_vehicle_cmd(vehicle_command_s *vcmd);\n+\tvoid publish_vehicle_command(vehicle_command_s &vehicle_command);\n \n #if CONFIG_NAVIGATOR_ADSB\n \t/**",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2de5d746924b62120cd182895fe06e344e8b7ba/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 82,
        "changes": 162,
        "patch": "@@ -662,10 +662,10 @@ void Navigator::run()\n \t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n \n \t\t\t\tif (_mission.get_land_start_available()) {\n-\t\t\t\t\tvehicle_command_s vcmd = {};\n-\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n-\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n-\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n+\t\t\t\t\tvehicle_command_s vehicle_command{};\n+\t\t\t\t\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n+\t\t\t\t\tvehicle_command.param1 = _mission.get_land_start_index();\n+\t\t\t\t\tpublish_vehicle_command(vehicle_command);\n \n \t\t\t\t} else {\n \t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n@@ -864,10 +864,10 @@ void Navigator::run()\n \t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n \t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n \t\t    force_vtol()) {\n-\t\t\tvehicle_command_s vcmd = {};\n-\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n-\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n-\t\t\tpublish_vehicle_cmd(&vcmd);\n+\t\t\tvehicle_command_s vehicle_command{};\n+\t\t\tvehicle_command.command = NAV_CMD_DO_VTOL_TRANSITION;\n+\t\t\tvehicle_command.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n+\t\t\tpublish_vehicle_command(vehicle_command);\n \t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n \t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n \t\t\t\t     \"Transition to hover mode and descend\");\n@@ -1220,28 +1220,28 @@ void Navigator::load_fence_from_file(const char *filename)\n void Navigator::take_traffic_conflict_action()\n {\n \n-\tvehicle_command_s vcmd = {};\n+\tvehicle_command_s vehicle_command{};\n \n \tswitch (_adsb_conflict._conflict_detection_params.traffic_avoidance_mode) {\n \n \tcase 2: {\n \t\t\t_rtl.set_return_alt_min(true);\n-\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_NAV_RETURN_TO_LAUNCH;\n-\t\t\tpublish_vehicle_cmd(&vcmd);\n+\t\t\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_NAV_RETURN_TO_LAUNCH;\n+\t\t\tpublish_vehicle_command(vehicle_command);\n \t\t\tbreak;\n \t\t}\n \n \tcase 3: {\n-\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_NAV_LAND;\n-\t\t\tpublish_vehicle_cmd(&vcmd);\n+\t\t\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_NAV_LAND;\n+\t\t\tpublish_vehicle_command(vehicle_command);\n \t\t\tbreak;\n \n \t\t}\n \n \tcase 4: {\n \n-\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_NAV_LOITER_UNLIM;\n-\t\t\tpublish_vehicle_cmd(&vcmd);\n+\t\t\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_NAV_LOITER_UNLIM;\n+\t\t\tpublish_vehicle_command(vehicle_command);\n \t\t\tbreak;\n \n \t\t}\n@@ -1392,100 +1392,98 @@ void Navigator::publish_navigator_status()\n \t}\n }\n \n-void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n+void Navigator::publish_vehicle_command(vehicle_command_s &vehicle_command)\n {\n-\tvcmd->timestamp = hrt_absolute_time();\n-\tvcmd->source_system = _vstatus.system_id;\n-\tvcmd->source_component = _vstatus.component_id;\n-\tvcmd->target_system = _vstatus.system_id;\n-\tvcmd->confirmation = false;\n-\tvcmd->from_external = false;\n+\tvehicle_command.timestamp = hrt_absolute_time();\n+\tvehicle_command.source_system = _vstatus.system_id;\n+\tvehicle_command.source_component = _vstatus.component_id;\n+\tvehicle_command.target_system = _vstatus.system_id;\n+\tvehicle_command.confirmation = false;\n+\tvehicle_command.from_external = false;\n \n \tint target_camera_component_id;\n \n \t// The camera commands are not processed on the autopilot but will be\n \t// sent to the mavlink links to other components.\n-\tswitch (vcmd->command) {\n-\n-\n+\tswitch (vehicle_command.command) {\n \tcase NAV_CMD_IMAGE_START_CAPTURE:\n \n-\t\tif (static_cast<int>(vcmd->param3) == 1) {\n-\t\t\t// When sending a single capture we need to include the sequence number, thus camera_trigger needs to handle this cmd\n-\t\t\tvcmd->param1 = 0.0f;\n-\t\t\tvcmd->param2 = 0.0f;\n-\t\t\tvcmd->param3 = 0.0f;\n-\t\t\tvcmd->param4 = 0.0f;\n-\t\t\tvcmd->param5 = 1.0;\n-\t\t\tvcmd->param6 = 0.0;\n-\t\t\tvcmd->param7 = 0.0f;\n-\t\t\tvcmd->command = vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL;\n+\t\tif (static_cast<int>(vehicle_command.param3) == 1) {\n+\t\t\t// When sending a single capture we need to include the sequence number, thus camera_trigger needs to handle this command\n+\t\t\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL;\n+\t\t\tvehicle_command.param1 = 0.f; // Session control hide lens\n+\t\t\tvehicle_command.param2 = 0.f; // Zoom absolute position\n+\t\t\tvehicle_command.param3 = 0.f; // Zoom step\n+\t\t\tvehicle_command.param4 = 0.f; // Focus lock\n+\t\t\tvehicle_command.param5 = 1.; // Shoot command\n+\t\t\tvehicle_command.param6 = 0.; // Command identity\n+\t\t\tvehicle_command.param7 = 0.f; // Shot identifier\n \n \t\t} else {\n \t\t\t// We are only capturing multiple if param3 is 0 or > 1.\n \t\t\t// For multiple pictures the sequence number does not need to be included, thus there is no need to go through camera_trigger\n \t\t\t_is_capturing_images = true;\n \t\t}\n \n-\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\t\ttarget_camera_component_id = static_cast<int>(vehicle_command.param1); // Target id from param 1\n \n \t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n-\t\t\tvcmd->target_component = target_camera_component_id;\n+\t\t\tvehicle_command.target_component = target_camera_component_id;\n \n \t\t} else {\n-\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t\tvehicle_command.target_component = 100; // MAV_COMP_ID_CAMERA\n \t\t}\n \n \t\tbreak;\n \n \tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n \t\t_is_capturing_images = false;\n-\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\t\ttarget_camera_component_id = static_cast<int>(vehicle_command.param1); // Target id from param 1\n \n \t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n-\t\t\tvcmd->target_component = target_camera_component_id;\n+\t\t\tvehicle_command.target_component = target_camera_component_id;\n \n \t\t} else {\n-\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t\tvehicle_command.target_component = 100; // MAV_COMP_ID_CAMERA\n \t\t}\n \n \t\tbreak;\n \n \tcase NAV_CMD_SET_CAMERA_MODE:\n-\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\t\ttarget_camera_component_id = static_cast<int>(vehicle_command.param1); // Target id from param 1\n \n \t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n-\t\t\tvcmd->target_component = target_camera_component_id;\n+\t\t\tvehicle_command.target_component = target_camera_component_id;\n \n \t\t} else {\n-\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t\tvehicle_command.target_component = 100; // MAV_COMP_ID_CAMERA\n \t\t}\n \n \t\tbreak;\n \n \tcase NAV_CMD_SET_CAMERA_SOURCE:\n-\t\ttarget_camera_component_id = static_cast<int>(vcmd->param1); // Target id from param 1\n+\t\ttarget_camera_component_id = static_cast<int>(vehicle_command.param1); // Target id from param 1\n \n \t\tif (target_camera_component_id > 0 && target_camera_component_id < 256) {\n-\t\t\tvcmd->target_component = target_camera_component_id;\n+\t\t\tvehicle_command.target_component = target_camera_component_id;\n \n \t\t} else {\n-\t\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\t\tvehicle_command.target_component = 100; // MAV_COMP_ID_CAMERA\n \t\t}\n \n \t\tbreak;\n \n \tcase NAV_CMD_VIDEO_START_CAPTURE:\n \tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n-\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n+\t\tvehicle_command.target_component = 100; // MAV_COMP_ID_CAMERA\n \t\tbreak;\n \n \tdefault:\n-\t\tvcmd->target_component = 0;\n+\t\tvehicle_command.target_component = 0;\n \t\tbreak;\n \t}\n \n-\t_vehicle_cmd_pub.publish(*vcmd);\n+\t_vehicle_cmd_pub.publish(vehicle_command);\n }\n \n void Navigator::publish_distance_sensor_mode_request()\n@@ -1531,37 +1529,37 @@ void Navigator::publish_vehicle_command_ack(const vehicle_command_s &cmd, uint8_\n \n void Navigator::acquire_gimbal_control()\n {\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_CONFIGURE;\n-\tvcmd.param1 = _vstatus.system_id;\n-\tvcmd.param2 = _vstatus.component_id;\n-\tvcmd.param3 = -1.0f; // Leave unchanged.\n-\tvcmd.param4 = -1.0f; // Leave unchanged.\n-\tpublish_vehicle_cmd(&vcmd);\n+\tvehicle_command_s vehicle_command{};\n+\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_CONFIGURE;\n+\tvehicle_command.param1 = _vstatus.system_id; // Take primary control\n+\tvehicle_command.param2 = _vstatus.component_id;\n+\tvehicle_command.param3 = -1.f; // Leave secondary control unchanged\n+\tvehicle_command.param4 = -1.f;\n+\tpublish_vehicle_command(vehicle_command);\n }\n \n void Navigator::release_gimbal_control()\n {\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_CONFIGURE;\n-\tvcmd.param1 = -3.0f; // Remove control if it had it.\n-\tvcmd.param2 = -3.0f; // Remove control if it had it.\n-\tvcmd.param3 = -1.0f; // Leave unchanged.\n-\tvcmd.param4 = -1.0f; // Leave unchanged.\n-\tpublish_vehicle_cmd(&vcmd);\n+\tvehicle_command_s vehicle_command{};\n+\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_CONFIGURE;\n+\tvehicle_command.param1 = -3.f; // Remove primary control if it was taken\n+\tvehicle_command.param2 = -3.f;\n+\tvehicle_command.param3 = -1.f; // Leave secondary control unchanged\n+\tvehicle_command.param4 = -1.f;\n+\tpublish_vehicle_command(vehicle_command);\n }\n \n \n void\n Navigator::stop_capturing_images()\n {\n \tif (_is_capturing_images) {\n-\t\tvehicle_command_s vcmd = {};\n-\t\tvcmd.command = NAV_CMD_IMAGE_STOP_CAPTURE;\n-\t\tvcmd.param1 = 0.0f;\n-\t\tpublish_vehicle_cmd(&vcmd);\n+\t\tvehicle_command_s vehicle_command{};\n+\t\tvehicle_command.command = NAV_CMD_IMAGE_STOP_CAPTURE;\n+\t\tvehicle_command.param1 = 0.f;\n+\t\tpublish_vehicle_command(vehicle_command);\n \n-\t\t// _is_capturing_images is reset inside publish_vehicle_cmd.\n+\t\t// _is_capturing_images is reset inside publish_vehicle_command.\n \t}\n }\n \n@@ -1607,24 +1605,24 @@ void Navigator::mode_completed(uint8_t nav_state, uint8_t result)\n void Navigator::disable_camera_trigger()\n {\n \t// Disable camera trigger\n-\tvehicle_command_s cmd {};\n-\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n+\tvehicle_command_s vehicle_command{};\n+\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n \t// Pause trigger\n-\tcmd.param1 = -1.0f;\n-\tcmd.param3 = 1.0f;\n-\tpublish_vehicle_cmd(&cmd);\n+\tvehicle_command.param1 = -1.f;\n+\tvehicle_command.param3 = 1.f;\n+\tpublish_vehicle_command(vehicle_command);\n }\n \n void Navigator::set_gimbal_neutral()\n {\n-\tvehicle_command_s vcmd = {};\n-\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_PITCHYAW;\n-\tvcmd.param1 = NAN;\n-\tvcmd.param2 = NAN;\n-\tvcmd.param3 = NAN;\n-\tvcmd.param4 = NAN;\n-\tvcmd.param5 = gimbal_manager_set_attitude_s::GIMBAL_MANAGER_FLAGS_NEUTRAL;\n-\tpublish_vehicle_cmd(&vcmd);\n+\tvehicle_command_s vehicle_command{};\n+\tvehicle_command.command = vehicle_command_s::VEHICLE_CMD_DO_GIMBAL_MANAGER_PITCHYAW;\n+\tvehicle_command.param1 = NAN; // Don't set any angles\n+\tvehicle_command.param2 = NAN;\n+\tvehicle_command.param3 = NAN; // Don't set any angular velocities\n+\tvehicle_command.param4 = NAN;\n+\tvehicle_command.param5 = gimbal_manager_set_attitude_s::GIMBAL_MANAGER_FLAGS_NEUTRAL;\n+\tpublish_vehicle_command(vehicle_command);\n }\n \n void Navigator::sendWarningDescentStoppedDueToTerrain()",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/b2de5d746924b62120cd182895fe06e344e8b7ba/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::publish_navigator_status",
        "Navigator::mode_completed",
        "value",
        "Navigator::run",
        "Navigator::publish_vehicle_command_ack",
        "Land::on_active",
        "MissionBlock::issue_command",
        "publish_vehicle_cmd",
        "MissionBlock::set_land_item",
        "MissionBase::do_abort_landing",
        "Navigator::publish_vehicle_cmd",
        "Navigator::load_fence_from_file"
      ],
      "by_file": {
        "src/modules/navigator/land.cpp": [
          "Land::on_active"
        ],
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::do_abort_landing"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::issue_command",
          "MissionBlock::set_land_item"
        ],
        "src/modules/navigator/navigator.h": [
          "publish_vehicle_cmd",
          "value"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_navigator_status",
          "Navigator::mode_completed",
          "Navigator::run",
          "Navigator::publish_vehicle_command_ack",
          "Navigator::publish_vehicle_cmd",
          "Navigator::load_fence_from_file"
        ]
      }
    }
  },
  {
    "title": "Rover: Update RTL behaviour and land detection",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24642",
    "number": 24642,
    "created_at": "2025-03-31T14:09:28Z",
    "merged": true,
    "merged_at": "2025-05-07T15:42:07Z",
    "state": "closed",
    "conversation": {
      "author": "chfriedrich98",
      "body": "<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\n1. All the states prior to `LAND` in the direct RTL state machine are unnecessary if the vehicle is of type `ROVER`.\r\n2. The parameter used for RTL time calculation for rovers is outdated\r\n3. In mission fast reverse there is a hanging `NEXT` waypoint.\r\n4. Rover land detection only detects landing during RTL if the return point is home, which does not work if the vehicle is supposed to return to a rally point etc.\r\n\r\n### Solution\r\n1. Direclty skip to `LAND` state on activation if the vehicle type is `ROVER`.\r\n2. Replace with correct parameter `RO_SPEED_LIM`.\r\n3. Reset the `NEXT` waypoint when landing starts.\r\n4. During RTL check if the `NEXT` waypoint is invalid which indicates that the `CURRENT` waypoint is the final waypoint.\r\n    Set the vehicle to `LANDED` if the distance to the current waypoint is less than `NAV_ACC_RAD` \r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-04-01T08:40:45Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: -120 byte (-0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  -0.0%    -327  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    -8.9%    -256  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -4.5%    -127  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n  -0.0%     -24  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -3.2%      -8  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -7.1%      -8  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n  -0.0%     -72  [ = ]       0    .debug_frame\n  -0.0% -10.5Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n   -14.8% -6.18Ki  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -9.4% -4.32Ki  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +0.0%     +21  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%    -678  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n   -18.9%    -654  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -0.2%      -9  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +0.1%      +6  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.1%      +8  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    -0.4%      -4  [ = ]       0    task/task_cancelpt.c\n  -0.0% -1.91Ki  [ = ]       0    .debug_loc\n   -46.9% -1.27Ki  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n   -28.3%    -657  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n  -0.0%    -390  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n   -51.8%    -344  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n   -10.6%     -40  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +3.1%      +2  [ = ]       0    task/task_cancelpt.c\n  -0.0%     -39  [ = ]       0    .debug_str\n   -14.5%     -59  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -5.6%    -926  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +1.6%    +852  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +6.6%     +94  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n  -0.9%      -2  [ = ]       0    .shstrtab\n  -0.0%     -78  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    +1.5%     +10  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n   -11.4%     -84  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    -0.5%      -4  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.1%     +32  [ = ]       0    [section .strtab]\n  -0.0%     -64  [ = ]       0    .symtab\n    +2.7%     +16  [ = ]       0    ../../src/drivers/uavcan/actuators/hardpoint.cpp\n    -5.4%     -48  [ = ]       0    ../../src/lib/version/version.c\n    +0.9%     +16  [ = ]       0    ../../src/modules/control_allocator/ControlAllocator.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n   -11.6%     -80  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    -0.8%     -16  [ = ]       0    ../../src/modules/sensors/sensors.cpp\n    +0.1%     +32  [ = ]       0    [section .symtab]\n  +0.2%    +120  [ = ]       0    [Unmapped]\n  -0.0%    -120  -0.0%    -120    .text\n    +0.5%     +16  +0.5%     +16    ../../src/modules/navigator/rtl_direct.cpp\n    +1.0%     +12  +1.0%     +12    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.0%      +5  +0.0%      +5    [section .text]\n    +0.6%      +4  +0.6%      +4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +0.2%      +3  +0.2%      +3    ../../src/systemcmds/ver/ver.cpp\n    +1.9%      +2  +1.9%      +2    ../../src/modules/land_detector/AirshipLandDetector.cpp\n    -0.0%      -4  -0.0%      -4    ../../src/modules/logger/logger.cpp\n    -4.4%     -52  -4.4%     -52    ../../src/modules/land_detector/land_detector_main.cpp\n   -28.8%    -106 -28.8%    -106    ../../src/modules/land_detector/RoverLandDetector.cpp\n  -0.0% -14.0Ki  -0.0%    -120    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: -128 byte (-0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  -0.0%    -327  [ = ]       0    .debug_abbrev\n     +11%     +56  [ = ]       0    ../../src/lib/version/version.c\n    -8.9%    -256  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -4.5%    -127  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n  -0.0%     -24  [ = ]       0    .debug_aranges\n    -5.0%      -8  [ = ]       0    ../../src/lib/version/version.c\n    -3.2%      -8  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -7.1%      -8  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n  -0.0%     -72  [ = ]       0    .debug_frame\n  -0.0% -10.5Ki  [ = ]       0    .debug_info\n    -0.2%      -4  [ = ]       0    ../../src/lib/version/version.c\n   -15.0% -6.18Ki  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -9.5% -4.32Ki  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +0.0%     +21  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n  -0.0%    -670  [ = ]       0    .debug_line\n    -1.3%     -25  [ = ]       0    ../../src/lib/version/version.c\n   -18.9%    -654  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -0.2%      -9  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +0.1%      +6  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.1%      +8  [ = ]       0    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.4%      +4  [ = ]       0    task/task_cancelpt.c\n  -0.0% -1.91Ki  [ = ]       0    .debug_loc\n   -46.9% -1.27Ki  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n   -28.3%    -657  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n  -0.0%    -390  [ = ]       0    .debug_ranges\n    -2.6%      -8  [ = ]       0    ../../src/lib/version/version.c\n   -51.8%    -344  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n   -10.6%     -40  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +3.1%      +2  [ = ]       0    task/task_cancelpt.c\n  -0.0%     -39  [ = ]       0    .debug_str\n   -14.5%     -59  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n    -5.6%    -926  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    +1.6%    +852  [ = ]       0    ../../src/modules/navigator/navigator_main.cpp\n    +6.6%     +94  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n  -0.9%      -2  [ = ]       0    .shstrtab\n  -0.0%     -78  [ = ]       0    .strtab\n    -8.1%     -32  [ = ]       0    ../../src/lib/version/version.c\n    +1.5%     +10  [ = ]       0    ../../src/modules/land_detector/RoverLandDetector.cpp\n   -11.4%     -84  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    -0.5%      -4  [ = ]       0    ../../src/modules/navigator/rtl_direct.cpp\n    +0.0%     +32  [ = ]       0    [section .strtab]\n  -0.0%     -64  [ = ]       0    .symtab\n    +2.8%     +16  [ = ]       0    ../../src/drivers/uavcan/actuators/hardpoint.cpp\n    -7.0%     -64  [ = ]       0    ../../src/lib/version/version.c\n    +0.9%     +16  [ = ]       0    ../../src/modules/control_allocator/ControlAllocator.cpp\n    +0.3%     +16  [ = ]       0    ../../src/modules/fw_pos_control/FixedwingPositionControl.cpp\n   -11.6%     -80  [ = ]       0    ../../src/modules/land_detector/land_detector_main.cpp\n    -0.8%     -16  [ = ]       0    ../../src/modules/sensors/sensors.cpp\n    +0.1%     +48  [ = ]       0    [section .symtab]\n  +0.2%    +128  [ = ]       0    [Unmapped]\n  -0.0%    -128  -0.0%    -128    .text\n    +0.5%     +16  +0.5%     +16    ../../src/modules/navigator/rtl_direct.cpp\n    +1.0%     +12  +1.0%     +12    ../../src/modules/navigator/rtl_mission_fast_reverse.cpp\n    +0.6%      +4  +0.6%      +4    ../../src/modules/navigator/mission_feasibility_checker.cpp\n    +1.9%      +2  +1.9%      +2    ../../src/modules/land_detector/AirshipLandDetector.cpp\n    -0.0%      -4  -0.0%      -4    ../../src/modules/logger/logger.cpp\n    -4.4%     -52  -4.4%     -52    ../../src/modules/land_detector/land_detector_main.cpp\n   -28.8%    -106 -28.8%    -106    ../../src/modules/land_detector/RoverLandDetector.cpp\n  -0.0% -14.0Ki  -0.0%    -128    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-05-07T10:05:50_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2025-04-07T07:22:37Z",
          "body": "Wouldn't it be nicer to include this extra rover logic in `getActivationLandState()` as well?",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "chfriedrich98",
          "created_at": "2025-05-07T10:03:47Z",
          "body": "In [e89f607](https://github.com/PX4/PX4-Autopilot/pull/24642/commits/e89f607c7a50d2ce41f6af797f460ddc1fa8c28c) renamed the function to `getActivationState()`, which is more accurate and moved the rover check into the function as you proposed.",
          "path": "src/modules/navigator/rtl_direct.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-04-07T07:24:58Z",
          "body": "Agree, only have one comment.",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "chfriedrich98",
          "created_at": "2025-05-07T10:03:47Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-05-07T15:41:47Z",
          "body": "Thanks!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes multiple incorrect behavioral conditions and state transitions: it changes the RTL state machine to skip unnecessary states for ROVERs, replaces an outdated parameter used in RTL timing, resets the NEXT waypoint to avoid a hanging waypoint in mission fast-reverse, and corrects the land-detection condition to detect landing at the final waypoint even when returning to a rally point. These are all logic issues (incorrect condition checks and improper state handling) rather than syntax or style fixes.",
    "patches": {
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "patch": "@@ -77,7 +77,7 @@ void RtlDirect::on_activation()\n \n \tparameters_update();\n \n-\t_rtl_state = getActivationLandState();\n+\t_rtl_state = getActivationState();\n \n \t// reset cruising speed and throttle to default for RTL\n \t_navigator->reset_cruising_speed();\n@@ -405,24 +405,28 @@ void RtlDirect::set_rtl_item()\n \tpublish_rtl_direct_navigator_mission_item(); // for logging\n }\n \n-RtlDirect::RTLState RtlDirect::getActivationLandState()\n+RtlDirect::RTLState RtlDirect::getActivationState()\n {\n \t_land_detected_sub.update();\n \n-\tRTLState land_state;\n+\tRTLState activation_state;\n \n-\tif (_land_detected_sub.get().landed) {\n+\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n+\t\t// Skip to LAND state if we are a rover\n+\t\tactivation_state = RTLState::LAND;\n+\n+\t} else if (_land_detected_sub.get().landed) {\n \t\t// For safety reasons don't go into RTL if landed.\n-\t\tland_state = RTLState::IDLE;\n+\t\tactivation_state = RTLState::IDLE;\n \n \t} else if ((_global_pos_sub.get().alt < _rtl_alt) || _enforce_rtl_alt) {\n-\t\tland_state = RTLState::CLIMBING;\n+\t\tactivation_state = RTLState::CLIMBING;\n \n \t} else {\n-\t\tland_state = RTLState::MOVE_TO_LOITER;\n+\t\tactivation_state = RTLState::MOVE_TO_LOITER;\n \t}\n \n-\treturn land_state;\n+\treturn activation_state;\n }\n \n rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n@@ -438,7 +442,7 @@ rtl_time_estimate_s RtlDirect::calc_rtl_time_estimate()\n \t\tstart_state_for_estimate = _rtl_state;\n \n \t} else {\n-\t\tstart_state_for_estimate = getActivationLandState();\n+\t\tstart_state_for_estimate = getActivationState();\n \t}\n \n \t// Calculate RTL time estimate only when there is a valid destination",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e89f607c7a50d2ce41f6af797f460ddc1fa8c28c/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct.h": {
        "filename": "src/modules/navigator/rtl_direct.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -159,7 +159,7 @@ class RtlDirect : public MissionBlock, public ModuleParams\n \t */\n \tvoid publish_rtl_direct_navigator_mission_item();\n \n-\tRTLState getActivationLandState();\n+\tRTLState getActivationState();\n \n \tvoid setLoiterPosition();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e89f607c7a50d2ce41f6af797f460ddc1fa8c28c/src%2Fmodules%2Fnavigator%2Frtl_direct.h"
      },
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -269,6 +269,7 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t\t_mission_item.altitude = _home_pos_sub.get().alt;\n \t\t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n+\t\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->next);\n \n \t\t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n \n@@ -278,6 +279,7 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n \t}\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/e89f607c7a50d2ce41f6af797f460ddc1fa8c28c/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlDirect::on_activation",
        "RtlDirect::set_rtl_item",
        "RtlDirect::getActivationLandState",
        "RtlMissionFastReverse::handleLanding",
        "RtlDirect::calc_rtl_time_estimate",
        "getActivationLandState"
      ],
      "by_file": {
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::on_activation",
          "RtlDirect::set_rtl_item",
          "RtlDirect::getActivationLandState",
          "RtlDirect::calc_rtl_time_estimate"
        ],
        "src/modules/navigator/rtl_direct.h": [
          "getActivationLandState"
        ],
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::handleLanding"
        ]
      }
    }
  },
  {
    "title": "Add FW loiter size and orientation control",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24625",
    "number": 24625,
    "created_at": "2025-03-27T23:30:32Z",
    "merged": false,
    "merged_at": null,
    "state": "open",
    "conversation": {
      "author": "ryanjAA",
      "body": "Fixes: https://github.com/PX4/PX4-Autopilot/issues/24612\r\n\r\nParams 3 and 4 handling are missing. This adds it in.\r\n\r\nParam 3 now will respond to a loiter size and param 4 to 0/1 for CW/CCW. \r\n\r\nAlso, on alt only changes if you omit param3/4 it explicitly does what you have set as your default (rather than last done which is how it is now) to ensure you get the default unless the param is passed.\r\n\r\nhttps://logs.px4.io/plot_app?log=61232f4d-fa71-4965-bd37-0be6c4740bb8\r\n(Main from today)\r\n\r\n\r\nhttps://discord.com/channels/1022170275984457759/1022186266957201480/1224558850179469414\r\nhttps://discord.com/channels/1022170275984457759/1022186266957201480/1354505832426901546\r\n\r\n",
      "issue_comments": [
        {
          "author": "ryanjAA",
          "created_at": "2025-03-27T23:31:28Z",
          "body": "@sfuhrer \r\n\r\n\r\nAlso, this allows QGC to expose loiter size and direction control",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-30T16:00:57Z",
          "body": "And alternative is to use https://mavlink.io/en/messages/common.html#MAV_CMD_DO_ORBIT. We already have support on the PX4 side for it, incl. [direction change](https://github.com/PX4/PX4-Autopilot/blob/ff8c4b918a81e36ee4e6910e0562c4fe312d9bf8/src/modules/navigator/navigator_main.cpp#L528).\r\n@ryanjAA how do you intend to use this change? Will you change QGC along it or how do you send the reposition?",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2025-04-29T09:56:22Z",
          "body": "```suggestion\r\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param3) && cmd.param3 > FLT_EPSILON) {\r\n```",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-29T10:03:21Z",
          "body": "Do we really need this separate handling? In the `only_alt_change_requested` case we, as the name says, want to keep everything beside the altitude as it was set before, no?",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 47,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-29T10:04:41Z",
          "body": "```suggestion\r\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = (PX4_ISFINITE(cmd.param4) && (cmd.param4 >= FLT_EPSILON));\r\n```\r\nThat's more robust to detect >0 than comparing against a float 1.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2025-04-29T23:09:06Z",
          "body": "Ya, that's definitely better. Good call.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "ryanjAA",
          "created_at": "2025-04-29T23:17:06Z",
          "body": "I added this so when a 'change-altitude-only' command  is sent (i.e. param3 and param4 omitted), we explicitly apply the vehicleâ€™s default loiter radius and direction, exactly the behavior people expect today. Without this, the vehicle would continue using the previous radius/direction settings, which can be surprising.\r\n\r\nAlso, this makes the behavior match the MAVLink specâ€™s intent that omitted parameters revert to defaults.\r\n\r\nThat said, I don't actually care but I do think it's the right thing.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 47,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-30T15:51:36Z",
          "body": "@ryanjAA I still challenge that it's expected that if you send a \"change altitude\" through QGC the loiter direction changes (see screen-recording). \r\nCould QGC send a full GoTo setpoint again? Probably, but it's currently not doing it, thus this change changes the current behavior.\r\n\r\n[Screencast from 30-04-25 17:48:25.webm](https://github.com/user-attachments/assets/acdbdce1-3ce8-426d-a007-ea3d8c5b0610)\r\n",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 47,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-30T16:07:17Z",
          "body": "> Also, this makes the behavior match the MAVLink specâ€™s intent that omitted parameters revert to defaults.\r\n\r\nBut then the lat/long fields should also not being assumed but reset to e.g. the current vehicle position. Currently there it keeps the lat/long from the previous setpoint.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 47,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-04-29T10:05:56Z",
          "body": "Thanks for your contribution and sorry for the slow response. This looks largely good and follows the mavlink standard, I only have some small remarks.",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "ryanjAA",
          "created_at": "2025-04-29T23:09:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "ryanjAA",
          "created_at": "2025-04-29T23:17:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-30T15:51:36Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-04-30T16:07:18Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR addresses missing handling of params 3 and 4 (loiter size and direction) which caused the vehicle to ignore those inputs (incorrect behavior). It also fixes improper state/default handling for altitude-only commands (previously retained last-used values instead of applying configured defaults), which is a logic/state management bug.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 8,
        "changes": 34,
        "patch": "@@ -310,17 +310,35 @@ void Navigator::run()\n \t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n \t\t\t\t\t}\n \n-\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n-\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n-\n-\t\t\t\t\t// Go on and check which changes had been requested\n-\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n-\t\t\t\t\t\trep->current.yaw = cmd.param4;\n+\t\t\t\t\t// (3) Loiter radius (param3)\n+\t\t\t\t\tif (PX4_ISFINITE(cmd.param3) && cmd.param3 > FLT_EPSILON) {\n+\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param3);\n \n \t\t\t\t\t} else {\n+\t\t\t\t\t\t// Use current or default if param3 not valid\n+\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// (4) Loiter direction / yaw (param4)\n+\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n+\t\t\t\t\t\t// param4 >= 1 => counter-clockwise, else default CW\n+\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = (PX4_ISFINITE(cmd.param4) && (cmd.param4 >= FLT_EPSILON));\n \t\t\t\t\t\trep->current.yaw = NAN;\n+\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// multicopter => param4 = yaw\n+\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n+\t\t\t\t\t\t\trep->current.yaw = cmd.param4;\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\trep->current.yaw = NAN;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \n+\n+\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n+\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n+\n \t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n \t\t\t\t\t\t// Position change with optional altitude change\n \t\t\t\t\t\trep->current.lat = cmd.param5;\n@@ -392,7 +410,7 @@ void Navigator::run()\n \t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n+\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = (PX4_ISFINITE(cmd.param4) ? (cmd.param4 >= 1.0f) : false);\n \t\t\t\t\t}\n \n \t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n@@ -474,7 +492,7 @@ void Navigator::run()\n \t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n \t\t\t\t\t}\n \n-\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n+\t\t\t\t\trep->current.loiter_direction_counter_clockwise = (PX4_ISFINITE(cmd.param4) ? (cmd.param4 >= 1.0f) : false);\n \n \t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ac4faa24fba4c77c718042a96cae713ddbc43695/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Add RTL_TYPE to continue or reverse",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24581",
    "number": 24581,
    "created_at": "2025-03-21T00:02:28Z",
    "merged": true,
    "merged_at": "2025-03-27T17:29:42Z",
    "state": "closed",
    "conversation": {
      "author": "julianoes",
      "body": "This adds RTL_TYPE 4 which means continue the mission or reverse back to the takeoff location, whichever is closer in terms of mission items in-between.\r\n\r\nThis would be nicer to have on a distance rather than mission item count basis but that would require access to the dataman and make it more complex.",
      "issue_comments": [
        {
          "author": "dakejahl",
          "created_at": "2025-03-21T02:36:26Z",
          "body": "could you precalculate (on uploador init) an array of distances corresponding to the distance between each waypoint? ",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2025-03-27T17:29:10Z",
          "body": "@KonradRudin (and @dakejahl) that's a good idea, I like it! I'm not sure it's worth the trouble at this point though.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2025-03-21T02:37:14Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "KonradRudin",
          "created_at": "2025-03-24T14:48:16Z",
          "body": "LGTM. as @dakejahl mentioned, you could extend the mission_item_s struct to include a mission_distance_to_point value which calculates the mission distance from beginning up to this point. This can be calculated when uploading a mission. Then you can check if the distance to the current waypoint is larger then the distance from this waypoint to the land item. However this would increase the storage size and you would need to cache the current mision item in the RTL class as well. Not sure if it is worth the trouble.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR introduces a new RTL mode (continue or reverse) based on mission-item count, which is a feature addition/behavior choice rather than a correction of incorrect program logic. Review comments discuss potential improvements (using distance) but do not identify or correct an existing logic bug or unintended behavior.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "patch": "@@ -318,7 +318,7 @@ void RTL::setRtlTypeAndDestination()\n \n \tuint8_t safe_point_index{0U};\n \n-\tif (_param_rtl_type.get() != 2) {\n+\tif (_param_rtl_type.get() != 2 && _param_rtl_type.get() != 4) {\n \t\t// check the closest allowed destination.\n \t\tDestinationType destination_type{DestinationType::DESTINATION_TYPE_HOME};\n \t\tPositionYawSetpoint rtl_position;\n@@ -566,6 +566,14 @@ void RTL::init_rtl_mission_type()\n \t\t} else {\n \t\t\tnew_rtl_mission_type = RtlType::RTL_MISSION_FAST_REVERSE;\n \t\t}\n+\n+\t} else if (_param_rtl_type.get() == 4) {\n+\t\tif (hasMissionLandStart() && reverseIsFurther()) {\n+\t\t\tnew_rtl_mission_type = RtlType::RTL_MISSION_FAST;\n+\n+\t\t} else {\n+\t\t\tnew_rtl_mission_type = RtlType::RTL_MISSION_FAST_REVERSE;\n+\t\t}\n \t}\n \n \tif (_set_rtl_mission_type == new_rtl_mission_type) {\n@@ -630,6 +638,12 @@ bool RTL::hasMissionLandStart() const\n \t       && _navigator->get_mission_result()->valid;\n }\n \n+bool RTL::reverseIsFurther() const\n+{\n+\treturn (_mission_sub.get().land_start_index - _mission_sub.get().current_seq) < _mission_sub.get().current_seq;\n+}\n+\n+\n bool RTL::hasVtolLandApproach(const PositionYawSetpoint &rtl_position) const\n {\n \treturn readVtolLandApproaches(rtl_position).isAnyApproachValid();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0240aac67ecde0bded7fd6a3de841ad7a6a81303/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -105,6 +105,14 @@ class RTL : public NavigatorMode, public ModuleParams\n \t */\n \tbool hasMissionLandStart() const;\n \n+\n+\t/**\n+\t * @brief Check whether there are more waypoints between current waypoint\n+\t *        and the takeoff location than the end/land location.\n+\t * @return true if the reverse is more items away.\n+\t */\n+\tbool reverseIsFurther() const;\n+\n \t/**\n \t * @brief function to call regularly to do background work\n \t */",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0240aac67ecde0bded7fd6a3de841ad7a6a81303/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -112,6 +112,7 @@ PARAM_DEFINE_FLOAT(RTL_MIN_DIST, 10.0f);\n  * @value 1 Return to closest safe point other than home (mission landing pattern or rally point), via direct path. If no mission landing or rally points are defined return home via direct path. Always chose closest safe landing point if vehicle is a VTOL in hover mode.\n  * @value 2 Return to a planned mission landing, if available, using the mission path, else return to home via the reverse mission path. Do not consider rally points.\n  * @value 3 Return via direct path to closest destination: home, start of mission landing pattern or safe point. If the destination is a mission landing pattern, follow the pattern to land.\n+ * @value 4 Return to the planned mission landing, or to home via the reverse mission path, whichever is closer by counting waypoints. Do not consider rally points.\n  * @group Return Mode\n  */\n PARAM_DEFINE_INT32(RTL_TYPE, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0240aac67ecde0bded7fd6a3de841ad7a6a81303/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::init_rtl_mission_type",
        "RTL::hasMissionLandStart",
        "RTL::setRtlTypeAndDestination"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::init_rtl_mission_type",
          "RTL::hasMissionLandStart",
          "RTL::setRtlTypeAndDestination"
        ]
      }
    }
  },
  {
    "title": "Fixed-wing: loiter after takeoff is established at current position, not around Home",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24508",
    "number": 24508,
    "created_at": "2025-03-13T15:07:22Z",
    "merged": true,
    "merged_at": "2025-03-17T10:52:12Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Alternative to https://github.com/PX4/PX4-Autopilot/pull/24454, fixes https://github.com/PX4/PX4-Autopilot/issues/24496#issuecomment-2719544023\r\n\r\n### Solved Problem\r\nSee https://github.com/PX4/PX4-Autopilot/pull/24454\r\n\r\n### Solution\r\nDo a if(MC) check, and keep current logic only for MC, while for FW establish loiter always at current position. \r\nReason for differentiation MC/FW: And MC takeoff is considered complete before reaching set altitude, while for [FW it has to achieve the altitude fully](https://github.com/PX4/PX4-Autopilot/blob/e0d15b7a8042cfb38dcba6a064eb8685646526c0/src/modules/navigator/mission_block.cpp#L205). \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: fixed-wing: loiter after takeoff is established at current position, not around Home\r\n```\r\n\r\n### Alternatives\r\n- We could add a method `setLoiterItemFromCurrentAltitudeSetpoint()` which sets a loiter at the current lateral position but doesn't overwrite the existing altitude setpoint field. \r\n- align FW/MC in that the takeoff altitude always has to be fully reached before declaring the takeoff completed. ",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "dakejahl",
          "created_at": "2025-03-13T18:38:29Z",
          "body": "In #24454 all of this logic was removed. Is it intended to add back this and below logic? Or should we do the VEHICLE_TYPE_ROTARY_WING check higher up to maintain the changes in #24454 for non-multicopter?",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 17,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-17T10:51:39Z",
          "body": "Let's play it save now and do the minimal-invasive change compared to main from one week ago. And that means only patch the line here.",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 17,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2025-03-13T18:38:31Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dakejahl",
          "created_at": "2025-03-14T18:23:47Z",
          "body": "Merging this now so that CI is fixed so other PRs can merge",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-17T10:51:39Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR changes control flow to differentiate multicopter (MC) and fixedâ€‘wing (FW) behavior so that loiter after takeoff for FW is established at the aircraft's current position rather than around Home. This corrects an incorrect state/behavior (wrong loiter location) caused by a shared logic path and thus fixes a logic bug in the mission/takeoff handling.",
    "patches": {
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "patch": "@@ -69,6 +69,26 @@ Takeoff::on_active()\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n \t\t_navigator->mode_completed(getNavigatorStateId());\n+\n+\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t\t// set loiter item so position controllers stop doing takeoff logic\n+\t\tif (_navigator->get_land_detected()->landed) {\n+\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n+\n+\t\t} else {\n+\t\t\tif (pos_sp_triplet->current.valid\n+\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\n+\t\t\t} else {\n+\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n+\t\t\t}\n+\t\t}\n+\n+\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\n+\t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/8612d5f74a49e39bb65a2596045a079a28327063/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Takeoff::on_active"
      ],
      "by_file": {
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "MissionBase: replay change speed on resume immediately if not going to  previous",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24484",
    "number": 24484,
    "created_at": "2025-03-11T09:36:57Z",
    "merged": true,
    "merged_at": "2025-03-12T08:17:58Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nThis fixes an issue where the speed was not correctly set at the beginning of a survey (with first wp having a DO_CHANGE_SPEED attached) when the user paused and resumed the mission prior to reaching the first waypoint.\r\n\r\nSee following screen recording: mission is paused before reaching the survey, and on resume the survey speed is not applied.\r\n\r\nhttps://github.com/user-attachments/assets/10b6ff69-2af9-4749-86a5-003cdd038ec9\r\n\r\nDigging further down: when resuming the mission, the previous DO_CHANGE_SPEED are not immediately replayed but only once the next waypoint is reached. In the case here, this coincides with the next DO_CHANGE_SPEED (12) of the survey, which is thus overwritten by the previous DO_CHANGE_SPEED (5), and the survey is flown at 5m/s instead of 12.\r\n\r\n### Solution\r\nReplay DO_CHANGE_SPEED setpoints immediately on mission resume unless the vehicle first has to go back to previous waypoint.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix XYZ\r\nNew parameter: XYZ_Z\r\nDocumentation: Need to clarify page ... / done, read docs.px4.io/...\r\n```\r\n\r\n### Test coverage\r\nSITL tests with quad and survey pattern (which has a different mission speed defined as rest of mission).\r\n\r\n### Context\r\nThis is a follow up to https://github.com/PX4/PX4-Autopilot/pull/23484.\r\n",
      "issue_comments": [],
      "review_comments": [
        {
          "author": "StefanoColli",
          "created_at": "2025-03-11T10:25:18Z",
          "body": "```suggestion\r\n\t\t// Only replay speed changes immediately if we are not resuming the mission at the previous position item.\r\n```",
          "path": "src/modules/navigator/mission_base.cpp",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "StefanoColli",
          "created_at": "2025-03-11T14:13:42Z",
          "body": "Nice catch! There is only a small typo to be corrected",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "StefanoColli",
          "created_at": "2025-03-11T16:20:50Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes a logic error: on mission resume the code delayed replaying DO_CHANGE_SPEED setpoints until the next waypoint, causing incorrect speed to be active (a state/flow timing bug). The change updates the resume logic to immediately replay change-speed commands unless the vehicle must first return to the previous waypoint, correcting the unintended behavior.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "patch": "@@ -218,6 +218,8 @@ MissionBase::on_activation()\n \n \tint32_t resume_index = _inactivation_index > 0 ? _inactivation_index : 0;\n \n+\tbool resume_mission_on_previous = false;\n+\n \tif (_inactivation_index > 0 && cameraWasTriggering()) {\n \t\tsize_t num_found_items{0U};\n \t\tgetPreviousPositionItems(_inactivation_index - 1, &resume_index, num_found_items, 1U);\n@@ -229,9 +231,20 @@ MissionBase::on_activation()\n \t\t\tsetMissionIndex(resume_index);\n \n \t\t\t_align_heading_necessary = true;\n+\t\t\tresume_mission_on_previous = true;\n \t\t}\n \t}\n \n+\tif (!resume_mission_on_previous) {\n+\t\t// Only replay speed changes immediately if we are not resuming the mission at the previous position item.\n+\t\t// Otherwise it must be handled in the on_active() method once we reach the previous position item.\n+\t\treplayCachedSpeedChangeItems();\n+\t\t_speed_replayed_on_activation = true;\n+\n+\t} else {\n+\t\t_speed_replayed_on_activation = false;\n+\t}\n+\n \tcheckClimbRequired(_mission.current_seq);\n \tset_mission_items();\n \n@@ -304,14 +317,16 @@ MissionBase::on_active()\n \t\treplayCachedGimbalItems();\n \t}\n \n-\t// Replay cached mission commands once the last mission waypoint is re-reached after the mission interruption.\n-\t// Each replay function also clears the cached items afterwards\n+\t// Replay cached trigger commands once the last mission waypoint is re-reached after the mission resume\n \tif (_mission.current_seq > _mission_activation_index) {\n \t\t// replay trigger commands\n \t\tif (cameraWasTriggering()) {\n \t\t\treplayCachedTriggerItems();\n \t\t}\n+\t}\n \n+\tif (!_speed_replayed_on_activation && _mission.current_seq > _mission_activation_index) {\n+\t\t// replay speed change items if not already done on mission (re-)activation\n \t\treplayCachedSpeedChangeItems();\n \t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/79e2993fef3f5d40ecb357e07e36544653002a88/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_base.h": {
        "filename": "src/modules/navigator/mission_base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -332,6 +332,7 @@ class MissionBase : public MissionBlock, public ModuleParams\n \tfloat _mission_init_climb_altitude_amsl{NAN}; \t\t/**< altitude AMSL the vehicle will climb to when mission starts */\n \tint _inactivation_index{-1}; // index of mission item at which the mission was paused. Used to resume survey missions at previous waypoint to not lose images.\n \tint _mission_activation_index{-1};\t\t\t\t\t/**< Index of the mission item that will bring the vehicle back to a mission waypoint */\n+\tbool _speed_replayed_on_activation{false};\t\t\t/**< Flag indicating if the speed change items have been replayed on activation */\n \n \tint32_t _load_mission_index{-1}; /**< Mission inted of loaded mission items in dataman cache*/\n \tint32_t _dataman_cache_size_signed; /**< Size of the dataman cache. A negativ value indicates that previous mission items should be loaded, a positiv value the next mission items*/",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/79e2993fef3f5d40ecb357e07e36544653002a88/src%2Fmodules%2Fnavigator%2Fmission_base.h"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_active",
        "MissionBase::on_activation"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active",
          "MissionBase::on_activation"
        ]
      }
    }
  },
  {
    "title": "RTL: Always publish available approaches from home and rally points ",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24458",
    "number": 24458,
    "created_at": "2025-03-05T17:37:14Z",
    "merged": true,
    "merged_at": "2025-03-07T08:01:19Z",
    "state": "closed",
    "conversation": {
      "author": "KonradRudin",
      "body": "\r\n\r\n<!--\r\n\r\nThank you for your contribution!\r\n\r\nGet early feedback through\r\n- Dronecode Discord: https://discord.gg/dronecode\r\n- PX4 Discuss: http://discuss.px4.io/\r\n- opening a draft pr and sharing the link\r\n\r\n-->\r\n\r\n### Solved Problem\r\nIf the takeoff_land_req parameter is set to 5 you can't upload a mission without landing, although approaches are defined in certain situation (e.g. RTL_TYPE=1). \r\n\r\nFixes #{Github issue ID}\r\n\r\n### Solution\r\n- Make sure that the RTL module always publishes that land approaches are available for home or rally points. As even for RTL_TYPE=1 it would use the home approach if nothing else is defined.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix Make sure that mission landing is not required when home approaches are set in while MIS_TKO_LAND_REQ=5\r\n```\r\n\r\n### Test coverage\r\n- Tested in SITL\r\n\r\n### Context\r\nRelated links, screenshot before/after, video\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "2025-03-05T17:50:10Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-03-06T06:58:53Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect program behavior where mission upload was blocked by MIS_TKO_LAND_REQ=5 even though valid home/rally approaches existed. The change adjusts the RTL module's state publication so available approaches are correctly advertised, preventing an erroneous requirement enforcement (a logic/state error).",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "patch": "@@ -360,14 +360,7 @@ void RTL::setRtlTypeAndDestination()\n \t_rtl_status_pub.get().timestamp = hrt_absolute_time();\n \t_rtl_status_pub.get().safe_points_id = _safe_points_id;\n \t_rtl_status_pub.get().is_evaluation_pending = _dataman_state != DatamanState::UpdateRequestWait;\n-\t_rtl_status_pub.get().has_vtol_approach = false;\n-\n-\tif ((_param_rtl_type.get() == 0) || (_param_rtl_type.get() == 3)) {\n-\t\t_rtl_status_pub.get().has_vtol_approach = _home_has_land_approach || _one_rally_point_has_land_approach;\n-\n-\t} else if (_param_rtl_type.get() == 1) {\n-\t\t_rtl_status_pub.get().has_vtol_approach = _one_rally_point_has_land_approach;\n-\t}\n+\t_rtl_status_pub.get().has_vtol_approach = _home_has_land_approach || _one_rally_point_has_land_approach;\n \n \t_rtl_status_pub.get().rtl_type = static_cast<uint8_t>(_rtl_type);\n \t_rtl_status_pub.get().safe_point_index = safe_point_index;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/bba2aa666c0426041e2d709ed9dd43529f256c37/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::setRtlTypeAndDestination"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::setRtlTypeAndDestination"
        ]
      }
    }
  },
  {
    "title": "Takeoff: loiter after takeoff is established where the takeoff mode is completed, not around Home",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24454",
    "number": 24454,
    "created_at": "2025-03-05T09:00:09Z",
    "merged": true,
    "merged_at": "2025-03-12T12:05:47Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "### Solved Problem\r\nLoiter after takeoff is done around Home instead of at current location, unless the distance to Home is too high at this point, see [this condition](https://github.com/PX4/PX4-Autopilot/blob/0ee592f67c4f52cf8e7a0d9939e00e5f1a3348f6/src/modules/navigator/loiter.cpp#L104C4-L104C6).\r\n\r\n### Solution\r\nWe already [set loiter position in loiter.cpp](https://github.com/PX4/PX4-Autopilot/blob/0ee592f67c4f52cf8e7a0d9939e00e5f1a3348f6/src/modules/navigator/loiter.cpp#L108-L116), and thus I propose to remove it from the `takeoff::on_active()`. \r\n\r\nWhat we possibly drop with that [switch is to set IDLE](https://github.com/PX4/PX4-Autopilot/blob/0ee592f67c4f52cf8e7a0d9939e00e5f1a3348f6/src/modules/navigator/takeoff.cpp#L77) when the vehicle is landed after the takeoff is complete. But do we really need it? In [this PR](https://github.com/PX4/PX4-Autopilot/pull/23704) I propose to remove the IDLE setpoint anyway.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: loiter after takeoff is established at the position where the takeoff mode is completed, not around Home\r\n```\r\n\r\n### Alternatives\r\nWe could add a if(FW) check in set_takeoff_position(), and only use the existing current setpoint if not a FW. I don't see why it's needed though.\r\n\r\n### Test coverage\r\nSITL tested with plane and quad with takeoff command.\r\nAlso flight tested on a plane (handlaunch) with takeoff mode.\r\n\r\n### Context\r\nBefore \r\n![image](https://github.com/user-attachments/assets/4bbf337f-2257-454b-8785-4f587b04e8b0)\r\n\r\nNow\r\n![image](https://github.com/user-attachments/assets/89fd9167-7ee9-408c-96a2-1c93fd0f17b3)\r\n\r\n",
      "issue_comments": [
        {
          "author": "hamishwillee",
          "created_at": "2025-03-06T04:50:51Z",
          "body": "FYI, I think this is nearly what docs say anyway - https://docs.px4.io/main/en/flight_modes_fw/takeoff.html#technical-summary\r\n\r\nI.e. that you takeoff and loiter once you reach your clearance altitude. So not so much \"loiter where you take off\" as loiter where ever you are after you have taken off.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "2025-03-06T13:54:44Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect behavior where the loiter setpoint after takeoff was being forced to Home (via takeoff::on_active) instead of using the actual current loiter position established in loiter.cpp, causing an unintended state/position. Removing the redundant/incorrect set of the loiter position corrects the state transition and aligns behavior with intended logic and docs.",
    "patches": {
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "patch": "@@ -69,25 +69,6 @@ Takeoff::on_active()\n \t\t_navigator->get_mission_result()->finished = true;\n \t\t_navigator->set_mission_result_updated();\n \t\t_navigator->mode_completed(getNavigatorStateId());\n-\n-\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n-\n-\t\t// set loiter item so position controllers stop doing takeoff logic\n-\t\tif (_navigator->get_land_detected()->landed) {\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n-\n-\t\t} else {\n-\t\t\tif (pos_sp_triplet->current.valid) {\n-\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n-\n-\t\t\t} else {\n-\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n-\t\t\t}\n-\t\t}\n-\n-\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n-\n-\t\t_navigator->set_position_setpoint_triplet_updated();\n \t}\n }\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/dbe8d7ad1090d5efef96ecd6da568bc6715d7b1f/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Takeoff::on_active"
      ],
      "by_file": {
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "Move NUM_MISSION_ITEMS_SUPPORTED to dataman",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/25134",
    "number": 25134,
    "created_at": "2025-06-29T21:35:32Z",
    "merged": true,
    "merged_at": "2025-06-30T22:25:00Z",
    "state": "closed",
    "conversation": {
      "author": "julianoes",
      "body": "The define CONFIG_NUM_MISSION_ITMES_SUPPORTED is used in dataman, not navigator, so this config variable needs to be moved to the dataman module, otherwise it breaks the build if navigator is not included in the build.\r\n\r\nFollow up to https://github.com/PX4/PX4-Autopilot/pull/24252.",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2025-06-29T21:40:40Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR moves a configuration define to the correct module to avoid build failures when navigator isn't included. This is a build/configuration organization fix, not a runtime logic bug â€” it doesn't correct incorrect program behavior or state, but prevents a build error due to misplaced configuration.",
    "patches": {
      "src/modules/navigator/Kconfig": {
        "filename": "src/modules/navigator/Kconfig",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "patch": "@@ -27,12 +27,3 @@ menuconfig NAVIGATOR_ADSB\n \t---help---\n \t\tAdd support for acting on ADSB transponder_report or ADSB_VEHICLE MAVLink messages.\n \t\tActions are warnings, Loiter, Land and RTL without climb.\n-\n-menuconfig NUM_MISSION_ITMES_SUPPORTED\n-\tint \"Maximum number of mission items\"\n-\tdefault 500\n-\tdepends on MODULES_NAVIGATOR\n-\t---help---\n-\t\tThis limit always applies if mission items are stored on the SD card or in RAM. It should be set\n-\t\tadequately per boards such that if the items are stored in RAM they still fit the available memory.\n-\t\tThe runtime parameter to configure the storage option is `SYS_DM_BACKEND`.",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/1129f8a6e2feccdb7226b0dc1d269fffa4bd6153/src%2Fmodules%2Fnavigator%2FKconfig"
      }
    },
    "modified_functions": {
      "all": [],
      "by_file": {}
    }
  },
  {
    "title": "Takeoff: only use local position in execution logic and allow setting loiter point of fixed-wing takeoff",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/25123",
    "number": 25123,
    "created_at": "2025-06-26T12:10:49Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Partially replaces https://github.com/PX4/PX4-Autopilot/pull/25083 (without the takeoff without navigation part).\r\n\r\n### Solved Problem\r\n- It's currently not possible to define the position of the loiter that gets established upon climbing to the takeoff altitude, instead it will just loiter at the current position. Especially for large vehicles with big loiter radii it's desired to move this place further from away (and have it at pre-defined position).\r\n- the Takeoff flight mode can be executed without global position, but was internally using global position\r\n- in https://github.com/PX4/PX4-Autopilot/pull/24280 we removed the dependency for FW vehicles on vehicle_global_position in Mission, Loiter and RTL, but seemed to have forgotten the takeoff modes\r\n\r\n### Solution\r\n- use the lat/long fields [MAV_CMD_NAV_TAKEOFF](https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_TAKEOFF) to define where to loiter\r\n- only use local position in Takeoff flight mode. That should make it more robust against \r\n- only require vehicle_local_position_relaxed for Takeoff and VTOL_Takeoff\r\n\r\nIn more detail:\r\n- split up the takeoff phase into \"climbout\" and \"go to loiter\" states.\r\n- during climbout the course setpoint is fixed to the heading the vehicle had on launch and the height rate setpoint set to `FW_CLMB_MAX`\r\n- climbout altitude can be configured with new parameter (`TKO_CLMB_OUT_ALT`). We can hopefully expose this setting also to the users through a field in [NAV_TAKEOFF](https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_TAKEOFF).\r\nafter reaching the climbout altitude, the vehicle starts going to the loiter point\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: FW Takeoff: and add option to define loiter position\r\n```\r\n\r\n### Alternatives\r\n- Add a \"climbout altitude\" field to  [MAV_CMD_NAV_TAKEOFF](https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_TAKEOFF) to replace the added param `TKO_CLMB_OUT_ALT`. \r\n- can we remove the absolute altitude dependency of TECS as a next step?\r\n\r\n### Test coverage\r\nSITL tested, partially flight tested.\r\n\r\n\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-06-26T12:17:12Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 1040 byte (0.05 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.1% +1.02Ki  +0.1% +1.02Ki    .text\n    +280%    +342  +280%    +342    Takeoff::on_active()\n     +35%    +140   +35%    +140    Takeoff::set_takeoff_position()\n    +0.1%    +120  +0.1%    +120    g_cromfs_image\n    +467%    +112  +467%    +112    Takeoff::Takeoff()\n     +29%     +72   +29%     +72    mode_util::getModeRequirements()\n    [NEW]     +44  [NEW]     +44    Takeoff::setLoiterAltitudeLocalZ()\n    +275%     +44  +275%     +44    Takeoff::~Takeoff()\n    +1.2%     +40  +1.2%     +40    Navigator::run()\n     +70%     +28   +70%     +28    Takeoff\n    +0.0%     +28  +0.0%     +28    [section .text]\n    +7.1%     +24  +7.1%     +24    Navigator::~Navigator()\n    [NEW]     +20  [NEW]     +20    Takeoff::updateParamsImpl()\n   -94.8%     +18 -94.8%     +18    [7 Others]\n    +5.5%     +12  +5.5%     +12    Commander::checkForMissionUpdate()\n    +6.7%      +8  +6.7%      +8    Navigator::preproject_stop_point()\n    +0.1%      +8  +0.1%      +8    px4::parameters\n    +3.1%      +4  +3.1%      +4    Navigator::params_update()\n    -2.4%      -4  -2.4%      -4    Commander::answer_command()\n    -2.0%      -4  -2.0%      -4    Land::on_active()\n    -9.1%      -4  -9.1%      -4    Navigator::reset_triplets()\n    -0.7%     -12  -0.7%     -12    Navigator::Navigator()\n  +0.0%    +896  [ = ]       0    .debug_abbrev\n  +0.0%     +72  [ = ]       0    .debug_aranges\n  +0.0%    +228  [ = ]       0    .debug_frame\n  +0.1% +35.5Ki  [ = ]       0    .debug_info\n  +0.0% +2.37Ki  [ = ]       0    .debug_line\n    [DEL]      -3  [ = ]       0    [Unmapped]\n    +0.0% +2.38Ki  [ = ]       0    [section .debug_line]\n  +0.0% +1.53Ki  [ = ]       0    .debug_loclists\n  +0.1%    +403  [ = ]       0    .debug_rnglists\n    [NEW]      +2  [ = ]       0    [Unmapped]\n    +0.1%    +401  [ = ]       0    [section .debug_rnglists]\n  +0.0% +1.20Ki  [ = ]       0    .debug_str\n  +0.0%    +156  [ = ]       0    .strtab\n    [NEW]     +39  [ = ]       0    Takeoff::setLoiterAltitudeLocalZ()\n    [NEW]     +71  [ = ]       0    Takeoff::updateParamsImpl()\n     +96%     +46  [ = ]       0    Takeoff::~Takeoff()\n   -40.0%     -16  [ = ]       0    __stm32_dmastart_veneer\n    +100%     +16  [ = ]       0    __strcmp_veneer\n  +0.0%    +176  [ = ]       0    .symtab\n     +67%     +32  [ = ]       0    FixedWingModeManager::control_auto_takeoff()\n   -20.0%     -16  [ = ]       0    Land::~Land()\n     +50%     +16  [ = ]       0    Navigator::abort_landing()\n   -50.0%     -16  [ = ]       0    Navigator::force_vtol()\n     +50%     +16  [ = ]       0    Navigator::publish_distance_sensor_mode_request()\n   -50.0%     -16  [ = ]       0    Navigator::publish_vehicle_command_ack()\n     +33%     +16  [ = ]       0    Navigator::release_gimbal_control()\n   -25.0%     -16  [ = ]       0    Navigator::reset_position_setpoint()\n    +100%     +16  [ = ]       0    Navigator::reset_triplets()\n   -50.0%     -16  [ = ]       0    Navigator::stop_capturing_images()\n     +50%     +16  [ = ]       0    Takeoff::on_active()\n    [NEW]     +64  [ = ]       0    Takeoff::setLoiterAltitudeLocalZ()\n    [NEW]     +32  [ = ]       0    Takeoff::updateParamsImpl()\n    +100%     +80  [ = ]       0    Takeoff::~Takeoff()\n    -0.3%     -32  [ = ]       0    [section .symtab]\n   -40.0%     -32  [ = ]       0    __stm32_dmastart_veneer\n     +67%     +32  [ = ]       0    __strcmp_veneer\n  -9.3% -1.02Ki  [ = ]       0    [Unmapped]\n  +0.1% +42.5Ki  +0.0% +1.02Ki    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 1088 byte (0.06 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.1% +1.06Ki  +0.1% +1.06Ki    .text\n    +280%    +342  +280%    +342    Takeoff::on_active()\n     +35%    +140   +35%    +140    Takeoff::set_takeoff_position()\n    +0.1%    +120  +0.1%    +120    g_cromfs_image\n    +467%    +112  +467%    +112    Takeoff::Takeoff()\n     +29%     +72   +29%     +72    mode_util::getModeRequirements()\n    [NEW]     +44  [NEW]     +44    Takeoff::setLoiterAltitudeLocalZ()\n    +275%     +44  +275%     +44    Takeoff::~Takeoff()\n   -99.1%     +42 -99.1%     +42    [15 Others]\n    +1.2%     +40  +1.2%     +40    Navigator::run()\n     +70%     +28   +70%     +28    Takeoff\n    +0.0%     +28  +0.0%     +28    [section .text]\n    +7.1%     +24  +7.1%     +24    Navigator::~Navigator()\n    [NEW]     +20  [NEW]     +20    Takeoff::updateParamsImpl()\n    +4.7%     +20  +4.7%     +20    param_reset_specific\n    +5.5%     +12  +5.5%     +12    Commander::checkForMissionUpdate()\n    +6.7%      +8  +6.7%      +8    Navigator::preproject_stop_point()\n    +0.1%      +8  +0.1%      +8    px4::parameters\n    +5.9%      +4  +5.9%      +4    ConstLayer::containedAsBitset()\n    -2.4%      -4  -2.4%      -4    Commander::answer_command()\n    -2.0%      -4  -2.0%      -4    Land::on_active()\n    -0.7%     -12  -0.7%     -12    Navigator::Navigator()\n  +0.0%    +896  [ = ]       0    .debug_abbrev\n  +0.0%     +72  [ = ]       0    .debug_aranges\n  +0.1%    +248  [ = ]       0    .debug_frame\n  +0.1% +35.4Ki  [ = ]       0    .debug_info\n  +0.0% +2.44Ki  [ = ]       0    .debug_line\n   -14.3%      -1  [ = ]       0    [Unmapped]\n    +0.0% +2.44Ki  [ = ]       0    [section .debug_line]\n  +0.0% +1.62Ki  [ = ]       0    .debug_loclists\n  +0.1%    +411  [ = ]       0    .debug_rnglists\n    +100%      +1  [ = ]       0    [Unmapped]\n    +0.1%    +410  [ = ]       0    [section .debug_rnglists]\n  +0.0% +1.20Ki  [ = ]       0    .debug_str\n  +0.0%    +156  [ = ]       0    .strtab\n    [NEW]     +39  [ = ]       0    Takeoff::setLoiterAltitudeLocalZ()\n    [NEW]     +71  [ = ]       0    Takeoff::updateParamsImpl()\n     +96%     +46  [ = ]       0    Takeoff::~Takeoff()\n  +0.0%    +176  [ = ]       0    .symtab\n   -50.0%     -16  [ = ]       0    ConstLayer::containedAsBitset()\n     +67%     +32  [ = ]       0    FixedWingModeManager::control_auto_takeoff()\n   -20.0%     -16  [ = ]       0    Land::~Land()\n     +50%     +16  [ = ]       0    Navigator::abort_landing()\n   -50.0%     -16  [ = ]       0    Navigator::force_vtol()\n     +50%     +16  [ = ]       0    Navigator::publish_distance_sensor_mode_request()\n   -50.0%     -16  [ = ]       0    Navigator::publish_vehicle_command_ack()\n     +33%     +16  [ = ]       0    Navigator::release_gimbal_control()\n   -25.0%     -16  [ = ]       0    Navigator::reset_position_setpoint()\n    +100%     +16  [ = ]       0    Navigator::reset_triplets()\n   -50.0%     -16  [ = ]       0    Navigator::stop_capturing_images()\n     +50%     +16  [ = ]       0    Takeoff::on_active()\n    [NEW]     +64  [ = ]       0    Takeoff::setLoiterAltitudeLocalZ()\n    [NEW]     +32  [ = ]       0    Takeoff::updateParamsImpl()\n    +100%     +80  [ = ]       0    Takeoff::~Takeoff()\n    -0.3%     -32  [ = ]       0    [section .symtab]\n     +33%     +16  [ = ]       0    param_import_internal()\n -18.3% -1.06Ki  [ = ]       0    [Unmapped]\n  +0.1% +42.6Ki  +0.1% +1.06Ki    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-06-26T12:22:50_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect/fragile takeoff behavior: the Takeoff mode previously depended on global position (while it can run without it) and always loitered at the current position rather than a commanded loiter point. Those are logic issues (improper state/data reliance and incorrect behavior), and the changes (use local position for execution, honor MAV_CMD_NAV_TAKEOFF lat/long, split climbout/go-to-loiter) correct the program's logic.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -640,6 +640,10 @@ void Navigator::run()\n \n \t\t\t\trep->next.valid = false;\n \n+\t\t\t\t// after the straight climbout the vehicle will establish on a loiter at this position\n+\t\t\t\t_takeoff.setLoiterPosition(matrix::Vector2d(cmd.param5, cmd.param6));\n+\t\t\t\t_takeoff.setLoiterAltitudeLocalZ(cmd.param7);\n+\n \t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n \n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/56dc86c589b808037facfa88204ddde2297a172c/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 127,
        "deletions": 28,
        "changes": 155,
        "patch": "@@ -43,7 +43,8 @@\n #include <px4_platform_common/events.h>\n \n Takeoff::Takeoff(Navigator *navigator) :\n-\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF)\n+\tMissionBlock(navigator, vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF),\n+\tModuleParams(navigator)\n {\n }\n \n@@ -54,41 +55,109 @@ Takeoff::on_activation()\n \n \t// reset cruising speed to default\n \t_navigator->reset_cruising_speed();\n+\n+\t_fw_takeoff_state = fw_takeoff_state::CLIMBOUT; // only used for fixed-wing takeoff\n }\n \n void\n Takeoff::on_active()\n {\n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n+\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n \n-\tif (rep->current.valid) {\n-\t\t// reset the position\n-\t\tset_takeoff_position();\n+\t\tswitch (_fw_takeoff_state) {\n+\t\tcase fw_takeoff_state::CLIMBOUT: {\n+\t\t\t\tif (_navigator->get_local_position()->z < _climbout_alt_z) {\n \n-\t} else if (is_mission_item_reached_or_completed() && !_navigator->get_mission_result()->finished) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n-\t\t_navigator->mode_completed(getNavigatorStateId());\n+\t\t\t\t\tsetLoiterItemCommonFields(&_mission_item);\n \n-\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n \n-\t\t// set loiter item so position controllers stop doing takeoff logic\n-\t\tif (_navigator->get_land_detected()->landed) {\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n+\t\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t\t} else {\n-\t\t\tif (pos_sp_triplet->current.valid\n-\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n+\t\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n+\t\t\t\t\t// however it will just continue loitering as there is no next mission item\n+\t\t\t\t\t_mission_item.time_inside = 1.f;\n+\t\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n+\t\t\t\t\t_mission_item.altitude = _navigator->get_local_position()->ref_alt - _loiter_height_z;\n \n-\t\t\t} else {\n-\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n+\t\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t\t\t\t\tpos_sp_triplet->current.lat = _loiter_position_lat_lon(0) > DBL_EPSILON ?\n+\t\t\t\t\t\t\t\t      _loiter_position_lat_lon(0) : _navigator->get_global_position()->lat;\n+\t\t\t\t\tpos_sp_triplet->current.lon = _loiter_position_lat_lon(1) > DBL_EPSILON ?\n+\t\t\t\t\t\t\t\t      _loiter_position_lat_lon(1) : _navigator->get_global_position()->lon;\n+\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n+\t\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n+\n+\t\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n+\t\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n+\n+\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t\t\t\t\treset_mission_item_reached();\n+\n+\t\t\t\t\t_fw_takeoff_state = fw_takeoff_state::GO_TO_LOITER;\n+\t\t\t\t\t_climbout_alt_z = NAN; // reset for next takeoff command\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n \t\t\t}\n+\n+\t\tcase fw_takeoff_state::GO_TO_LOITER: {\n+\n+\t\t\t\t// consider reached once above the altitude acceptance radius of the loiter altitude\n+\t\t\t\tif (_navigator->get_local_position()->z < _loiter_height_z + _navigator->get_altitude_acceptance_radius()) {\n+\n+\t\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n+\t\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n+\t\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n+\t\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n+\n+\t\t\t\t\t// the FW takeoff mode is completed, exit to Hold (handled by Commander)\n+\t\t\t\t\t_navigator->get_mission_result()->finished = true;\n+\t\t\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t\t\t_navigator->mode_completed(getNavigatorStateId());\n+\n+\t\t\t\t\t_loiter_height_z = NAN; // reset for next takeoff command\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\tdefault:\n+\t\t\tbreak;\n \t\t}\n \n-\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t} else { // rotary-wing takeoff\n+\t\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n+\n+\t\tif (rep->current.valid) {\n+\t\t\t// reset the position\n+\t\t\tset_takeoff_position();\n+\n+\t\t} else if (is_mission_item_reached_or_completed() && !_navigator->get_mission_result()->finished) {\n+\t\t\t_navigator->get_mission_result()->finished = true;\n+\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->mode_completed(getNavigatorStateId());\n+\n+\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t\t// set loiter item so position controllers stop doing takeoff logic\n+\t\t\tif (_navigator->get_land_detected()->landed) {\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n+\n+\t\t\t} else {\n+\t\t\t\tif (pos_sp_triplet->current.valid\n+\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t}\n \t}\n }\n \n@@ -97,13 +166,21 @@ Takeoff::set_takeoff_position()\n {\n \tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n \n-\tfloat takeoff_altitude_amsl = 0.f;\n+\t_takeoff_init_z = _navigator->get_local_position()->z;\n+\tconst float alt_ref = PX4_ISFINITE(_navigator->get_local_position()->ref_alt) ?\n+\t\t\t      _navigator->get_local_position()->ref_alt : 0.f;\n \n-\tif (rep->current.valid && PX4_ISFINITE(rep->current.alt)) {\n-\t\ttakeoff_altitude_amsl = rep->current.alt;\n+\tfloat takeoff_setpoint_z = 0.f;\n+\n+\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n+\t    && _param_tko_clmb_out_alt.get() > FLT_EPSILON) {\n+\t\ttakeoff_setpoint_z = - (_param_tko_clmb_out_alt.get() - _takeoff_init_z);\n+\n+\t} else if (rep->current.valid && PX4_ISFINITE(rep->current.alt)) {\n+\t\ttakeoff_setpoint_z = - (rep->current.alt - alt_ref);\n \n \t} else {\n-\t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt + _navigator->get_param_mis_takeoff_alt();\n+\t\ttakeoff_setpoint_z = - (_navigator->get_param_mis_takeoff_alt() - _takeoff_init_z);\n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n \t\t\t\t \"Using default takeoff altitude: %.1f m\\t\", (double)_navigator->get_param_mis_takeoff_alt());\n \n@@ -112,16 +189,27 @@ Takeoff::set_takeoff_position()\n \t\t\t\t    _navigator->get_param_mis_takeoff_alt());\n \t}\n \n-\tif (takeoff_altitude_amsl < _navigator->get_global_position()->alt) {\n+\tif (takeoff_setpoint_z > _takeoff_init_z) {\n \t\t// If the suggestion is lower than our current alt, let's not go down.\n-\t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt;\n+\t\ttakeoff_setpoint_z = _takeoff_init_z;\n \t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Already higher than takeoff altitude\\t\");\n \t\tevents::send(events::ID(\"navigator_takeoff_already_higher\"), {events::Log::Error, events::LogInternal::Info},\n \t\t\t     \"Already higher than takeoff altitude (not descending)\");\n \t}\n \n+\t_climbout_alt_z = takeoff_setpoint_z; // only for FW takeoff\n+\n+\tif (!PX4_ISFINITE(_loiter_height_z)) {\n+\t\tif (_navigator->get_loiter_min_alt() > FLT_EPSILON) {\n+\t\t\t_loiter_height_z = - (_navigator->get_loiter_min_alt() - _takeoff_init_z);\n+\n+\t\t} else {\n+\t\t\t_loiter_height_z = takeoff_setpoint_z;\n+\t\t}\n+\t}\n+\n \t// set current mission item to takeoff\n-\tset_takeoff_item(&_mission_item, takeoff_altitude_amsl);\n+\tset_takeoff_item(&_mission_item, alt_ref - takeoff_setpoint_z);\n \t_navigator->get_mission_result()->finished = false;\n \t_navigator->set_mission_result_updated();\n \treset_mission_item_reached();\n@@ -151,3 +239,14 @@ Takeoff::set_takeoff_position()\n \n \t_navigator->set_position_setpoint_triplet_updated();\n }\n+\n+void\n+Takeoff::setLoiterAltitudeLocalZ(const float height_m)\n+{\n+\tif (PX4_ISFINITE(_navigator->get_local_position()->ref_alt)) {\n+\t\t_loiter_height_z = - (height_m - _navigator->get_local_position()->ref_alt);\n+\n+\t} else {\n+\t\t_loiter_height_z = - height_m;\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/56dc86c589b808037facfa88204ddde2297a172c/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/takeoff.h": {
        "filename": "src/modules/navigator/takeoff.h",
        "status": "modified",
        "additions": 20,
        "deletions": 2,
        "changes": 22,
        "patch": "@@ -42,8 +42,10 @@\n \n #include \"navigator_mode.h\"\n #include \"mission_block.h\"\n+#include <lib/mathlib/mathlib.h>\n+#include <px4_platform_common/module_params.h>\n \n-class Takeoff : public MissionBlock\n+class Takeoff : public MissionBlock,  public ModuleParams\n {\n public:\n \tTakeoff(Navigator *navigator);\n@@ -52,7 +54,23 @@ class Takeoff : public MissionBlock\n \tvoid on_activation() override;\n \tvoid on_active() override;\n \n-private:\n+\tvoid setLoiterPosition(matrix::Vector2d loiter_location) { _loiter_position_lat_lon = loiter_location; }\n+\tvoid setLoiterAltitudeLocalZ(const float height_m);\n \n+private:\n \tvoid set_takeoff_position();\n+\n+\tenum class fw_takeoff_state {\n+\t\tCLIMBOUT = 0,\n+\t\tGO_TO_LOITER\n+\t} _fw_takeoff_state;\n+\n+\tfloat _takeoff_init_z{NAN};\n+\tfloat _climbout_alt_z{NAN};\n+\tmatrix::Vector2d _loiter_position_lat_lon{static_cast<double>(NAN), static_cast<double>(NAN)};\n+\tfloat _loiter_height_z{NAN};\n+\n+\tDEFINE_PARAMETERS(\n+\t\t(ParamFloat<px4::params::TKO_CLMB_OUT_ALT>) _param_tko_clmb_out_alt\n+\t)\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/56dc86c589b808037facfa88204ddde2297a172c/src%2Fmodules%2Fnavigator%2Ftakeoff.h"
      },
      "src/modules/navigator/takeoff_params.c": {
        "filename": "src/modules/navigator/takeoff_params.c",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "patch": "@@ -0,0 +1,57 @@\n+/****************************************************************************\n+ *\n+ *   Copyright (c) 2025 PX4 Development Team. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ * 3. Neither the name PX4 nor the names of its contributors may be\n+ *    used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ****************************************************************************/\n+\n+/**\n+ * @file takeoff_params.c\n+ *\n+ * Parameters for the takeoff navigation mode.\n+ *\n+ */\n+\n+/**\n+ * Takeoff relative climbout altitude\n+ *\n+ * Altitude relative to home at which the vehicle will stop with the straight\n+ * climbout and start heading in nominal configuration to the defined Hold position.\n+ * Only applies to fixed-wing takeoff mode (excluding Mission takeoffs).\n+ *\n+ * Not used if set to negative value, in which case the climbout altitude\n+ * is set equal to the Hold altitude.\n+ *\n+ * @unit m\n+ * @min -1\n+ * @decimal 1\n+ * @increment 1\n+ * @group Takeoff\n+ */\n+PARAM_DEFINE_FLOAT(TKO_CLMB_OUT_ALT, -1);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/56dc86c589b808037facfa88204ddde2297a172c/src%2Fmodules%2Fnavigator%2Ftakeoff_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "Takeoff::on_activation",
        "Navigator::run",
        "Takeoff::set_takeoff_position"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_activation",
          "Takeoff::set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "FW Takeoff: keep climbing with wings level in case of navigation loss, and add option to define loiter position",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/25083",
    "number": 25083,
    "created_at": "2025-06-20T11:24:06Z",
    "merged": true,
    "merged_at": "2025-07-14T12:29:59Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "Replaces https://github.com/PX4/PX4-Autopilot/pull/23797\r\n\r\n### Solved Problem\r\n- A navigation failsafe during the climbout of a takeoff can be fatal, as the system doesn't have much clearance to the ground yet. It thus better to keep climbing in that case instead of failsafing.\r\n- It's currently not possible to define the position of the loiter that gets established upon climbing to the takeoff altitude, instead it will just loiter at the current position. Especially for large vehicles with big loiter radii it's desired to move this place further from away (and have it at pre-defined position).\r\n\r\n### Solution\r\n- check `local_position.xy_valid` in the FW mode manager, and in case of invalidity, set lateral_acceleration to 0 (instead of holding a course setpoint)\r\n- use the lat/long fields [MAV_CMD_NAV_TAKEOFF](https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_TAKEOFF) to define where to loiter\r\n\r\nIn more detail:\r\n- split up the takeoff phase into \"climbout\" and \"go to loiter\" states.\r\n- during climbout the course setpoint is fixed to the heading the vehicle had on launch and the height rate setpoint set to `FW_CLMB_MAX`\r\n- climbout is done once the altitude of the takeoff (loiter) is reached\r\n- if a navigation failsafe happens while the vehicle is in takeoff (e.g. GNSS and airspeed failure), it will keep climbing with wings level\r\n- the takeoff flight mode for FW doesn't require any local or global position validity, thus can be activated inside a tube without GNSS and with mag disturbance\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature: FW Takeoff: keep climbing with wings level in case of navigation loss\r\nFeature: FW Takeoff: and add option to define loiter position\r\n```\r\n\r\n### Test coverage\r\nSITL tested, flight tested.\r\n\r\n- \"all normal flight\"\r\n--> vehicle climbed to takeoff altitude while holding course to center of loiter, once passed the altitude it established loiter at defined location and switched to Hold mode.\r\n\r\n- \"navigation loss flight\" (GNSS denied and without airspeed sensor fusion)\r\n<img width=\"1431\" height=\"987\" alt=\"image\" src=\"https://github.com/user-attachments/assets/37105015-9669-411c-828b-189f6d287a24\" />\r\n--> vehicle climbs with wings level until takeoff altitude is reached, then failsafes to fixed-bank loiter\r\n\r\n\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-06-20T11:30:03Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 1448 byte (0.07 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.1% +1.41Ki  +0.1% +1.41Ki    .text\n    [NEW]    +740  [NEW]    +740    FixedWingModeManager::control_auto_takeoff_no_nav()\n    +366%    +446  +366%    +446    Takeoff::on_active()\n     +17%     +68   +17%     +68    Takeoff::set_takeoff_position()\n    +1.4%     +48  +1.4%     +48    Navigator::run()\n    +150%     +36  +150%     +36    Takeoff::Takeoff()\n    +2.5%     +32  +2.5%     +32    uORB::Publication<>::publish()\n    +0.8%     +16  +0.8%     +16    FixedWingModeManager::Run()\n    +1.2%     +16  +1.2%     +16    FixedWingModeManager::control_auto_takeoff()\n    +5.2%     +12  +5.2%     +12    Commander::checkForMissionUpdate()\n    +0.0%     +12  +0.0%     +12    [section .text]\n    +4.3%     +12  +4.3%     +12    mode_util::getModeRequirements()\n    +1.9%      +8  +1.9%      +8    FixedWingModeManager::set_control_mode_current()\n   -73.9%      +6 -73.9%      +6    [2 Others]\n    +0.6%      +4  +0.6%      +4    FixedWingModeManager::vehicle_attitude_poll()\n    +0.2%      +4  +0.2%      +4    MissionBlock::is_mission_item_reached_or_completed()\n    +1.0%      +4  +1.0%      +4    MissionBlock::mission_item_to_position_setpoint()\n     +17%      +4   +17%      +4    Takeoff::on_activation()\n    -2.5%      -4  -2.5%      -4    Commander::handleCommandsFromModeExecutors()\n    -1.0%      -4  -1.0%      -4    EKFGSF_yaw::fuseVelocity()\n    -2.0%      -4  -2.0%      -4    Land::on_active()\n    -0.5%      -8  -0.5%      -8    Navigator::Navigator()\n  +0.0%    +294  [ = ]       0    .debug_abbrev\n  +0.0%     +16  [ = ]       0    .debug_aranges\n  +0.0%    +148  [ = ]       0    .debug_frame\n  +0.0% +9.33Ki  [ = ]       0    .debug_info\n  +0.0% +2.34Ki  [ = ]       0    .debug_line\n     +75%      +3  [ = ]       0    [Unmapped]\n    +0.0% +2.34Ki  [ = ]       0    [section .debug_line]\n  +0.0% +1.48Ki  [ = ]       0    .debug_loclists\n  +0.1%    +332  [ = ]       0    .debug_rnglists\n    +200%      +2  [ = ]       0    [Unmapped]\n    +0.1%    +330  [ = ]       0    [section .debug_rnglists]\n  +0.0%    +445  [ = ]       0    .debug_str\n  -0.4%      -1  [ = ]       0    .shstrtab\n  +0.0%    +133  [ = ]       0    .strtab\n    [NEW]     +61  [ = ]       0    FixedWingModeManager::control_auto_takeoff_no_nav()\n   -18.8%     -16  [ = ]       0    ___ZN3Ekf17measurementUpdateERN6matrix6VectorIfLj24EEERKS2_ff_veneer\n     +47%     +16  [ = ]       0    __nxsched_resume_scheduler_veneer\n    +4.4%     +72  [ = ]       0    uORB::Publication<>::publish()\n  +0.0%     +96  [ = ]       0    .symtab\n    +100%     +32  [ = ]       0    EKFGSF_yaw::fuseVelocity()\n    [NEW]     +48  [ = ]       0    FixedWingModeManager::control_auto_takeoff_no_nav()\n   -20.0%     -16  [ = ]       0    Land::~Land()\n    +100%     +32  [ = ]       0    Takeoff::on_active()\n    -0.3%     -32  [ = ]       0    [section .symtab]\n   -40.0%     -32  [ = ]       0    ___ZN3Ekf17measurementUpdateERN6matrix6VectorIfLj24EEERKS2_ff_veneer\n     +50%     +16  [ = ]       0    __hrt_elapsed_time_veneer\n     +67%     +32  [ = ]       0    __nxsched_resume_scheduler_veneer\n   -33.3%     -16  [ = ]       0    __stm32_i2c_set_bytes_to_transfer_veneer\n    +3.1%     +32  [ = ]       0    uORB::Publication<>::publish()\n   +32% +2.59Ki  [ = ]       0    [Unmapped]\n  +0.0% +18.6Ki  +0.1% +1.41Ki    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 1448 byte (0.07 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.1% +1.41Ki  +0.1% +1.41Ki    .text\n    [NEW]    +740  [NEW]    +740    FixedWingModeManager::control_auto_takeoff_no_nav()\n    +366%    +446  +366%    +446    Takeoff::on_active()\n     +17%     +68   +17%     +68    Takeoff::set_takeoff_position()\n    +1.4%     +48  +1.4%     +48    Navigator::run()\n    +150%     +36  +150%     +36    Takeoff::Takeoff()\n    +2.5%     +32  +2.5%     +32    uORB::Publication<>::publish()\n    +0.8%     +16  +0.8%     +16    FixedWingModeManager::Run()\n    +1.2%     +16  +1.2%     +16    FixedWingModeManager::control_auto_takeoff()\n    +5.2%     +12  +5.2%     +12    Commander::checkForMissionUpdate()\n    +4.3%     +12  +4.3%     +12    mode_util::getModeRequirements()\n    +1.9%      +8  +1.9%      +8    FixedWingModeManager::set_control_mode_current()\n    +0.0%      +8  +0.0%      +8    [section .text]\n    +1.0%      +4  +1.0%      +4    EKFGSF_yaw::fuseVelocity()\n    +0.6%      +4  +0.6%      +4    FixedWingModeManager::vehicle_attitude_poll()\n    +0.2%      +4  +0.2%      +4    MissionBlock::is_mission_item_reached_or_completed()\n    +1.0%      +4  +1.0%      +4    MissionBlock::mission_item_to_position_setpoint()\n     +17%      +4   +17%      +4    Takeoff::on_activation()\n   -85.7%      +2 -85.7%      +2    [1 Others]\n    -2.5%      -4  -2.5%      -4    Commander::handleCommandsFromModeExecutors()\n    -2.0%      -4  -2.0%      -4    Land::on_active()\n    -0.5%      -8  -0.5%      -8    Navigator::Navigator()\n  +0.0%    +294  [ = ]       0    .debug_abbrev\n  +0.0%     +16  [ = ]       0    .debug_aranges\n  +0.0%    +148  [ = ]       0    .debug_frame\n  +0.0% +9.33Ki  [ = ]       0    .debug_info\n  +0.0% +2.34Ki  [ = ]       0    .debug_line\n    [NEW]      +3  [ = ]       0    [Unmapped]\n    +0.0% +2.34Ki  [ = ]       0    [section .debug_line]\n  +0.0% +1.44Ki  [ = ]       0    .debug_loclists\n  +0.1%    +330  [ = ]       0    .debug_rnglists\n  +0.0%    +445  [ = ]       0    .debug_str\n  +1.3%      +3  [ = ]       0    .shstrtab\n  +0.0%    +133  [ = ]       0    .strtab\n    [NEW]     +61  [ = ]       0    FixedWingModeManager::control_auto_takeoff_no_nav()\n    +4.4%     +72  [ = ]       0    uORB::Publication<>::publish()\n  +0.0%     +96  [ = ]       0    .symtab\n   -50.0%     -32  [ = ]       0    EKFGSF_yaw::fuseVelocity()\n    [NEW]     +48  [ = ]       0    FixedWingModeManager::control_auto_takeoff_no_nav()\n   -20.0%     -16  [ = ]       0    Land::~Land()\n    +100%     +32  [ = ]       0    Takeoff::on_active()\n    +0.3%     +32  [ = ]       0    [section .symtab]\n    +3.1%     +32  [ = ]       0    uORB::Publication<>::publish()\n -19.8% -1.41Ki  [ = ]       0    [Unmapped]\n  +0.0% +14.5Ki  +0.1% +1.41Ki    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-07-14T09:57:55_**",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2025-06-25T03:46:56Z",
          "body": "@sfuhrer Still hoping for an answer to https://discord.com/channels/1022170275984457759/1374697513193312347, which will be affected by this.\r\n\r\nI.e. this has docs impact",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-10T17:46:30Z",
          "body": "@RomanBapst I've removed some of the added functionality (the climbout altitude param) again and addressed your comments. Please have a look at the last 4 commits (will squash them prior to merging). ",
          "type": "issue_comment"
        },
        {
          "author": "github-actions[bot]",
          "created_at": "2025-07-14T09:53:29Z",
          "body": "No flaws found\n<!-- Sticky Pull Request Commentflaws -->",
          "type": "issue_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-14T09:56:00Z",
          "body": "Added docs updates, squashed commits and rebased on main. Merging once CI passes.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "RomanBapst",
          "created_at": "2025-06-24T07:27:27Z",
          "body": "```suggestion\r\n\t} _fixed_wing_takeoff_state;\r\n```",
          "path": "src/modules/navigator/takeoff.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-24T07:28:41Z",
          "body": "Can be set directly in the header",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:04:13Z",
          "body": "@sfuhrer How does it work with altitude, we actually need gobal altitude but only require a local one. I assume it's because we always have baro and assume that global alt is always available, right?",
          "path": "src/modules/commander/ModeUtil/mode_requirements.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:13:58Z",
          "body": "@sfuhrer Should we sanitize this a bit more, e.g. it needs to be higher or equal than the min?",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 74,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:15:53Z",
          "body": "@sfuhrer Should we for now set throttle to 0 to make sure the vehicle does not do anything crazy? If not, then we need to at least test that it's safe. ",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:19:41Z",
          "body": "@sfuhrer In the normal takeoff function, you have used the max climb rate. Why not use the same here?",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-25T15:47:05Z",
          "body": "oversight, will adjust to to use the MAX as well.",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-25T15:47:24Z",
          "body": "I'll address this today, so before merging.",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-25T15:48:47Z",
          "body": "yeah correct. I thought about making the interface in local position only but that has other issues. ",
          "path": "src/modules/commander/ModeUtil/mode_requirements.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T07:20:17Z",
          "body": "done",
          "path": "src/modules/navigator/takeoff.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T07:20:55Z",
          "body": "The reason I added it here is to always reset it on activation. Makes sense no?",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-26T12:35:50Z",
          "body": "right, I thought this was in the constructor",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T13:04:07Z",
          "body": "It's actually constrained [here](https://github.com/PX4/PX4-Autopilot/blob/35096d3278e6829dd6d5883a6f57543955a07b16/src/modules/fw_lateral_longitudinal_control/FwLateralLongitudinalControl.cpp#L648) in the FWLatLongController, so I don't think here it's also necessary.",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 74,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T13:14:11Z",
          "body": "Leaving it for now. In https://github.com/PX4/PX4-Autopilot/pull/25123 I would have switched to local position but it didn't solve it for all, as TECS still requires global position.",
          "path": "src/modules/commander/ModeUtil/mode_requirements.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-08T11:56:47Z",
          "body": "```suggestion\r\n\t\tconst float climbout_exiting_altitude = _navigator->get_local_position()->xy_valid ? _climbout_alt_msl :\r\n```",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-08T13:32:55Z",
          "body": "@sfuhrer This is not relative to home, but relative to the takeoff location, right?",
          "path": "src/modules/navigator/takeoff_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-08T13:37:01Z",
          "body": "@sfuhrer I think the parameter is also used for multicopters now, no? In `set_takeoff_position`",
          "path": "src/modules/navigator/takeoff_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-09T09:30:04Z",
          "body": "True, will adapt it comment.",
          "path": "src/modules/navigator/takeoff_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-09T09:30:31Z",
          "body": "Right, but it shouldn't, I'll add a guard.",
          "path": "src/modules/navigator/takeoff_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-10T11:07:09Z",
          "body": "changed it.",
          "path": "src/modules/navigator/takeoff_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-10T11:07:45Z",
          "body": "Haha not so exciting at all..",
          "path": "src/modules/navigator/takeoff.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-11T07:12:58Z",
          "body": "ModuleParams can be removed",
          "path": "src/modules/navigator/takeoff.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-11T07:16:22Z",
          "body": "Can adapt the comment to reflect that it also uses these coordinates to takeoff towards.",
          "path": "src/modules/navigator/navigator_main.cpp",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-11T07:17:33Z",
          "body": "check if it needs a docs update",
          "path": "src/modules/fw_mode_manager/FixedWingModeManager.cpp",
          "position": 52,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2025-07-15T01:35:06Z",
          "body": "Is the stuff above here correct? \r\n\r\nAs per https://discord.com/channels/1022170275984457759/1022186266957201480/threads/1374697513193312347 it sounds like it might not be - specifically this says that course is set based on the vehicle heading on arming, while it sounds like that might not be true, in particular if a takeoff command is used.",
          "path": "docs/en/flight_modes_fw/takeoff.md",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-15T07:53:06Z",
          "body": "We need to distinguish between Mission takeoff and takeoff in Takeoff mode. In Mission mode the takeoff is happening towards the planned Takeoff waypoint (unchanged here). In Takeoff mode I added functionality here in this PR to specify the direction and loiter point - optionally, if not set, it will keep using the current heading. To enable the setting of the takeoff point also a ground control software change is needed, currently in QGC you can only select the Takeoff mode but not set anything (how this looks like in AMC is attached below). \r\nAs to my understanding we document the behavior of PX4 in conjunction with QGC I kept the documentation as it was, with the \"vehicle heading sets takeoff course\".\r\n<img width=\"1442\" height=\"1056\" alt=\"image\" src=\"https://github.com/user-attachments/assets/8e422548-2c18-45b4-aca9-f5b4957053e7\" />\r\n",
          "path": "docs/en/flight_modes_fw/takeoff.md",
          "position": 16,
          "type": "review_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2025-07-16T06:21:20Z",
          "body": "@sfuhrer Thank you\r\n\r\n> As to my understanding we document the behavior of PX4 in conjunction with QGC I kept the documentation as it was, with the \"vehicle heading sets takeoff course\".\r\n\r\nNo, we document as how do do everything you might reasonably want to do, however you want to do it. If we only documented what QGC can do we'd have about 1/2 the functionality :-)\r\n\r\nIf we just document the minimum then no one can, for example, know that they might control this using MAVLink, ROS2, or that they the could add the implementation to QGC.\r\n\r\nI have done a first draft in https://github.com/PX4/PX4-Autopilot/pull/25226 to simplify the task. \r\n",
          "path": "docs/en/flight_modes_fw/takeoff.md",
          "position": 16,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "RomanBapst",
          "created_at": "2025-06-24T07:27:27Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-24T07:28:41Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:04:13Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:13:58Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:15:54Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-25T03:19:41Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-25T15:47:05Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-25T15:47:24Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-25T15:48:48Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T07:20:17Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T07:20:55Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-06-26T12:35:50Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T13:04:07Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-06-26T13:14:11Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-08T11:56:47Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-08T13:32:55Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-08T13:37:01Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-09T09:30:04Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-09T09:30:31Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-10T11:07:09Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-10T11:07:45Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-10T13:13:15Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2025-07-11T13:48:48Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-11T14:00:13Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2025-07-15T01:35:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-15T07:53:06Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "hamishwillee",
          "created_at": "2025-07-16T06:21:20Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect flight logic and unsafe state transitions during fixedâ€‘wing takeoff: previously a navigation failsafe during climbout could trigger inappropriate course holding or failsafing with little ground clearance. The changes add explicit checks (local_position.xy_valid), split takeoff into climbout vs goâ€‘toâ€‘loiter states, and alter control outputs so the vehicle keeps climbing wingsâ€‘level on navigation loss, which corrects an improper conditional/state handling and undesired behavior.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "patch": "@@ -640,6 +640,10 @@ void Navigator::run()\n \n \t\t\t\trep->next.valid = false;\n \n+\t\t\t\t// Fixed-wing: vehicle will takeoff towards these coordinates and establish on a loiter there\n+\t\t\t\t_takeoff.setLoiterPosition(matrix::Vector2d(cmd.param5, cmd.param6));\n+\t\t\t\t_takeoff.setLoiterAltitudeAmsl(cmd.param7);\n+\n \t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n \n #if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff459584cccd257c909b61fbd6146cbbb3d752bf/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 20,
        "changes": 129,
        "patch": "@@ -54,41 +54,123 @@ Takeoff::on_activation()\n \n \t// reset cruising speed to default\n \t_navigator->reset_cruising_speed();\n+\n+\t_fw_takeoff_state = fw_takeoff_state::CLIMBOUT; // only used for fixed-wing takeoff\n }\n \n void\n Takeoff::on_active()\n {\n-\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n+\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n \n-\tif (rep->current.valid) {\n-\t\t// reset the position\n-\t\tset_takeoff_position();\n+\t\tswitch (_fw_takeoff_state) {\n+\t\tcase fw_takeoff_state::CLIMBOUT: {\n+\t\t\t\tif (_navigator->get_global_position()->alt >= _loiter_altitude_msl) {\n \n-\t} else if (is_mission_item_reached_or_completed() && !_navigator->get_mission_result()->finished) {\n-\t\t_navigator->get_mission_result()->finished = true;\n-\t\t_navigator->set_mission_result_updated();\n-\t\t_navigator->mode_completed(getNavigatorStateId());\n+\t\t\t\t\tsetLoiterItemCommonFields(&_mission_item);\n \n-\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n \n-\t\t// set loiter item so position controllers stop doing takeoff logic\n-\t\tif (_navigator->get_land_detected()->landed) {\n-\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n+\t\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n \n-\t\t} else {\n-\t\t\tif (pos_sp_triplet->current.valid\n-\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n-\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n+\t\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n+\t\t\t\t\t// however it will just continue loitering as there is no next mission item\n+\t\t\t\t\t_mission_item.time_inside = 1.f;\n+\t\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n+\t\t\t\t\t_mission_item.altitude = _loiter_altitude_msl;\n \n-\t\t\t} else {\n-\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n+\t\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t\t\t\t\tpos_sp_triplet->current.lat = _loiter_position_lat_lon(0) > DBL_EPSILON ?\n+\t\t\t\t\t\t\t\t      _loiter_position_lat_lon(0) : _navigator->get_global_position()->lat;\n+\t\t\t\t\tpos_sp_triplet->current.lon = _loiter_position_lat_lon(1) > DBL_EPSILON ?\n+\t\t\t\t\t\t\t\t      _loiter_position_lat_lon(1) : _navigator->get_global_position()->lon;\n+\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n+\t\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n+\t\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n+\n+\t\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n+\t\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n+\n+\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\n+\t\t\t\t\treset_mission_item_reached();\n+\n+\t\t\t\t\t_fw_takeoff_state = fw_takeoff_state::GO_TO_LOITER;\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\tcase fw_takeoff_state::GO_TO_LOITER: {\n+\t\t\t\tconst bool navigation_valid = _navigator->get_local_position()->xy_valid;\n+\t\t\t\tbool lateral_acceptance_reached = true;\n+\n+\t\t\t\tif (navigation_valid) {\n+\t\t\t\t\t// only consider lateral acceptance if position estimation is valid\n+\t\t\t\t\tconst float distance_to_loiter = get_distance_to_next_waypoint(_navigator->get_global_position()->lat,\n+\t\t\t\t\t\t\t\t\t _navigator->get_global_position()->lon, _mission_item.lat, _mission_item.lon);\n+\n+\t\t\t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n+\t\t\t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n+\t\t\t\t\t\t\t_navigator->get_loiter_radius();\n+\t\t\t\t\tlateral_acceptance_reached = distance_to_loiter < _navigator->get_acceptance_radius() + mission_item_loiter_radius_abs;\n+\t\t\t\t}\n+\n+\t\t\t\tconst bool vertical_acceptance_reached = _navigator->get_global_position()->alt >= _loiter_altitude_msl -\n+\t\t\t\t\t\t_navigator->get_altitude_acceptance_radius();\n+\n+\t\t\t\tif (lateral_acceptance_reached && vertical_acceptance_reached) {\n+\n+\t\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n+\t\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n+\t\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n+\t\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n+\n+\t\t\t\t\t// the FW takeoff mode is completed, exit to Hold (handled by Commander)\n+\t\t\t\t\t_navigator->get_mission_result()->finished = true;\n+\t\t\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t\t\t_navigator->mode_completed(getNavigatorStateId());\n+\n+\t\t\t\t\t_loiter_altitude_msl = NAN; // reset for next takeoff command\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n \t\t\t}\n+\n+\t\tdefault:\n+\t\t\tbreak;\n \t\t}\n \n-\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t} else { // rotary-wing takeoff\n+\t\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n+\n+\t\tif (rep->current.valid) {\n+\t\t\t// reset the position\n+\t\t\tset_takeoff_position();\n+\n+\t\t} else if (is_mission_item_reached_or_completed() && !_navigator->get_mission_result()->finished) {\n+\t\t\t_navigator->get_mission_result()->finished = true;\n+\t\t\t_navigator->set_mission_result_updated();\n+\t\t\t_navigator->mode_completed(getNavigatorStateId());\n+\n+\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n+\n+\t\t\t// set loiter item so position controllers stop doing takeoff logic\n+\t\t\tif (_navigator->get_land_detected()->landed) {\n+\t\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n \n-\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t\t} else {\n+\t\t\t\tif (pos_sp_triplet->current.valid\n+\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n+\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n+\t\t\t_navigator->set_position_setpoint_triplet_updated();\n+\t\t}\n \t}\n }\n \n@@ -120,6 +202,13 @@ Takeoff::set_takeoff_position()\n \t\t\t     \"Already higher than takeoff altitude (not descending)\");\n \t}\n \n+\tif (!PX4_ISFINITE(_loiter_altitude_msl)) {\n+\t\tif (_navigator->get_loiter_min_alt() > FLT_EPSILON) {\n+\t\t\t_loiter_altitude_msl = math::max(_loiter_altitude_msl, takeoff_altitude_amsl + _navigator->get_loiter_min_alt());\n+\n+\t\t}\n+\t}\n+\n \t// set current mission item to takeoff\n \tset_takeoff_item(&_mission_item, takeoff_altitude_amsl);\n \t_navigator->get_mission_result()->finished = false;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff459584cccd257c909b61fbd6146cbbb3d752bf/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/takeoff.h": {
        "filename": "src/modules/navigator/takeoff.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "patch": "@@ -42,6 +42,7 @@\n \n #include \"navigator_mode.h\"\n #include \"mission_block.h\"\n+#include <lib/mathlib/mathlib.h>\n \n class Takeoff : public MissionBlock\n {\n@@ -52,7 +53,17 @@ class Takeoff : public MissionBlock\n \tvoid on_activation() override;\n \tvoid on_active() override;\n \n+\tvoid setLoiterPosition(matrix::Vector2d loiter_location) { _loiter_position_lat_lon = loiter_location; }\n+\tvoid setLoiterAltitudeAmsl(const float height_m) { _loiter_altitude_msl = height_m; }\n+\n private:\n \n+\tenum class fw_takeoff_state {\n+\t\tCLIMBOUT = 0,\n+\t\tGO_TO_LOITER\n+\t} _fw_takeoff_state;\n+\n \tvoid set_takeoff_position();\n+\tmatrix::Vector2d _loiter_position_lat_lon{static_cast<double>(NAN), static_cast<double>(NAN)};\n+\tfloat _loiter_altitude_msl{NAN};\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/ff459584cccd257c909b61fbd6146cbbb3d752bf/src%2Fmodules%2Fnavigator%2Ftakeoff.h"
      }
    },
    "modified_functions": {
      "all": [
        "Takeoff::on_activation",
        "Navigator::run",
        "Takeoff::set_takeoff_position"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_activation",
          "Takeoff::set_takeoff_position"
        ]
      }
    }
  },
  {
    "title": "Navigator: RTL reverse: when landing set next to invalid to fix horizontal oscillations",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24985",
    "number": 24985,
    "created_at": "2025-06-06T13:08:05Z",
    "merged": true,
    "merged_at": "2025-06-06T13:47:35Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nVehicle oscillates horizontally while in landing after a reverse RTL (RTL_TYPE=2 and no mission landing).\r\n![image](https://github.com/user-attachments/assets/776871b1-d984-4c80-8a9f-8415a61c899a)\r\nWe were testing it without https://github.com/PX4/PX4-Autopilot/pull/24642, which would already have fixed this specific issue. Nevertheless, I think it's better to also set the next to invalid when in the `do_need_move_to_item()` phase.\r\n\r\n### Solution\r\nExtend what was done in https://github.com/PX4/PX4-Autopilot/pull/24642 by also reset next setpoint during the `do_need_move_to_item()` phase.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nImprovement: RTL reverse: reset next position triplet in `do_need_move_to_item()` phase\r\n```\r\n\r\n### Alternatives\r\nThe [position smoothing](https://github.com/PX4/PX4-Autopilot/blob/64989c3b8d062561523a71a68a999b446e50a91e/src/modules/flight_mode_manager/tasks/Auto/FlightTaskAuto.cpp#L175) does something shady when the next waypoint is valid during a vertical decent for landing. Should be addressed as well later on.\r\n\r\n### Test coverage\r\nSITL tested.\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "MaEtUgR",
          "created_at": "2025-06-06T13:47:18Z",
          "body": "Having a land waypoint (with no absolute vertical altitude) but also a next waypoint which is somewhere completely else screws up the logic here:\r\nhttps://github.com/PX4/PX4-Autopilot/blob/64989c3b8d062561523a71a68a999b446e50a91e/src/lib/motion_planning/PositionSmoothing.cpp#L235\r\nand results in the computed speed jumping up and down depending on the current flight direction.\r\n![image](https://github.com/user-attachments/assets/b4098557-217e-49a6-887a-f44d5d1ef088)\r\n\r\nThe cause to get into this situation is the next waypoint not being set correctly in reverse mission RTL which this pr fixes. The hotfix here solves.\r\n\r\n![image](https://github.com/user-attachments/assets/d51b36e3-c047-4753-a527-809dd893ccb0)\r\n\r\nWe need to simplify both sides of this logic, reverse RTL and waypoint execution and combine eventually such that there's no very complex and limiting interface between two such tightly integrated pieces.",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes an incorrect program state/transition: the 'next' waypoint remained valid during reverse-RTL landing, which caused the position smoothing code to compute oscillatory/incorrect horizontal speeds. Resetting the next setpoint during the do_need_move_to_item() phase corrects the state and prevents the undesired behavior.",
    "patches": {
      "src/modules/navigator/rtl_mission_fast_reverse.cpp": {
        "filename": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "patch": "@@ -251,6 +251,11 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t_mission_item.lon = _home_pos_sub.get().lon;\n \t\t\t_mission_item.yaw = NAN;\n \n+\t\t\t// make previous and next setpoints invalid, such that there will be no line following.\n+\t\t\t// If the vehicle drifted off the path during back-transition it should just go straight to the landing point.\n+\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n+\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->next);\n+\n \t\t\tif ((_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) &&\n \t\t\t    do_need_move_to_item()) {\n \t\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND;\n@@ -261,15 +266,9 @@ void RtlMissionFastReverse::handleLanding(WorkItemType &new_work_item_type)\n \t\t\t\t_mission_item.autocontinue = true;\n \t\t\t\t_mission_item.time_inside = 0.0f;\n \n-\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n-\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n-\t\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n-\n \t\t\t} else {\n \t\t\t\t_mission_item.altitude = _home_pos_sub.get().alt;\n \t\t\t\t_mission_item.altitude_is_relative = false;\n-\t\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n-\t\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->next);\n \n \t\t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/649558cee68d39e4921edd7b8fb92d8d359d7d47/src%2Fmodules%2Fnavigator%2Frtl_mission_fast_reverse.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RtlMissionFastReverse::handleLanding"
      ],
      "by_file": {
        "src/modules/navigator/rtl_mission_fast_reverse.cpp": [
          "RtlMissionFastReverse::handleLanding"
        ]
      }
    }
  },
  {
    "title": "mission: add RTL to is_mission_item_reached_or_completed()",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24946",
    "number": 24946,
    "created_at": "2025-05-30T08:36:57Z",
    "merged": true,
    "merged_at": "2025-06-30T16:20:44Z",
    "state": "closed",
    "conversation": {
      "author": "mahima-yoga",
      "body": "This ensures that a mission is marked as completed when RTL is the last item. \r\n\r\n### Solved Problem\r\nMission not marked as complete when RTL is the last mission item. \r\n\r\n### Solution\r\n- Add `NAV_CMD_RETURN_TO_LAUNCH` to `is_mission_item_reached_or_completed()`. \r\n\r\nItem was added to block of action commands that completes instantaneously. If it's grouped with the the other land actions `NAV_CMD_LAND` / `NAV_CMD_VTOL_LAND` the action never completes as (my understanding:) RTL executes outside of the mission framework. \r\n \r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix add RTL to is_mission_item_reached_or_completed()\r\n```\r\n\r\n### Test coverage\r\n\r\nTested in SITL: \r\n\r\n![image](https://github.com/user-attachments/assets/df581239-40f4-47ec-8f12-ed399708ad8a)\r\n",
      "issue_comments": [
        {
          "author": "mahima-yoga",
          "created_at": "2025-06-02T11:22:30Z",
          "body": "re CI failure: \r\n\r\nhttps://github.com/PX4/PX4-Autopilot/issues/24954",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2025-06-11T02:35:49Z",
          "body": "Hm, so why does this pass when I run it locally?\r\n\r\nEdit: nevermind, I had not rebuilt properly.\r\n\r\n```\r\n==> Running tests for iris\r\n--> Test case 1 of 18: 'Takeoff and hold position' running ...\r\n--- Test case 1 of 18: 'Takeoff and hold position' succeeded.\r\n--> Test case 2 of 18: 'Failure Injection - Reject mid-air when it is disabled' running ...\r\n--- Test case 2 of 18: 'Failure Injection - Reject mid-air when it is disabled' succeeded.\r\n--> Test case 3 of 18: 'Land on GPS lost during mission (baro height mode)' running ...\r\n--- Test case 3 of 18: 'Land on GPS lost during mission (baro height mode)' succeeded.\r\n--> Test case 4 of 18: 'Land on GPS lost during mission (GPS height mode)' running ...\r\n--- Test case 4 of 18: 'Land on GPS lost during mission (GPS height mode)' succeeded.\r\n--> Test case 5 of 18: 'Continue on mag lost during mission' running ...\r\n--- Test case 5 of 18: 'Continue on mag lost during mission' succeeded.\r\n--> Test case 6 of 18: 'Continue on baro lost during mission (baro height mode)' running ...\r\n--- Test case 6 of 18: 'Continue on baro lost during mission (baro height mode)' succeeded.\r\n--> Test case 7 of 18: 'Continue on baro lost during mission (GPS height mode)' running ...\r\n--- Test case 7 of 18: 'Continue on baro lost during mission (GPS height mode)' succeeded.\r\n--> Test case 8 of 18: 'Continue on baro stuck during mission (baro height mode)' running ...\r\n--- Test case 8 of 18: 'Continue on baro stuck during mission (baro height mode)' succeeded.\r\n--> Test case 9 of 18: 'Continue on baro stuck during mission (GPS height mode)' running ...\r\n--- Test case 9 of 18: 'Continue on baro stuck during mission (GPS height mode)' succeeded.\r\n--> Test case 10 of 18: 'Takeoff and Land' running ...\r\n--- Test case 10 of 18: 'Takeoff and Land' succeeded.\r\n--> Test case 11 of 18: 'Fly square Multicopter Missions including RTL' running ...\r\n--- Test case 11 of 18: 'Fly square Multicopter Missions including RTL' succeeded.\r\n--> Test case 12 of 18: 'Fly square Multicopter Missions with manual RTL' running ...\r\n--- Test case 12 of 18: 'Fly square Multicopter Missions with manual RTL' succeeded.\r\n--> Test case 13 of 18: 'Fly straight Multicopter Mission' running ...\r\n--- Test case 13 of 18: 'Fly straight Multicopter Mission' succeeded.\r\n--> Test case 14 of 18: 'Offboard takeoff and land' running ...\r\n--- Test case 14 of 18: 'Offboard takeoff and land' succeeded.\r\n--> Test case 15 of 18: 'Offboard position control' running ...\r\n--- Test case 15 of 18: 'Offboard position control' succeeded.\r\n--> Test case 16 of 18: 'Offboard attitude control' running ...\r\n--- Test case 16 of 18: 'Offboard attitude control' succeeded.\r\n--> Test case 17 of 18: 'Fly forward in position control' running ...\r\n--- Test case 17 of 18: 'Fly forward in position control' succeeded.\r\n--> Test case 18 of 18: 'Fly forward in altitude control' running ...\r\n--- Test case 18 of 18: 'Fly forward in altitude control' succeeded.\r\n==> Running tests for iris\r\n--> Test case 1 of 1: 'Offboard attitude control' running ...\r\n--- Test case 1 of 1: 'Offboard attitude control' succeeded.\r\n\r\nResults:\r\n  - iris:\r\n     - 'Takeoff and hold position': succeeded\r\n     - 'Failure Injection - Reject mid-air when it is disabled': succeeded\r\n     - 'Land on GPS lost during mission (baro height mode)': succeeded\r\n     - 'Land on GPS lost during mission (GPS height mode)': succeeded\r\n     - 'Continue on mag lost during mission': succeeded\r\n     - 'Continue on baro lost during mission (baro height mode)': succeeded\r\n     - 'Continue on baro lost during mission (GPS height mode)': succeeded\r\n     - 'Continue on baro stuck during mission (baro height mode)': succeeded\r\n     - 'Continue on baro stuck during mission (GPS height mode)': succeeded\r\n     - 'Takeoff and Land': succeeded\r\n     - 'Fly square Multicopter Missions including RTL': succeeded\r\n     - 'Fly square Multicopter Missions with manual RTL': succeeded\r\n     - 'Fly straight Multicopter Mission': succeeded\r\n     - 'Offboard takeoff and land': succeeded\r\n     - 'Offboard position control': succeeded\r\n     - 'Offboard attitude control': succeeded\r\n     - 'Fly forward in position control': succeeded\r\n     - 'Fly forward in altitude control': succeeded\r\n  - iris:\r\n     - 'Offboard attitude control': succeeded\r\n  - standard_vtol (not selected)\r\n  - tailsitter (not selected)\r\n  - typhoon_h480 (not selected)\r\n```",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2025-06-25T00:47:08Z",
          "body": "This passed, now I'm going to rebase it once more.",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2025-06-30T08:50:25Z",
          "body": "@mrpollo we should now merge this one, to get my changes in.",
          "type": "issue_comment"
        },
        {
          "author": "mrpollo",
          "created_at": "2025-06-30T19:39:10Z",
          "body": "@julianoes SITL tests on the push commit failed https://github.com/PX4/PX4-Autopilot/actions/runs/15978273656/job/45066295014",
          "type": "issue_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2025-06-30T22:18:54Z",
          "body": "@mrpollo yes, I see this one every now and then, but I haven't seen it locally, at least not recently.\r\n\r\nI believe it's an actual estimation/control problem:\r\n\r\n```\r\n [  70.413|mavsdk_tests] ../../../test/mavsdk_tests/autopilot_tester.cpp:646: FAILED:\r\n[  70.414|mavsdk_tests]   CHECK( current_deviation <= max_deviation_m )\r\n[  70.414|mavsdk_tests] with expansion:\r\n[  70.414|mavsdk_tests]   0.20062f <= 0.2f\r\n```\r\n\r\nMy \"fix\" would be to increase the threshold...",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "mrpollo",
          "created_at": "2025-06-30T16:20:12Z",
          "body": "Thanks @mahima-yoga / @julianoes ðŸŽ‰ ",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect program behavior: RTL (NAV_CMD_RETURN_TO_LAUNCH) was not treated as a mission-item-completed condition, so missions ending with RTL were not marked complete. Adding RTL to is_mission_item_reached_or_completed() corrects the conditional classification/state logic that determines mission completion.",
    "patches": {
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -96,6 +96,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tcase NAV_CMD_SET_CAMERA_FOCUS:\n \tcase NAV_CMD_DO_CHANGE_SPEED:\n \tcase NAV_CMD_DO_SET_HOME:\n+\tcase NAV_CMD_RETURN_TO_LAUNCH:\n \n \t\treturn true;\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4a7352c067d81947b75987dbcd34f07997990704/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::is_mission_item_reached_or_completed"
      ],
      "by_file": {
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ]
      }
    }
  },
  {
    "title": "Navigator: allow executing a disarm command during a mission",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/24910",
    "number": 24910,
    "created_at": "2025-05-23T14:50:11Z",
    "merged": true,
    "merged_at": "2025-05-27T11:26:30Z",
    "state": "closed",
    "conversation": {
      "author": "mahima-yoga",
      "body": "### Solved Problem\r\n\r\nFor missions with intermediate landings, vehicle doesn't disarm when landed. \r\n\r\n### Solution\r\n- Add disarm command during mission \r\n\r\nAfter disarming, to continue the mission you need to select the next waypoint resume the mission. \r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix Allow executing disarm command during a mission \r\n```\r\n### Test coverage\r\n\r\nTested in SITL. Landing in the middle of a mission: \r\n\r\n![image](https://github.com/user-attachments/assets/d53b23fd-a171-4434-b3e7-2efd9b882d7a)\r\n\r\nlatest_arming_reason: ARM_DISARM_REASON_COMMAND_INTERNAL = 3\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-05-23T14:56:10Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 56 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +56  +0.0%     +56    .text\n    +5.0%     +48  +5.0%     +48    MavlinkMissionManager::parse_mavlink_mission_item()\n    +0.0%      +8  +0.0%      +8    [section .text]\n    +1.7%      +4  +1.7%      +4    FeasibilityChecker::checkTakeoffLandAvailable()\n    +0.2%      +4  +0.2%      +4    MissionBlock::is_mission_item_reached_or_completed()\n    -0.9%      -4  -0.9%      -4    FeasibilityChecker::checkMissionItemValidity()\n    -3.8%      -4  -3.8%      -4    Mission::handleVtolTransition()\n  +0.0%     +55  [ = ]       0    .debug_abbrev\n  +0.0%     +96  [ = ]       0    .debug_info\n  +0.0%      +9  [ = ]       0    .debug_line\n   -75.0%      -3  [ = ]       0    [Unmapped]\n    +0.0%     +12  [ = ]       0    [section .debug_line]\n  +0.0%      +8  [ = ]       0    .debug_loclists\n  -0.0%      -1  [ = ]       0    .debug_rnglists\n  +0.0%     +29  [ = ]       0    .debug_str\n  -0.6%     -56  [ = ]       0    [Unmapped]\n  +0.0%    +196  +0.0%     +56    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 48 byte (0 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%     +48  +0.0%     +48    .text\n    +5.0%     +48  +5.0%     +48    MavlinkMissionManager::parse_mavlink_mission_item()\n    +1.7%      +4  +1.7%      +4    FeasibilityChecker::checkTakeoffLandAvailable()\n    +0.2%      +4  +0.2%      +4    MissionBlock::is_mission_item_reached_or_completed()\n    -0.9%      -4  -0.9%      -4    FeasibilityChecker::checkMissionItemValidity()\n    -3.8%      -4  -3.8%      -4    Mission::handleVtolTransition()\n  +0.0%     +55  [ = ]       0    .debug_abbrev\n  +0.0%     +96  [ = ]       0    .debug_info\n  +0.0%      +9  [ = ]       0    .debug_line\n   -75.0%      -3  [ = ]       0    [Unmapped]\n    +0.0%     +12  [ = ]       0    [section .debug_line]\n  +0.0%     +36  [ = ]       0    .debug_loclists\n  -0.0%      -1  [ = ]       0    .debug_rnglists\n  +0.0%     +29  [ = ]       0    .debug_str\n  -0.6%     -48  [ = ]       0    [Unmapped]\n  +0.0%    +224  +0.0%     +48    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-05-23T14:56:09_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2025-05-27T11:25:52Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR addresses incorrect behavior where a disarm command was ignored during missions with intermediate landings. This is a logic/state-handling bug (improper state transition/command handling) and the change permits executing disarm during a mission to produce the intended behavior (tested in SITL).",
    "patches": {
      "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": {
        "filename": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -263,6 +263,7 @@ bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item,\n \t    mission_item.nav_cmd != NAV_CMD_DO_LAND_START &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_TRIGGER_CONTROL &&\n \t    mission_item.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n+\t    mission_item.nav_cmd != NAV_CMD_COMPONENT_ARM_DISARM &&\n \t    mission_item.nav_cmd != NAV_CMD_IMAGE_START_CAPTURE &&\n \t    mission_item.nav_cmd != NAV_CMD_IMAGE_STOP_CAPTURE &&\n \t    mission_item.nav_cmd != NAV_CMD_VIDEO_START_CAPTURE &&",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d498114ee1a51eb8fa7655c532f4dac6e525e7ca/src%2Fmodules%2Fnavigator%2FMissionFeasibility%2FFeasibilityChecker.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -82,6 +82,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n \tcase NAV_CMD_DO_MOUNT_CONTROL:\n \tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n+\tcase NAV_CMD_COMPONENT_ARM_DISARM:\n \tcase NAV_CMD_DO_SET_ROI:\n \tcase NAV_CMD_DO_SET_ROI_LOCATION:\n \tcase NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n@@ -95,6 +96,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \tcase NAV_CMD_SET_CAMERA_FOCUS:\n \tcase NAV_CMD_DO_CHANGE_SPEED:\n \tcase NAV_CMD_DO_SET_HOME:\n+\n \t\treturn true;\n \n \t// Indefinite Waypoints",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d498114ee1a51eb8fa7655c532f4dac6e525e7ca/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -76,6 +76,7 @@ enum NAV_CMD {\n \tNAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = 214,\n \tNAV_CMD_DO_SET_CAM_TRIGG_DIST = 206,\n \tNAV_CMD_OBLIQUE_SURVEY = 260,\n+\tNAV_CMD_COMPONENT_ARM_DISARM = 400,\n \tNAV_CMD_SET_CAMERA_MODE = 530,\n \tNAV_CMD_SET_CAMERA_SOURCE = 534,\n \tNAV_CMD_SET_CAMERA_ZOOM = 531,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d498114ee1a51eb8fa7655c532f4dac6e525e7ca/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      }
    },
    "modified_functions": {
      "all": [
        "FeasibilityChecker::checkMissionItemValidity",
        "MissionBlock::is_mission_item_reached_or_completed"
      ],
      "by_file": {
        "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp": [
          "FeasibilityChecker::checkMissionItemValidity"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached_or_completed"
        ]
      }
    }
  },
  {
    "title": "Navigator/FW mode manager: fix handling of counter-clockwise loiter",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/25265",
    "number": 25265,
    "created_at": "2025-07-22T11:33:25Z",
    "merged": true,
    "merged_at": "2025-07-28T08:57:56Z",
    "state": "closed",
    "conversation": {
      "author": "sfuhrer",
      "body": "\r\n### Solved Problem\r\nWhen `NAV_LOITER_RAD` is negative, the direction is counter-clockwise. This was not always properly handled and not reflected in the parameter description. \r\n\r\n### Solution\r\n- refactor: renaming of `get_loiter_radius()` to `get_default_loiter_radius()`\r\n- In Navigator: cleanly extract direction from parameter and pass it through PositionSetpoint.msg (has separate fields for radius and direction).\r\n- In FWFlightModeManager: handle negative values of `NAV_LOITER_RAD` correctly (in the case where the PositionSetpoint loiter_radius is not filled)\r\n- Fix param description of NAV_LOITER_RAD, make the limits symmetric and open them up to 10km (why not, 1km is rather preventive for some usecases)\r\n\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nBugfix: Navigator/FW mode manager: fix handling of counter-clockwise loiter\r\n```\r\n\r\n### Test coverage\r\nSimulation tested.\r\n\r\n",
      "issue_comments": [
        {
          "author": "github-actions[bot]",
          "created_at": "2025-07-22T11:39:12Z",
          "body": "## ðŸ”Ž FLASH Analysis\n<details>\n  <summary>px4_fmu-v5x [Total VM Diff: 280 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +280  +0.0%    +280    .text\n    +2.0%     +68  +2.0%     +68    Navigator::run()\n    +0.0%     +56  +0.0%     +56    g_cromfs_image\n    +6.6%     +36  +6.6%     +36    FixedWingModeManager::control_auto_loiter()\n    +2.7%     +32  +2.7%     +32    FixedWingModeManager::control_auto_landing_circular()\n    +2.0%      +8  +2.0%      +8    MissionBase::do_abort_landing()\n     +15%      +8   +15%      +8    MissionBlock::setLoiterItemFromCurrentPositionWithBraking()\n    +8.3%      +8  +8.3%      +8    MissionBlock::set_idle_item()\n    +5.1%      +8  +5.1%      +8    MissionBlock::set_land_item()\n    +0.8%      +8  +0.8%      +8    Navigator::geofence_breach_check()\n    +6.2%      +8  +6.2%      +8    Navigator::reset_position_setpoint()\n    +1.2%      +8  +1.2%      +8    RtlDirectMissionLand::setActiveMissionItems()\n    +1.4%      +8  +1.4%      +8    Takeoff::on_active()\n   -99.6%      +8 -99.6%      +8    [6 Others]\n    +3.8%      +4  +3.8%      +4    Mission::handleVtolTransition()\n    +1.0%      +4  +1.0%      +4    MissionBase::handleLanding()\n    +1.8%      +4  +1.8%      +4    MissionBase::isLanding()\n    +5.6%      +4  +5.6%      +4    MissionBlock::initialize()\n    +0.2%      +4  +0.2%      +4    MissionBlock::is_mission_item_reached_or_completed()\n    +1.0%      +4  +1.0%      +4    MissionBlock::mission_item_to_position_setpoint()\n    -0.6%      -4  -0.6%      -4    FixedWingModeManager::vehicle_attitude_poll()\n    -1.4%      -4  -1.4%      -4    MissionBase::setMissionToClosestItem()\n  +0.0%     +54  [ = ]       0    .debug_abbrev\n  +0.0%      +8  [ = ]       0    .debug_frame\n  +0.0%    +188  [ = ]       0    .debug_info\n  +0.0%    +526  [ = ]       0    .debug_line\n   -33.3%      -1  [ = ]       0    [Unmapped]\n    +0.0%    +527  [ = ]       0    [section .debug_line]\n  +0.0%     +80  [ = ]       0    .debug_loclists\n  +0.0%    +160  [ = ]       0    .debug_rnglists\n   -33.3%      -1  [ = ]       0    [Unmapped]\n    +0.0%    +161  [ = ]       0    [section .debug_rnglists]\n  +0.0%    +108  [ = ]       0    .debug_str\n  -2.9%    -280  [ = ]       0    [Unmapped]\n  +0.0% +1.10Ki  +0.0%    +280    TOTAL\n\n  ```\n</details>\n\n<details>\n  <summary>px4_fmu-v6x [Total VM Diff: 272 byte (0.01 %)]</summary>\n\n  ```\n      FILE SIZE        VM SIZE    \n --------------  -------------- \n  +0.0%    +272  +0.0%    +272    .text\n    +2.0%     +68  +2.0%     +68    Navigator::run()\n    +0.0%     +40  +0.0%     +40    g_cromfs_image\n    +6.6%     +36  +6.6%     +36    FixedWingModeManager::control_auto_loiter()\n    +2.7%     +32  +2.7%     +32    FixedWingModeManager::control_auto_landing_circular()\n   -99.1%     +16 -99.1%     +16    [6 Others]\n    +2.0%      +8  +2.0%      +8    MissionBase::do_abort_landing()\n     +15%      +8   +15%      +8    MissionBlock::setLoiterItemFromCurrentPositionWithBraking()\n    +8.3%      +8  +8.3%      +8    MissionBlock::set_idle_item()\n    +5.1%      +8  +5.1%      +8    MissionBlock::set_land_item()\n    +0.8%      +8  +0.8%      +8    Navigator::geofence_breach_check()\n    +6.2%      +8  +6.2%      +8    Navigator::reset_position_setpoint()\n    +1.2%      +8  +1.2%      +8    RtlDirectMissionLand::setActiveMissionItems()\n    +1.4%      +8  +1.4%      +8    Takeoff::on_active()\n    +3.8%      +4  +3.8%      +4    Mission::handleVtolTransition()\n    +1.0%      +4  +1.0%      +4    MissionBase::handleLanding()\n    +1.8%      +4  +1.8%      +4    MissionBase::isLanding()\n    +5.6%      +4  +5.6%      +4    MissionBlock::initialize()\n    +0.2%      +4  +0.2%      +4    MissionBlock::is_mission_item_reached_or_completed()\n    +1.0%      +4  +1.0%      +4    MissionBlock::mission_item_to_position_setpoint()\n    -0.6%      -4  -0.6%      -4    FixedWingModeManager::vehicle_attitude_poll()\n    -1.4%      -4  -1.4%      -4    MissionBase::setMissionToClosestItem()\n  +0.0%     +54  [ = ]       0    .debug_abbrev\n  +0.0%      +8  [ = ]       0    .debug_frame\n  +0.0%    +188  [ = ]       0    .debug_info\n  +0.0%    +526  [ = ]       0    .debug_line\n    [DEL]      -1  [ = ]       0    [Unmapped]\n    +0.0%    +527  [ = ]       0    [section .debug_line]\n  +0.0%     +92  [ = ]       0    .debug_loclists\n  +0.0%    +164  [ = ]       0    .debug_rnglists\n    [NEW]      +3  [ = ]       0    [Unmapped]\n    +0.0%    +161  [ = ]       0    [section .debug_rnglists]\n  +0.0%    +108  [ = ]       0    .debug_str\n  -5.6%    -272  [ = ]       0    [Unmapped]\n  +0.0% +1.11Ki  +0.0%    +272    TOTAL\n\n  ```\n</details>\n\n**Updated: _2025-07-28T08:24:33_**",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "dawr68",
          "created_at": "2025-07-25T13:04:15Z",
          "body": "",
          "state": "DISMISSED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes â€” the PR fixes incorrect runtime behavior where a negative NAV_LOITER_RAD (meaning counterâ€‘clockwise loiter) was not consistently interpreted or propagated, causing wrong loiter direction. The change separates radius and direction in the PositionSetpoint, extracts direction from the parameter, and corrects FW mode manager fallback handling, which addresses a logic/state handling and dataâ€‘flow bug rather than a syntax/style issue.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -406,7 +406,7 @@ MissionBase::isLanding()\n \t\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n \t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n \t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n-\t\t\t\t\t_navigator->get_loiter_radius();\n+\t\t\t\t\t_navigator->get_default_loiter_rad();\n \n \t\t\ton_landing_stage = d_current <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs);\n \t\t}\n@@ -883,7 +883,7 @@ MissionBase::do_abort_landing()\n \t_mission_item.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n \t_mission_item.altitude_is_relative = false;\n \t_mission_item.altitude = alt_sp;\n-\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t_mission_item.loiter_radius = _navigator->get_default_loiter_rad();\n \t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \t_mission_item.autocontinue = false;\n \t_mission_item.origin = ORIGIN_ONBOARD;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -170,7 +170,7 @@ MissionBlock::is_mission_item_reached_or_completed()\n \t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n \t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n \t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n-\t\t\t\t_navigator->get_loiter_radius();\n+\t\t\t\t_navigator->get_default_loiter_rad();\n \n \t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n \t\t\t\t_navigator->get_global_position()->lat,\n@@ -626,7 +626,7 @@ MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, posi\n \tsp->alt = get_absolute_altitude_for_item(item);\n \tsp->yaw = item.yaw;\n \tsp->loiter_radius = (fabsf(item.loiter_radius) > FLT_EPSILON) ? fabsf(item.loiter_radius) :\n-\t\t\t    _navigator->get_loiter_radius();\n+\t\t\t    _navigator->get_default_loiter_rad();\n \tsp->loiter_direction_counter_clockwise = item.loiter_radius < 0;\n \n \tif (item.acceptance_radius > FLT_EPSILON && PX4_ISFINITE(item.acceptance_radius)) {\n@@ -730,7 +730,7 @@ MissionBlock::setLoiterItemFromCurrentPosition(struct mission_item_s *item)\n \t}\n \n \titem->altitude = loiter_altitude_amsl;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_radius = _navigator->get_default_loiter_rad();\n \titem->yaw = NAN;\n }\n \n@@ -742,7 +742,7 @@ MissionBlock::setLoiterItemFromCurrentPositionWithBraking(struct mission_item_s\n \t_navigator->preproject_stop_point(item->lat, item->lon);\n \n \titem->altitude = _navigator->get_global_position()->alt;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_radius = _navigator->get_default_loiter_rad();\n \titem->yaw = NAN;\n }\n \n@@ -773,7 +773,7 @@ MissionBlock::set_takeoff_item(struct mission_item_s *item, float abs_altitude)\n \titem->altitude_is_relative = false;\n \n \titem->acceptance_radius = _navigator->get_acceptance_radius();\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_radius = _navigator->get_default_loiter_rad();\n \titem->autocontinue = false;\n \titem->origin = ORIGIN_ONBOARD;\n }\n@@ -808,7 +808,7 @@ MissionBlock::set_land_item(struct mission_item_s *item)\n \n \titem->altitude = 0;\n \titem->altitude_is_relative = false;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_radius = _navigator->get_default_loiter_rad();\n \titem->acceptance_radius = _navigator->get_acceptance_radius();\n \titem->time_inside = 0.0f;\n \titem->autocontinue = true;\n@@ -824,7 +824,7 @@ MissionBlock::set_idle_item(struct mission_item_s *item)\n \titem->altitude_is_relative = false;\n \titem->altitude = _navigator->get_home_position()->alt;\n \titem->yaw = NAN;\n-\titem->loiter_radius = _navigator->get_loiter_radius();\n+\titem->loiter_radius = _navigator->get_default_loiter_rad();\n \titem->acceptance_radius = _navigator->get_acceptance_radius();\n \titem->time_inside = 0.0f;\n \titem->autocontinue = true;\n@@ -896,7 +896,7 @@ MissionBlock::initialize()\n \t_mission_item.lat = (double)NAN;\n \t_mission_item.lon = (double)NAN;\n \t_mission_item.yaw = NAN;\n-\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t_mission_item.loiter_radius = _navigator->get_default_loiter_rad();\n \t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n \t_mission_item.time_inside = 0.0f;\n \t_mission_item.autocontinue = true;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -179,7 +179,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tGeofence &get_geofence() { return _geofence; }\n \n-\tfloat get_loiter_radius() { return _param_nav_loiter_rad.get(); }\n+\tfloat get_default_loiter_rad() { return fabsf(_param_nav_loiter_rad.get()); }\n+\tbool get_default_loiter_CCW() { return _param_nav_loiter_rad.get() < -FLT_EPSILON; }\n \n \t/**\n \t * Returns the default acceptance radius defined by the parameter",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "patch": "@@ -368,7 +368,7 @@ void Navigator::run()\n \n \n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\t\t\t\trep->current.loiter_radius = get_default_loiter_rad();\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n@@ -471,7 +471,7 @@ void Navigator::run()\n \t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n \n \t\t\t\t\t} else {\n-\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\t\t\trep->current.loiter_radius = get_default_loiter_rad();\n \t\t\t\t\t}\n \n \t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n@@ -509,8 +509,8 @@ void Navigator::run()\n \t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n+\t\t\t\t\trep->current.loiter_radius = get_default_loiter_rad();\n+\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_default_loiter_CCW();\n \t\t\t\t\trep->current.loiter_orientation = 0.0f;\n \t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n \t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n@@ -525,7 +525,7 @@ void Navigator::run()\n \n \t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n \t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n-\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n+\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < -FLT_EPSILON;\n \t\t\t\t\t}\n \n \t\t\t\t\trep->current.lat = position_setpoint.lat;\n@@ -557,8 +557,8 @@ void Navigator::run()\n \t\t\t\tif (geofence_allows_position(position_setpoint)) {\n \t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n \t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n-\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n-\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n+\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_default_loiter_rad());\n+\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_default_loiter_CCW();\n \t\t\t\t\trep->current.loiter_orientation = 0.0f;\n \t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n \t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n@@ -571,7 +571,7 @@ void Navigator::run()\n \n \t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n \t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n-\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n+\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < -FLT_EPSILON;\n \t\t\t\t\t}\n \n \t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n@@ -604,8 +604,8 @@ void Navigator::run()\n \t\t\t\trep->previous.lon = get_global_position()->lon;\n \t\t\t\trep->previous.alt = get_global_position()->alt;\n \n-\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n-\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n+\t\t\t\trep->current.loiter_radius = get_default_loiter_rad();\n+\t\t\t\trep->current.loiter_direction_counter_clockwise = get_default_loiter_CCW();\n \t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n \t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n \n@@ -941,7 +941,7 @@ void Navigator::geofence_breach_check()\n \t\t\tvertical_test_point_distance = _gf_breach_avoidance.computeVerticalBrakingDistanceMultirotor();\n \n \t\t} else {\n-\t\t\ttest_point_distance = 2.0f * get_loiter_radius();\n+\t\t\ttest_point_distance = 2.0f * get_default_loiter_rad();\n \t\t\tvertical_test_point_distance = 5.0f;\n \n \t\t\tif (hrt_absolute_time() - pos_ctrl_status.timestamp < 100000 && PX4_ISFINITE(pos_ctrl_status.nav_bearing)) {\n@@ -1056,7 +1056,7 @@ void Navigator::geofence_breach_check()\n \t\t\t\trep->current.lon = loiter_longitude;\n \t\t\t\trep->current.alt = loiter_altitude_amsl;\n \t\t\t\trep->current.valid = true;\n-\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n+\t\t\t\trep->current.loiter_radius = get_default_loiter_rad();\n \t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n \t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n \t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n@@ -1173,7 +1173,7 @@ void Navigator::reset_position_setpoint(position_setpoint_s &sp)\n \tsp.lat = static_cast<double>(NAN);\n \tsp.lon = static_cast<double>(NAN);\n \tsp.yaw = NAN;\n-\tsp.loiter_radius = get_loiter_radius();\n+\tsp.loiter_radius = get_default_loiter_rad();\n \tsp.acceptance_radius = get_default_acceptance_radius();\n \tsp.cruising_speed = get_cruising_speed();\n \tsp.cruising_throttle = get_cruising_throttle();",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      },
      "src/modules/navigator/navigator_params.c": {
        "filename": "src/modules/navigator/navigator_params.c",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "patch": "@@ -43,11 +43,14 @@\n /**\n  * Loiter radius (FW only)\n  *\n- * Default value of loiter radius in FW mode (e.g. for Loiter mode).\n+ * Default value of loiter radius in fixed-wing mode (e.g. for Loiter mode).\n+ *\n+ * The direction of the loiter can be set via the sign: A positive value for\n+ * clockwise, negative for counter-clockwise.\n  *\n  * @unit m\n- * @min 25\n- * @max 1000\n+ * @min -10000\n+ * @max 10000\n  * @decimal 1\n  * @increment 0.5\n  * @group Mission",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Fnavigator_params.c"
      },
      "src/modules/navigator/rtl_direct.cpp": {
        "filename": "src/modules/navigator/rtl_direct.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -244,7 +244,7 @@ void RtlDirect::set_rtl_item()\n \t\t\t\t.alt = _rtl_alt,\n \t\t\t\t.yaw = _param_wv_en.get() ? NAN : _navigator->get_local_position()->heading,\n \t\t\t};\n-\t\t\tsetLoiterToAltMissionItem(_mission_item, pos_yaw_sp, _navigator->get_loiter_radius());\n+\t\t\tsetLoiterToAltMissionItem(_mission_item, pos_yaw_sp, _navigator->get_default_loiter_rad());\n \n \t\t\tbreak;\n \t\t}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Frtl_direct.cpp"
      },
      "src/modules/navigator/rtl_direct_mission_land.cpp": {
        "filename": "src/modules/navigator/rtl_direct_mission_land.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -142,7 +142,7 @@ void RtlDirectMissionLand::setActiveMissionItems()\n \t\t_mission_item.time_inside = 0.0f;\n \t\t_mission_item.autocontinue = true;\n \t\t_mission_item.origin = ORIGIN_ONBOARD;\n-\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t_mission_item.loiter_radius = _navigator->get_default_loiter_rad();\n \n \t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL Mission land: climb to %d m\\t\",\n \t\t\t\t (int)ceilf(_rtl_alt));",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Frtl_direct_mission_land.cpp"
      },
      "src/modules/navigator/takeoff.cpp": {
        "filename": "src/modules/navigator/takeoff.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -77,7 +77,7 @@ Takeoff::on_active()\n \t\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n \t\t\t\t\t// however it will just continue loitering as there is no next mission item\n \t\t\t\t\t_mission_item.time_inside = 1.f;\n-\t\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t\t\t_mission_item.loiter_radius = _navigator->get_default_loiter_rad();\n \t\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n \t\t\t\t\t_mission_item.altitude = _loiter_altitude_msl;\n \n@@ -114,7 +114,7 @@ Takeoff::on_active()\n \n \t\t\t\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n \t\t\t\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n-\t\t\t\t\t\t\t_navigator->get_loiter_radius();\n+\t\t\t\t\t\t\t_navigator->get_default_loiter_rad();\n \t\t\t\t\tlateral_acceptance_reached = distance_to_loiter < _navigator->get_acceptance_radius() + mission_item_loiter_radius_abs;\n \t\t\t\t}\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Ftakeoff.cpp"
      },
      "src/modules/navigator/vtol_takeoff.cpp": {
        "filename": "src/modules/navigator/vtol_takeoff.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -116,7 +116,7 @@ VtolTakeoff::on_active()\n \t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n \t\t\t\t// however it will just continue loitering as there is no next mission item\n \t\t\t\t_mission_item.time_inside = 1.f;\n-\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n+\t\t\t\t_mission_item.loiter_radius = _navigator->get_default_loiter_rad();\n \t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n \t\t\t\t_mission_item.altitude = _takeoff_alt_msl + _param_loiter_alt.get();\n ",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/d16649099bfefbec9516152a31ac6f5f2f3c5e44/src%2Fmodules%2Fnavigator%2Fvtol_takeoff.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBlock::set_idle_item",
        "VtolTakeoff::on_active",
        "MissionBlock::set_takeoff_item",
        "MissionBlock::set_land_item",
        "MissionBase::do_abort_landing",
        "RtlDirectMissionLand::setActiveMissionItems",
        "MissionBlock::mission_item_to_position_setpoint",
        "MissionBlock::setLoiterItemFromCurrentPosition",
        "MissionBlock::initialize",
        "mode",
        "Navigator::run",
        "Takeoff::on_active",
        "Navigator::geofence_breach_check",
        "RtlDirect::set_rtl_item",
        "get_loiter_radius",
        "MissionBlock::is_mission_item_reached_or_completed",
        "Navigator::reset_position_setpoint",
        "MissionBlock::setLoiterItemFromCurrentPositionWithBraking",
        "MissionBase::isLanding"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::do_abort_landing",
          "MissionBase::isLanding"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::set_idle_item",
          "MissionBlock::setLoiterItemFromCurrentPosition",
          "MissionBlock::initialize",
          "MissionBlock::set_takeoff_item",
          "MissionBlock::set_land_item",
          "MissionBlock::is_mission_item_reached_or_completed",
          "MissionBlock::setLoiterItemFromCurrentPositionWithBraking",
          "MissionBlock::mission_item_to_position_setpoint"
        ],
        "src/modules/navigator/navigator.h": [
          "get_loiter_radius"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::geofence_breach_check",
          "Navigator::run",
          "Navigator::reset_position_setpoint"
        ],
        "src/modules/navigator/navigator_params.c": [
          "mode"
        ],
        "src/modules/navigator/rtl_direct.cpp": [
          "RtlDirect::set_rtl_item"
        ],
        "src/modules/navigator/rtl_direct_mission_land.cpp": [
          "RtlDirectMissionLand::setActiveMissionItems"
        ],
        "src/modules/navigator/takeoff.cpp": [
          "Takeoff::on_active"
        ],
        "src/modules/navigator/vtol_takeoff.cpp": [
          "VtolTakeoff::on_active"
        ]
      }
    }
  },
  {
    "title": "fix: allow RTL during mission",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/25191",
    "number": 25191,
    "created_at": "2025-07-10T14:38:44Z",
    "merged": true,
    "merged_at": "2025-07-11T07:10:43Z",
    "state": "closed",
    "conversation": {
      "author": "mahima-yoga",
      "body": "\r\n### Solved Problem\r\n\r\nFor missions with multiple land items (eg. delivery missions): If an RTL is triggered after a landing, then `isLanding()` returns true and the vehicle continues with the mission instead of executing the RTL.\r\n\r\n### Solution\r\n\r\n`isLanding()` should only be true for the items between `land_start_index` and `land_index`. If there are items after the land index, then they don't belong to the landing anymore.\r\n\r\n### Changelog Entry\r\nFor release notes:\r\n```\r\nFeature/Bugfix isLanding() in MissionBase only return true during landing\r\n```\r\n\r\n### Test coverage\r\nTested in SITL: Mission with multiple landings. In between the 2nd and 3rd landing, triggered an RTL through the GS. \r\n\r\nMain: https://review.px4.io/plot_app?log=06418ae7-e01b-43be-9fc7-973f14638573\r\nPR: https://review.px4.io/plot_app?log=504571b2-2aa5-4691-8443-e9c0b0ecaa9e\r\n\r\n<img width=\"1544\" height=\"619\" alt=\"image\" src=\"https://github.com/user-attachments/assets/1b1320dc-6757-44f5-a81a-55c4c03a82f9\" />\r\n\r\n",
      "issue_comments": [],
      "review_comments": [],
      "reviews": [
        {
          "author": "dakejahl",
          "created_at": "2025-07-10T18:53:34Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2025-07-11T07:10:36Z",
          "body": "Thanks!",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "Yes. The PR fixes a logic bug where isLanding() incorrectly returned true for mission items after a landing (an incorrect boundary/range check), causing the vehicle to continue the mission instead of executing RTL. Restricting isLanding() to items between land_start_index and land_index corrects the state detection so RTL can run as intended.",
    "patches": {
      "src/modules/navigator/mission_base.cpp": {
        "filename": "src/modules/navigator/mission_base.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -384,7 +384,8 @@ MissionBase::on_active()\n bool\n MissionBase::isLanding()\n {\n-\tif (hasMissionLandStart() && (_mission.current_seq > _mission.land_start_index)) {\n+\tif (hasMissionLandStart() && (_mission.current_seq > _mission.land_start_index)\n+\t    && (_mission.current_seq <= _mission.land_index)) {\n \t\tstatic constexpr size_t max_num_next_items{1u};\n \t\tint32_t next_mission_items_index[max_num_next_items];\n \t\tsize_t num_found_items;",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4dc694dbfa69abf4f82812a580485e24bcd1177f/src%2Fmodules%2Fnavigator%2Fmission_base.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "MissionBase::on_active"
      ],
      "by_file": {
        "src/modules/navigator/mission_base.cpp": [
          "MissionBase::on_active"
        ]
      }
    }
  },
  {
    "title": "Update navigator_main.cpp",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/6951",
    "number": 6951,
    "created_at": "2017-04-01T03:42:04Z",
    "merged": true,
    "merged_at": "2017-04-02T10:15:11Z",
    "state": "closed",
    "conversation": {
      "author": "FantasyJXF",
      "body": "fix a spell error",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-02T10:14:58Z",
          "body": "Thanks!",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-02T10:15:07Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "The PR description explicitly states it fixes a spelling error and there are no comments or review notes indicating incorrect behavior or state changes. This appears to be a cosmetic/text change in navigator_main.cpp rather than a change to program logic or control flow.",
    "patches": {
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -352,7 +352,7 @@ Navigator::task_main()\n \n \twhile (!_task_should_exit) {\n \n-\t\t/* wait for up to 200ms for data */\n+\t\t/* wait for up to 1000ms for data */\n \t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n \n \t\tif (pret == 0) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0ba9bd12dd0c5a69ef1c15bae3423861a330535c/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Navigator::task_main"
      ],
      "by_file": {
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::task_main"
        ]
      }
    }
  },
  {
    "title": "Vtol transition improvements",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/6904",
    "number": 6904,
    "created_at": "2017-03-27T23:29:12Z",
    "merged": true,
    "merged_at": "2017-04-02T23:39:40Z",
    "state": "closed",
    "conversation": {
      "author": "sanderux",
      "body": "A few improvements to transitions\r\nas discussed in https://github.com/PX4/Firmware/issues/6856",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2017-03-28T00:11:46Z",
          "body": "Have you flown this yet? If not do you want to also add FW full weight at the start of forward transition? I've actually been flying with FW actuators on at all times.",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-28T00:34:46Z",
          "body": "no i havent flown it yet, was planning to do that tomorrow.\r\nI'll add the FW full weight",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-29T00:30:31Z",
          "body": "i'll take this for a spin tomorrow or the day after.",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-30T22:30:37Z",
          "body": "Works great: http://logs.uaventure.com/view/pGRAVhWbYLeRN3uuTwSxYM",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-04-01T19:00:06Z",
          "body": "I discussed with @dagar that 50% of back transition time should work in all scenarios. I'll remove the param",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-04-02T22:37:02Z",
          "body": "@dagar @LorenzMeier \r\nThese improvements have been tested based on the parameterized back transition rampup, that now changed to static 50% of back transition duration.\r\n\r\nSITL tested with debugging output on weight values, works as expected.\r\nI think this is ok to merge",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-05-12T09:03:52Z",
          "body": "@LorenzMeier can we get this in 1.6?",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2017-05-12T10:23:48Z",
          "body": "I donated understand the question since this branch is already merged to master and hence to the feature freeze for 1.6?",
          "type": "issue_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-05-12T10:29:16Z",
          "body": "Ok, i didnt see it tagged so i assumed it didnt make it",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2017-03-28T00:08:44Z",
          "body": "Do we know the altitude is necessarily valid?",
          "path": "src/modules/navigator/mission.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2017-03-28T00:08:50Z",
          "body": "I don't think we should parameterize this unless we need to.",
          "path": "src/modules/vtol_att_control/vtol_att_control_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-28T00:32:37Z",
          "body": "It only does this when commanded in a mission, so yes.\r\nBut it doesnt really matter, it's just to avoid a quick spike in the pitch setpoint.\r\n",
          "path": "src/modules/navigator/mission.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-28T00:33:50Z",
          "body": "I think we do, all time based loops are parameterized. I agree we are drowning in params but i think that calls for a different approach to params. but something like this will change for smaller and larger vtols",
          "path": "src/modules/vtol_att_control/vtol_att_control_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-01T18:42:00Z",
          "body": "Isn't this linked to the forward and back transition period? The motor ramp up time should be hard-linked to that, not driven by an unrelated parameter that people easily forget.",
          "path": "src/modules/vtol_att_control/vtol_att_control_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-02T22:44:00Z",
          "body": "This function is only used in VTOL, so it should be ok. But its not ideal.",
          "path": "src/modules/navigator/mission.cpp",
          "position": 4,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2017-04-02T22:46:17Z",
          "body": "We really need to fix this...",
          "path": "src/modules/vtol_att_control/standard.cpp",
          "position": 46,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-04-02T23:01:32Z",
          "body": "yes, but that will require either a param or a VERY clear warning to users",
          "path": "src/modules/vtol_att_control/standard.cpp",
          "position": 46,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2017-04-02T23:11:05Z",
          "body": "Right, although it would only be VTOL users that provide their own mixers.",
          "path": "src/modules/vtol_att_control/standard.cpp",
          "position": 46,
          "type": "review_comment"
        },
        {
          "author": "sanderux",
          "created_at": "2017-04-02T23:13:00Z",
          "body": "Is this reversed in the mixer too?",
          "path": "src/modules/vtol_att_control/standard.cpp",
          "position": 46,
          "type": "review_comment"
        },
        {
          "author": "dagar",
          "created_at": "2017-04-02T23:26:29Z",
          "body": "Yes. We can continue the discussion here. https://github.com/PX4/Firmware/issues/4797\r\nThis could be a good excuse to unify the VTOL mixers with regular FW & MC. Some of them are special, but many could just reuse a regular MC mixer on MAIN, regular FW mixer on AUX.",
          "path": "src/modules/vtol_att_control/standard.cpp",
          "position": 46,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2017-03-28T00:08:44Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "2017-03-28T00:08:50Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-28T00:32:37Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sanderux",
          "created_at": "2017-03-28T00:33:50Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-01T18:42:35Z",
          "body": "We need to make sure vehicle configuration remains maintainable and find a way to link different parameters to one main intent (like duration).",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-02T22:43:40Z",
          "body": "",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2017-04-02T22:44:00Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "2017-04-02T22:46:17Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sanderux",
          "created_at": "2017-04-02T23:01:33Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "2017-04-02T23:11:05Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sanderux",
          "created_at": "2017-04-02T23:13:00Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "dagar",
          "created_at": "2017-04-02T23:26:29Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR changes VTOL transition weighting and timing (e.g. FW actuator weighting at start of forward transition and a fixed 50% back-transition rampup), which are behavioral/state transition changes. Those affect control logic and correct unintended transition behavior; tests and flight logs are cited, indicating this addresses an incorrect runtime behavior rather than a syntax/style change.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -1497,7 +1497,6 @@ Mission::generate_waypoint_from_heading(struct position_setpoint_s *setpoint, fl\n \t\t1000000.0f,\n \t\t&(setpoint->lat),\n \t\t&(setpoint->lon));\n-\tsetpoint->alt = _navigator->get_global_position()->alt;\n \tsetpoint->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n \tsetpoint->yaw = yaw;\n }",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4e24fd9640453eb0509a3e02dc42885dbb142153/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::generate_waypoint_from_heading"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::generate_waypoint_from_heading"
        ]
      }
    }
  },
  {
    "title": "rtl: implemented RTL based on cone shape",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/12382",
    "number": 12382,
    "created_at": "2019-07-01T15:36:24Z",
    "merged": true,
    "merged_at": "2019-07-05T16:05:10Z",
    "state": "closed",
    "conversation": {
      "author": "RomanBapst",
      "body": "This implements very basic RTL behavior using a cone to define the required return altitude (see figure below). Currently the user can define the half-angle of the cone and the cone is centered around the home position. If the vehicle is inside the cone, it will return at the current altitude.\r\nIf the vehicle is outside the cone the vehicle will first climb until it either intersects the cone or reaches the parametrized return altitude, whichever is lower.\r\nThe vehicle will always at least climb to the parametrized descend altitude.\r\n\r\nCone half angle parameter special cases:\r\n<=0: this will lead to the RTL behavior we currently have. The drone will always climb to the return altitude.\r\n .>= 90: In this case the drone will always return at the current altitude with the only restriction that this altitude must be larger than the RTL descend altitude.\r\n\r\nI did some basic testing in SITL but it needs more. Also feel free to comment on the choice of cone parameter and it's default value.\r\n![rtl](https://user-images.githubusercontent.com/7610489/60448520-11a18880-9c26-11e9-818c-dbf6538faa3c.jpg)\r\n",
      "issue_comments": [
        {
          "author": "LorenzMeier",
          "created_at": "2019-07-01T15:56:55Z",
          "body": "Awesome and great that you included a sketch for Hamish! Please Tag the flight test team for new PRs.",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2019-07-01T16:13:35Z",
          "body": "One idea for the parameter is that you could have enums with a few common values (including <=0 and >= 90 cases that you described above) + a few reasonable steps inbetween (30, etc). Then it's more accessible to users that might want to simply preserve the legacy behavior, but also enables selecting advanced and entering whatever you want.",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-01T19:52:58Z",
          "body": "@dagar I implemented something. Is that something along the lines you were talking about?",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-01T19:54:41Z",
          "body": "@PX4/testflights Could you guys please give this a shot? Please make sure to try all RTL cone shapes (RTL_CONE_SHAPE parameter).\r\nI think a good way to test this is to set the return altitude relatively high (e.g. 100m).",
          "type": "issue_comment"
        },
        {
          "author": "jorge789",
          "created_at": "2019-07-02T22:27:23Z",
          "body": "### Tested on PixRacer V4:\r\n\r\n- Modes Tested\r\nPosition Mode: Good.\r\nFailsafe RTL (Return To Land)\r\n\r\n**- Procedure**\r\nArm and Take off in position mode, after flying for approximately one minute,  trigger RTL, wait for vehicle to return and land as expected.\r\n\r\n**- Notes**\r\nNo issue noted, good flight in general.\r\n\r\n**Log 1**\r\n**Note:**RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 95m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=44a6a8c4-034b-4ab9-9c94-1e4088fbec5f\r\n\r\n**Log 2**\r\n**Note:**RTL_CONE_SHAPE parameter set to 2; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 40m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=47df2c77-d1c0-4303-8017-ee285d0c9295\r\n\r\n**Log 3**\r\n**Note:**RTL_CONE_SHAPE parameter set to 3; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 18m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=ff0fe029-a8a1-4a20-aacb-2d6115898be5\r\n\r\n**Log 4**\r\n**Note:**RTL_CONE_SHAPE parameter set to 4; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 9m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=0b5efc93-0336-438f-843a-688798606962\r\n\r\n\r\n### Tested on Pixhawk 2 Cube V3:\r\n\r\n- Modes Tested\r\nPosition Mode: Good.\r\nFailsafe RTL (Return To Land)\r\n\r\n**- Procedure**\r\nArm and Take off in position mode, after flying for approximately one minute,  trigger RTL, wait for vehicle to return and land as expected.\r\n\r\n**- Notes**\r\nNo issue noted, good flight in general.\r\n\r\n**Log 1**\r\n**Note:**RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 95m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=a274ac68-cf8c-4f58-92bb-2994c21015d0\r\n\r\n**Log 2**\r\n**Note:**RTL_CONE_SHAPE parameter set to 2; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 40m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=0e571036-bf67-4626-a814-cc641aeac61e\r\n\r\n**Log 3**\r\n**Note:**RTL_CONE_SHAPE parameter set to 3; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 18m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=39039abd-3a21-47bc-b6ab-565c58b1288a\r\n\r\n**Log 4**\r\n**Note:**RTL_CONE_SHAPE parameter set to 4; RTL_RETURN_ALT= 100m\r\n40m away from home and 5m above form home; trigger RTL.\r\n- Note: Vehicle climbed up to 10m, positioned itself above home and started landing.\r\nhttps://review.px4.io/plot_app?log=62689cfd-0466-4ad0-b030-12189ece7ec1",
          "type": "issue_comment"
        },
        {
          "author": "dannyfpv",
          "created_at": "2019-07-02T22:29:00Z",
          "body": "### Tested on Pixhawk4 v5\r\n\r\n**Modes Tested:** \r\n- Position Mode: no issue \r\n- RTL mode: no issues\r\n\r\n**Log: #1**\r\nRTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m\r\n40m away from home and 4m above form home; trigger RTL. \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing. \r\nhttps://review.px4.io/plot_app?log=63f37f29-1c72-4f95-b595-4b0e47b5114e\r\n\r\nlog: #2\r\nRTL_CONE_SHAPE parameter set to 2; RTL_RETURN_ALT= 100m\r\n40m away from home and 4m above form home; trigger RTL. \r\n- Note: Vehicle climbed up to 45m, positioned itself above home and started landing. \r\nhttps://review.px4.io/plot_app?log=f1017334-a73c-45f9-af9a-8bdef676578f\r\n\r\nlog: #3\r\nRTL_CONE_SHAPE parameter set to 3; RTL_RETURN_ALT= 100m\r\n40m away from home and 4m above form home; trigger RTL. \r\n- Note: Vehicle climbed up to 26m, positioned itself above home and started landing. \r\nhttps://review.px4.io/plot_app?log=e385d74f-a3a5-4e68-ae2d-85af5c5cd761\r\n\r\nlog: #4\r\nRTL_CONE_SHAPE parameter set to 4; RTL_RETURN_ALT= 100m\r\n40m away from home and 4m above form home; trigger RTL. \r\n- Note: Vehicle climbed up to 9.5m, positioned itself above home and started landing. \r\nhttps://review.px4.io/plot_app?log=2d0ad457-56c2-4baf-a0ab-96ccb550ec35",
          "type": "issue_comment"
        },
        {
          "author": "Junkim3DR",
          "created_at": "2019-07-02T22:36:45Z",
          "body": "### Tested on Pixhawk 4mini v5\r\n\r\n**Modes Tested:**\r\n- Position Mode: Good.\r\n- RTL Mode: Good.\r\n\r\n**Procedure**\r\nArm and takeoff in Position mode, position vehicle 40m away from home and 4m above form home; trigger RTL.\r\n\r\n**Logs**\r\n- https://review.px4.io/plot_app?log=fd1f2b62-2b48-4d4c-ae89-0c09edd90785\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=94d70dc2-cc7b-4b3a-a692-b386676bcb6e\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=479ac124-61b8-4f65-9778-20acd8485b69\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=bfa0670d-f230-4037-88e4-c232032d877e\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n\r\n\r\n\r\n### Tested on Pixhawk Pro v4\r\n\r\n**Modes Tested:**\r\n- Position Mode: Good.\r\n- RTL Mode: Good.\r\n\r\n**Procedure**\r\nArm and takeoff in Position mode, position vehicle 40m away from home and 4m above form home; trigger RTL.\r\n\r\n**Logs**\r\n- https://review.px4.io/plot_app?log=2e4736e2-fdb8-4110-a766-eefdafce6081\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=cb60fd65-f7b9-4341-b1a6-3bc6e5413837\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=ab56a776-0dcb-4b8d-82ca-f3df8d7b7de8\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=82d7ae35-a4af-4f39-8630-a9ada27087bd\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n\r\n\r\n\r\n### Tested on NXP FMUK66 v3\r\n\r\n**Modes Tested:**\r\n- Position Mode: Good.\r\n- RTL Mode: Good.\r\n\r\n**Procedure**\r\nArm and takeoff in Position mode, position vehicle 40m away from home and 4m above form home; trigger RTL.\r\n\r\n**Logs**\r\n- https://review.px4.io/plot_app?log=03e7dd26-897a-492e-8ea3-a8f9f7732e60\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=6b3cae5a-cf6e-47e7-bb42-46eceb537ced\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=c9e42a1d-874d-45b4-a957-5ec847df0184\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.\r\n\r\n- https://review.px4.io/plot_app?log=2e875870-ebc7-4d5b-af51-1a3e74e3b9e2\r\n_ RTL_CONE_SHAPE parameter set to 1; RTL_RETURN_ALT= 100m _ \r\n- Note: Vehicle climbed up to 85m, positioned itself above home and started landing.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2019-07-03T07:27:32Z",
          "body": "@RomanBapst Let's get the changes quickly in (going back to the angle, doing the values as straight angles).",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-03T11:59:53Z",
          "body": "@PX4/testflights Thanks for testing!",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-03T12:08:41Z",
          "body": "@bkueng @julianoes @dagar @LorenzMeier How do we feel about the \"RTL_MIN_DIST\" parameter?\r\nThis one was previously used to decide whether to climb to the RTL altitude or go straight home.\r\nAfter this PR gets merged the parameter is only used to make a stupid decision regarding which yaw setpoint to choose when close to home.\r\nhttps://github.com/PX4/Firmware/blob/master/src/modules/navigator/rtl.cpp#L177\r\nSo in any case we would need to adjust the description of that parameter.",
          "type": "issue_comment"
        },
        {
          "author": "LorenzMeier",
          "created_at": "2019-07-03T12:35:20Z",
          "body": "Can we get rid of the param entirely?",
          "type": "issue_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-05T08:43:36Z",
          "body": "I added back support for RTL min distance to home for legacy reasons.\r\nThis should be good to go as soon as CI passes.",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2019-07-08T06:16:07Z",
          "body": "@RomanBapst Parameter docs for RTL_RETURN_ALT are no longer correct: \"RTL altitude / Comment: Altitude to fly back in RTL in meters\"",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "dagar",
          "created_at": "2019-07-01T16:15:12Z",
          "body": "```suggestion\r\n\tfloat _rtl_alt{0.0f};\t// AMSL altitude at which the vehicle should return to the home position\r\n```",
          "path": "src/modules/navigator/rtl.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "bkueng",
          "created_at": "2019-07-02T09:01:02Z",
          "body": "You can still use `@value 25`, etc, avoiding the need for the `switch case`.",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2019-07-03T07:16:54Z",
          "body": "I agree, just use a float param and call it `RTL_CONE_ANGLE`.",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-03T11:54:18Z",
          "body": "@bkueng @julianoes Thanks for the review, I did as you suggested.",
          "path": "src/modules/navigator/rtl_params.c",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "julianoes",
          "created_at": "2019-07-05T10:36:10Z",
          "body": "Agreed.",
          "path": "src/modules/navigator/rtl.h",
          "position": 1,
          "type": "review_comment"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-05T11:44:22Z",
          "body": "@julianoes Thanks, I fixed that before but then it got lost during a reset. Fixed now!",
          "path": "src/modules/navigator/rtl.h",
          "position": 1,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "dagar",
          "created_at": "2019-07-01T16:15:12Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bkueng",
          "created_at": "2019-07-02T09:01:02Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "julianoes",
          "created_at": "2019-07-03T07:18:44Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-03T11:54:18Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "julianoes",
          "created_at": "2019-07-05T10:36:10Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "RomanBapst",
          "created_at": "2019-07-05T11:44:22Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "bresch",
          "created_at": "2019-07-05T16:04:53Z",
          "body": "Nice! Let's merge that",
          "state": "APPROVED",
          "type": "review"
        }
      ]
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR implements a new RTL algorithm (cone-based return altitude) and adjusts parameter handling rather than correcting an unintended or incorrect code path. The change is an intentional behavior/feature update (with legacy parameter handling restored) and reviewers/tests show it produces the expected new behavior, not a fix of an existing logic bug.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 11,
        "changes": 63,
        "patch": "@@ -67,6 +67,9 @@ RTL::rtl_type() const\n void\n RTL::on_activation()\n {\n+\n+\t_rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n+\n \tif (_navigator->get_land_detected()->landed) {\n \t\t// For safety reasons don't go into RTL if landed.\n \t\t_rtl_state = RTL_STATE_LANDED;\n@@ -133,14 +136,6 @@ RTL::set_rtl_item()\n \t// Check if we are pretty close to home already.\n \tconst float home_dist = get_distance_to_next_waypoint(home.lat, home.lon, gpos.lat, gpos.lon);\n \n-\t// Compute the return altitude.\n-\tfloat return_alt = math::max(home.alt + _param_rtl_return_alt.get(), gpos.alt);\n-\n-\t// We are close to home, limit climb to min.\n-\tif (home_dist < _param_rtl_min_dist.get()) {\n-\t\treturn_alt = home.alt + _param_rtl_descend_alt.get();\n-\t}\n-\n \t// Compute the loiter altitude.\n \tconst float loiter_altitude = math::min(home.alt + _param_rtl_descend_alt.get(), gpos.alt);\n \n@@ -150,7 +145,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.lat = gpos.lat;\n \t\t\t_mission_item.lon = gpos.lon;\n-\t\t\t_mission_item.altitude = return_alt;\n+\t\t\t_mission_item.altitude = _rtl_alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n \t\t\t_mission_item.yaw = _navigator->get_local_position()->yaw;\n \t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n@@ -159,7 +154,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n \n \t\t\tmavlink_and_console_log_info(_navigator->get_mavlink_log_pub(), \"RTL: climb to %d m (%d m above home)\",\n-\t\t\t\t\t\t     (int)ceilf(return_alt), (int)ceilf(return_alt - _navigator->get_home_position()->alt));\n+\t\t\t\t\t\t     (int)ceilf(_rtl_alt), (int)ceilf(_rtl_alt - _navigator->get_home_position()->alt));\n \t\t\tbreak;\n \t\t}\n \n@@ -169,7 +164,7 @@ RTL::set_rtl_item()\n \t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n \t\t\t_mission_item.lat = home.lat;\n \t\t\t_mission_item.lon = home.lon;\n-\t\t\t_mission_item.altitude = return_alt;\n+\t\t\t_mission_item.altitude = _rtl_alt;\n \t\t\t_mission_item.altitude_is_relative = false;\n \n \t\t\t// Use home yaw if close to home.\n@@ -353,3 +348,49 @@ RTL::advance_rtl()\n \t\tbreak;\n \t}\n }\n+\n+\n+float RTL::calculate_return_alt_from_cone_half_angle(float cone_half_angle_deg)\n+{\n+\tconst home_position_s &home = *_navigator->get_home_position();\n+\tconst vehicle_global_position_s &gpos = *_navigator->get_global_position();\n+\n+\t// horizontal distance to home position\n+\tconst float home_dist = get_distance_to_next_waypoint(home.lat, home.lon, gpos.lat, gpos.lon);\n+\n+\tfloat rtl_altitude;\n+\n+\tif (home_dist <= _param_rtl_min_dist.get()) {\n+\t\trtl_altitude = home.alt + _param_rtl_descend_alt.get();\n+\n+\t} else if (gpos.alt > home.alt + _param_rtl_return_alt.get() || cone_half_angle_deg >= 90.0f) {\n+\t\trtl_altitude = gpos.alt;\n+\n+\t} else if (cone_half_angle_deg <= 0) {\n+\t\trtl_altitude = home.alt + _param_rtl_return_alt.get();\n+\n+\t} else {\n+\n+\t\t// constrain cone half angle to meaningful values. All other cases are already handled above.\n+\t\tconst float cone_half_angle_rad = math::radians(math::constrain(cone_half_angle_deg, 1.0f, 89.0f));\n+\n+\t\t// minimum height above home position required\n+\t\tfloat height_above_home_min = home_dist / tanf(cone_half_angle_rad);\n+\n+\t\t// minimum altitude we need in order to be within the user defined cone\n+\t\tconst float altitude_min = math::constrain(height_above_home_min + home.alt, home.alt,\n+\t\t\t\t\t   home.alt + _param_rtl_return_alt.get());\n+\n+\t\tif (gpos.alt < altitude_min) {\n+\t\t\trtl_altitude = altitude_min;\n+\n+\t\t} else {\n+\t\t\trtl_altitude = gpos.alt;\n+\t\t}\n+\t}\n+\n+\t// always demand altitude which is higher or equal the RTL descend altitude\n+\trtl_altitude = math::max(rtl_altitude, home.alt + _param_rtl_descend_alt.get());\n+\n+\treturn rtl_altitude;\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c663010d7dd73e250290fbfaae31f8581400cd52/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      },
      "src/modules/navigator/rtl.h": {
        "filename": "src/modules/navigator/rtl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "patch": "@@ -80,6 +80,9 @@ class RTL : public MissionBlock, public ModuleParams\n \t */\n \tvoid\t\tadvance_rtl();\n \n+\n+\tfloat calculate_return_alt_from_cone_half_angle(float cone_half_angle_deg);\n+\n \tenum RTLState {\n \t\tRTL_STATE_NONE = 0,\n \t\tRTL_STATE_CLIMB,\n@@ -91,13 +94,15 @@ class RTL : public MissionBlock, public ModuleParams\n \t\tRTL_STATE_LANDED,\n \t} _rtl_state{RTL_STATE_NONE};\n \n+\tfloat _rtl_alt{0.0f};\t// AMSL altitude at which the vehicle should return to the home position\n \tbool _rtl_alt_min{false};\n \n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::RTL_RETURN_ALT>) _param_rtl_return_alt,\n \t\t(ParamFloat<px4::params::RTL_DESCEND_ALT>) _param_rtl_descend_alt,\n \t\t(ParamFloat<px4::params::RTL_LAND_DELAY>) _param_rtl_land_delay,\n \t\t(ParamFloat<px4::params::RTL_MIN_DIST>) _param_rtl_min_dist,\n-\t\t(ParamInt<px4::params::RTL_TYPE>) _param_rtl_type\n+\t\t(ParamInt<px4::params::RTL_TYPE>) _param_rtl_type,\n+\t\t(ParamInt<px4::params::RTL_CONE_ANG>) _param_rtl_cone_half_angle_deg\n \t)\n };",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c663010d7dd73e250290fbfaae31f8581400cd52/src%2Fmodules%2Fnavigator%2Frtl.h"
      },
      "src/modules/navigator/rtl_params.c": {
        "filename": "src/modules/navigator/rtl_params.c",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "patch": "@@ -116,3 +116,21 @@ PARAM_DEFINE_FLOAT(RTL_MIN_DIST, 5.0f);\n  * @group Return Mode\n  */\n PARAM_DEFINE_INT32(RTL_TYPE, 0);\n+\n+/**\n+ * Half-angle of the RTL cone.\n+ *\n+ * Defines the half-angle of the cone which defines the vehicle RTL behavior.\n+ *\n+ * @unit degrees\n+ * @min 0\n+ * @max 90\n+ * @value 0 No cone, always climb to RTL_RETURN_ALT above home.\n+ * @value 25 25 degrees half cone angle.\n+ * @value 45 45 degrees half cone angle.\n+ * @value 65 65 degrees half cone angle.\n+ * @value 80 80 degrees half cone angle.\n+ * @value 90 Only climb to at least RTL_DESCEND_ALT above home.\n+ * @group Return Mode\n+ */\n+PARAM_DEFINE_INT32(RTL_CONE_ANG, 0);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/c663010d7dd73e250290fbfaae31f8581400cd52/src%2Fmodules%2Fnavigator%2Frtl_params.c"
      }
    },
    "modified_functions": {
      "all": [
        "math::max",
        "RTL::rtl_type",
        "RTL::advance_rtl",
        "RTL::set_rtl_item"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "math::max",
          "RTL::rtl_type",
          "RTL::advance_rtl",
          "RTL::set_rtl_item"
        ]
      }
    }
  },
  {
    "title": "navigator fix vehicle_status update",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/12364",
    "number": 12364,
    "created_at": "2019-06-28T22:40:39Z",
    "merged": true,
    "merged_at": "2019-06-29T01:35:30Z",
    "state": "closed",
    "conversation": {
      "author": "dagar",
      "body": "The old behavior (prior to uORB::Subscription update) was to only manual set the arming state if orb_copy failed. Reposition wasn't working because of the arming check.\r\n\r\n@BazookaJoe1900 ",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2019-06-29T01:34:43Z",
          "body": "Verified reposition is now working in SITL. All of the arming_state checks in navigator are against ARMING_STATE_ARMED and vehicle_status struct is zeroed (ARMING_STATE_INIT), so manually initializing to ARMING_STATE_STANDBY isn't necessary.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": [
        {
          "author": "julianoes",
          "created_at": "2019-07-01T11:12:51Z",
          "body": "Good find!",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR fixes incorrect program behavior caused by improper handling/initialization of vehicle_status.arm_state which caused arming checks to fail and prevented repositioning. The change restores correct state semantics (removing unnecessary manual initialization) so the navigator's arming checks behave as intended, which matches a logic error (incorrect state handling).",
    "patches": {
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -387,7 +387,6 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \t// update subscriptions\n \tvoid\t\tparams_update();\n-\tvoid\t\tvehicle_status_update();\n \n \t/**\n \t * Publish a new position setpoint triplet for position controllers",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0a8a52cf7eef50eb283c97415482c1f1c021b5c3/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 12,
        "changes": 13,
        "patch": "@@ -116,15 +116,6 @@ Navigator::~Navigator()\n \torb_unsubscribe(_local_pos_sub);\n }\n \n-void\n-Navigator::vehicle_status_update()\n-{\n-\tif (_vstatus_sub.update(&_vstatus)) {\n-\t\t/* in case the commander is not be running */\n-\t\t_vstatus.arming_state = vehicle_status_s::ARMING_STATE_STANDBY;\n-\t}\n-}\n-\n void\n Navigator::params_update()\n {\n@@ -156,8 +147,6 @@ Navigator::run()\n \t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n \t}\n \n-\t/* copy all topics first time */\n-\tvehicle_status_update();\n \tparams_update();\n \n \t/* wakeup source(s) */\n@@ -218,7 +207,7 @@ Navigator::run()\n \t\t\tparams_update();\n \t\t}\n \n-\t\tvehicle_status_update();\n+\t\t_vstatus_sub.update(&_vstatus);\n \t\t_land_detected_sub.update(&_land_detected);\n \t\t_position_controller_status_sub.update();\n \t\t_home_pos_sub.update(&_home_pos);",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/0a8a52cf7eef50eb283c97415482c1f1c021b5c3/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "vehicle_status_update",
        "Navigator::run"
      ],
      "by_file": {
        "src/modules/navigator/navigator.h": [
          "vehicle_status_update"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::run"
        ]
      }
    }
  },
  {
    "title": "Fix RTL falsely going to mission landing",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/18282",
    "number": 18282,
    "created_at": "2021-09-22T12:48:06Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "ThomasRigi",
      "body": "**Describe problem solved by this pull request**\r\nFixes https://github.com/PX4/PX4-Autopilot/issues/18271\r\n\r\n**Describe your solution**\r\nUse `_deny_mission_landing` to prevent the drone from going to the mission landing when it shouldn't. \r\n\r\n**Describe possible alternatives**\r\nAs I mentioned in https://github.com/PX4/PX4-Autopilot/issues/18271#issuecomment-924850749 it would also be possible to expose `_destination.type` via a new getter function, but since `_deny_mission_landing` is already only used in this place I thought it better to use this properly.\r\n\r\n**Test data / coverage**\r\nSITL with gazebo standard vtol. Flown with RTL_TYPE = 1 and 3 to rally points and home and mission landing. (but I did not keep all the logs)\r\n",
      "issue_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2021-11-05T15:10:06Z",
          "body": "Replaced by https://github.com/PX4/PX4-Autopilot/pull/18500",
          "type": "issue_comment"
        }
      ],
      "review_comments": [
        {
          "author": "sfuhrer",
          "created_at": "2021-10-19T16:44:53Z",
          "body": "With this change it though no longer denies mission landings in hover if VTOL, does it?\r\n\r\nMaybe we can get around that by changing https://github.com/Auterion/PX4_firmware_private/blob/6bd3b04f663b7fd1cd8147cb3dac2b755b966a6e/src/modules/navigator/rtl.cpp#L152 to \r\n`if (dist_squared < min_dist_squared || (rtl_type() != RTL_CLOSEST && !vtol_in_rw_mode)) {`?",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 45,
          "type": "review_comment"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-10-20T13:46:23Z",
          "body": "I don't understand in the first place why it should deny mission landings in the first place when it's in MC mode. For me this is not a criteria for choosing which rally point to go to. Consider the case where you've almost finished your mission, so the land is the closest RP, why would you not want to go there? And then most of the time you force a MC landing anyway as it's a VTOL...",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 45,
          "type": "review_comment"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-10-22T13:24:21Z",
          "body": "What we need is to disable the \"enforcing\" of the mission landing if in hover, but ofc it should still be possible to chose the closest landing point (including the mission landing). \r\nWhy --> you don't want to enforce hovering to the mission landing if the RTL is triggered during a takeoff.",
          "path": "src/modules/navigator/rtl.cpp",
          "position": 45,
          "type": "review_comment"
        }
      ],
      "reviews": [
        {
          "author": "sfuhrer",
          "created_at": "2021-10-19T16:47:33Z",
          "body": "Thanks for the thorough analysis on the fix! I SITL tested it quite a bit now myself, and it seems to do what it should with the changes, even if it's not nice to requiring this `_deny_mission_landing` flag in the first place (it was there before, so no objection against using it here).\r\n\r\nI still can't really get my head around the super convoluted RTL options, we need to clean up there quite urgently..",
          "state": "APPROVED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-10-19T16:48:57Z",
          "body": "Let's have a look at the \"go to Home in hover and VTOL\" case.",
          "state": "CHANGES_REQUESTED",
          "type": "review"
        },
        {
          "author": "ThomasRigi",
          "created_at": "2021-10-20T13:46:24Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        },
        {
          "author": "sfuhrer",
          "created_at": "2021-10-22T13:24:21Z",
          "body": "",
          "state": "COMMENTED",
          "type": "review"
        }
      ]
    },
    "isLogicError": true,
    "logicErrorDescription": "The PR corrects incorrect runtime behavior where RTL would choose a mission landing when it should not, by using the _deny_mission_landing flag to enforce the intended decision. This is a classic logic error (improper conditional/state transition) causing undesired behavior rather than a syntax or style issue, and reviewers and SITL tests confirm it fixes the problem.",
    "patches": {
      "src/modules/navigator/rtl.cpp": {
        "filename": "src/modules/navigator/rtl.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "patch": "@@ -110,6 +110,7 @@ void RTL::find_RTL_destination()\n \tdouble min_dist_squared = coord_dist_sq(dlat, dlon);\n \n \t_destination.type = RTL_DESTINATION_HOME;\n+\t_deny_mission_landing = true;\n \n \tconst bool vtol_in_rw_mode = _navigator->get_vstatus()->is_vtol\n \t\t\t\t     && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n@@ -126,7 +127,6 @@ void RTL::find_RTL_destination()\n \t\t\tmission_landing_lat = _navigator->get_mission_landing_lat();\n \t\t\tmission_landing_lon = _navigator->get_mission_landing_lon();\n \t\t\tmission_landing_alt = _navigator->get_mission_landing_alt();\n-\t\t\tdestination_type = RTL_DESTINATION_HOME;\n \n \t\t} else {\n \t\t\tmission_landing_lat = _navigator->get_mission_landing_start_lat();\n@@ -146,13 +146,15 @@ void RTL::find_RTL_destination()\n \t\t\t_destination.lon = mission_landing_lon;\n \t\t\t_destination.alt = mission_landing_alt;\n \t\t\t_destination.type = destination_type;\n+\t\t\t_deny_mission_landing = false;\n \n \n \t\t}\n \t}\n \n \t// do not consider rally point if RTL type is set to RTL_MISSION, so exit function and use either home or mission landing\n \tif (rtl_type() == RTL_MISSION) {\n+\t\t_deny_mission_landing = false;\n \t\treturn;\n \t}\n \n@@ -192,6 +194,7 @@ void RTL::find_RTL_destination()\n \n \tif (closest_index > 0) {\n \t\t_destination.type = RTL_DESTINATION_SAFE_POINT;\n+\t\t_deny_mission_landing = true;\n \n \t\t// There is a safe point closer than home/mission landing\n \t\t// TODO: handle all possible mission_safe_point.frame cases\n@@ -239,10 +242,6 @@ void RTL::find_RTL_destination()\n \n void RTL::on_activation()\n {\n-\n-\t_deny_mission_landing = _navigator->get_vstatus()->is_vtol\n-\t\t\t\t&& _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n-\n \t// output the correct message, depending on where the RTL destination is\n \tswitch (_destination.type) {\n \tcase RTL_DESTINATION_HOME:",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/4a3d78e34892086e26184b4764e7fc492e1da8aa/src%2Fmodules%2Fnavigator%2Frtl.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "RTL::find_RTL_destination"
      ],
      "by_file": {
        "src/modules/navigator/rtl.cpp": [
          "RTL::find_RTL_destination"
        ]
      }
    }
  },
  {
    "title": "Grouping of mission items",
    "url": "https://github.com/PX4/PX4-Autopilot/pull/18279",
    "number": 18279,
    "created_at": "2021-09-22T10:19:24Z",
    "merged": false,
    "merged_at": null,
    "state": "closed",
    "conversation": {
      "author": "MatejFranceskin",
      "body": "**Describe problem solved by this pull request**\r\nUser story:\r\nWe want to be able to associate data acquired by the vehicle (f.e. photos) with groups of mission items.\r\nFor example: user wants to inspect 2 bridges and creates a flight plan with several way points in proximity of each bridge.\r\nWith the proposed solution we would group mission items in 2 groups. For each photo we will add current group id and group timestamp to image metadata. This metadata will be later used to f.e. filter out only photos taken at \"bridge 2\".\r\n\r\n**Describe your solution**\r\n\r\nImplements new mavlink commands and messages defined in \"Mission item grouping commands and messages\" PR:\r\n[https://github.com/mavlink/mavlink/pull/1687](https://github.com/mavlink/mavlink/pull/1687)\r\n\r\nThis PR adds mission items grouping commands. Groups are defined by START/STOP items and 64bit unsigned integer ID. A group can be nested inside another group. When control reaches MAV_CMD_GROUP_START or MAV_CMD_GROUP_END it emits GROUP_START message with group ID and current timestamp.\r\nIf current mission item is set with a command (jumping to any of the items in the plan) then we scan all mission items from the start and find all groups that should be opened or closed.\r\n\r\n**Describe possible alternatives**\r\n\r\n**Test data / coverage**\r\nManually tested with QGC on the GCS, PX4 + mavlink_router + camera_manager on the vehicle.\r\n\r\n**Additional context**\r\n",
      "issue_comments": [
        {
          "author": "dagar",
          "created_at": "2021-09-22T16:14:41Z",
          "body": "Can you fix the style check failures? https://github.com/PX4/PX4-Autopilot/pull/18279/checks?check_run_id=3673965630\r\n![Screenshot from 2021-09-22 12-14-15](https://user-images.githubusercontent.com/84712/134382020-8f3ff9bb-5dec-4666-bfad-c8daf5abee2b.png)\r\n\r\n\r\n",
          "type": "issue_comment"
        },
        {
          "author": "dagar",
          "created_at": "2021-11-06T03:02:43Z",
          "body": "https://github.com/PX4/PX4-Autopilot/pull/18238 has merged",
          "type": "issue_comment"
        },
        {
          "author": "hamishwillee",
          "created_at": "2024-11-20T22:44:09Z",
          "body": "The commands this uses have been withdrawn from MAVLink development.xml as there is no evidence that there is intent to implement: https://github.com/mavlink/mavlink/pull/2176\r\n\r\nRecommend you close this PR.",
          "type": "issue_comment"
        }
      ],
      "review_comments": [],
      "reviews": []
    },
    "isLogicError": false,
    "logicErrorDescription": "This PR implements a new feature (mission item grouping and new MAVLink commands/messages) rather than correcting incorrect behavior. The description and comments discuss adding functionality and style/check issues, and reviewers note the MAVLink commands were withdrawn â€” there is no indication the change fixes an existing logic bug.",
    "patches": {
      "src/modules/navigator/mission.cpp": {
        "filename": "src/modules/navigator/mission.cpp",
        "status": "modified",
        "additions": 254,
        "deletions": 0,
        "changes": 254,
        "patch": "@@ -48,6 +48,7 @@\n #include \"mission.h\"\n #include \"navigator.h\"\n \n+#include <crc32.h>\n #include <string.h>\n #include <drivers/drv_hrt.h>\n #include <dataman/dataman.h>\n@@ -491,6 +492,10 @@ Mission::update_mission()\n \n \tconst mission_s old_mission = _mission;\n \n+\tuint32_t old_started_groups[max_started_groups];\n+\tsize_t old_started_groups_num;\n+\tget_started_groups(_current_mission_index, old_started_groups, old_started_groups_num);\n+\n \tif (_mission_sub.copy(&_mission)) {\n \t\t/* determine current index */\n \t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n@@ -554,6 +559,42 @@ Mission::update_mission()\n \tfind_mission_land_start();\n \n \tset_current_mission_item();\n+\n+\tuint32_t new_started_groups[max_started_groups];\n+\tsize_t new_started_groups_num;\n+\tget_started_groups(_current_mission_index, new_started_groups, new_started_groups_num);\n+\n+\t// End all previously started groups that are not started anymore\n+\tfor (size_t i = 0; i < old_started_groups_num; i++) {\n+\t\tbool found = false;\n+\n+\t\tfor (size_t j = 0; j < new_started_groups_num; j++) {\n+\t\t\tif (old_started_groups[i] == new_started_groups[j]) {\n+\t\t\t\tfound = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!found) {\n+\t\t\t_navigator->set_group_end(old_started_groups[i]);\n+\t\t}\n+\t}\n+\n+\t// Start all groups that were not started before\n+\tfor (size_t i = 0; i < new_started_groups_num; i++) {\n+\t\tbool found = false;\n+\n+\t\tfor (size_t j = 0; j < old_started_groups_num; j++) {\n+\t\t\tif (new_started_groups[i] == old_started_groups[j]) {\n+\t\t\t\tfound = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!found) {\n+\t\t\t_navigator->set_group_start(new_started_groups[i]);\n+\t\t}\n+\t}\n }\n \n \n@@ -1735,6 +1776,8 @@ Mission::check_mission_valid(bool force)\n \n \t\t// find and store landing start marker (if available)\n \t\tfind_mission_land_start();\n+\n+\t\tcalculate_mission_checksums();\n \t}\n }\n \n@@ -1925,3 +1968,214 @@ void Mission::publish_navigator_mission_item()\n \n \t_navigator_mission_item_pub.publish(navigator_mission_item);\n }\n+\n+void Mission::calculate_mission_checksums()\n+{\n+\tunion {\n+\t\tuint8_t uint8_part;\n+\t\tuint8_t uint16_part;\n+\t\tfloat float_part;\n+\t} crc_part;\n+\n+\tmission_s mission_state = {};\n+\tmission_stats_entry_s stats;\n+\tmission_checksum_s csum{};\n+\n+\tcsum.timestamp = hrt_absolute_time();\n+\tcsum.mission_checksum = 0;\n+\tcsum.fence_checksum = 0;\n+\tcsum.rally_checksum = 0;\n+\tcsum.all_checksum = 0;\n+\n+\tbool fail = false;\n+\n+\tdm_lock(DM_KEY_MISSION_STATE);\n+\n+\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s)) != sizeof(mission_s)) {\n+\t\tPX4_ERR(\"dataman read failure\");\n+\t\tfail = true;\n+\t}\n+\n+\tdm_unlock(DM_KEY_MISSION_STATE);\n+\n+\tif (fail) {\n+\t\treturn;\n+\t}\n+\n+\tdm_item_t dm_current = (dm_item_t)(_mission.dataman_id);\n+\tdm_lock(dm_current);\n+\n+\tfor (int i = 0; i < mission_state.count && !fail; i++) {\n+\t\tstruct mission_item_s mission_item = {};\n+\t\tconst ssize_t len = sizeof(mission_item);\n+\n+\t\tif (dm_read(dm_current, i, &mission_item, len) != len) {\n+\t\t\tPX4_ERR(\"dataman read failure\");\n+\t\t\tfail = true;\n+\n+\t\t} else {\n+\t\t\tcrc_part.uint8_part = mission_item.frame;\n+\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint8_part), csum.mission_checksum);\n+\t\t\tcrc_part.uint16_part = mission_item.nav_cmd;\n+\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint16_part), csum.mission_checksum);\n+\t\t\tcrc_part.uint8_part = mission_item.autocontinue;\n+\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint8_part), csum.mission_checksum);\n+\n+\t\t\tfor (int j = 0; j < 4; j++) {\n+\t\t\t\tcrc_part.float_part = mission_item.params[j];\n+\t\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.mission_checksum);\n+\t\t\t}\n+\n+\t\t\tcrc_part.float_part = mission_item.lat;\n+\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.mission_checksum);\n+\t\t\tcrc_part.float_part = mission_item.lon;\n+\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.mission_checksum);\n+\t\t\tcrc_part.float_part = mission_item.params[6];\n+\t\t\tcsum.mission_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.mission_checksum);\n+\t\t}\n+\t}\n+\n+\tdm_unlock(dm_current);\n+\n+\tif (fail) {\n+\t\treturn;\n+\t}\n+\n+\tcsum.all_checksum = csum.mission_checksum;\n+\n+\tdm_lock(DM_KEY_FENCE_POINTS);\n+\n+\tif (dm_read(DM_KEY_FENCE_POINTS, 0, &stats, sizeof(mission_stats_entry_s)) != sizeof(mission_stats_entry_s)) {\n+\t\tPX4_ERR(\"dataman read failure\");\n+\t\tfail = true;\n+\t}\n+\n+\tfor (size_t i = 1; i <= stats.num_items && !fail; i++) {\n+\t\tmission_fence_point_s mission_fence_point;\n+\t\tconst ssize_t len = sizeof(mission_fence_point);\n+\n+\t\tif (dm_read(DM_KEY_FENCE_POINTS, i, &mission_fence_point, len) != len) {\n+\t\t\tPX4_ERR(\"dataman read failure\");\n+\t\t\tfail = true;\n+\n+\t\t} else {\n+\t\t\tcrc_part.uint8_part = mission_fence_point.frame;\n+\t\t\tcsum.fence_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint8_part), csum.fence_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint8_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.uint16_part = mission_fence_point.nav_cmd;\n+\t\t\tcsum.fence_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint16_part), csum.fence_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint16_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_fence_point.lat;\n+\t\t\tcsum.fence_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.fence_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_fence_point.lon;\n+\t\t\tcsum.fence_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.fence_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_fence_point.alt;\n+\t\t\tcsum.fence_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.fence_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_fence_point.circle_radius;\n+\t\t\tcsum.fence_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.fence_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\t\t}\n+\t}\n+\n+\tdm_unlock(DM_KEY_FENCE_POINTS);\n+\n+\tif (fail) {\n+\t\treturn;\n+\t}\n+\n+\tdm_lock(DM_KEY_SAFE_POINTS);\n+\n+\tif (dm_read(DM_KEY_SAFE_POINTS, 0, &stats, sizeof(mission_stats_entry_s)) != sizeof(mission_stats_entry_s)) {\n+\t\tPX4_ERR(\"dataman read failure\");\n+\t\tfail = true;\n+\t}\n+\n+\tfor (size_t i = 1; i <= stats.num_items && !fail; i++) {\n+\t\tmission_safe_point_s mission_safe_point;\n+\t\tconst ssize_t len = sizeof(mission_safe_point);\n+\n+\t\tif (dm_read(DM_KEY_SAFE_POINTS, i, &mission_safe_point, len) != len) {\n+\t\t\tPX4_ERR(\"dataman read failure\");\n+\t\t\tfail = true;\n+\n+\t\t} else {\n+\t\t\tcrc_part.uint8_part = mission_safe_point.frame;\n+\t\t\tcsum.rally_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint8_part), csum.rally_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.uint8_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_safe_point.lat;\n+\t\t\tcsum.rally_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.rally_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_safe_point.lon;\n+\t\t\tcsum.rally_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.rally_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\n+\t\t\tcrc_part.float_part = mission_safe_point.alt;\n+\t\t\tcsum.rally_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.rally_checksum);\n+\t\t\tcsum.all_checksum = crc32part(&crc_part.uint8_part, sizeof(crc_part.float_part), csum.all_checksum);\n+\t\t}\n+\t}\n+\n+\tdm_unlock(DM_KEY_SAFE_POINTS);\n+\n+\tif (!fail) {\n+\t\tmission_checksum_pub.publish(csum);\n+\t}\n+}\n+\n+void\n+Mission::get_started_groups(size_t current_item, uint32_t started_groups[], size_t &num)\n+{\n+\tdm_item_t dm_current = (dm_item_t)(_mission.dataman_id);\n+\tnum = 0;\n+\n+\tfor (size_t i = 0; i < current_item; i++) {\n+\t\tstruct mission_item_s missionitem = {};\n+\t\tconst ssize_t len = sizeof(missionitem);\n+\n+\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n+\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n+\t\t\tPX4_ERR(\"dataman read failure\");\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (missionitem.nav_cmd == NAV_CMD_GROUP_START) {\n+\t\t\tuint32_t group_id = static_cast<uint32_t>(missionitem.params[0]);\n+\t\t\tbool found = false;\n+\n+\t\t\tfor (size_t n = 0; n < num; n++) {\n+\t\t\t\tif (started_groups[n] == group_id) {\n+\t\t\t\t\tfound = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (!found && num < max_started_groups) {\n+\t\t\t\tstarted_groups[num++] = group_id;\n+\t\t\t}\n+\n+\t\t} else if (missionitem.nav_cmd == NAV_CMD_GROUP_END) {\n+\t\t\tuint32_t group_id = static_cast<uint32_t>(missionitem.params[0]);\n+\n+\t\t\tfor (size_t n = 0; n < num; n++) {\n+\t\t\t\tif (started_groups[n] == group_id) {\n+\t\t\t\t\tfor (size_t m = n + 1; m < num; m++) {\n+\t\t\t\t\t\tstarted_groups[m - 1] = started_groups[m];\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tnum--;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fmission.cpp"
      },
      "src/modules/navigator/mission.h": {
        "filename": "src/modules/navigator/mission.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -56,6 +56,7 @@\n #include <uORB/Subscription.hpp>\n #include <uORB/topics/home_position.h>\n #include <uORB/topics/mission.h>\n+#include <uORB/topics/mission_checksum.h>\n #include <uORB/topics/mission_result.h>\n #include <uORB/topics/navigator_mission_item.h>\n #include <uORB/topics/position_setpoint_triplet.h>\n@@ -64,6 +65,8 @@\n #include <uORB/topics/vehicle_roi.h>\n #include <uORB/uORB.h>\n \n+const int max_started_groups = 3;\n+\n class Navigator;\n \n class Mission : public MissionBlock, public ModuleParams\n@@ -237,13 +240,18 @@ class Mission : public MissionBlock, public ModuleParams\n \n \tvoid publish_navigator_mission_item();\n \n+\tvoid calculate_mission_checksums();\n+\n+\tvoid get_started_groups(size_t current_item, uint32_t started_groups[], size_t &num);\n+\n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n \t\t(ParamFloat<px4::params::MIS_DIST_WPS>) _param_mis_dist_wps,\n \t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n \t)\n \n \tuORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item};\n+\tuORB::Publication<mission_checksum_s> mission_checksum_pub{ORB_ID::mission_checksum};\n \n \tuORB::Subscription\t_mission_sub{ORB_ID(mission)};\t\t/**< mission subscription */\n \tmission_s\t\t_mission {};",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fmission.h"
      },
      "src/modules/navigator/mission_block.cpp": {
        "filename": "src/modules/navigator/mission_block.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "patch": "@@ -110,6 +110,14 @@ MissionBlock::is_mission_item_reached()\n \tcase NAV_CMD_SET_CAMERA_FOCUS:\n \t\treturn true;\n \n+\tcase NAV_CMD_GROUP_START:\n+\t\t_navigator->set_group_start(static_cast<uint32_t>(_mission_item.params[0]));\n+\t\treturn true;\n+\n+\tcase NAV_CMD_GROUP_END:\n+\t\t_navigator->set_group_end(static_cast<uint32_t>(_mission_item.params[0]));\n+\t\treturn true;\n+\n \tcase NAV_CMD_DO_VTOL_TRANSITION:\n \n \t\tif (int(_mission_item.params[0]) == 3) {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fmission_block.cpp"
      },
      "src/modules/navigator/mission_feasibility_checker.cpp": {
        "filename": "src/modules/navigator/mission_feasibility_checker.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "patch": "@@ -278,7 +278,9 @@ MissionFeasibilityChecker::checkMissionItemValidity(const mission_s &mission)\n \t\t    missionitem.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n \t\t    missionitem.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n \t\t    missionitem.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n-\t\t    missionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n+\t\t    missionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION &&\n+\t\t    missionitem.nav_cmd != NAV_CMD_GROUP_START &&\n+\t\t    missionitem.nav_cmd != NAV_CMD_GROUP_END) {\n \n \t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission rejected: item %i: unsupported cmd: %d\\t\",\n \t\t\t\t\t     (int)(i + 1),",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fmission_feasibility_checker.cpp"
      },
      "src/modules/navigator/navigation.h": {
        "filename": "src/modules/navigator/navigation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -84,6 +84,8 @@ enum NAV_CMD {\n \tNAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = 214,\n \tNAV_CMD_DO_SET_CAM_TRIGG_DIST = 206,\n \tNAV_CMD_OBLIQUE_SURVEY = 260,\n+\tNAV_CMD_GROUP_START = 301,\n+\tNAV_CMD_GROUP_END = 302,\n \tNAV_CMD_SET_CAMERA_MODE = 530,\n \tNAV_CMD_SET_CAMERA_ZOOM = 531,\n \tNAV_CMD_SET_CAMERA_FOCUS = 532,",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fnavigation.h"
      },
      "src/modules/navigator/navigator.h": {
        "filename": "src/modules/navigator/navigator.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -307,6 +307,8 @@ class Navigator : public ModuleBase<Navigator>, public ModuleParams\n \n \tvoid\t\tacquire_gimbal_control();\n \tvoid\t\trelease_gimbal_control();\n+\tvoid \t\tset_group_start(uint32_t id);\n+\tvoid \t\tset_group_end(uint32_t id);\n \n private:\n \tDEFINE_PARAMETERS(",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fnavigator.h"
      },
      "src/modules/navigator/navigator_main.cpp": {
        "filename": "src/modules/navigator/navigator_main.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "patch": "@@ -1463,12 +1463,48 @@ Navigator::publish_mission_result()\n \n \t/* reset some of the flags */\n \t_mission_result.item_do_jump_changed = false;\n+\t_mission_result.groups_started_num = 0;\n+\t_mission_result.groups_ended_num = 0;\n \t_mission_result.item_changed_index = 0;\n \t_mission_result.item_do_jump_remaining = 0;\n \n \t_mission_result_updated = false;\n }\n \n+void\n+Navigator::set_group_start(uint32_t id)\n+{\n+\tif (id == 0 || _mission_result.groups_started_num >= max_started_groups) {\n+\t\treturn;\n+\t}\n+\n+\tfor (uint8_t i = 0; i < _mission_result.groups_started_num; i++) {\n+\t\tif (_mission_result.groups_started[_mission_result.groups_started_num] == id) {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\t_mission_result.groups_started[_mission_result.groups_started_num++] = id;\n+\t_mission_result_updated = true;\n+}\n+\n+void\n+Navigator::set_group_end(uint32_t id)\n+{\n+\tif (id == 0 || _mission_result.groups_ended_num >= max_started_groups) {\n+\t\treturn;\n+\t}\n+\n+\tfor (uint8_t i = 0; i < _mission_result.groups_ended_num; i++) {\n+\t\tif (_mission_result.groups_ended[_mission_result.groups_ended_num] == id) {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\t_mission_result.groups_ended[_mission_result.groups_ended_num++] = id;\n+\t_mission_result_updated = true;\n+}\n+\n void\n Navigator::set_mission_failure_heading_timeout()\n {",
        "blob_url": "https://github.com/PX4/PX4-Autopilot/blob/150018abbb3d04f3a057a170c9b679c9b8358dfe/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp"
      }
    },
    "modified_functions": {
      "all": [
        "Mission::update_mission",
        "MissionBlock::is_mission_item_reached",
        "Mission::check_mission_valid",
        "MissionFeasibilityChecker::checkMissionItemValidity",
        "Navigator::publish_mission_result",
        "Mission::publish_navigator_mission_item"
      ],
      "by_file": {
        "src/modules/navigator/mission.cpp": [
          "Mission::publish_navigator_mission_item",
          "Mission::update_mission",
          "Mission::check_mission_valid"
        ],
        "src/modules/navigator/mission_block.cpp": [
          "MissionBlock::is_mission_item_reached"
        ],
        "src/modules/navigator/mission_feasibility_checker.cpp": [
          "MissionFeasibilityChecker::checkMissionItemValidity"
        ],
        "src/modules/navigator/navigator_main.cpp": [
          "Navigator::publish_mission_result"
        ]
      }
    }
  }
]