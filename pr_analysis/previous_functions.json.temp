{
  "21782": {
    "RTL::on_active": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "a6d2c2cf5e21ecdad8d737c31de81fab128898c5",
      "source": "void RTL::on_active()\n{\n\tif (_rtl_state != RTL_STATE_LANDED && is_mission_item_reached_or_completed()) {\n\t\tadvance_rtl();\n\t\tset_rtl_item();\n\t}\n\n\tif (_rtl_state == RTL_STATE_LAND && _param_rtl_pld_md.get() > 0) {\n\t\t_navigator->get_precland()->on_active();\n\n\t} else if (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n\n\t// Limit rtl time calculation to 1Hz\n\tif ((hrt_absolute_time() - _destination_check_time) > 1_s) {\n\t\t_destination_check_time = hrt_absolute_time();\n\n\t\tconst vehicle_global_position_s &global_position = *_navigator->get_global_position();\n\n\t\tconst bool global_position_recently_updated = global_position.timestamp > 0\n\t\t\t\t&& hrt_elapsed_time(&global_position.timestamp) < 10_s;\n\n\t\trtl_time_estimate_s rtl_time_estimate{};\n\t\trtl_time_estimate.valid = false;\n\n\t\t// Calculate RTL destination and time estimate only when there is a valid home and global position\n\t\tif (_navigator->home_global_position_valid() && global_position_recently_updated) {\n\t\t\tfind_RTL_destination();\n\t\t\tcalcRtlTimeEstimate(_rtl_state, rtl_time_estimate);\n\t\t\trtl_time_estimate.valid = true;\n\t\t}\n\n\t\trtl_time_estimate.timestamp = hrt_absolute_time();\n\t\t_rtl_time_estimate_pub.publish(rtl_time_estimate);\n\t}\n}"
    }
  },
  "21775": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "a6d2c2cf5e21ecdad8d737c31de81fab128898c5",
      "source": "Loiter::on_activation()\n{\n\tif (_navigator->get_reposition_triplet()->current.valid) {\n\t\treposition();\n\n\t} else {\n\t\tset_loiter_position();\n\t}\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Loiter::set_loiter_position": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "a6d2c2cf5e21ecdad8d737c31de81fab128898c5",
      "source": "Loiter::set_loiter_position()\n{\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n\t    _navigator->get_land_detected()->landed) {\n\n\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n\t\t// setpoint as invalid and idle (both, just to be sure).\n\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t_loiter_pos_set = false;\n\t\treturn;\n\n\t} else if (_loiter_pos_set) {\n\t\t// Already set, nothing to do.\n\t\treturn;\n\t}\n\n\t_loiter_pos_set = true;\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t} else {\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// convert mission item to current setpoint\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "21697": {
    "Navigator::publish_vehicle_cmd": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "6ee2d796ead73ec074892e3f402032352f5d66dd",
      "source": "void Navigator::publish_vehicle_cmd(vehicle_command_s *vcmd)\n{\n\tvcmd->timestamp = hrt_absolute_time();\n\tvcmd->source_system = _vstatus.system_id;\n\tvcmd->source_component = _vstatus.component_id;\n\tvcmd->target_system = _vstatus.system_id;\n\tvcmd->confirmation = false;\n\tvcmd->from_external = false;\n\n\t// The camera commands are not processed on the autopilot but will be\n\t// sent to the mavlink links to other components.\n\tswitch (vcmd->command) {\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\n\t\tif (static_cast<int>(vcmd->param3) == 1) {\n\t\t\t// When sending a single capture we need to include the sequence number, thus camera_trigger needs to handle this cmd\n\t\t\tvcmd->param1 = 0.0f;\n\t\t\tvcmd->param2 = 0.0f;\n\t\t\tvcmd->param3 = 0.0f;\n\t\t\tvcmd->param4 = 0.0f;\n\t\t\tvcmd->param5 = 1.0;\n\t\t\tvcmd->param6 = 0.0;\n\t\t\tvcmd->param7 = 0.0f;\n\t\t\tvcmd->command = vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL;\n\n\t\t} else {\n\t\t\t// We are only capturing multiple if param3 is 0 or > 1.\n\t\t\t// For multiple pictures the sequence number does not need to be included, thus there is no need to go through camera_trigger\n\t\t\t_is_capturing_images = true;\n\t\t}\n\n\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n\t\tbreak;\n\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\t\t_is_capturing_images = false;\n\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n\t\tbreak;\n\n\tcase NAV_CMD_VIDEO_START_CAPTURE:\n\tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n\t\tvcmd->target_component = 100; // MAV_COMP_ID_CAMERA\n\t\tbreak;\n\n\tdefault:\n\t\tvcmd->target_component = _vstatus.component_id;\n\t\tbreak;\n\t}\n\n\t_vehicle_cmd_pub.publish(*vcmd);\n}"
    }
  },
  "21689": {
    "FeasibilityChecker::checkTakeoff": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "cd485b3a13cb4be6e18b31f2485c16298f68a2ae",
      "source": "bool FeasibilityChecker::checkTakeoff(mission_item_s &mission_item)\n{\n\n\t// look for a takeoff waypoint\n\tif (mission_item.nav_cmd == NAV_CMD_TAKEOFF || mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF) {\n\t\t// make sure that the altitude of the waypoint is above the home altitude\n\t\tconst float takeoff_alt = mission_item.altitude_is_relative\n\t\t\t\t\t  ? mission_item.altitude\n\t\t\t\t\t  : mission_item.altitude - _home_alt_msl;\n\n\t\tif (takeoff_alt < FLT_EPSILON) {\n\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: Takeoff altitude below home altitude!\\t\");\n\t\t\tevents::send<float>(events::ID(\"navigator_mis_takeoff_too_low\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t    \"Mission rejected: takeoff altitude too low! Minimum: {1:.1m_v}\",\n\t\t\t\t\t    mission_item.altitude_is_relative ? 0.0f : _home_alt_msl);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!_has_vtol_takeoff) {\n\t\t\t_has_vtol_takeoff = mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF;\n\t\t}\n\n\t\tif (!_has_takeoff) {\n\t\t\t_has_takeoff = true;\n\t\t}\n\n\n\t\tif (_found_item_with_position) {\n\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: takeoff not first waypoint item\\t\");\n\t\t\tevents::send(events::ID(\"navigator_mis_takeoff_not_first\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t     \"Mission rejected: takeoff is not the first waypoint item\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!_found_item_with_position) {\n\t\t_found_item_with_position = (mission_item.nav_cmd != NAV_CMD_IDLE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DELAY &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_JUMP &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_CHANGE_SPEED &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_HOME &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_LAND_START &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_TRIGGER_CONTROL &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_IMAGE_START_CAPTURE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_IMAGE_STOP_CAPTURE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_VIDEO_START_CAPTURE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_VIDEO_STOP_CAPTURE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_CONTROL_VIDEO &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_MOUNT_CONFIGURE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_MOUNT_CONTROL &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_ROI &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_LOCATION &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_NONE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_DIST &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_OBLIQUE_SURVEY &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n\t\t\t\t\t     mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION);\n\t}\n\n\treturn true;\n}"
    }
  },
  "21776": {
    "Loiter::set_loiter_position": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "b08995807c604fe2893d4dae538b4fd43e32a174",
      "source": "Loiter::set_loiter_position()\n{\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n\t    _navigator->get_land_detected()->landed) {\n\n\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n\t\t// setpoint as invalid and idle (both, just to be sure).\n\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\n\t}\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t} else {\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// convert mission item to current setpoint\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Loiter::on_active": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "b08995807c604fe2893d4dae538b4fd43e32a174",
      "source": "Loiter::on_active()\n{\n\tif (_navigator->get_reposition_triplet()->current.valid) {\n\t\treposition();\n\t}\n}"
    },
    "Loiter::Loiter": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "b08995807c604fe2893d4dae538b4fd43e32a174",
      "source": "Loiter::Loiter(Navigator *navigator) :\n\tMissionBlock(navigator),\n\tModuleParams(navigator)\n{\n}"
    }
  },
  "21663": {
    "Navigator::check_traffic": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "1b0370c7350b5a7aadd67f7589d2229908c93b69",
      "source": "void Navigator::check_traffic()\n{\n\n\tif (_traffic_sub.updated()) {\n\n\t\t_traffic_sub.copy(&_adsb_conflict._transponder_report);\n\n\t\tuint16_t required_flags = transponder_report_s::PX4_ADSB_FLAGS_VALID_COORDS |\n\t\t\t\t\t  transponder_report_s::PX4_ADSB_FLAGS_VALID_HEADING |\n\t\t\t\t\t  transponder_report_s::PX4_ADSB_FLAGS_VALID_VELOCITY | transponder_report_s::PX4_ADSB_FLAGS_VALID_ALTITUDE;\n\n\t\tif ((_adsb_conflict._transponder_report.flags & required_flags) == required_flags) {\n\n\t\t\t_adsb_conflict.detect_traffic_conflict(get_global_position()->lat, get_global_position()->lon,\n\t\t\t\t\t\t\t       get_global_position()->alt, _local_pos.vx, _local_pos.vy, _local_pos.vz);\n\n\t\t\tif (_adsb_conflict.handle_traffic_conflict()) {\n\t\t\t\ttake_traffic_conflict_action();\n\t\t\t}\n\t\t}\n\t}\n\n\t_adsb_conflict.remove_expired_conflicts();\n\n}"
    }
  },
  "21665": {
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "1cc7393437cfc994abcf5abb8cc1fb585cf33321",
      "source": "Mission::set_mission_items()\n{\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tstruct mission_item_s mission_item_after_next_position;\n\tbool has_next_position_item = false;\n\tbool has_after_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\tif (prepare_mission_items(&_mission_item, &mission_item_next_position, &has_next_position_item,\n\t\t\t\t  &mission_item_after_next_position, &has_after_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_MISSION) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Executing Reverse Mission\\t\" :\n\t\t\t\t\t \"Executing Mission\\t\");\n\n\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\tevents::send(events::ID(\"mission_execute_rev\"), events::Log::Info, \"Executing Reverse Mission\");\n\n\t\t\t} else {\n\t\t\t\tevents::send(events::ID(\"mission_execute\"), events::Log::Info, \"Executing Mission\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_MISSION;\n\n\t} else {\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, landed\\t\" :\n\t\t\t\t\t\t \"Mission finished, landed\\t\");\n\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_rev\"), events::Log::Info, \"Reverse Mission finished, landed\");\n\n\t\t\t\t} else {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished\"), events::Log::Info, \"Mission finished, landed\");\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, loitering\\t\" :\n\t\t\t\t\t\t \"Mission finished, loitering\\t\");\n\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_rev_loiter\"), events::Log::Info, \"Reverse Mission finished, loitering\");\n\n\t\t\t\t} else {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_loiter\"), events::Log::Info, \"Mission finished, loitering\");\n\t\t\t\t}\n\n\t\t\t\t/* use last setpoint for loiter */\n\t\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t\t} else {\n\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\n\t\t}\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t// set mission finished\n\t\t_navigator->get_mission_result()->finished = true;\n\t\t_navigator->set_mission_result_updated();\n\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION);\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, refusing takeoff\\t\");\n\t\t\t\tevents::send(events::ID(\"mission_not_valid_refuse\"), {events::Log::Error, events::LogInternal::Disabled},\n\t\t\t\t\t     \"No valid mission available, refusing takeoff\");\n\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, loitering\\t\");\n\t\t\t\tevents::send(events::ID(\"mission_not_valid_loiter\"), {events::Log::Error, events::LogInternal::Disabled},\n\t\t\t\t\t     \"No valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\tpublish_navigator_mission_item(); // for logging\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle mission items depending on the mode */\n\n\tconst position_setpoint_s current_setpoint_copy = _navigator->get_position_setpoint_triplet()->current;\n\n\tif (item_contains_position(_mission_item)) {\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\t/* force vtol land */\n\t\t\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\t\t\t/* in fixed-wing this whole block will be ignored and a takeoff item is always propagated */\n\t\t\t\tif (do_need_vertical_takeoff() &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_DEFAULT &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Takeoff to %.1f meters above home\\t\",\n\t\t\t\t\t\t\t (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\t\t\t\t\tevents::send<float>(events::ID(\"mission_takeoff_to\"), events::Log::Info,\n\t\t\t\t\t\t\t    \"Takeoff to {1:.1m_v} above home\", takeoff_alt - _navigator->get_home_position()->alt);\n\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t\t\t/* hold heading for takeoff items */\n\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t\t\t   && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t\t\t/* if there is no need to do a takeoff but we have a takeoff item, treat is as waypoint */\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t\t   && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\t\t\t\t\t// if the vehicle is already in fixed wing mode then the current mission item\n\t\t\t\t\t// will be accepted immediately and the work items will be skipped\n\t\t\t\t\t_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\t/* if we just did a normal takeoff navigate to the actual waypoint now */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_TAKEOFF &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\t/* if we just did a VTOL takeoff, prepare transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_TAKEOFF &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT &&\n\t\t\t\t    _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\t\t\t\t/* set yaw setpoint to heading of VTOL_TAKEOFF wp against current position */\n\t\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t\t\t\t\t    _navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t\t    _mission_item.lat, _mission_item.lon);\n\n\t\t\t\t\t_mission_item.force_heading = true;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t\t\t/* set position setpoint to current while aligning */\n\t\t\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\t/* heading is aligned now, prepare transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_ALIGN &&\n\t\t\t\t    _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\t/* re-enable weather vane again after alignment */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\t\t\t\t/* check if the vtol_takeoff waypoint is on top of us */\n\t\t\t\t\tif (do_need_move_to_takeoff()) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t}\n\n\t\t\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\t/* move to land wp as fixed wing */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t    && (_work_item_type == WORK_ITEM_TYPE_DEFAULT || _work_item_type == WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF)\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t\t\t}\n\n\t\t\t\t\t_mission_item.altitude = altitude;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t\t_mission_item.vtol_back_transition = true;\n\t\t\t\t}\n\n\t\t\t\t/* transition to MC */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n\t\t\t\t    && !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\t\t\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n\n\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following\n\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\t/* move to landing waypoint before descent if necessary */\n\t\t\t\tif (do_need_move_to_land() &&\n\t\t\t\t    (_work_item_type == WORK_ITEM_TYPE_DEFAULT ||\n\t\t\t\t     _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION) &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignoring waypoint altitude:\n\t\t\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t\t\t * what the altitude means on this waypoint type.\n\t\t\t\t\t */\n\t\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t\t\tif (pos_sp_triplet->current.valid\n\t\t\t\t\t    && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t\t\t}\n\n\t\t\t\t\t_mission_item.altitude = altitude;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\n\t\t\t\t\t\t} else { //_mission_item.land_precision == 2\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* we just moved to the landing waypoint, now descend */\n\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\n\t\t\t\t\t\t} else { //_mission_item.land_precision == 2\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/* ignore yaw for landing items */\n\t\t\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t\t\t * that aligns the vehicle first */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\n\t\t\t\t// for fast forward convert certain types to simple waypoint\n\t\t\t\t// XXX: add other types which should be ignored in fast forward\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD &&\n\t\t\t\t    ((_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED) ||\n\t\t\t\t     (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT))) {\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\tif (item_contains_position(_mission_item)) {\n\t\t\t\t\t// convert mission item to a simple waypoint\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t\t     \"MissionReverse: Got a non-position mission item, ignoring it\\t\");\n\t\t\t\t\tevents::send(events::ID(\"mission_ignore_non_position_item\"), events::Log::Info,\n\t\t\t\t\t\t     \"MissionReverse: Got a non-position mission item, ignoring it\");\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* handle non-position mission items such as commands */\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t/* turn towards next waypoint before MC to FW transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t    && !_navigator->get_land_detected()->landed\n\t\t\t\t    && has_next_position_item) {\n\n\t\t\t\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t\t\tset_align_mission_item(&_mission_item, &mission_item_next_position);\n\n\t\t\t\t\t/* set position setpoint to target during the transition */\n\t\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n\t\t\t\t}\n\n\t\t\t\t/* yaw is aligned now */\n\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t\t\t/* re-enable weather vane again after alignment */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t}\n\n\t\t\t\t// ignore certain commands in mission fast forward\n\t\t\t\tif ((_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD) &&\n\t\t\t\t    (_mission_item.nav_cmd == NAV_CMD_DELAY)) {\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\t// nothing to do, all commands are ignored\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\t// The logic in this section establishes the tracking between the current waypoint\n\t// which we are approaching and the next waypoint, which will tell us in which direction\n\t// we will change our trajectory right after reaching it.\n\n\t// Because actions, gates and jump labels can be interleaved with waypoints,\n\t// we are searching around the current mission item in the list to find the closest\n\t// gate and the closest waypoint. We then store them separately.\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Check if the mission item is a gate along the current trajectory\n\tif (item_contains_gate(_mission_item)) {\n\n\t\t// The mission item is a gate, let's check if the next item in the list provides\n\t\t// a position to go towards.\n\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (has_next_position_item) {\n\t\t\t// We have a position, convert it to the setpoint and update setpoint triplet\n\t\t\tmission_apply_limitation(mission_item_next_position);\n\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// ELSE: The current position setpoint stays unchanged.\n\n\t} else {\n\t\t// The mission item is not a gate, set the current position setpoint from mission item (is protected against non-position items)\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (new_work_item_type != WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t\tmission_apply_limitation(_mission_item);\n\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// ELSE: The current position setpoint stays unchanged.\n\t}\n\n\t// Only set the previous position item if the current one really changed\n\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\tif ((_work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) &&\n\t    !position_setpoint_equal(&pos_sp_triplet->current, &current_setpoint_copy)) {\n\t\tpos_sp_triplet->previous = current_setpoint_copy;\n\t}\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND\n\t    || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_MISSION) {\n\t\tset_current_mission_item();\n\t}\n\n\t// If the mission item under evaluation contains a gate, we need to check if we have a next position item so\n\t// the controller can fly the correct line between the current and next setpoint\n\tif (item_contains_gate(_mission_item)) {\n\t\tif (has_after_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_apply_limitation(mission_item_next_position);\n\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->next);\n\n\t\t} else {\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t// Allow a rotary wing vehicle to decelerate before reaching a wp with a hold time or a timeout\n\t\t// This is done by setting the position triplet's next position's valid flag to false,\n\t\t// which makes the FlightTask disregard the next position\n\t\t// TODO: Setting the next waypoint's validity flag to handle braking / correct waypoint behavior\n\t\t// seems hacky, handle this more properly.\n\t\tconst bool brake_for_hold = _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_time_inside(_mission_item) > FLT_EPSILON || item_has_timeout(_mission_item));\n\n\t\tif (_mission_item.autocontinue && !brake_for_hold) {\n\t\t\t/* try to process next mission item */\n\t\t\tif (has_next_position_item) {\n\t\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->next);\n\n\t\t\t} else {\n\t\t\t\t/* next mission item is not available */\n\t\t\t\tpos_sp_triplet->next.valid = false;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "VtolTakeoff::on_active": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "1cc7393437cfc994abcf5abb8cc1fb585cf33321",
      "source": "VtolTakeoff::on_active()\n{\n\tif (is_mission_item_reached_or_completed()) {\n\t\treset_mission_item_reached();\n\n\t\tswitch\t(_takeoff_state) {\n\t\tcase vtol_takeoff_state::TAKEOFF_HOVER: {\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_navigator->get_home_position()->lat,\n\t\t\t\t\t\t\t    _navigator->get_home_position()->lon, _loiter_location(0), _loiter_location(1)));\n\t\t\t\t_mission_item.force_heading = true;\n\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::ALIGN_HEADING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::ALIGN_HEADING: {\n\n\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t_mission_item.lat = _loiter_location(0);\n\t\t\t\t_mission_item.lon = _loiter_location(1);\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\tissue_command(_mission_item);\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::TRANSITION;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::TRANSITION: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t\t} else {\n\t\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t\t}\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n\t\t\t\t// however it will just continue loitering as there is no next mission item\n\t\t\t\t_mission_item.time_inside = 1;\n\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.lat = _loiter_location(0);\n\t\t\t\tpos_sp_triplet->current.lon = _loiter_location(1);\n\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n\n\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\treset_mission_item_reached();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::CLIMB;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::CLIMB: {\n\n\t\t\t\t// reset any potentially valid reposition triplet which was not handled\n\t\t\t\t// we do this to avoid random loiter locations after switching to loiter mode after this\n\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n\n\t\t\t\t// the VTOL takeoff is done\n\t\t\t\t_navigator->get_mission_result()->finished = true;\n\t\t\t\t_navigator->set_mission_result_updated();\n\t\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "RTL::set_rtl_item": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "1cc7393437cfc994abcf5abb8cc1fb585cf33321",
      "source": "void RTL::set_rtl_item()\n{\n\t_navigator->set_can_loiter_at_sp(false);\n\n\tconst vehicle_global_position_s &gpos = *_navigator->get_global_position();\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon, gpos.lat, gpos.lon);\n\tconst float loiter_altitude = math::min(_destination.alt + _param_rtl_descend_alt.get(), _rtl_alt);\n\n\t// if we will switch to mission for landing, already set the loiter radius (incl. direction) from mission\n\tconst float landing_loiter_radius = _destination.type == RTL_DESTINATION_MISSION_LANDING ?\n\t\t\t\t\t    _navigator->get_mission_landing_loiter_radius() : _param_rtl_loiter_rad.get();\n\n\tconst RTLHeadingMode rtl_heading_mode = static_cast<RTLHeadingMode>(_param_rtl_hdg_md.get());\n\n\tswitch (_rtl_state) {\n\tcase RTL_STATE_CLIMB: {\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\n\t\t\t_mission_item.lat = gpos.lat;\n\t\t\t_mission_item.lon = gpos.lon;\n\t\t\t_mission_item.altitude = _rtl_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode != RTLHeadingMode::RTL_DESTINATION_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: climb to %d m (%d m above destination)\\t\",\n\t\t\t\t\t (int)ceilf(_rtl_alt), (int)ceilf(_rtl_alt - _destination.alt));\n\t\t\tevents::send<int32_t, int32_t>(events::ID(\"rtl_climb_to\"), events::Log::Info,\n\t\t\t\t\t\t       \"RTL: climb to {1m_v} ({2m_v} above destination)\",\n\t\t\t\t\t\t       (int32_t)ceilf(_rtl_alt), (int32_t)ceilf(_rtl_alt - _destination.alt));\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_RETURN: {\n\n\t\t\t// For FW flight:set to LOITER_TIME (with 0s loiter time), such that the loiter (orbit) status\n\t\t\t// can be displayed on groundstation and the WP is accepted once within loiter radius\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\n\t\t\t} else {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = _rtl_alt; // Don't change altitude\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING &&\n\t\t\t    destination_dist > _param_rtl_min_dist.get()) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_DESTINATION_HEADING ||\n\t\t\t\t   destination_dist < _param_rtl_min_dist.get()) {\n\t\t\t\t// Use destination yaw if close to _destination.\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = landing_loiter_radius;\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: return at %d m (%d m above destination)\\t\",\n\t\t\t\t\t (int)ceilf(_mission_item.altitude), (int)ceilf(_mission_item.altitude - _destination.alt));\n\t\t\tevents::send<int32_t, int32_t>(events::ID(\"rtl_return_at\"), events::Log::Info,\n\t\t\t\t\t\t       \"RTL: return at {1m_v} ({2m_v} above destination)\",\n\t\t\t\t\t\t       (int32_t)ceilf(_mission_item.altitude), (int32_t)ceilf(_mission_item.altitude - _destination.alt));\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_DESCEND: {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\t// Except for vtol which might be still off here and should point towards this location.\n\t\t\tconst float d_current = get_distance_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n\n\t\t\tif (_navigator->get_vstatus()->is_vtol && (d_current > _navigator->get_acceptance_radius())) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = landing_loiter_radius;\n\n\t\t\t// Disable previous setpoint to prevent drift.\n\t\t\tpos_sp_triplet->previous.valid = false;\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: descend to %d m (%d m above destination)\\t\",\n\t\t\t\t\t (int)ceilf(_mission_item.altitude), (int)ceilf(_mission_item.altitude - _destination.alt));\n\t\t\tevents::send<int32_t, int32_t>(events::ID(\"rtl_descend_to\"), events::Log::Info,\n\t\t\t\t\t\t       \"RTL: descend to {1m_v} ({2m_v} above destination)\",\n\t\t\t\t\t\t       (int32_t)ceilf(_mission_item.altitude), (int32_t)ceilf(_mission_item.altitude - _destination.alt));\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_LOITER: {\n\t\t\tconst bool autocontinue = (_param_rtl_land_delay.get() > FLT_EPSILON);\n\n\t\t\tif (autocontinue) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: loiter %.1fs\\t\",\n\t\t\t\t\t\t (double)_param_rtl_land_delay.get());\n\t\t\t\tevents::send<float>(events::ID(\"rtl_loiter\"), events::Log::Info, \"RTL: loiter {1:.1}s\", _param_rtl_land_delay.get());\n\n\t\t\t} else {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: completed, loitering\\t\");\n\t\t\t\tevents::send(events::ID(\"rtl_completed_loiter\"), events::Log::Info, \"RTL: completed, loitering\");\n\t\t\t}\n\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;    // Don't change altitude.\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = max(_param_rtl_land_delay.get(), 0.0f);\n\t\t\t_mission_item.autocontinue = autocontinue;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = landing_loiter_radius;\n\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_HEAD_TO_CENTER: {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_DESTINATION_HEADING) {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t}\n\n\t\t\t_mission_item.vtol_back_transition = true;\n\t\t\t// acceptance_radius will be overwritten since vtol_back_transition is set,\n\t\t\t// set as a default value only\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\n\t\t\t// Disable previous setpoint to prevent drift.\n\t\t\tpos_sp_triplet->previous.valid = false;\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_TRANSITION_TO_MC: {\n\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_MOVE_TO_LAND_HOVER_VTOL: {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_DESTINATION_HEADING) {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_LAND: {\n\t\t\t// Land at destination.\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LAND;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = _destination.alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n\n\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t} else if (_mission_item.land_precision == 2) {\n\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t_navigator->get_precland()->on_activation();\n\t\t\t}\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: land at destination\\t\");\n\t\t\tevents::send(events::ID(\"rtl_land_at_destination\"), events::Log::Info, \"RTL: land at destination\");\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_LANDED: {\n\t\t\tset_idle_item(&_mission_item);\n\t\t\tset_return_alt_min(false);\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treset_mission_item_reached();\n\n\t// Execute command if set. This is required for commands like VTOL transition.\n\tif (!item_contains_position(_mission_item)) {\n\t\tissue_command(_mission_item);\n\t}\n\n\t// Convert mission item to current position setpoint and make it valid.\n\tmission_apply_limitation(_mission_item);\n\n\tif (mission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current)) {\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n}"
    }
  },
  "21620": {
    "RTL::find_RTL_destination": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "52163808d6658665d9bcfcba5ec906a8fbcb0235",
      "source": "void RTL::find_RTL_destination()\n{\n\t// get home position:\n\thome_position_s &home_landing_position = *_navigator->get_home_position();\n\n\t// get global position\n\tconst vehicle_global_position_s &global_position = *_navigator->get_global_position();\n\n\t// set destination to home per default, then check if other valid landing spot is closer\n\t_destination.set(home_landing_position);\n\n\t// get distance to home position\n\tdouble dlat = home_landing_position.lat - global_position.lat;\n\tdouble dlon = home_landing_position.lon - global_position.lon;\n\n\tdouble lon_scale = cos(radians(global_position.lat));\n\n\tauto coord_dist_sq = [lon_scale](double lat_diff, double lon_diff) -> double {\n\t\tdouble lon_diff_scaled =  lon_scale * matrix::wrap(lon_diff, -180., 180.);\n\t\treturn lat_diff * lat_diff + lon_diff_scaled * lon_diff_scaled;\n\t};\n\n\tdouble min_dist_squared = coord_dist_sq(dlat, dlon);\n\n\t_destination.type = RTL_DESTINATION_HOME;\n\n\tconst bool vtol_in_rw_mode = _navigator->get_vstatus()->is_vtol\n\t\t\t\t     && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\n\t// consider the mission landing if not RTL_TYPE_HOME_OR_RALLY type set\n\tif (_param_rtl_type.get() != RTL_TYPE_HOME_OR_RALLY && _navigator->get_mission_start_land_available()) {\n\t\tdouble mission_landing_lat;\n\t\tdouble mission_landing_lon;\n\t\tfloat mission_landing_alt;\n\n\t\tif (vtol_in_rw_mode) {\n\t\t\tmission_landing_lat = _navigator->get_mission_landing_lat();\n\t\t\tmission_landing_lon = _navigator->get_mission_landing_lon();\n\t\t\tmission_landing_alt = _navigator->get_mission_landing_alt();\n\n\t\t} else {\n\t\t\tmission_landing_lat = _navigator->get_mission_landing_start_lat();\n\t\t\tmission_landing_lon = _navigator->get_mission_landing_start_lon();\n\t\t\tmission_landing_alt = _navigator->get_mission_landing_start_alt();\n\t\t}\n\n\t\tdlat = mission_landing_lat - global_position.lat;\n\t\tdlon = mission_landing_lon - global_position.lon;\n\t\tdouble dist_squared = coord_dist_sq(dlat, dlon);\n\n\t\t// always find closest destination if in hover and VTOL\n\t\tif (_param_rtl_type.get() == RTL_TYPE_CLOSEST || (vtol_in_rw_mode && !_navigator->on_mission_landing())) {\n\n\t\t\t// compare home position to landing position to decide which is closer\n\t\t\tif (dist_squared < min_dist_squared) {\n\t\t\t\t_destination.type = RTL_DESTINATION_MISSION_LANDING;\n\t\t\t\tmin_dist_squared = dist_squared;\n\t\t\t\t_destination.lat = mission_landing_lat;\n\t\t\t\t_destination.lon = mission_landing_lon;\n\t\t\t\t_destination.alt = mission_landing_alt;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// it has to be the mission landing\n\t\t\t_destination.type = RTL_DESTINATION_MISSION_LANDING;\n\t\t\tmin_dist_squared = dist_squared;\n\t\t\t_destination.lat = mission_landing_lat;\n\t\t\t_destination.lon = mission_landing_lon;\n\t\t\t_destination.alt = mission_landing_alt;\n\t\t}\n\t}\n\n\t// do not consider rally point if RTL type is set to RTL_TYPE_MISSION_LANDING_REVERSED, so exit function and use either home or mission landing\n\tif (_param_rtl_type.get() == RTL_TYPE_MISSION_LANDING_REVERSED) {\n                if (_param_rtl_cone_half_angle_deg.get() > 0\n                    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n                        _rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n\n                } else {\n                        _rtl_alt = max(global_position.alt, _destination.alt + _param_rtl_return_alt.get());\n                }\n\t\treturn;\n\t}\n\n\t// compare to safe landing positions\n\tmission_safe_point_s closest_safe_point {};\n\tmission_stats_entry_s stats;\n\tint ret = dm_read(DM_KEY_SAFE_POINTS, 0, &stats, sizeof(mission_stats_entry_s));\n\tint num_safe_points = 0;\n\n\tif (ret == sizeof(mission_stats_entry_s)) {\n\t\tnum_safe_points = stats.num_items;\n\t}\n\n\t// check if a safe point is closer than home or landing\n\tint closest_index = 0;\n\n\tfor (int current_seq = 1; current_seq <= num_safe_points; ++current_seq) {\n\t\tmission_safe_point_s mission_safe_point;\n\n\t\tif (dm_read(DM_KEY_SAFE_POINTS, current_seq, &mission_safe_point, sizeof(mission_safe_point_s)) !=\n\t\t    sizeof(mission_safe_point_s)) {\n\t\t\tPX4_ERR(\"dm_read failed\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// TODO: take altitude into account for distance measurement\n\t\tdlat = mission_safe_point.lat - global_position.lat;\n\t\tdlon = mission_safe_point.lon - global_position.lon;\n\t\tdouble dist_squared = coord_dist_sq(dlat, dlon);\n\n\t\tif (dist_squared < min_dist_squared) {\n\t\t\tclosest_index = current_seq;\n\t\t\tmin_dist_squared = dist_squared;\n\t\t\tclosest_safe_point = mission_safe_point;\n\t\t}\n\t}\n\n\tif (closest_index > 0) {\n\t\t_destination.type = RTL_DESTINATION_SAFE_POINT;\n\n\t\t// There is a safe point closer than home/mission landing\n\t\t// TODO: handle all possible mission_safe_point.frame cases\n\t\tswitch (closest_safe_point.frame) {\n\t\tcase 0: // MAV_FRAME_GLOBAL\n\t\t\t_destination.lat = closest_safe_point.lat;\n\t\t\t_destination.lon = closest_safe_point.lon;\n\t\t\t_destination.alt = closest_safe_point.alt;\n\t\t\t_destination.yaw = home_landing_position.yaw;\n\t\t\tbreak;\n\n\t\tcase 3: // MAV_FRAME_GLOBAL_RELATIVE_ALT\n\t\t\t_destination.lat = closest_safe_point.lat;\n\t\t\t_destination.lon = closest_safe_point.lon;\n\t\t\t_destination.alt = closest_safe_point.alt + home_landing_position.alt; // alt of safe point is rel to home\n\t\t\t_destination.yaw = home_landing_position.yaw;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RTL: unsupported MAV_FRAME\\t\");\n\t\t\tevents::send<uint8_t>(events::ID(\"rtl_unsupported_mav_frame\"), events::Log::Error, \"RTL: unsupported MAV_FRAME ({1})\",\n\t\t\t\t\t      closest_safe_point.frame);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (_param_rtl_cone_half_angle_deg.get() > 0\n\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t_rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n\n\t} else {\n\t\t_rtl_alt = max(global_position.alt, _destination.alt + _param_rtl_return_alt.get());\n\t}\n}"
    }
  },
  "21641": {
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "ee96d209d78510fe7bcc2c34e526648fa79c0135",
      "source": "Mission::set_mission_items()\n{\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tstruct mission_item_s mission_item_after_next_position;\n\tbool has_next_position_item = false;\n\tbool has_after_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\tif (prepare_mission_items(&_mission_item, &mission_item_next_position, &has_next_position_item,\n\t\t\t\t  &mission_item_after_next_position, &has_after_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_MISSION) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Executing Reverse Mission\\t\" :\n\t\t\t\t\t \"Executing Mission\\t\");\n\n\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\tevents::send(events::ID(\"mission_execute_rev\"), events::Log::Info, \"Executing Reverse Mission\");\n\n\t\t\t} else {\n\t\t\t\tevents::send(events::ID(\"mission_execute\"), events::Log::Info, \"Executing Mission\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_MISSION;\n\n\t} else {\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, landed\\t\" :\n\t\t\t\t\t\t \"Mission finished, landed\\t\");\n\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_rev\"), events::Log::Info, \"Reverse Mission finished, landed\");\n\n\t\t\t\t} else {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished\"), events::Log::Info, \"Mission finished, landed\");\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, loitering\\t\" :\n\t\t\t\t\t\t \"Mission finished, loitering\\t\");\n\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_rev_loiter\"), events::Log::Info, \"Reverse Mission finished, loitering\");\n\n\t\t\t\t} else {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_loiter\"), events::Log::Info, \"Mission finished, loitering\");\n\t\t\t\t}\n\n\t\t\t\t/* use last setpoint for loiter */\n\t\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t\t} else {\n\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\n\t\t}\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t// set mission finished\n\t\t_navigator->get_mission_result()->finished = true;\n\t\t_navigator->set_mission_result_updated();\n\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION);\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, refusing takeoff\\t\");\n\t\t\t\tevents::send(events::ID(\"mission_not_valid_refuse\"), {events::Log::Error, events::LogInternal::Disabled},\n\t\t\t\t\t     \"No valid mission available, refusing takeoff\");\n\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, loitering\\t\");\n\t\t\t\tevents::send(events::ID(\"mission_not_valid_loiter\"), {events::Log::Error, events::LogInternal::Disabled},\n\t\t\t\t\t     \"No valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\tpublish_navigator_mission_item(); // for logging\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle mission items depending on the mode */\n\n\tconst position_setpoint_s current_setpoint_copy = _navigator->get_position_setpoint_triplet()->current;\n\n\tif (item_contains_position(_mission_item)) {\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\t/* force vtol land */\n\t\t\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\t\t\t/* in fixed-wing this whole block will be ignored and a takeoff item is always propagated */\n\t\t\t\tif (do_need_vertical_takeoff() &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_DEFAULT &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Takeoff to %.1f meters above home\\t\",\n\t\t\t\t\t\t\t (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\t\t\t\t\tevents::send<float>(events::ID(\"mission_takeoff_to\"), events::Log::Info,\n\t\t\t\t\t\t\t    \"Takeoff to {1:.1m_v} above home\", takeoff_alt - _navigator->get_home_position()->alt);\n\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t\t\t/* hold heading for takeoff items */\n\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t\t\t   && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t\t\t/* if there is no need to do a takeoff but we have a takeoff item, treat is as waypoint */\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t\t   && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\t\t\t\t\t// if the vehicle is already in fixed wing mode then the current mission item\n\t\t\t\t\t// will be accepted immediately and the work items will be skipped\n\t\t\t\t\t_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\t/* if we just did a normal takeoff navigate to the actual waypoint now */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_TAKEOFF &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\t/* if we just did a VTOL takeoff, prepare transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_TAKEOFF &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT &&\n\t\t\t\t    _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\t\t\t\t/* set yaw setpoint to heading of VTOL_TAKEOFF wp against current position */\n\t\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t\t\t\t\t    _navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t\t    _mission_item.lat, _mission_item.lon);\n\n\t\t\t\t\t_mission_item.force_heading = true;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t\t\t/* set position setpoint to current while aligning */\n\t\t\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\t/* heading is aligned now, prepare transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_ALIGN &&\n\t\t\t\t    _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\t/* re-enable weather vane again after alignment */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\t\t\t\t/* check if the vtol_takeoff waypoint is on top of us */\n\t\t\t\t\tif (do_need_move_to_takeoff()) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t}\n\n\t\t\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\t/* move to land wp as fixed wing */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t    && (_work_item_type == WORK_ITEM_TYPE_DEFAULT || _work_item_type == WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF)\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t\t\t}\n\n\t\t\t\t\t_mission_item.altitude = altitude;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t\t_mission_item.vtol_back_transition = true;\n\t\t\t\t}\n\n\t\t\t\t/* transition to MC */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n\t\t\t\t    && !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\t\t\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n\n\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following\n\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\t/* move to landing waypoint before descent if necessary */\n\t\t\t\tif (do_need_move_to_land() &&\n\t\t\t\t    (_work_item_type == WORK_ITEM_TYPE_DEFAULT ||\n\t\t\t\t     _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION) &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignoring waypoint altitude:\n\t\t\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t\t\t * what the altitude means on this waypoint type.\n\t\t\t\t\t */\n\t\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t\t\tif (pos_sp_triplet->current.valid\n\t\t\t\t\t    && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t\t\t}\n\n\t\t\t\t\t_mission_item.altitude = altitude;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\n\t\t\t\t\t\t} else { //_mission_item.land_precision == 2\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* we just moved to the landing waypoint, now descend */\n\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\n\t\t\t\t\t\t} else { //_mission_item.land_precision == 2\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/* ignore yaw for landing items */\n\t\t\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t\t\t * that aligns the vehicle first */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\n\t\t\t\t// for fast forward convert certain types to simple waypoint\n\t\t\t\t// XXX: add other types which should be ignored in fast forward\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD &&\n\t\t\t\t    ((_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED) ||\n\t\t\t\t     (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT))) {\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\tif (item_contains_position(_mission_item)) {\n\t\t\t\t\t// convert mission item to a simple waypoint\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t\t     \"MissionReverse: Got a non-position mission item, ignoring it\\t\");\n\t\t\t\t\tevents::send(events::ID(\"mission_ignore_non_position_item\"), events::Log::Info,\n\t\t\t\t\t\t     \"MissionReverse: Got a non-position mission item, ignoring it\");\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* handle non-position mission items such as commands */\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t/* turn towards next waypoint before MC to FW transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t    && !_navigator->get_land_detected()->landed\n\t\t\t\t    && has_next_position_item) {\n\n\t\t\t\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t\t\tset_align_mission_item(&_mission_item, &mission_item_next_position);\n\n\t\t\t\t\t/* set position setpoint to target during the transition */\n\t\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n\t\t\t\t}\n\n\t\t\t\t/* yaw is aligned now */\n\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t\t\t/* re-enable weather vane again after alignment */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t}\n\n\t\t\t\t// ignore certain commands in mission fast forward\n\t\t\t\tif ((_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD) &&\n\t\t\t\t    (_mission_item.nav_cmd == NAV_CMD_DELAY)) {\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\t// nothing to do, all commands are ignored\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\t// The logic in this section establishes the tracking between the current waypoint\n\t// which we are approaching and the next waypoint, which will tell us in which direction\n\t// we will change our trajectory right after reaching it.\n\n\t// Because actions, gates and jump labels can be interleaved with waypoints,\n\t// we are searching around the current mission item in the list to find the closest\n\t// gate and the closest waypoint. We then store them separately.\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Check if the mission item is a gate along the current trajectory\n\tif (item_contains_gate(_mission_item)) {\n\n\t\t// The mission item is a gate, let's check if the next item in the list provides\n\t\t// a position to go towards.\n\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (has_next_position_item) {\n\t\t\t// We have a position, convert it to the setpoint and update setpoint triplet\n\t\t\tmission_apply_limitation(mission_item_next_position);\n\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// ELSE: The current position setpoint stays unchanged.\n\n\t} else {\n\t\t// The mission item is not a gate, set the current position setpoint from mission item (is protected against non-position items)\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (new_work_item_type != WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t\tmission_apply_limitation(_mission_item);\n\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// ELSE: The current position setpoint stays unchanged.\n\t}\n\n\t// Only set the previous position item if the current one really changed\n\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\tif ((_work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) &&\n\t    !position_setpoint_equal(&pos_sp_triplet->current, &current_setpoint_copy)) {\n\t\tpos_sp_triplet->previous = current_setpoint_copy;\n\t}\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND\n\t    || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_MISSION) {\n\t\tset_current_mission_item();\n\t}\n\n\t// If the mission item under evaluation contains a gate, we need to check if we have a next position item so\n\t// the controller can fly the correct line between the current and next setpoint\n\tif (item_contains_gate(_mission_item)) {\n\t\tif (has_after_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_apply_limitation(mission_item_next_position);\n\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->next);\n\n\t\t} else {\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t// Allow a rotary wing vehicle to decelerate before reaching a wp with a hold time or a timeout\n\t\t// This is done by setting the position triplet's next position's valid flag to false,\n\t\t// which makes the FlightTask disregard the next position\n\t\t// TODO: Setting the next waypoint's validity flag to handle braking / correct waypoint behavior\n\t\t// seems hacky, handle this more properly.\n\t\tconst bool brake_for_hold = _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_time_inside(_mission_item) > FLT_EPSILON || item_has_timeout(_mission_item));\n\n\t\tif (_mission_item.autocontinue && !brake_for_hold) {\n\t\t\t/* try to process next mission item */\n\t\t\tif (has_next_position_item) {\n\t\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->next);\n\n\t\t\t} else {\n\t\t\t\t/* next mission item is not available */\n\t\t\t\tpos_sp_triplet->next.valid = false;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "VtolTakeoff::on_active": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "ee96d209d78510fe7bcc2c34e526648fa79c0135",
      "source": "VtolTakeoff::on_active()\n{\n\tif (is_mission_item_reached_or_completed()) {\n\t\treset_mission_item_reached();\n\n\t\tswitch\t(_takeoff_state) {\n\t\tcase vtol_takeoff_state::TAKEOFF_HOVER: {\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_navigator->get_home_position()->lat,\n\t\t\t\t\t\t\t    _navigator->get_home_position()->lon, _loiter_location(0), _loiter_location(1)));\n\t\t\t\t_mission_item.force_heading = true;\n\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::ALIGN_HEADING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::ALIGN_HEADING: {\n\n\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t_mission_item.lat = _loiter_location(0);\n\t\t\t\t_mission_item.lon = _loiter_location(1);\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\tissue_command(_mission_item);\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::TRANSITION;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::TRANSITION: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t\t} else {\n\t\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t\t}\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n\t\t\t\t// however it will just continue loitering as there is no next mission item\n\t\t\t\t_mission_item.time_inside = 1;\n\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.lat = _loiter_location(0);\n\t\t\t\tpos_sp_triplet->current.lon = _loiter_location(1);\n\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n\n\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\treset_mission_item_reached();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::CLIMB;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::CLIMB: {\n\n\t\t\t\t// reset any potentially valid reposition triplet which was not handled\n\t\t\t\t// we do this to avoid random loiter locations after switching to loiter mode after this\n\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n\n\t\t\t\t// the VTOL takeoff is done\n\t\t\t\t_navigator->get_mission_result()->finished = true;\n\t\t\t\t_navigator->set_mission_result_updated();\n\t\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "RTL::set_rtl_item": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "ee96d209d78510fe7bcc2c34e526648fa79c0135",
      "source": "void RTL::set_rtl_item()\n{\n\t_navigator->set_can_loiter_at_sp(false);\n\n\tconst vehicle_global_position_s &gpos = *_navigator->get_global_position();\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon, gpos.lat, gpos.lon);\n\tconst float loiter_altitude = math::min(_destination.alt + _param_rtl_descend_alt.get(), _rtl_alt);\n\n\t// if we will switch to mission for landing, already set the loiter radius (incl. direction) from mission\n\tconst float landing_loiter_radius = _destination.type == RTL_DESTINATION_MISSION_LANDING ?\n\t\t\t\t\t    _navigator->get_mission_landing_loiter_radius() : _param_rtl_loiter_rad.get();\n\n\tconst RTLHeadingMode rtl_heading_mode = static_cast<RTLHeadingMode>(_param_rtl_hdg_md.get());\n\n\tswitch (_rtl_state) {\n\tcase RTL_STATE_CLIMB: {\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\n\t\t\t_mission_item.lat = gpos.lat;\n\t\t\t_mission_item.lon = gpos.lon;\n\t\t\t_mission_item.altitude = _rtl_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode != RTLHeadingMode::RTL_DESTINATION_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: climb to %d m (%d m above destination)\\t\",\n\t\t\t\t\t (int)ceilf(_rtl_alt), (int)ceilf(_rtl_alt - _destination.alt));\n\t\t\tevents::send<int32_t, int32_t>(events::ID(\"rtl_climb_to\"), events::Log::Info,\n\t\t\t\t\t\t       \"RTL: climb to {1m_v} ({2m_v} above destination)\",\n\t\t\t\t\t\t       (int32_t)ceilf(_rtl_alt), (int32_t)ceilf(_rtl_alt - _destination.alt));\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_RETURN: {\n\n\t\t\t// For FW flight:set to LOITER_TIME (with 0s loiter time), such that the loiter (orbit) status\n\t\t\t// can be displayed on groundstation and the WP is accepted once within loiter radius\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\n\t\t\t} else {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = _rtl_alt; // Don't change altitude\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING &&\n\t\t\t    destination_dist > _param_rtl_min_dist.get()) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_DESTINATION_HEADING ||\n\t\t\t\t   destination_dist < _param_rtl_min_dist.get()) {\n\t\t\t\t// Use destination yaw if close to _destination.\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = landing_loiter_radius;\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: return at %d m (%d m above destination)\\t\",\n\t\t\t\t\t (int)ceilf(_mission_item.altitude), (int)ceilf(_mission_item.altitude - _destination.alt));\n\t\t\tevents::send<int32_t, int32_t>(events::ID(\"rtl_return_at\"), events::Log::Info,\n\t\t\t\t\t\t       \"RTL: return at {1m_v} ({2m_v} above destination)\",\n\t\t\t\t\t\t       (int32_t)ceilf(_mission_item.altitude), (int32_t)ceilf(_mission_item.altitude - _destination.alt));\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_DESCEND: {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\t// Except for vtol which might be still off here and should point towards this location.\n\t\t\tconst float d_current = get_distance_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n\n\t\t\tif (_navigator->get_vstatus()->is_vtol && (d_current > _navigator->get_acceptance_radius())) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _mission_item.lat, _mission_item.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = landing_loiter_radius;\n\n\t\t\t// Disable previous setpoint to prevent drift.\n\t\t\tpos_sp_triplet->previous.valid = false;\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: descend to %d m (%d m above destination)\\t\",\n\t\t\t\t\t (int)ceilf(_mission_item.altitude), (int)ceilf(_mission_item.altitude - _destination.alt));\n\t\t\tevents::send<int32_t, int32_t>(events::ID(\"rtl_descend_to\"), events::Log::Info,\n\t\t\t\t\t\t       \"RTL: descend to {1m_v} ({2m_v} above destination)\",\n\t\t\t\t\t\t       (int32_t)ceilf(_mission_item.altitude), (int32_t)ceilf(_mission_item.altitude - _destination.alt));\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_LOITER: {\n\t\t\tconst bool autocontinue = (_param_rtl_land_delay.get() > FLT_EPSILON);\n\n\t\t\tif (autocontinue) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: loiter %.1fs\\t\",\n\t\t\t\t\t\t (double)_param_rtl_land_delay.get());\n\t\t\t\tevents::send<float>(events::ID(\"rtl_loiter\"), events::Log::Info, \"RTL: loiter {1:.1}s\", _param_rtl_land_delay.get());\n\n\t\t\t} else {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: completed, loitering\\t\");\n\t\t\t\tevents::send(events::ID(\"rtl_completed_loiter\"), events::Log::Info, \"RTL: completed, loitering\");\n\t\t\t}\n\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;    // Don't change altitude.\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = max(_param_rtl_land_delay.get(), 0.0f);\n\t\t\t_mission_item.autocontinue = autocontinue;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.loiter_radius = landing_loiter_radius;\n\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_HEAD_TO_CENTER: {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_DESTINATION_HEADING) {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t}\n\n\t\t\t_mission_item.vtol_back_transition = true;\n\t\t\t// acceptance_radius will be overwritten since vtol_back_transition is set,\n\t\t\t// set as a default value only\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\n\t\t\t// Disable previous setpoint to prevent drift.\n\t\t\tpos_sp_triplet->previous.valid = false;\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_TRANSITION_TO_MC: {\n\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_MOVE_TO_LAND_HOVER_VTOL: {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = loiter_altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_NAVIGATION_HEADING) {\n\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(gpos.lat, gpos.lon, _destination.lat, _destination.lon);\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_DESTINATION_HEADING) {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\n\t\t\t} else if (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_LAND: {\n\t\t\t// Land at destination.\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LAND;\n\t\t\t_mission_item.lat = _destination.lat;\n\t\t\t_mission_item.lon = _destination.lon;\n\t\t\t_mission_item.altitude = _destination.alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\tif (rtl_heading_mode == RTLHeadingMode::RTL_CURRENT_HEADING) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = _destination.yaw;\n\t\t\t}\n\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n\n\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t} else if (_mission_item.land_precision == 2) {\n\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t_navigator->get_precland()->on_activation();\n\t\t\t}\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: land at destination\\t\");\n\t\t\tevents::send(events::ID(\"rtl_land_at_destination\"), events::Log::Info, \"RTL: land at destination\");\n\t\t\tbreak;\n\t\t}\n\n\tcase RTL_STATE_LANDED: {\n\t\t\tset_idle_item(&_mission_item);\n\t\t\tset_return_alt_min(false);\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treset_mission_item_reached();\n\n\t// Execute command if set. This is required for commands like VTOL transition.\n\tif (!item_contains_position(_mission_item)) {\n\t\tissue_command(_mission_item);\n\t}\n\n\t// Convert mission item to current position setpoint and make it valid.\n\tmission_apply_limitation(_mission_item);\n\n\tif (mission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current)) {\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n}"
    }
  },
  "21602": {
    "FeasibilityChecker::doCommonChecks": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "599a66c8a5f33fd9e139ab950e716d0e36a3e809",
      "source": "void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int current_index)\n{\n\n\tif (!_distance_between_waypoints_failed) {\n\t\t_distance_between_waypoints_failed = !checkDistancesBetweenWaypoints(mission_item);\n\t}\n\n\tif (!_distance_first_waypoint_failed) {\n\t\t_distance_first_waypoint_failed = !checkHorizontalDistanceToFirstWaypoint(mission_item);\n\t}\n\n\tif (!_below_home_alt_failed) {\n\t\t_below_home_alt_failed = !checkIfBelowHomeAltitude(mission_item, current_index);\n\t}\n\n\tif (!_takeoff_failed) {\n\t\t_takeoff_failed = !checkTakeoff(mission_item);\n\t}\n}"
    },
    "FeasibilityChecker::checkIfBelowHomeAltitude": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "599a66c8a5f33fd9e139ab950e716d0e36a3e809",
      "source": "bool FeasibilityChecker::checkIfBelowHomeAltitude(const mission_item_s &mission_item, const int current_index)\n{\n\t/* calculate the global waypoint altitude */\n\tfloat wp_alt = (mission_item.altitude_is_relative) ? mission_item.altitude + _home_alt_msl : mission_item.altitude;\n\n\tif (PX4_ISFINITE(_home_alt_msl) && _home_alt_msl > wp_alt && MissionBlock::item_contains_position(mission_item)) {\n\n\n\n\t\tmavlink_log_critical(_mavlink_log_pub, \"Warning: Waypoint %d below home\\t\", current_index + 1);\n\t\tevents::send<int16_t>(events::ID(\"navigator_mis_wp_below_home\"), {events::Log::Warning, events::LogInternal::Info},\n\t\t\t\t      \"Waypoint {1} below home\", current_index + 1);\n\t}\n\n\treturn true;\n}"
    }
  },
  "21503": {
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "08782a083715b2622f09f6286a06f197e8b89613",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\t// copy mission to clear any update\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\tposition_setpoint.lon = cmd.param6;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\n\t\t\t\tif (_mission.land_start()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\tset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL: {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tconst bool rtl_activated_now = !_rtl_activated;\n\n\t\t\t\tswitch (_rtl.get_rtl_type()) {\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING:\n\t\t\t\tcase RTL::RTL_TYPE_CLOSEST: {\n\t\t\t\t\t\t// If a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode.\n\t\t\t\t\t\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission.\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t_shouldEngageMissionForLanding = _rtl.getRTLDestinationTypeMission()\n\t\t\t\t\t\t\t\t\t\t\t && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (_shouldEngageMissionForLanding && (on_mission_landing() || _rtl.getRTLState() > RTL::RTL_STATE_CLIMB)) {\n\n\t\t\t\t\t\t\t// already in a mission landing, we just need to inform the user and stay in mission\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\t\t// the first time we're here start the mission landig\n\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING_REVERSED:\n\t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n\t\t\t\t\t\t// the mission contains a landing spot\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\n\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\tif (_navigation_mode == nullptr) {\n\t\t\t\t\t\t\t\t// switching from an manual mode, go to landing if not already landing\n\t\t\t\t\t\t\t\tif (!on_mission_landing()) {\n\t\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// switching from an auto mode, continue the mission from the closest item\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, continue mission\\t\");\n\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated\"), events::Log::Info,\n\t\t\t\t\t\t\t\t     \"RTL Mission activated, continue mission\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// fly the mission in reverse if switching from a non-manual mode\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_REVERSE);\n\n\t\t\t\t\t\tif ((_navigation_mode != nullptr && (_navigation_mode != &_rtl || _mission.get_mission_changed())) &&\n\t\t\t\t\t\t    (! _mission.get_mission_finished()) &&\n\t\t\t\t\t\t    (!get_land_detected()->landed)) {\n\t\t\t\t\t\t\t// determine the closest mission item if switching from a non-mission mode, and we are either not already\n\t\t\t\t\t\t\t// mission mode or the mission waypoints changed.\n\t\t\t\t\t\t\t// The seconds condition is required so that when no mission was uploaded and one is available the closest\n\t\t\t\t\t\t\t// mission item is determined and also that if the user changes the active mission index while rtl is active\n\t\t\t\t\t\t\t// always that waypoint is tracked first.\n\t\t\t\t\t\t\tif ((_navigation_mode != &_mission) && (rtl_activated_now || _mission.get_mission_waypoints_changed())) {\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly mission in reverse\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_rev\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly mission in reverse\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly to home\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_home\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly to home\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL HOME activated\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_home_activated\"), events::Log::Info, \"RTL activated\");\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t_rtl_activated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\t_can_loiter_at_sp = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {\n\t\t\t_rtl_activated = false;\n\t\t\t_rtl.resetRtlState();\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    }
  },
  "21492": {
    "Mission::on_inactive": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "202e2770da50caff0ed00c06a574e3c39933df52",
      "source": "Mission::on_inactive()\n{\n\t/* Without home a mission can't be valid yet anyway, let's wait. */\n\tif (!_navigator->home_global_position_valid()) {\n\t\treturn;\n\t}\n\n\tif (_inited) {\n\t\tif (_mission_sub.updated()) {\n\t\t\tupdate_mission();\n\n\t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n\t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n\t\t\t}\n\t\t}\n\n\t\t/* reset the current mission if needed */\n\t\tif (need_to_reset_mission()) {\n\t\t\treset_mission(_mission);\n\t\t\t_navigator->reset_cruising_speed();\n\t\t\t_current_mission_index = 0;\n\t\t}\n\n\t} else {\n\n\t\t/* load missions from storage */\n\t\tmission_s mission_state = {};\n\n\t\tdm_lock(DM_KEY_MISSION_STATE);\n\n\t\t/* read current state */\n\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n\n\t\tdm_unlock(DM_KEY_MISSION_STATE);\n\n\t\tif (read_res == sizeof(mission_s)) {\n\t\t\t_mission.dataman_id = mission_state.dataman_id;\n\t\t\t_mission.count = mission_state.count;\n\t\t\t_current_mission_index = mission_state.current_seq;\n\n\t\t\t// find and store landing start marker (if available)\n\t\t\tfind_mission_land_start();\n\t\t}\n\n\t\t/* On init let's check the mission, maybe there is already one available. */\n\t\tcheck_mission_valid(false);\n\n\t\t_inited = true;\n\t}\n\n\t/* require takeoff after non-loiter or landing */\n\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n\t\t_need_takeoff = true;\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* reset so MISSION_ITEM_REACHED isn't published */\n\t_navigator->get_mission_result()->seq_reached = -1;\n}"
    }
  },
  "21484": {
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "5c1e0ddd96f8dee25dd2846a059f25acdc4665a2",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\t// copy mission to clear any update\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\tposition_setpoint.lon = cmd.param6;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\n\t\t\t\tif (_mission.land_start()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\tset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL: {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tconst bool rtl_activated_now = !_rtl_activated;\n\n\t\t\t\tswitch (_rtl.get_rtl_type()) {\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING:\n\t\t\t\tcase RTL::RTL_TYPE_CLOSEST: {\n\t\t\t\t\t\t// If a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode.\n\t\t\t\t\t\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission.\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t_shouldEngageMissionForLanding = _rtl.getRTLDestinationTypeMission()\n\t\t\t\t\t\t\t\t\t\t\t && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (_shouldEngageMissionForLanding && (on_mission_landing() || _rtl.getRTLState() > RTL::RTL_STATE_CLIMB)) {\n\n\t\t\t\t\t\t\t// already in a mission landing, we just need to inform the user and stay in mission\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\t\t// the first time we're here start the mission landig\n\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING_REVERSED:\n\t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n\t\t\t\t\t\t// the mission contains a landing spot\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\n\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\tif (_navigation_mode == nullptr) {\n\t\t\t\t\t\t\t\t// switching from an manual mode, go to landing if not already landing\n\t\t\t\t\t\t\t\tif (!on_mission_landing()) {\n\t\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// switching from an auto mode, continue the mission from the closest item\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, continue mission\\t\");\n\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated\"), events::Log::Info,\n\t\t\t\t\t\t\t\t     \"RTL Mission activated, continue mission\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// fly the mission in reverse if switching from a non-manual mode\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_REVERSE);\n\n\t\t\t\t\t\tif ((_navigation_mode != nullptr && (_navigation_mode != &_rtl || _mission.get_mission_changed())) &&\n\t\t\t\t\t\t    (! _mission.get_mission_finished()) &&\n\t\t\t\t\t\t    (!get_land_detected()->landed)) {\n\t\t\t\t\t\t\t// determine the closest mission item if switching from a non-mission mode, and we are either not already\n\t\t\t\t\t\t\t// mission mode or the mission waypoints changed.\n\t\t\t\t\t\t\t// The seconds condition is required so that when no mission was uploaded and one is available the closest\n\t\t\t\t\t\t\t// mission item is determined and also that if the user changes the active mission index while rtl is active\n\t\t\t\t\t\t\t// always that waypoint is tracked first.\n\t\t\t\t\t\t\tif ((_navigation_mode != &_mission) && (rtl_activated_now || _mission.get_mission_waypoints_changed())) {\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly mission in reverse\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_rev\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly mission in reverse\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly to home\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_home\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly to home\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL HOME activated\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_home_activated\"), events::Log::Info, \"RTL activated\");\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t_rtl_activated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\t_can_loiter_at_sp = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {\n\t\t\t_rtl_activated = false;\n\t\t\t_rtl.resetRtlState();\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    }
  },
  "21710": {
    "Mission::on_activation": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::on_activation()\n{\n\tif (_mission_waypoints_changed) {\n\t\t// do not set the closest mission item in the normal mission mode\n\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t}\n\n\t\t_mission_waypoints_changed = false;\n\t}\n\n\t// we already reset the mission items\n\t_execution_mode_changed = false;\n\n\tset_mission_items();\n\n\t// unpause triggering if it was paused\n\tvehicle_command_s cmd = {};\n\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n\t// unpause trigger\n\tcmd.param1 = -1.0f;\n\tcmd.param3 = 0.0f;\n\t_navigator->publish_vehicle_cmd(&cmd);\n\n\t// reset cruise speed\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Mission::publish_navigator_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "void Mission::publish_navigator_mission_item()\n{\n\tnavigator_mission_item_s navigator_mission_item{};\n\n\tnavigator_mission_item.instance_count = _navigator->mission_instance_count();\n\tnavigator_mission_item.sequence_current = _current_mission_index;\n\tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n\tnavigator_mission_item.latitude = _mission_item.lat;\n\tnavigator_mission_item.longitude = _mission_item.lon;\n\tnavigator_mission_item.altitude = _mission_item.altitude;\n\n\tnavigator_mission_item.time_inside = get_time_inside(_mission_item);\n\tnavigator_mission_item.acceptance_radius = _mission_item.acceptance_radius;\n\tnavigator_mission_item.loiter_radius = _mission_item.loiter_radius;\n\tnavigator_mission_item.yaw = _mission_item.yaw;\n\n\tnavigator_mission_item.frame = _mission_item.frame;\n\tnavigator_mission_item.frame = _mission_item.origin;\n\n\tnavigator_mission_item.loiter_exit_xtrack = _mission_item.loiter_exit_xtrack;\n\tnavigator_mission_item.force_heading = _mission_item.force_heading;\n\tnavigator_mission_item.altitude_is_relative = _mission_item.altitude_is_relative;\n\tnavigator_mission_item.autocontinue = _mission_item.autocontinue;\n\tnavigator_mission_item.vtol_back_transition = _mission_item.vtol_back_transition;\n\n\tnavigator_mission_item.timestamp = hrt_absolute_time();\n\n\t_navigator_mission_item_pub.publish(navigator_mission_item);\n}"
    },
    "calculate_breaking_stop": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "void release_gimbal_control();\n\n\tvoid calculate_breaking_stop(double &lat, double &lon, float &yaw);\n\n\tvoid stop_capturing_images();\n\tvoid disable_camera_trigger();\n\n\tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n\nprivate:\n\n\tint _local_pos_sub{-1}"
    },
    "Mission::set_execution_mode": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::set_execution_mode(const uint8_t mode)\n{\n\tif (_mission_execution_mode != mode) {\n\t\t_execution_mode_changed = true;\n\t\t_navigator->get_mission_result()->execution_mode = mode;\n\n\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD:\n\t\t\tif (mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t// command a transition if in vtol mc mode\n\t\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    _navigator->get_vstatus()->is_vtol &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\n\t\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t\tpublish_navigator_mission_item(); // for logging\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t\tissue_command(_mission_item);\n\t\t\t\t}\n\n\t\t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n\t\t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n\t\t\t\t}\n\n\t\t\t\tif (_current_mission_index > _mission.count - 1) {\n\t\t\t\t\t_current_mission_index = _mission.count - 1;\n\n\t\t\t\t} else if (_current_mission_index > 0) {\n\t\t\t\t\t--_current_mission_index;\n\t\t\t\t}\n\n\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE:\n\t\t\tif ((mode == mission_result_s::MISSION_EXECUTION_MODE_NORMAL) ||\n\t\t\t    (mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD)) {\n\t\t\t\t// handle switch from reverse to forward mission\n\t\t\t\tif (_current_mission_index < 0) {\n\t\t\t\t\t_current_mission_index = 0;\n\n\t\t\t\t} else if (_current_mission_index < _mission.count - 1) {\n\t\t\t\t\t++_current_mission_index;\n\t\t\t\t}\n\n\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t_mission_execution_mode = mode;\n\t}\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid(false);\n\n\t/* Check if stored mission plan has changed */\n\tconst bool mission_sub_updated = _mission_sub.updated();\n\n\tif (mission_sub_updated) {\n\t\t_navigator->reset_triplets();\n\t\tupdate_mission();\n\t}\n\n\t/* mission is running (and we are armed), need reset after disarm */\n\t_need_mission_reset = true;\n\n\t_mission_changed = false;\n\n\t/* reset mission items if needed */\n\tif (mission_sub_updated || _mission_waypoints_changed || _execution_mode_changed) {\n\t\tif (_mission_waypoints_changed) {\n\t\t\t// do not set the closest mission item in the normal mission mode\n\t\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t\t}\n\n\t\t\t_mission_waypoints_changed = false;\n\t\t}\n\n\t\t_execution_mode_changed = false;\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n\t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n\t\t   there is no need to report that we reached it because we didn't. */\n\t\tif (_work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tset_mission_item_reached();\n\t\t}\n\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* check if a cruise speed change has been commanded */\n\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\tcruising_speed_sp_update();\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif (!_param_mis_mnt_yaw_ctl.get()\n\t    && (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING)\n\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t || _work_item_type == WORK_ITEM_TYPE_ALIGN)) {\n\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n\t\t// needs to rotate such that ROI is in the field of view.\n\t\t// ROI only makes sense for multicopters.\n\t\theading_sp_update();\n\t}\n\n\t// TODO: Add vtol heading update method if required.\n\t// Question: Why does vtol ever have to update heading?\n\n\t/* check if landing needs to be aborted */\n\tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n\t    && (_navigator->abort_landing())) {\n\n\t\tdo_abort_landing();\n\t}\n\n\tif (_work_item_type == WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t_navigator->get_precland()->on_active();\n\n\t} else if (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n}"
    },
    "Mission::update_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::update_mission()\n{\n\n\tbool failed = true;\n\n\t/* Reset vehicle_roi\n\t * Missions that do not explicitly configure ROI would not override\n\t * an existing ROI setting from previous missions */\n\t_navigator->reset_vroi();\n\n\tconst mission_s old_mission = _mission;\n\n\tif (_mission_sub.copy(&_mission)) {\n\t\t/* determine current index */\n\t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n\t\t\t_current_mission_index = _mission.current_seq;\n\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_mission_index >= (int)_mission.count) {\n\t\t\t\t_current_mission_index = 0;\n\n\t\t\t} else if (_current_mission_index < 0) {\n\t\t\t\t/* if not initialized, set it to 0 */\n\t\t\t\t_current_mission_index = 0;\n\t\t\t}\n\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\tcheck_mission_valid(true);\n\n\t\tfailed = !_navigator->get_mission_result()->valid;\n\n\t\tif (!failed) {\n\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t_navigator->get_mission_result()->failure = false;\n\n\t\t\t/* reset sequence info as well */\n\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\n\t\t\t/* reset work item if new mission has been accepted */\n\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_changed = true;\n\t\t}\n\n\t\t/* check if the mission waypoints changed while the vehicle is in air\n\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n\t\tif (((_mission.count != old_mission.count) ||\n\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n\t\t    !_navigator->get_land_detected()->landed) {\n\t\t\t_mission_waypoints_changed = true;\n\t\t}\n\n\t} else {\n\t\tPX4_ERR(\"mission update failed\");\n\t}\n\n\tif (failed) {\n\t\t// only warn if the check failed on merit\n\t\tif ((int)_mission.count > 0) {\n\t\t\tPX4_WARN(\"mission check failed\");\n\t\t}\n\n\t\t// reset the mission\n\t\t_mission.count = 0;\n\t\t_mission.current_seq = 0;\n\t\t_current_mission_index = 0;\n\t}\n\n\t// find and store landing start marker (if available)\n\tfind_mission_land_start();\n\n\tset_current_mission_item();\n}"
    },
    "Navigator::mode_completed": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "void Navigator::mode_completed(uint8_t nav_state, uint8_t result)\n{\n\tmode_completed_s mode_completed{};\n\tmode_completed.timestamp = hrt_absolute_time();\n\tmode_completed.result = result;\n\tmode_completed.nav_state = nav_state;\n\t_mode_completed_pub.publish(mode_completed);\n}"
    },
    "Mission::on_inactive": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::on_inactive()\n{\n\t/* Without home a mission can't be valid yet anyway, let's wait. */\n\tif (!_navigator->home_global_position_valid()) {\n\t\treturn;\n\t}\n\n\tif (_inited) {\n\t\tif (_mission_sub.updated()) {\n\t\t\tupdate_mission();\n\n\t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n\t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n\t\t\t}\n\t\t}\n\n\t\t/* reset the current mission if needed */\n\t\tif (need_to_reset_mission()) {\n\t\t\treset_mission(_mission);\n\t\t\t_navigator->reset_cruising_speed();\n\t\t\t_current_mission_index = 0;\n\t\t\t_navigator->reset_vroi();\n\t\t\tset_current_mission_item();\n\t\t}\n\n\t} else {\n\n\t\t/* load missions from storage */\n\t\tmission_s mission_state = {};\n\n\t\tdm_lock(DM_KEY_MISSION_STATE);\n\n\t\t/* read current state */\n\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n\n\t\tdm_unlock(DM_KEY_MISSION_STATE);\n\n\t\tif (read_res == sizeof(mission_s)) {\n\t\t\t_mission.dataman_id = mission_state.dataman_id;\n\t\t\t_mission.count = mission_state.count;\n\t\t\t_current_mission_index = mission_state.current_seq;\n\n\t\t\t// find and store landing start marker (if available)\n\t\t\tfind_mission_land_start();\n\t\t}\n\n\t\t/* On init let's check the mission, maybe there is already one available. */\n\t\tcheck_mission_valid(false);\n\n\t\t_inited = true;\n\t}\n\n\t/* require takeoff after non-loiter or landing */\n\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n\t\t_need_takeoff = true;\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* reset so MISSION_ITEM_REACHED isn't published */\n\t_navigator->get_mission_result()->seq_reached = -1;\n}"
    },
    "Mission::on_inactivation": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::on_inactivation()\n{\n\t_navigator->disable_camera_trigger();\n\t_navigator->stop_capturing_images();\n\t_navigator->release_gimbal_control();\n\n\tif (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n}"
    },
    "stop_capturing_images": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "void calculate_breaking_stop(double &lat, double &lon, float &yaw);\n\n\tvoid stop_capturing_images();\n\tvoid disable_camera_trigger();\n\n\tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n\nprivate:\n\n\tint _local_pos_sub{-1}"
    },
    "Mission::set_current_mission_index": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::set_current_mission_index(uint16_t index)\n{\n\tif (index == _current_mission_index) {\n\t\treturn true; // nothing to do, so return true\n\n\t} else if (_navigator->get_mission_result()->valid && (index < _mission.count)) {\n\n\t\t_current_mission_index = index;\n\n\t\t// a mission index is set manually which has the higher priority than the closest mission item\n\t\t// as it is set by the user\n\t\t_mission_waypoints_changed = false;\n\n\t\t// update mission items if already in active mission\n\t\tif (_navigator->is_planned_mission()) {\n\t\t\t// prevent following \"previous - current\" line\n\t\t\t_navigator->get_position_setpoint_triplet()->previous.valid = false;\n\t\t\t_navigator->get_position_setpoint_triplet()->current.valid = false;\n\t\t\t_navigator->get_position_setpoint_triplet()->next.valid = false;\n\t\t\tset_mission_items();\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
    },
    "Mission::reset_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d262d269ceaeb95596e118d70140e034308ea30b",
      "source": "Mission::reset_mission(struct mission_s &mission)\n{\n\tdm_lock(DM_KEY_MISSION_STATE);\n\n\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s)) == sizeof(mission_s)) {\n\t\tif (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) {\n\t\t\t/* set current item to 0 */\n\t\t\tmission.current_seq = 0;\n\n\t\t\t/* reset jump counters */\n\t\t\tif (mission.count > 0) {\n\t\t\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n\n\t\t\t\tfor (unsigned index = 0; index < mission.count; index++) {\n\t\t\t\t\tstruct mission_item_s item;\n\t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t\t\t\tif (dm_read(dm_current, index, &item, len) != len) {\n\t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\t\t\t\titem.do_jump_current_count = 0;\n\n\t\t\t\t\t\tif (dm_write(dm_current, index, &item, len) != len) {\n\t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Could not read mission.\\t\");\n\t\t\tevents::send(events::ID(\"mission_cannot_read_mission\"), events::Log::Error, \"Could not read mission\");\n\n\t\t\t/* initialize mission state in dataman */\n\t\t\tmission.timestamp = hrt_absolute_time();\n\t\t\tmission.dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n\t\t\tmission.count = 0;\n\t\t\tmission.current_seq = 0;\n\t\t}\n\n\t\tdm_write(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s));\n\t}\n\n\tdm_unlock(DM_KEY_MISSION_STATE);\n}"
    }
  },
  "21446": {
    "FeasibilityChecker::checkMissionItemValidity": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "8f520ab019fb1f95b9cdef06ac646740ac5162f0",
      "source": "bool FeasibilityChecker::checkMissionItemValidity(mission_item_s &mission_item, const int current_index)\n{\n\t/* reject relative alt without home set */\n\tif (mission_item.altitude_is_relative && !PX4_ISFINITE(_home_alt_msl)\n\t    && MissionBlock::item_contains_position(mission_item)) {\n\n\n\n\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: No home pos, WP %d uses rel alt\\t\", current_index + 1);\n\t\tevents::send<int16_t>(events::ID(\"navigator_mis_no_home_rel_alt\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t      \"Mission rejected: No home position, waypoint {1} uses relative altitude\",\n\t\t\t\t      current_index + 1);\n\t\treturn false;\n\n\t}\n\n\t// check if we find unsupported items and reject mission if so\n\tif (mission_item.nav_cmd != NAV_CMD_IDLE &&\n\t    mission_item.nav_cmd != NAV_CMD_WAYPOINT &&\n\t    mission_item.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n\t    mission_item.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n\t    mission_item.nav_cmd != NAV_CMD_RETURN_TO_LAUNCH &&\n\t    mission_item.nav_cmd != NAV_CMD_LAND &&\n\t    mission_item.nav_cmd != NAV_CMD_TAKEOFF &&\n\t    mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT &&\n\t    mission_item.nav_cmd != NAV_CMD_VTOL_TAKEOFF &&\n\t    mission_item.nav_cmd != NAV_CMD_VTOL_LAND &&\n\t    mission_item.nav_cmd != NAV_CMD_DELAY &&\n\t    mission_item.nav_cmd != NAV_CMD_CONDITION_GATE &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_WINCH &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_GRIPPER &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_JUMP &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_CHANGE_SPEED &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_HOME &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_LAND_START &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_TRIGGER_CONTROL &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n\t    mission_item.nav_cmd != NAV_CMD_IMAGE_START_CAPTURE &&\n\t    mission_item.nav_cmd != NAV_CMD_IMAGE_STOP_CAPTURE &&\n\t    mission_item.nav_cmd != NAV_CMD_VIDEO_START_CAPTURE &&\n\t    mission_item.nav_cmd != NAV_CMD_VIDEO_STOP_CAPTURE &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_CONTROL_VIDEO &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_MOUNT_CONFIGURE &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_MOUNT_CONTROL &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_LOCATION &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_ROI_NONE &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_DIST &&\n\t    mission_item.nav_cmd != NAV_CMD_OBLIQUE_SURVEY &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL &&\n\t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_MODE &&\n\t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_ZOOM &&\n\t    mission_item.nav_cmd != NAV_CMD_SET_CAMERA_FOCUS &&\n\t    mission_item.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n\n\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: item %i: unsupported cmd: %d\\t\",\n\t\t\t\t     (int)(current_index + 1),\n\t\t\t\t     (int)mission_item.nav_cmd);\n\t\tevents::send<uint16_t, uint16_t>(events::ID(\"navigator_mis_unsup_cmd\"), {events::Log::Error, events::LogInternal::Warning},\n\t\t\t\t\t\t \"Mission rejected: item {1}: unsupported command: {2}\", current_index + 1, mission_item.nav_cmd);\n\t\treturn false;\n\t}\n\n\t// check if the mission starts with a land command while the vehicle is landed\n\tif ((current_index == 0) && mission_item.nav_cmd == NAV_CMD_LAND && _is_landed) {\n\n\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: starts with landing\\t\");\n\t\tevents::send(events::ID(\"navigator_mis_starts_w_landing\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t     \"Mission rejected: starts with landing\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
    }
  },
  "21643": {
    "Mission::on_activation": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::on_activation()\n{\n\tif (_mission_waypoints_changed) {\n\t\t// do not set the closest mission item in the normal mission mode\n\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t}\n\n\t\t_mission_waypoints_changed = false;\n\t}\n\n\t// we already reset the mission items\n\t_execution_mode_changed = false;\n\n\tset_mission_items();\n\n\t// unpause triggering if it was paused\n\tvehicle_command_s cmd = {};\n\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n\t// unpause trigger\n\tcmd.param1 = -1.0f;\n\tcmd.param3 = 0.0f;\n\t_navigator->publish_vehicle_cmd(&cmd);\n\n\t// reset cruise speed\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Mission::publish_navigator_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "void Mission::publish_navigator_mission_item()\n{\n\tnavigator_mission_item_s navigator_mission_item{};\n\n\tnavigator_mission_item.instance_count = _navigator->mission_instance_count();\n\tnavigator_mission_item.sequence_current = _current_mission_index;\n\tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n\tnavigator_mission_item.latitude = _mission_item.lat;\n\tnavigator_mission_item.longitude = _mission_item.lon;\n\tnavigator_mission_item.altitude = _mission_item.altitude;\n\n\tnavigator_mission_item.time_inside = get_time_inside(_mission_item);\n\tnavigator_mission_item.acceptance_radius = _mission_item.acceptance_radius;\n\tnavigator_mission_item.loiter_radius = _mission_item.loiter_radius;\n\tnavigator_mission_item.yaw = _mission_item.yaw;\n\n\tnavigator_mission_item.frame = _mission_item.frame;\n\tnavigator_mission_item.frame = _mission_item.origin;\n\n\tnavigator_mission_item.loiter_exit_xtrack = _mission_item.loiter_exit_xtrack;\n\tnavigator_mission_item.force_heading = _mission_item.force_heading;\n\tnavigator_mission_item.altitude_is_relative = _mission_item.altitude_is_relative;\n\tnavigator_mission_item.autocontinue = _mission_item.autocontinue;\n\tnavigator_mission_item.vtol_back_transition = _mission_item.vtol_back_transition;\n\n\tnavigator_mission_item.timestamp = hrt_absolute_time();\n\n\t_navigator_mission_item_pub.publish(navigator_mission_item);\n}"
    },
    "calculate_breaking_stop": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "void release_gimbal_control();\n\n\tvoid \t\tcalculate_breaking_stop(double &lat, double &lon, float &yaw);\n\tvoid        \tstop_capturing_images();\n\n\tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n\nprivate:\n\n\tint _local_pos_sub{-1}"
    },
    "Mission::set_execution_mode": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::set_execution_mode(const uint8_t mode)\n{\n\tif (_mission_execution_mode != mode) {\n\t\t_execution_mode_changed = true;\n\t\t_navigator->get_mission_result()->execution_mode = mode;\n\n\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD:\n\t\t\tif (mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t// command a transition if in vtol mc mode\n\t\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    _navigator->get_vstatus()->is_vtol &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\n\t\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t\tpublish_navigator_mission_item(); // for logging\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t\tissue_command(_mission_item);\n\t\t\t\t}\n\n\t\t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n\t\t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n\t\t\t\t}\n\n\t\t\t\tif (_current_mission_index > _mission.count - 1) {\n\t\t\t\t\t_current_mission_index = _mission.count - 1;\n\n\t\t\t\t} else if (_current_mission_index > 0) {\n\t\t\t\t\t--_current_mission_index;\n\t\t\t\t}\n\n\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE:\n\t\t\tif ((mode == mission_result_s::MISSION_EXECUTION_MODE_NORMAL) ||\n\t\t\t    (mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD)) {\n\t\t\t\t// handle switch from reverse to forward mission\n\t\t\t\tif (_current_mission_index < 0) {\n\t\t\t\t\t_current_mission_index = 0;\n\n\t\t\t\t} else if (_current_mission_index < _mission.count - 1) {\n\t\t\t\t\t++_current_mission_index;\n\t\t\t\t}\n\n\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t_mission_execution_mode = mode;\n\t}\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid(false);\n\n\t/* Check if stored mission plan has changed */\n\tconst bool mission_sub_updated = _mission_sub.updated();\n\n\tif (mission_sub_updated) {\n\t\t_navigator->reset_triplets();\n\t\tupdate_mission();\n\t}\n\n\t/* mission is running (and we are armed), need reset after disarm */\n\t_need_mission_reset = true;\n\n\t_mission_changed = false;\n\n\t/* reset mission items if needed */\n\tif (mission_sub_updated || _mission_waypoints_changed || _execution_mode_changed) {\n\t\tif (_mission_waypoints_changed) {\n\t\t\t// do not set the closest mission item in the normal mission mode\n\t\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t\t}\n\n\t\t\t_mission_waypoints_changed = false;\n\t\t}\n\n\t\t_execution_mode_changed = false;\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n\t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n\t\t   there is no need to report that we reached it because we didn't. */\n\t\tif (_work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tset_mission_item_reached();\n\t\t}\n\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* check if a cruise speed change has been commanded */\n\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\tcruising_speed_sp_update();\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif (!_param_mis_mnt_yaw_ctl.get()\n\t    && (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING)\n\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t || _work_item_type == WORK_ITEM_TYPE_ALIGN)) {\n\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n\t\t// needs to rotate such that ROI is in the field of view.\n\t\t// ROI only makes sense for multicopters.\n\t\theading_sp_update();\n\t}\n\n\t// TODO: Add vtol heading update method if required.\n\t// Question: Why does vtol ever have to update heading?\n\n\t/* check if landing needs to be aborted */\n\tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n\t    && (_navigator->abort_landing())) {\n\n\t\tdo_abort_landing();\n\t}\n\n\tif (_work_item_type == WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t_navigator->get_precland()->on_active();\n\n\t} else if (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n}"
    },
    "Mission::update_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::update_mission()\n{\n\n\tbool failed = true;\n\n\t/* Reset vehicle_roi\n\t * Missions that do not explicitly configure ROI would not override\n\t * an existing ROI setting from previous missions */\n\t_navigator->reset_vroi();\n\n\tconst mission_s old_mission = _mission;\n\n\tif (_mission_sub.copy(&_mission)) {\n\t\t/* determine current index */\n\t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n\t\t\t_current_mission_index = _mission.current_seq;\n\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_mission_index >= (int)_mission.count) {\n\t\t\t\t_current_mission_index = 0;\n\n\t\t\t} else if (_current_mission_index < 0) {\n\t\t\t\t/* if not initialized, set it to 0 */\n\t\t\t\t_current_mission_index = 0;\n\t\t\t}\n\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\tcheck_mission_valid(true);\n\n\t\tfailed = !_navigator->get_mission_result()->valid;\n\n\t\tif (!failed) {\n\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t_navigator->get_mission_result()->failure = false;\n\n\t\t\t/* reset sequence info as well */\n\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\n\t\t\t/* reset work item if new mission has been accepted */\n\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_changed = true;\n\t\t}\n\n\t\t/* check if the mission waypoints changed while the vehicle is in air\n\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n\t\tif (((_mission.count != old_mission.count) ||\n\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n\t\t    !_navigator->get_land_detected()->landed) {\n\t\t\t_mission_waypoints_changed = true;\n\t\t}\n\n\t} else {\n\t\tPX4_ERR(\"mission update failed\");\n\t}\n\n\tif (failed) {\n\t\t// only warn if the check failed on merit\n\t\tif ((int)_mission.count > 0) {\n\t\t\tPX4_WARN(\"mission check failed\");\n\t\t}\n\n\t\t// reset the mission\n\t\t_mission.count = 0;\n\t\t_mission.current_seq = 0;\n\t\t_current_mission_index = 0;\n\t}\n\n\t// find and store landing start marker (if available)\n\tfind_mission_land_start();\n\n\tset_current_mission_item();\n}"
    },
    "Mission::on_inactive": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::on_inactive()\n{\n\t/* Without home a mission can't be valid yet anyway, let's wait. */\n\tif (!_navigator->home_global_position_valid()) {\n\t\treturn;\n\t}\n\n\tif (_inited) {\n\t\tif (_mission_sub.updated()) {\n\t\t\tupdate_mission();\n\n\t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n\t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n\t\t\t}\n\t\t}\n\n\t\t/* reset the current mission if needed */\n\t\tif (need_to_reset_mission()) {\n\t\t\treset_mission(_mission);\n\t\t\t_navigator->reset_cruising_speed();\n\t\t\t_current_mission_index = 0;\n\t\t\t_navigator->reset_vroi();\n\t\t\tset_current_mission_item();\n\t\t}\n\n\t} else {\n\n\t\t/* load missions from storage */\n\t\tmission_s mission_state = {};\n\n\t\tdm_lock(DM_KEY_MISSION_STATE);\n\n\t\t/* read current state */\n\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n\n\t\tdm_unlock(DM_KEY_MISSION_STATE);\n\n\t\tif (read_res == sizeof(mission_s)) {\n\t\t\t_mission.dataman_id = mission_state.dataman_id;\n\t\t\t_mission.count = mission_state.count;\n\t\t\t_current_mission_index = mission_state.current_seq;\n\n\t\t\t// find and store landing start marker (if available)\n\t\t\tfind_mission_land_start();\n\t\t}\n\n\t\t/* On init let's check the mission, maybe there is already one available. */\n\t\tcheck_mission_valid(false);\n\n\t\t_inited = true;\n\t}\n\n\t/* require takeoff after non-loiter or landing */\n\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n\t\t_need_takeoff = true;\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* reset so MISSION_ITEM_REACHED isn't published */\n\t_navigator->get_mission_result()->seq_reached = -1;\n}"
    },
    "Mission::on_inactivation": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::on_inactivation()\n{\n\t// Disable camera trigger\n\tvehicle_command_s cmd {};\n\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n\t// Pause trigger\n\tcmd.param1 = -1.0f;\n\tcmd.param3 = 1.0f;\n\t_navigator->publish_vehicle_cmd(&cmd);\n\n\t_navigator->stop_capturing_images();\n\t_navigator->release_gimbal_control();\n\n\tif (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n}"
    },
    "Navigator::stop_capturing_images": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Navigator::stop_capturing_images()\n{\n\tif (_is_capturing_images) {\n\t\tvehicle_command_s vcmd = {};\n\t\tvcmd.command = NAV_CMD_IMAGE_STOP_CAPTURE;\n\t\tvcmd.param1 = 0.0f;\n\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t// _is_capturing_images is reset inside publish_vehicle_cmd.\n\t}\n}"
    },
    "stop_capturing_images": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "void \t\tcalculate_breaking_stop(double &lat, double &lon, float &yaw);\n\tvoid        \tstop_capturing_images();\n\n\tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n\nprivate:\n\n\tint _local_pos_sub{-1}"
    },
    "Mission::set_current_mission_index": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::set_current_mission_index(uint16_t index)\n{\n\tif (index == _current_mission_index) {\n\t\treturn true; // nothing to do, so return true\n\n\t} else if (_navigator->get_mission_result()->valid && (index < _mission.count)) {\n\n\t\t_current_mission_index = index;\n\n\t\t// a mission index is set manually which has the higher priority than the closest mission item\n\t\t// as it is set by the user\n\t\t_mission_waypoints_changed = false;\n\n\t\t// update mission items if already in active mission\n\t\tif (_navigator->is_planned_mission()) {\n\t\t\t// prevent following \"previous - current\" line\n\t\t\t_navigator->get_position_setpoint_triplet()->previous.valid = false;\n\t\t\t_navigator->get_position_setpoint_triplet()->current.valid = false;\n\t\t\t_navigator->get_position_setpoint_triplet()->next.valid = false;\n\t\t\tset_mission_items();\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
    },
    "Mission::reset_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "bd182ecf709ee9362723d74fb1ce4317f5159e01",
      "source": "Mission::reset_mission(struct mission_s &mission)\n{\n\tdm_lock(DM_KEY_MISSION_STATE);\n\n\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s)) == sizeof(mission_s)) {\n\t\tif (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) {\n\t\t\t/* set current item to 0 */\n\t\t\tmission.current_seq = 0;\n\n\t\t\t/* reset jump counters */\n\t\t\tif (mission.count > 0) {\n\t\t\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n\n\t\t\t\tfor (unsigned index = 0; index < mission.count; index++) {\n\t\t\t\t\tstruct mission_item_s item;\n\t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t\t\t\tif (dm_read(dm_current, index, &item, len) != len) {\n\t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\t\t\t\titem.do_jump_current_count = 0;\n\n\t\t\t\t\t\tif (dm_write(dm_current, index, &item, len) != len) {\n\t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Could not read mission.\\t\");\n\t\t\tevents::send(events::ID(\"mission_cannot_read_mission\"), events::Log::Error, \"Could not read mission\");\n\n\t\t\t/* initialize mission state in dataman */\n\t\t\tmission.timestamp = hrt_absolute_time();\n\t\t\tmission.dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n\t\t\tmission.count = 0;\n\t\t\tmission.current_seq = 0;\n\t\t}\n\n\t\tdm_write(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s));\n\t}\n\n\tdm_unlock(DM_KEY_MISSION_STATE);\n}"
    }
  },
  "21464": {
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "90d28d0034e7a6a5d4dc7357c9e793601e56e471",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\t// copy mission to clear any update\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\tposition_setpoint.lon = cmd.param6;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\n\t\t\t\tif (_mission.land_start()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\tset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL: {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tconst bool rtl_activated_now = !_rtl_activated;\n\n\t\t\t\tswitch (_rtl.get_rtl_type()) {\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING:\n\t\t\t\tcase RTL::RTL_TYPE_CLOSEST: {\n\t\t\t\t\t\t// If a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode.\n\t\t\t\t\t\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission.\n\t\t\t\t\t\tconst bool shouldEngageMissionForLanding = _rtl.getRTLDestinationTypeMission()\n\t\t\t\t\t\t\t\t&& _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t\t\t\t\tif (shouldEngageMissionForLanding && (on_mission_landing() || _rtl.getRTLState() > RTL::RTL_STATE_CLIMB)) {\n\n\t\t\t\t\t\t\t// already in a mission landing, we just need to inform the user and stay in mission\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\t\t// the first time we're here start the mission landig\n\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING_REVERSED:\n\t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n\t\t\t\t\t\t// the mission contains a landing spot\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\n\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\tif (_navigation_mode == nullptr) {\n\t\t\t\t\t\t\t\t// switching from an manual mode, go to landing if not already landing\n\t\t\t\t\t\t\t\tif (!on_mission_landing()) {\n\t\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// switching from an auto mode, continue the mission from the closest item\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, continue mission\\t\");\n\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated\"), events::Log::Info,\n\t\t\t\t\t\t\t\t     \"RTL Mission activated, continue mission\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// fly the mission in reverse if switching from a non-manual mode\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_REVERSE);\n\n\t\t\t\t\t\tif ((_navigation_mode != nullptr && (_navigation_mode != &_rtl || _mission.get_mission_changed())) &&\n\t\t\t\t\t\t    (! _mission.get_mission_finished()) &&\n\t\t\t\t\t\t    (!get_land_detected()->landed)) {\n\t\t\t\t\t\t\t// determine the closest mission item if switching from a non-mission mode, and we are either not already\n\t\t\t\t\t\t\t// mission mode or the mission waypoints changed.\n\t\t\t\t\t\t\t// The seconds condition is required so that when no mission was uploaded and one is available the closest\n\t\t\t\t\t\t\t// mission item is determined and also that if the user changes the active mission index while rtl is active\n\t\t\t\t\t\t\t// always that waypoint is tracked first.\n\t\t\t\t\t\t\tif ((_navigation_mode != &_mission) && (rtl_activated_now || _mission.get_mission_waypoints_changed())) {\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly mission in reverse\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_rev\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly mission in reverse\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly to home\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_home\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly to home\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL HOME activated\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_home_activated\"), events::Log::Info, \"RTL activated\");\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t_rtl_activated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\t_can_loiter_at_sp = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {\n\t\t\t_rtl_activated = false;\n\t\t\t_rtl.resetRtlState();\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    },
    "RTL::on_activation": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "90d28d0034e7a6a5d4dc7357c9e793601e56e471",
      "source": "void RTL::on_activation()\n{\n\t_rtl_state = RTL_STATE_NONE;\n\n\t// output the correct message, depending on where the RTL destination is\n\tswitch (_destination.type) {\n\tcase RTL_DESTINATION_HOME:\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: landing at home position.\\t\");\n\t\tevents::send(events::ID(\"rtl_land_at_home\"), events::Log::Info, \"RTL: landing at home position\");\n\t\tbreak;\n\n\tcase RTL_DESTINATION_MISSION_LANDING:\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: landing at mission landing.\\t\");\n\t\tevents::send(events::ID(\"rtl_land_at_mission\"), events::Log::Info, \"RTL: landing at mission landing\");\n\t\tbreak;\n\n\tcase RTL_DESTINATION_SAFE_POINT:\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: landing at safe landing point.\\t\");\n\t\tevents::send(events::ID(\"rtl_land_at_safe_point\"), events::Log::Info, \"RTL: landing at safe landing point\");\n\t\tbreak;\n\t}\n\n\tconst vehicle_global_position_s &global_position = *_navigator->get_global_position();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t// For safety reasons don't go into RTL if landed.\n\t\t_rtl_state = RTL_STATE_LANDED;\n\n\t} else if ((global_position.alt < _destination.alt + _param_rtl_return_alt.get()) || _rtl_alt_min) {\n\n\t\t// If lower than return altitude, climb up first.\n\t\t// If rtl_alt_min is true then forcing altitude change even if above.\n\t\t_rtl_state = RTL_STATE_CLIMB;\n\n\t} else {\n\t\t// Otherwise go straight to return\n\t\t_rtl_state = RTL_STATE_RETURN;\n\t}\n\n\t// reset cruising speed and throttle to default for RTL\n\t_navigator->set_cruising_speed();\n\t_navigator->set_cruising_throttle();\n\n\tset_rtl_item();\n\n}"
    },
    "Mission::land_start": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "90d28d0034e7a6a5d4dc7357c9e793601e56e471",
      "source": "Mission::land_start()\n{\n\t// if not currently landing, jump to do_land_start\n\tif (_land_start_available) {\n\t\t// check if we're currently already in mission mode and on landing part, then simply return true.\n\t\t// note: it's not enough to check landing(), as that is not reset until set_current_mission_index(get_land_start_index())\n\t\tif (_navigator->on_mission_landing()) {\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tset_current_mission_index(get_land_start_index());\n\t\t\treturn landing();\n\t\t}\n\t}\n\n\treturn false;\n}"
    },
    "on_mission_landing": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "90d28d0034e7a6a5d4dc7357c9e793601e56e471",
      "source": "bool is_planned_mission() const { return _navigation_mode == &_mission; }\n\n\tbool on_mission_landing() { return (_mission.landing() && _navigation_mode == &_mission); }"
    }
  },
  "21714": {
    "Mission::cacheItem": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "void Mission::cacheItem(const mission_item_s &mission_item)\n{\n\tswitch (mission_item.nav_cmd) {\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n\t\t_last_gimbal_configure_item = mission_item;\n\t\tbreak;\n\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n\t\t_last_gimbal_control_item = mission_item;\n\t\tbreak;\n\n\tcase NAV_CMD_SET_CAMERA_MODE:\n\t\t_last_camera_mode_item = mission_item;\n\t\tbreak;\n\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\t\t_last_camera_trigger_item = mission_item;\n\t\tbreak;\n\n\tcase NAV_CMD_DO_CHANGE_SPEED:\n\t\t_last_speed_change_item = mission_item;\n\t\tbreak;\n\n\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t// delete speed changes after a VTOL transition\n\t\t_last_speed_change_item = {};\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}"
    },
    "Mission::on_activation": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "Mission::on_activation()\n{\n\tif (_mission_waypoints_changed) {\n\t\t// do not set the closest mission item in the normal mission mode\n\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t}\n\n\t\t_mission_waypoints_changed = false;\n\t}\n\n\t// we already reset the mission items\n\t_execution_mode_changed = false;\n\n\t// reset the cache and fill it with the items up to the previous item. The cache contains\n\t// commands that are valid for the whole mission, not just a sinlge waypoint.\n\tif (_current_mission_index > 0) {\n\t\tresetItemCache();\n\t\tupdateCachedItemsUpToIndex(_current_mission_index - 1);\n\t}\n\n\tunsigned resume_index;\n\n\tif (_inactivation_index > 0 && cameraWasTriggering()\n\t    && getPreviousPositionItemIndex(_mission, _inactivation_index - 1, resume_index)) {\n\t\t// The mission we are resuming had camera triggering enabled. In order to not lose any images\n\t\t// we restart the mission at the previous position item.\n\t\t// We will replay the cached commands once we reach the previous position item and have yaw aligned.\n\t\tset_current_mission_index(resume_index);\n\n\t\t_align_heading_necessary = true;\n\n\t} else {\n\t\tset_mission_items();\n\t}\n\n\t_inactivation_index = -1; // reset\n\n\t// reset cruise speed\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Mission::replayCachedTriggerItems": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "void Mission::replayCachedTriggerItems()\n{\n\tif (_last_camera_trigger_item.nav_cmd > 0) {\n\t\tissue_command(_last_camera_trigger_item);\n\t\t_last_camera_trigger_item = {}; // delete cached item\n\t}\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid(false);\n\n\t/* Check if stored mission plan has changed */\n\tconst bool mission_sub_updated = _mission_sub.updated();\n\n\tif (mission_sub_updated) {\n\t\t_navigator->reset_triplets();\n\t\tupdate_mission();\n\t}\n\n\t/* mission is running (and we are armed), need reset after disarm */\n\t_need_mission_reset = true;\n\n\t_mission_changed = false;\n\n\t/* reset mission items if needed */\n\tif (mission_sub_updated || _mission_waypoints_changed || _execution_mode_changed) {\n\t\tif (_mission_waypoints_changed) {\n\t\t\t// do not set the closest mission item in the normal mission mode\n\t\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t\t}\n\n\t\t\t_mission_waypoints_changed = false;\n\t\t}\n\n\t\t_execution_mode_changed = false;\n\t\tset_mission_items();\n\t}\n\n\t// check if heading alignment is necessary, and add it to the current mission item if necessary\n\tif (_align_heading_necessary && is_mission_item_reached_or_completed()) {\n\t\tmission_item_s next_position_mission_item = {};\n\n\t\t// add yaw alignment requirement on the current mission item\n\t\tif (getNextPositionMissionItem(_mission, _current_mission_index + 1, next_position_mission_item)\n\t\t    && !PX4_ISFINITE(_mission_item.yaw)) {\n\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon));\n\t\t\t_mission_item.force_heading = true; // note: doesn't have effect in fixed-wing mode\n\t\t}\n\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n\n\t\treset_mission_item_reached();\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t_align_heading_necessary = false;\n\t}\n\n\t// replay gimbal and camera commands immediately after resuming mission\n\tif (haveCachedGimbalOrCameraItems()) {\n\t\treplayCachedGimbalCameraItems();\n\t}\n\n\t// replay trigger commands upon raching the resume waypoint if the trigger relay flag is set\n\tif (cameraWasTriggering() && is_mission_item_reached_or_completed()) {\n\t\treplayCachedTriggerItems();\n\t}\n\n\treplayCachedSpeedChangeItems();\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n\t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n\t\t   there is no need to report that we reached it because we didn't. */\n\t\tif (_work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tset_mission_item_reached();\n\t\t}\n\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* check if a cruise speed change has been commanded */\n\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\tcruising_speed_sp_update();\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif (!_param_mis_mnt_yaw_ctl.get()\n\t    && (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING)\n\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t || _work_item_type == WORK_ITEM_TYPE_ALIGN)) {\n\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n\t\t// needs to rotate such that ROI is in the field of view.\n\t\t// ROI only makes sense for multicopters.\n\t\theading_sp_update();\n\t}\n\n\t// TODO: Add vtol heading update method if required.\n\t// Question: Why does vtol ever have to update heading?\n\n\t/* check if landing needs to be aborted */\n\tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n\t    && (_navigator->abort_landing())) {\n\n\t\tdo_abort_landing();\n\t}\n\n\tif (_work_item_type == WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t_navigator->get_precland()->on_active();\n\n\t} else if (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n}"
    },
    "Navigator::get_altitude_acceptance_radius": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "float Navigator::get_altitude_acceptance_radius()\n{\n\tif (get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\tconst position_setpoint_s &next_sp = get_position_setpoint_triplet()->next;\n\n\t\tif (!force_vtol() && next_sp.type == position_setpoint_s::SETPOINT_TYPE_LAND && next_sp.valid) {\n\t\t\t// Use separate (tighter) altitude acceptance for clean altitude starting point before FW landing\n\t\t\treturn _param_nav_fw_altl_rad.get();\n\n\t\t} else {\n\t\t\treturn _param_nav_fw_alt_rad.get();\n\t\t}\n\n\t} else if (get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n\t\treturn INFINITY;\n\n\t} else {\n\t\tfloat alt_acceptance_radius = _param_nav_mc_alt_rad.get();\n\n\t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n\n\t\tif ((pos_ctrl_status.timestamp > _pos_sp_triplet.timestamp)\n\t\t    && pos_ctrl_status.altitude_acceptance > alt_acceptance_radius) {\n\t\t\talt_acceptance_radius = pos_ctrl_status.altitude_acceptance;\n\t\t}\n\n\t\treturn alt_acceptance_radius;\n\t}\n}"
    },
    "set_cruising_speed": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "*/\n\tvoid set_cruising_speed(float desired_speed) { _cruising_speed_current_mode = desired_speed; }"
    },
    "reset_cruising_speed": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "*/\n\tvoid reset_cruising_speed() { _cruising_speed_current_mode = -1.f; }"
    },
    "get_cruising_speed": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "*/\n\tfloat get_cruising_speed() { return _cruising_speed_current_mode; }"
    },
    "cruising_speed_sp_update": {
      "file": "src/modules/navigator/mission.h",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "*/\n\tvoid cruising_speed_sp_update();\n\n\t/**\n\t * Abort landing\n\t */\n\tvoid do_abort_landing();\n\n\t/**\n\t * Read the current and the next mission item. The next mission item read is the\n\t * next mission item that contains a position.\n\t *\n\t * @return true if current mission item available\n\t */\n\tbool prepare_mission_items(mission_item_s *mission_item,\n\t\t\t\t   mission_item_s *next_position_mission_item, bool *has_next_position_item,\n\t\t\t\t   mission_item_s *next_next_position_mission_item = nullptr, bool *has_next_next_position_item = nullptr);\n\n\t/**\n\t * Read current (offset == 0) or a specific (offset > 0) mission item\n\t * from the dataman and watch out for DO_JUMPS\n\t *\n\t * @return true if successful\n\t */\n\tbool read_mission_item(int offset, struct mission_item_s *mission_item);\n\n\t/**\n\t * Save current mission state to dataman\n\t */\n\tvoid save_mission_state();\n\n\t/**\n\t * Inform about a changed mission item after a DO_JUMP\n\t */\n\tvoid report_do_jump_mission_changed(int index, int do_jumps_remaining);\n\n\t/**\n\t * Set a mission item as reached\n\t */\n\tvoid set_mission_item_reached();\n\n\t/**\n\t * Set the current mission item\n\t */\n\tvoid set_current_mission_item();\n\n\t/**\n\t * Check whether a mission is ready to go\n\t */\n\tvoid check_mission_valid(bool force);\n\n\t/**\n\t * Reset mission\n\t */\n\tvoid reset_mission(struct mission_s &mission);\n\n\t/**\n\t * Returns true if we need to reset the mission (call this only when inactive)\n\t */\n\tbool need_to_reset_mission();\n\n\t/**\n\t * Find and store the index of the landing sequence (DO_LAND_START)\n\t */\n\tbool find_mission_land_start();\n\n\t/**\n\t * Return the index of the closest mission item to the current global position.\n\t */\n\tint32_t index_closest_mission_item() const;\n\n\tbool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;\n\n\tvoid publish_navigator_mission_item();\n\n\n\t/**\n\t* @brief Get the index associated with the last item that contains a position\n\t* @param mission The mission to search\n\t* @param start_index The index to start searching from\n\t* @param prev_pos_index The index of the previous position item containing a position\n\t* @return true if a previous position item was found\n\t*/\n\tbool getPreviousPositionItemIndex(const mission_s &mission, int start_index, unsigned &prev_pos_index) const;\n\n\t/**\n\t * @brief Get the next item after start_index that contains a position\n\t *\n\t * @param mission The mission to search\n\t * @param start_index The index to start searching from\n\t * @param mission_item The mission item to populate\n\t * @return true if successful\n\t */\n\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item) const;\n\n\t/**\n\t * @brief Read the mission item at the given index\n\t *\n\t * @param mission The mission to read from\n\t * @param index The index to read\n\t * @param missionitem The mission item to populate\n\t * @return true if successful\n\t */\n\tbool readMissionItemAtIndex(const mission_s &mission, const int index, mission_item_s &missionitem) const;\n\n\t/**\n\t * @brief Cache the mission items containing gimbal, camera mode and trigger commands\n\t *\n\t * @param mission_item The mission item to cache if applicable\n\t */\n\tvoid cacheItem(const mission_item_s &mission_item);\n\n\t/**\n\t * @brief Update the cached items up to the given index\n\t *\n\t * @param end_index The index to update up to\n\t */\n\tvoid updateCachedItemsUpToIndex(int end_index);\n\n\t/**\n\t * @brief Replay the cached gimbal and camera mode items\n\t */\n\tvoid replayCachedGimbalCameraItems();\n\n\t/**\n\t * @brief Replay the cached trigger items\n\t *\n\t */\n\tvoid replayCachedTriggerItems();\n\n\t/**\n\t * @brief Replay the cached speed change items and delete them afterwards\n\t *\n\t */\n\tvoid replayCachedSpeedChangeItems();\n\n\t/**\n\t * @brief Reset the item cache\n\t */\n\tvoid resetItemCache();\n\n\t/**\n\t * @brief Check if there are cached gimbal or camera mode items to be replayed\n\t *\n\t * @return true if there are cached items\n\t */\n\tbool haveCachedGimbalOrCameraItems();\n\n\t/**\n\t * @brief Check if the camera was triggering\n\t *\n\t * @return true if there was a camera trigger command in the cached items that didn't disable triggering\n\t */\n\tbool cameraWasTriggering();\n\n\tDEFINE_PARAMETERS(\n\t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n\t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n\t)\n\n\tuORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item}"
    },
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\t// copy mission to clear any update\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\n\t\t\t\tif (_mission.land_start()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\treset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL: {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tconst bool rtl_activated_now = !_rtl_activated;\n\n\t\t\t\tswitch (_rtl.get_rtl_type()) {\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING:\n\t\t\t\tcase RTL::RTL_TYPE_CLOSEST: {\n\t\t\t\t\t\t// If a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode.\n\t\t\t\t\t\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission.\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t_shouldEngageMissionForLanding = _rtl.getRTLDestinationTypeMission()\n\t\t\t\t\t\t\t\t\t\t\t && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (_shouldEngageMissionForLanding && (on_mission_landing() || _rtl.getRTLState() > RTL::RTL_STATE_CLIMB)) {\n\n\t\t\t\t\t\t\t// already in a mission landing, we just need to inform the user and stay in mission\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\t\t// the first time we're here start the mission landig\n\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING_REVERSED:\n\t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n\t\t\t\t\t\t// the mission contains a landing spot\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\n\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\tif (_navigation_mode == nullptr) {\n\t\t\t\t\t\t\t\t// switching from an manual mode, go to landing if not already landing\n\t\t\t\t\t\t\t\tif (!on_mission_landing()) {\n\t\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// switching from an auto mode, continue the mission from the closest item\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, continue mission\\t\");\n\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated\"), events::Log::Info,\n\t\t\t\t\t\t\t\t     \"RTL Mission activated, continue mission\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// fly the mission in reverse if switching from a non-manual mode\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_REVERSE);\n\n\t\t\t\t\t\tif ((_navigation_mode != nullptr && (_navigation_mode != &_rtl || _mission.get_mission_changed())) &&\n\t\t\t\t\t\t    (! _mission.get_mission_finished()) &&\n\t\t\t\t\t\t    (!get_land_detected()->landed)) {\n\t\t\t\t\t\t\t// determine the closest mission item if switching from a non-mission mode, and we are either not already\n\t\t\t\t\t\t\t// mission mode or the mission waypoints changed.\n\t\t\t\t\t\t\t// The seconds condition is required so that when no mission was uploaded and one is available the closest\n\t\t\t\t\t\t\t// mission item is determined and also that if the user changes the active mission index while rtl is active\n\t\t\t\t\t\t\t// always that waypoint is tracked first.\n\t\t\t\t\t\t\tif ((_navigation_mode != &_mission) && (rtl_activated_now || _mission.get_mission_waypoints_changed())) {\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly mission in reverse\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_rev\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly mission in reverse\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly to home\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_home\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly to home\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL HOME activated\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_home_activated\"), events::Log::Info, \"RTL activated\");\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t_rtl_activated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\t_can_loiter_at_sp = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {\n\t\t\t_rtl_activated = false;\n\t\t\t_rtl.resetRtlState();\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    },
    "Mission::heading_sp_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "d51734fa9e9da6760fe18116609cc9af78b5857e",
      "source": "Mission::heading_sp_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet =\n\t\t_navigator->get_position_setpoint_triplet();\n\n\t// Only update if current triplet is valid\n\tif (pos_sp_triplet->current.valid) {\n\n\t\tdouble point_from_latlon[2] = { _navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon\n\t\t\t\t\t      };\n\t\tdouble point_to_latlon[2] = { _navigator->get_global_position()->lat,\n\t\t\t\t\t      _navigator->get_global_position()->lon\n\t\t\t\t\t    };\n\t\tfloat yaw_offset = 0.0f;\n\n\t\t// Depending on ROI-mode, update heading\n\t\tswitch (_navigator->get_vroi().mode) {\n\t\tcase vehicle_roi_s::ROI_LOCATION: {\n\t\t\t\t// ROI is a fixed location. Vehicle needs to point towards that location\n\t\t\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n\t\t\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n\t\t\t\t// No yaw offset required\n\t\t\t\tyaw_offset = 0.0f;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_roi_s::ROI_WPNEXT: {\n\t\t\t\t// ROI is current waypoint. Vehcile needs to point towards current waypoint\n\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n\t\t\t\t// Add the gimbal's yaw offset\n\t\t\t\tyaw_offset = _navigator->get_vroi().yaw_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_roi_s::ROI_NONE:\n\t\tcase vehicle_roi_s::ROI_WPINDEX:\n\t\tcase vehicle_roi_s::ROI_TARGET:\n\t\tcase vehicle_roi_s::ROI_ENUM_END:\n\t\tdefault: {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Get desired heading and update it.\n\t\t// However, only update if distance to desired heading is\n\t\t// larger than acceptance radius to prevent excessive yawing\n\t\tfloat d_current = get_distance_to_next_waypoint(point_from_latlon[0],\n\t\t\t\t  point_from_latlon[1], point_to_latlon[0], point_to_latlon[1]);\n\n\t\tif (d_current > _navigator->get_acceptance_radius()) {\n\t\t\tfloat yaw = matrix::wrap_pi(\n\t\t\t\t\t    get_bearing_to_next_waypoint(point_from_latlon[0],\n\t\t\t\t\t\t\t    point_from_latlon[1], point_to_latlon[0],\n\t\t\t\t\t\t\t    point_to_latlon[1]) + yaw_offset);\n\n\t\t\t_mission_item.yaw = yaw;\n\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\t\t\tpos_sp_triplet->current.yaw_valid = true;\n\n\t\t} else {\n\t\t\tif (!pos_sp_triplet->current.yaw_valid) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\t\t\t\tpos_sp_triplet->current.yaw_valid = true;\n\t\t\t}\n\t\t}\n\n\t\t// we set yaw directly so we can run this in parallel to the FOH update\n\t\tpublish_navigator_mission_item();\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n}"
    }
  },
  "22100": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "2d3b32d5d1c9fb732e521f1bec864968a5071903",
      "source": "Loiter::on_activation()\n{\n\tif (_navigator->get_reposition_triplet()->current.valid\n\t    && hrt_elapsed_time(&_navigator->get_reposition_triplet()->current.timestamp) < 500_ms) {\n\t\treposition();\n\n\t} else {\n\t\t// this is executed when the flight mode is switched to Hold manually, not through a reposition\n\t\tset_loiter_position();\n\t}\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Loiter::on_inactive": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "2d3b32d5d1c9fb732e521f1bec864968a5071903",
      "source": "Loiter::on_inactive()\n{\n\t_loiter_pos_set = false;\n}"
    }
  },
  "21414": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "8ffcf5ce9a4d6858992d8c60f47e7d595641579e",
      "source": "Loiter::on_activation()\n{\n\tif (_navigator->get_reposition_triplet()->current.valid) {\n\t\treposition();\n\n\t} else {\n\t\tset_loiter_position();\n\t}\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Takeoff::on_activation": {
      "file": "src/modules/navigator/takeoff.cpp",
      "commit": "8ffcf5ce9a4d6858992d8c60f47e7d595641579e",
      "source": "Takeoff::on_activation()\n{\n\tset_takeoff_position();\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Mission::on_activation": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "8ffcf5ce9a4d6858992d8c60f47e7d595641579e",
      "source": "Mission::on_activation()\n{\n\tif (_mission_waypoints_changed) {\n\t\t// do not set the closest mission item in the normal mission mode\n\t\tif (_mission_execution_mode != mission_result_s::MISSION_EXECUTION_MODE_NORMAL) {\n\t\t\t_current_mission_index = index_closest_mission_item();\n\t\t}\n\n\t\t_mission_waypoints_changed = false;\n\t}\n\n\t// we already reset the mission items\n\t_execution_mode_changed = false;\n\n\tset_mission_items();\n\n\t// unpause triggering if it was paused\n\tvehicle_command_s cmd = {};\n\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n\t// unpause trigger\n\tcmd.param1 = -1.0f;\n\tcmd.param3 = 0.0f;\n\t_navigator->publish_vehicle_cmd(&cmd);\n\n\t// reset cruise speed\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Land::on_activation": {
      "file": "src/modules/navigator/land.cpp",
      "commit": "8ffcf5ce9a4d6858992d8c60f47e7d595641579e",
      "source": "Land::on_activation()\n{\n\t/* set current mission item to Land */\n\tset_land_item(&_mission_item);\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\treset_mission_item_reached();\n\n\t/* convert mission item to current setpoint */\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_can_loiter_at_sp(false);\n\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "RTL::on_activation": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "8ffcf5ce9a4d6858992d8c60f47e7d595641579e",
      "source": "void RTL::on_activation()\n{\n\t_rtl_state = RTL_STATE_NONE;\n\n\t// if a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode\n\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission\n\t_should_engange_mission_for_landing = (_destination.type == RTL_DESTINATION_MISSION_LANDING)\n\t\t\t\t\t      && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t// output the correct message, depending on where the RTL destination is\n\tswitch (_destination.type) {\n\tcase RTL_DESTINATION_HOME:\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: landing at home position.\\t\");\n\t\tevents::send(events::ID(\"rtl_land_at_home\"), events::Log::Info, \"RTL: landing at home position\");\n\t\tbreak;\n\n\tcase RTL_DESTINATION_MISSION_LANDING:\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: landing at mission landing.\\t\");\n\t\tevents::send(events::ID(\"rtl_land_at_mission\"), events::Log::Info, \"RTL: landing at mission landing\");\n\t\tbreak;\n\n\tcase RTL_DESTINATION_SAFE_POINT:\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: landing at safe landing point.\\t\");\n\t\tevents::send(events::ID(\"rtl_land_at_safe_point\"), events::Log::Info, \"RTL: landing at safe landing point\");\n\t\tbreak;\n\t}\n\n\tconst vehicle_global_position_s &global_position = *_navigator->get_global_position();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t// For safety reasons don't go into RTL if landed.\n\t\t_rtl_state = RTL_STATE_LANDED;\n\n\t} else if ((_destination.type == RTL_DESTINATION_MISSION_LANDING) && _navigator->getMissionLandingInProgress()) {\n\t\t// we were just on a mission landing, set _rtl_state past RTL_STATE_LOITER such that navigator will engage mission mode,\n\t\t// which will continue executing the landing\n\t\t_rtl_state = RTL_STATE_LAND;\n\n\n\t} else if ((global_position.alt < _destination.alt + _param_rtl_return_alt.get()) || _rtl_alt_min) {\n\n\t\t// If lower than return altitude, climb up first.\n\t\t// If rtl_alt_min is true then forcing altitude change even if above.\n\t\t_rtl_state = RTL_STATE_CLIMB;\n\n\t} else {\n\t\t// Otherwise go straight to return\n\t\t_rtl_state = RTL_STATE_RETURN;\n\t}\n\n\t// reset cruising speed and throttle to default for RTL\n\t_navigator->reset_cruising_speed();\n\t_navigator->set_cruising_throttle();\n\n\tset_rtl_item();\n\n}"
    }
  },
  "22078": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "f8b812966de830ac41a79f016fb1bfe59a7eabfa",
      "source": "Loiter::on_activation()\n{\n\tif (_navigator->get_reposition_triplet()->current.valid\n\t    && hrt_elapsed_time(&_navigator->get_reposition_triplet()->current.timestamp) < 500_ms) {\n\t\treposition();\n\n\t} else {\n\t\t// this is executed when the flight mode is switched to Hold manually, not through a reposition\n\t\tset_loiter_position();\n\t}\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Loiter::Loiter": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "f8b812966de830ac41a79f016fb1bfe59a7eabfa",
      "source": "Loiter::Loiter(Navigator *navigator) :\n\tMissionBlock(navigator),\n\tModuleParams(navigator)\n{\n}"
    }
  },
  "22097": {
    "VtolTakeoff::VtolTakeoff": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "1cbaa78ebaf99e5c07d586c9926a66fef4132b4e",
      "source": "VtolTakeoff::VtolTakeoff(Navigator *navigator) :\n\tMissionBlock(navigator),\n\tModuleParams(navigator)\n{\n}"
    },
    "VtolTakeoff::on_active": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "1cbaa78ebaf99e5c07d586c9926a66fef4132b4e",
      "source": "VtolTakeoff::on_active()\n{\n\tif (is_mission_item_reached_or_completed()) {\n\t\treset_mission_item_reached();\n\n\t\tswitch\t(_takeoff_state) {\n\t\tcase vtol_takeoff_state::TAKEOFF_HOVER: {\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_navigator->get_home_position()->lat,\n\t\t\t\t\t\t\t    _navigator->get_home_position()->lon, _loiter_location(0), _loiter_location(1)));\n\t\t\t\t_mission_item.force_heading = true;\n\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::ALIGN_HEADING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::ALIGN_HEADING: {\n\n\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t_mission_item.lat = _loiter_location(0);\n\t\t\t\t_mission_item.lon = _loiter_location(1);\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\tissue_command(_mission_item);\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::TRANSITION;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::TRANSITION: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t\t} else {\n\t\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t\t}\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n\t\t\t\t// however it will just continue loitering as there is no next mission item\n\t\t\t\t_mission_item.time_inside = 1.f;\n\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n\t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.lat = _loiter_location(0);\n\t\t\t\tpos_sp_triplet->current.lon = _loiter_location(1);\n\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n\n\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\treset_mission_item_reached();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::CLIMB;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::CLIMB: {\n\n\t\t\t\t// reset any potentially valid reposition triplet which was not handled\n\t\t\t\t// we do this to avoid random loiter locations after switching to loiter mode after this\n\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n\n\t\t\t\t// the VTOL takeoff is done\n\t\t\t\t_navigator->get_mission_result()->finished = true;\n\t\t\t\t_navigator->set_mission_result_updated();\n\t\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "VtolTakeoff::set_takeoff_position": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "1cbaa78ebaf99e5c07d586c9926a66fef4132b4e",
      "source": "VtolTakeoff::set_takeoff_position()\n{\n\t// set current mission item to takeoff\n\tset_takeoff_item(&_mission_item, _transition_alt_amsl);\n\n\t_mission_item.lat = _navigator->get_home_position()->lat;\n\t_mission_item.lon = _navigator->get_home_position()->lon;\n\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\n\t// convert mission item to current setpoint\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\tpos_sp_triplet->previous.valid = false;\n\tpos_sp_triplet->current.yaw_valid = true;\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "21963": {
    "GeofenceBreachAvoidance::generateLoiterPointForMultirotor": {
      "file": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
      "commit": "4fce159a2ab490410e730d492d4135f1beca2db4",
      "source": "GeofenceBreachAvoidance::generateLoiterPointForMultirotor(geofence_violation_type_u violation_type, Geofence *geofence)\n{\n\n\tif (violation_type.flags.fence_violation) {\n\t\tfloat current_distance = _test_point_distance * 0.5f;\n\t\tfloat current_min = 0.0f;\n\t\tfloat current_max = _test_point_distance;\n\t\tVector2d test_point;\n\n\t\t// binary search for the distance from the drone to the geofence in the given direction\n\t\twhile (abs(current_max - current_min) > 0.5f) {\n\t\t\ttest_point = waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, current_distance);\n\n\t\t\tif (!geofence->isInsidePolygonOrCircle(test_point(0), test_point(1), _current_alt_amsl)) {\n\t\t\t\tcurrent_max = current_distance;\n\n\t\t\t} else {\n\t\t\t\tcurrent_min = current_distance;\n\t\t\t}\n\n\t\t\tcurrent_distance = (current_max + current_min) * 0.5f;\n\t\t}\n\n\t\ttest_point = waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, current_distance);\n\n\t\tif (_multirotor_braking_distance > current_distance - _min_hor_dist_to_fence_mc) {\n\t\t\treturn waypointFromBearingAndDistance(test_point, _test_point_bearing + M_PI_F, _min_hor_dist_to_fence_mc);\n\n\t\t} else {\n\t\t\treturn waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, _multirotor_braking_distance);\n\t\t}\n\n\t} else if (violation_type.flags.dist_to_home_exceeded) {\n\n\t\treturn waypointFromHomeToTestPointAtDist(math::max(_max_hor_dist_home - _min_hor_dist_to_fence_mc, 0.0f));\n\n\t} else {\n\t\tif (_velocity_hor_abs > 0.5f) {\n\t\t\treturn waypointFromBearingAndDistance(_current_pos_lat_lon, _test_point_bearing, _multirotor_braking_distance);\n\n\t\t} else {\n\t\t\treturn _current_pos_lat_lon;\n\t\t}\n\t}\n}"
    }
  },
  "22057": {
    "Geofence::run": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "97c720242e7882275e231e1d8b65379da231b994",
      "source": "void Geofence::run()\n{\n\tbool success;\n\n\tswitch (_dataman_state) {\n\n\tcase DatamanState::UpdateRequestWait:\n\n\t\tif (_initiate_fence_updated) {\n\t\t\t_initiate_fence_updated = false;\n\t\t\t_dataman_state\t= DatamanState::Read;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Read:\n\n\t\t_dataman_state = DatamanState::ReadWait;\n\t\tsuccess = _dataman_client.readAsync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n\t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"geofence dataman read failed\");\n\t\t\t_error_state = DatamanState::Read;\n\t\t\t_dataman_state = DatamanState::Error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::ReadWait:\n\n\t\t_dataman_client.update();\n\n\t\tif (_dataman_client.lastOperationCompleted(success)) {\n\n\t\t\tif (!success) {\n\t\t\t\t_error_state = DatamanState::ReadWait;\n\t\t\t\t_dataman_state = DatamanState::Error;\n\n\t\t\t} else if (_update_counter != _stats.update_counter) {\n\n\t\t\t\t_update_counter = _stats.update_counter;\n\t\t\t\t_fence_updated = false;\n\n\t\t\t\t_dataman_cache.invalidate();\n\n\t\t\t\tif (_dataman_cache.size() != _stats.num_items) {\n\t\t\t\t\t_dataman_cache.resize(_stats.num_items);\n\t\t\t\t}\n\n\t\t\t\tfor (int index = 1; index <= _dataman_cache.size(); ++index) {\n\t\t\t\t\t_dataman_cache.load(DM_KEY_FENCE_POINTS, index);\n\t\t\t\t}\n\n\t\t\t\t_dataman_state = DatamanState::Load;\n\n\t\t\t} else {\n\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Load:\n\n\t\t_dataman_cache.update();\n\n\t\tif (!_dataman_cache.isLoading()) {\n\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t_updateFence();\n\t\t\t_fence_updated = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Error:\n\t\tPX4_ERR(\"Geofence update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n}"
    },
    "RTL::run": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "97c720242e7882275e231e1d8b65379da231b994",
      "source": "void RTL::run()\n{\n\tbool success;\n\n\tswitch (_dataman_state) {\n\n\tcase DatamanState::UpdateRequestWait:\n\n\t\tif (_initiate_safe_points_updated) {\n\t\t\t_initiate_safe_points_updated = false;\n\t\t\t_dataman_state\t= DatamanState::Read;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Read:\n\n\t\t_dataman_state\t= DatamanState::ReadWait;\n\t\tsuccess = _dataman_client.readAsync(DM_KEY_SAFE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n\t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"RTL dataman read failed\");\n\t\t\t_error_state = DatamanState::Read;\n\t\t\t_dataman_state = DatamanState::Error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::ReadWait:\n\n\t\t_dataman_client.update();\n\n\t\tif (_dataman_client.lastOperationCompleted(success)) {\n\n\t\t\tif (!success) {\n\t\t\t\t_error_state = DatamanState::ReadWait;\n\t\t\t\t_dataman_state = DatamanState::Error;\n\n\t\t\t} else if (_update_counter != _stats.update_counter) {\n\n\t\t\t\t_update_counter = _stats.update_counter;\n\t\t\t\t_safe_points_updated = false;\n\n\t\t\t\t_dataman_cache.invalidate();\n\n\t\t\t\tif (_dataman_cache.size() != _stats.num_items) {\n\t\t\t\t\t_dataman_cache.resize(_stats.num_items);\n\t\t\t\t}\n\n\t\t\t\tfor (int index = 1; index <= _dataman_cache.size(); ++index) {\n\t\t\t\t\t_dataman_cache.load(DM_KEY_SAFE_POINTS, index);\n\t\t\t\t}\n\n\t\t\t\t_dataman_state = DatamanState::Load;\n\n\t\t\t} else {\n\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Load:\n\n\t\t_dataman_cache.update();\n\n\t\tif (!_dataman_cache.isLoading()) {\n\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t_safe_points_updated = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Error:\n\t\tPX4_ERR(\"Safe points update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n}"
    }
  },
  "21985": {
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b28258dddee87e6131fe98ad3c2117bd520ede6e",
      "source": "Mission::set_mission_items()\n{\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tstruct mission_item_s mission_item_after_next_position;\n\tbool has_next_position_item = false;\n\tbool has_after_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\tif (prepare_mission_items(&_mission_item, &mission_item_next_position, &has_next_position_item,\n\t\t\t\t  &mission_item_after_next_position, &has_after_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_MISSION) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Executing Reverse Mission\\t\" :\n\t\t\t\t\t \"Executing Mission\\t\");\n\n\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\tevents::send(events::ID(\"mission_execute_rev\"), events::Log::Info, \"Executing Reverse Mission\");\n\n\t\t\t} else {\n\t\t\t\tevents::send(events::ID(\"mission_execute\"), events::Log::Info, \"Executing Mission\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_MISSION;\n\n\t} else {\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, landed\\t\" :\n\t\t\t\t\t\t \"Mission finished, landed\\t\");\n\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_rev\"), events::Log::Info, \"Reverse Mission finished, landed\");\n\n\t\t\t\t} else {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished\"), events::Log::Info, \"Mission finished, landed\");\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE ? \"Reverse Mission finished, loitering\\t\" :\n\t\t\t\t\t\t \"Mission finished, loitering\\t\");\n\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_rev_loiter\"), events::Log::Info, \"Reverse Mission finished, loitering\");\n\n\t\t\t\t} else {\n\t\t\t\t\tevents::send(events::ID(\"mission_finished_loiter\"), events::Log::Info, \"Mission finished, loitering\");\n\t\t\t\t}\n\n\t\t\t\t/* use last setpoint for loiter */\n\t\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t\t} else {\n\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\n\t\t}\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t// set mission finished\n\t\t_navigator->get_mission_result()->finished = true;\n\t\t_navigator->set_mission_result_updated();\n\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION);\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, refusing takeoff\\t\");\n\t\t\t\tevents::send(events::ID(\"mission_not_valid_refuse\"), {events::Log::Error, events::LogInternal::Disabled},\n\t\t\t\t\t     \"No valid mission available, refusing takeoff\");\n\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"No valid mission available, loitering\\t\");\n\t\t\t\tevents::send(events::ID(\"mission_not_valid_loiter\"), {events::Log::Error, events::LogInternal::Disabled},\n\t\t\t\t\t     \"No valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\t\t}\n\n\t\tpublish_navigator_mission_item(); // for logging\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle mission items depending on the mode */\n\n\tconst position_setpoint_s current_setpoint_copy = _navigator->get_position_setpoint_triplet()->current;\n\n\tif (item_contains_position(_mission_item)) {\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\t/* force vtol land */\n\t\t\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\t\t\t/* in fixed-wing this whole block will be ignored and a takeoff item is always propagated */\n\t\t\t\tif (do_need_vertical_takeoff() &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_DEFAULT &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Takeoff to %.1f meters above home\\t\",\n\t\t\t\t\t\t\t (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\t\t\t\t\tevents::send<float>(events::ID(\"mission_takeoff_to\"), events::Log::Info,\n\t\t\t\t\t\t\t    \"Takeoff to {1:.1m_v} above home\", takeoff_alt - _navigator->get_home_position()->alt);\n\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t\t\t/* hold heading for takeoff items */\n\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t\t\t   && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t\t\t/* if there is no need to do a takeoff but we have a takeoff item, treat is as waypoint */\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t\t   && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t\t   && new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\t\t\t\t\t// if the vehicle is already in fixed wing mode then the current mission item\n\t\t\t\t\t// will be accepted immediately and the work items will be skipped\n\t\t\t\t\t_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\t/* if we just did a normal takeoff navigate to the actual waypoint now */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_TAKEOFF &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\t/* if we just did a VTOL takeoff, prepare transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_TAKEOFF &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT &&\n\t\t\t\t    _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\t\t\t\t/* set yaw setpoint to heading of VTOL_TAKEOFF wp against current position */\n\t\t\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t\t\t\t\t    _navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t\t    _mission_item.lat, _mission_item.lon);\n\n\t\t\t\t\t_mission_item.force_heading = true;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t\t\t/* set position setpoint to current while aligning */\n\t\t\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\t/* heading is aligned now, prepare transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t\t\t\t    _work_item_type == WORK_ITEM_TYPE_ALIGN &&\n\t\t\t\t    _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t\t\t    !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\t/* re-enable weather vane again after alignment */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\t\t\t\t/* check if the vtol_takeoff waypoint is on top of us */\n\t\t\t\t\tif (do_need_move_to_takeoff()) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t}\n\n\t\t\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\t/* move to land wp as fixed wing */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t    && (_work_item_type == WORK_ITEM_TYPE_DEFAULT || _work_item_type == WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF)\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t\t\t}\n\n\t\t\t\t\t_mission_item.altitude = altitude;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t\t_mission_item.vtol_back_transition = true;\n\t\t\t\t}\n\n\t\t\t\t/* transition to MC */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING\n\t\t\t\t    && !_navigator->get_land_detected()->landed) {\n\n\t\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\t\t\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n\n\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following\n\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\t/* move to landing waypoint before descent if necessary */\n\t\t\t\tif (do_need_move_to_land() &&\n\t\t\t\t    (_work_item_type == WORK_ITEM_TYPE_DEFAULT ||\n\t\t\t\t     _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION) &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t\t\t/* use current mission item as next position item */\n\t\t\t\t\tmission_item_next_position = _mission_item;\n\t\t\t\t\thas_next_position_item = true;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignoring waypoint altitude:\n\t\t\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t\t\t * what the altitude means on this waypoint type.\n\t\t\t\t\t */\n\t\t\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t\t\tif (pos_sp_triplet->current.valid\n\t\t\t\t\t    && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t\t\t}\n\n\t\t\t\t\t_mission_item.altitude = altitude;\n\t\t\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\n\t\t\t\t\t// have to reset here because these field were used in set_vtol_transition_item\n\t\t\t\t\t_mission_item.time_inside = 0.f;\n\t\t\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n\t\t\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t\t\tpos_sp_triplet->previous.valid = false;\n\n\t\t\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\n\t\t\t\t\t\t} else { //_mission_item.land_precision == 2\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* we just moved to the landing waypoint, now descend */\n\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\t\t\tif (_mission_item.land_precision == 1) {\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Opportunistic);\n\n\t\t\t\t\t\t} else { //_mission_item.land_precision == 2\n\t\t\t\t\t\t\t_navigator->get_precland()->set_mode(PrecLandMode::Required);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_navigator->get_precland()->on_activation();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/* ignore yaw for landing items */\n\t\t\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t\t\t * that aligns the vehicle first */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\t}\n\n\n\t\t\t\t// for fast forward convert certain types to simple waypoint\n\t\t\t\t// XXX: add other types which should be ignored in fast forward\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD &&\n\t\t\t\t    ((_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED) ||\n\t\t\t\t     (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT))) {\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\tif (item_contains_position(_mission_item)) {\n\t\t\t\t\t// convert mission item to a simple waypoint\n\t\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t\t     \"MissionReverse: Got a non-position mission item, ignoring it\\t\");\n\t\t\t\t\tevents::send(events::ID(\"mission_ignore_non_position_item\"), events::Log::Info,\n\t\t\t\t\t\t     \"MissionReverse: Got a non-position mission item, ignoring it\");\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* handle non-position mission items such as commands */\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t/* turn towards next waypoint before MC to FW transition */\n\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t    && _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && new_work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t    && !_navigator->get_land_detected()->landed\n\t\t\t\t    && has_next_position_item) {\n\n\t\t\t\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t\t\tset_align_mission_item(&_mission_item, &mission_item_next_position);\n\n\t\t\t\t\t/* set position setpoint to target during the transition */\n\t\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n\t\t\t\t}\n\n\t\t\t\t/* yaw is aligned now */\n\t\t\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN &&\n\t\t\t\t    new_work_item_type == WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t\t\t/* re-enable weather vane again after alignment */\n\t\t\t\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t\t\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\t}\n\n\t\t\t\t// ignore certain commands in mission fast forward\n\t\t\t\tif ((_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD) &&\n\t\t\t\t    (_mission_item.nav_cmd == NAV_CMD_DELAY)) {\n\t\t\t\t\t_mission_item.autocontinue = true;\n\t\t\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\t// nothing to do, all commands are ignored\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\t// The logic in this section establishes the tracking between the current waypoint\n\t// which we are approaching and the next waypoint, which will tell us in which direction\n\t// we will change our trajectory right after reaching it.\n\n\t// Because actions, gates and jump labels can be interleaved with waypoints,\n\t// we are searching around the current mission item in the list to find the closest\n\t// gate and the closest waypoint. We then store them separately.\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Check if the mission item is a gate along the current trajectory\n\tif (item_contains_gate(_mission_item)) {\n\n\t\t// The mission item is a gate, let's check if the next item in the list provides\n\t\t// a position to go towards.\n\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (has_next_position_item) {\n\t\t\t// We have a position, convert it to the setpoint and update setpoint triplet\n\t\t\tmission_apply_limitation(mission_item_next_position);\n\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// ELSE: The current position setpoint stays unchanged.\n\n\t} else {\n\t\t// The mission item is not a gate, set the current position setpoint from mission item (is protected against non-position items)\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (new_work_item_type != WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t\tmission_apply_limitation(_mission_item);\n\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// ELSE: The current position setpoint stays unchanged.\n\t}\n\n\t// Only set the previous position item if the current one really changed\n\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\tif ((_work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) &&\n\t    !position_setpoint_equal(&pos_sp_triplet->current, &current_setpoint_copy)) {\n\t\tpos_sp_triplet->previous = current_setpoint_copy;\n\t}\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND\n\t    || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_MISSION) {\n\t\tset_current_mission_item();\n\t}\n\n\t// If the mission item under evaluation contains a gate, we need to check if we have a next position item so\n\t// the controller can fly the correct line between the current and next setpoint\n\tif (item_contains_gate(_mission_item)) {\n\t\tif (has_after_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_apply_limitation(mission_item_next_position);\n\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->next);\n\n\t\t} else {\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t// Allow a rotary wing vehicle to decelerate before reaching a wp with a hold time or a timeout\n\t\t// This is done by setting the position triplet's next position's valid flag to false,\n\t\t// which makes the FlightTask disregard the next position\n\t\t// TODO: Setting the next waypoint's validity flag to handle braking / correct waypoint behavior\n\t\t// seems hacky, handle this more properly.\n\t\tconst bool brake_for_hold = _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_time_inside(_mission_item) > FLT_EPSILON || item_has_timeout(_mission_item));\n\n\t\tif (_mission_item.autocontinue && !brake_for_hold) {\n\t\t\t/* try to process next mission item */\n\t\t\tif (has_next_position_item) {\n\t\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\t\tmission_item_to_position_setpoint(mission_item_next_position, &pos_sp_triplet->next);\n\n\t\t\t} else {\n\t\t\t\t/* next mission item is not available */\n\t\t\t\tpos_sp_triplet->next.valid = false;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBlock::is_mission_item_reached_or_completed": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "b28258dddee87e6131fe98ad3c2117bd520ede6e",
      "source": "MissionBlock::is_mission_item_reached_or_completed()\n{\n\tconst hrt_abstime now = hrt_absolute_time();\n\n\t// Handle indefinite waypoints and action commands\n\tswitch (_mission_item.nav_cmd) {\n\n\t// Action Commands that doesn't have timeout completes instantaneously\n\tcase NAV_CMD_DO_SET_ACTUATOR:\n\tcase NAV_CMD_DO_LAND_START:\n\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\tcase NAV_CMD_VIDEO_START_CAPTURE:\n\tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n\tcase NAV_CMD_DO_CONTROL_VIDEO:\n\tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n\tcase NAV_CMD_DO_MOUNT_CONTROL:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n\tcase NAV_CMD_DO_SET_ROI:\n\tcase NAV_CMD_DO_SET_ROI_LOCATION:\n\tcase NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\tcase NAV_CMD_DO_SET_ROI_NONE:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\tcase NAV_CMD_OBLIQUE_SURVEY:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:\n\tcase NAV_CMD_SET_CAMERA_MODE:\n\tcase NAV_CMD_SET_CAMERA_ZOOM:\n\tcase NAV_CMD_SET_CAMERA_FOCUS:\n\tcase NAV_CMD_DO_CHANGE_SPEED:\n\tcase NAV_CMD_DO_SET_HOME:\n\t\treturn true;\n\n\t// Indefinite Waypoints\n\tcase NAV_CMD_LAND: /* fall through */\n\n\tcase NAV_CMD_IDLE: /* fall through */\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\treturn false;\n\n\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\n\t\tif (int(_mission_item.params[0]) == 3) {\n\t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\t\t} else if (int(_mission_item.params[0]) == 4) {\n\t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t} else {\n\t\t\t// invalid vtol transition request\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DELAY:\n\t\t// Set reached flags directly such that only the delay time is considered\n\t\t_waypoint_position_reached = true;\n\t\t_waypoint_yaw_reached = true;\n\n\t\t// Set timestamp when entering only (it's reset to 0 for every waypoint)\n\t\tif (_time_wp_reached == 0) {\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DO_WINCH: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) *\n\t\t\t\t\t1E-6f; // TODO: Add proper microseconds_to_seconds function\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_DO_GRIPPER: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) * 1E-6f;\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\t/* do nothing, this is a 3D waypoint */\n\t\tbreak;\n\t}\n\n\t// Update the 'waypoint position reached' status\n\tif (!_navigator->get_land_detected()->landed && !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tconst float mission_item_altitude_amsl = get_absolute_altitude_for_item(_mission_item);\n\n\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n\t\t\t\t_navigator->get_loiter_radius();\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t/* We want to avoid the edge case where the acceptance radius is bigger or equal than\n\t\t\t * the altitude of the takeoff waypoint above home. Otherwise, we do not really follow\n\t\t\t * take-off procedures like leaving the landing gear down. */\n\n\t\t\tfloat takeoff_alt = _mission_item.altitude_is_relative ?\n\t\t\t\t\t    _mission_item.altitude :\n\t\t\t\t\t    (_mission_item.altitude - _navigator->get_home_position()->alt);\n\n\t\t\tfloat altitude_acceptance_radius = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* It should be safe to just use half of the takoeff_alt as an acceptance radius. */\n\t\t\tif (takeoff_alt > 0 && takeoff_alt < altitude_acceptance_radius) {\n\t\t\t\taltitude_acceptance_radius = takeoff_alt / 2.0f;\n\t\t\t}\n\n\t\t\t/* require only altitude for takeoff for multicopter */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t/* fixed-wing takeoff is reached once the vehicle has exceeded the takeoff altitude */\n\t\t\tif (_navigator->get_global_position()->alt > mission_item_altitude_amsl) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n\t\t\t// Accept takeoff waypoint to be reached if the distance in 2D plane is within acceptance radius\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t// For takeoff mission items use the parameter for the takeoff acceptance radius\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t   (_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t    _mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT)) {\n\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius + navigation switch distance. Time inside and turn count is handled elsewhere.\n\t\t\t */\n\n\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter.\n\t\t\t// First check if the altitude setpoint is the mission setpoint (that means that the loiter is not yet reached)\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\tif (fabsf(curr_sp->alt - mission_item_altitude_amsl) >= FLT_EPSILON) {\n\t\t\t\tdist_xy = -1.0f;\n\t\t\t\tdist_z = -1.0f;\n\n\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n\t\t\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t\tcurr_sp->alt = mission_item_altitude_amsl;\n\t\t\t\t\tcurr_sp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t}\n\n\t\t\t} else if (dist >= 0.f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t// loitering, check if new altitude is reached, while still also having check on position\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\t// if the setpoint is valid we are checking if we reached the gate\n\t\t\t// in the case of an invalid setpoint we are defaulting to\n\t\t\t// assuming that we have already reached the gate to not block\n\t\t\t// the further execution of the mission.\n\t\t\tif (curr_sp->valid) {\n\n\t\t\t\t// location of gate (mission item)\n\t\t\t\tMapProjection ref_pos{_mission_item.lat, _mission_item.lon};\n\n\t\t\t\t// current setpoint\n\t\t\t\tmatrix::Vector2f gate_to_curr_sp = ref_pos.project(curr_sp->lat, curr_sp->lon);\n\n\t\t\t\t// system position\n\t\t\t\tmatrix::Vector2f vehicle_pos = ref_pos.project(_navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t       _navigator->get_global_position()->lon);\n\t\t\t\tconst float dot_product = vehicle_pos.dot(gate_to_curr_sp.normalized());\n\n\t\t\t\t// if the dot product (projected vector) is positive, then\n\t\t\t\t// the current position is between the gate position and the\n\t\t\t\t// next waypoint\n\t\t\t\tif (dot_product >= 0) {\n\t\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t\t\t_time_wp_reached = now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfloat acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t// We use the acceptance radius of the mission item if it has been set (not NAN)\n\t\t\t// but only for multicopter.\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t    && PX4_ISFINITE(_mission_item.acceptance_radius) && _mission_item.acceptance_radius > FLT_EPSILON) {\n\t\t\t\tacceptance_radius = _mission_item.acceptance_radius;\n\t\t\t}\n\n\t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND || _mission_item.vtol_back_transition) {\n\n\t\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t\tfloat velocity = sqrtf(_navigator->get_local_position()->vx * _navigator->get_local_position()->vx +\n\t\t\t\t\t\t\t       _navigator->get_local_position()->vy * _navigator->get_local_position()->vy);\n\n\t\t\t\t\tconst float back_trans_dec = _navigator->get_vtol_back_trans_deceleration();\n\n\t\t\t\t\tif (back_trans_dec > FLT_EPSILON && velocity > FLT_EPSILON) {\n\t\t\t\t\t\tacceptance_radius = (velocity / back_trans_dec / 2) * velocity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// do not care for altitude when approaching the backtransition point. Not accepting the waypoint causes\n\t\t\t\t\t// the vehicle to perform a sharp turn after passing the land waypoint and this causes worse unexected behavior\n\t\t\t\t\talt_acc_rad_m = INFINITY;\n\n\t\t\t\t} else { //rotary wing\n\t\t\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\t\t\t\treturn _navigator->get_land_detected()->landed;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbool passed_curr_wp = false;\n\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tconst float dist_prev_to_curr = get_distance_to_next_waypoint(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.lon);\n\n\t\t\t\tif (dist_prev_to_curr > 1.0e-6f && _navigator->get_position_setpoint_triplet()->previous.valid) {\n\t\t\t\t\t// Fixed-wing guidance interprets this condition as line segment following\n\n\t\t\t\t\t// vector from previous waypoint to current waypoint\n\t\t\t\t\tfloat vector_prev_to_curr_north;\n\t\t\t\t\tfloat vector_prev_to_curr_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, &vector_prev_to_curr_north,\n\t\t\t\t\t\t\t\t\t &vector_prev_to_curr_east);\n\n\t\t\t\t\t// vector from next waypoint to aircraft\n\t\t\t\t\tfloat vector_curr_to_vehicle_north;\n\t\t\t\t\tfloat vector_curr_to_vehicle_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_global_position()->lon, &vector_curr_to_vehicle_north,\n\t\t\t\t\t\t\t\t\t &vector_curr_to_vehicle_east);\n\n\t\t\t\t\t// if dot product of vectors is positive, we are passed the current waypoint (the terminal point on the line segment) and should switch to next mission item\n\t\t\t\t\tpassed_curr_wp = vector_prev_to_curr_north * vector_curr_to_vehicle_north + vector_prev_to_curr_east *\n\t\t\t\t\t\t\t vector_curr_to_vehicle_east > 0.0f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist_xy >= 0.0f && (dist_xy <= acceptance_radius || passed_curr_wp) && dist_z <= alt_acc_rad_m) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\t// consider yaw reached for non-rotary wing vehicles (such as fixed-wing)\n\t\tif (_navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Update the 'waypoint position reached' status (only for rotary wing flight)\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))\n\t\t    && _navigator->get_local_position()->heading_good_for_control) {\n\n\t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()\n\t\t\t    || (_navigator->get_yaw_timeout() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t// Always accept yaw during takeoff\n\t\t\t// TODO: Ideally Navigator would handle a yaw reset and adjust its yaw setpoint, making the\n\t\t\t// following no longer necessary.\n\t\t\t// FlightTaskAuto is currently also ignoring the yaw setpoint during takeoff and thus \"handling\" it.\n\t\t\tif (_mission_item.nav_cmd == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n\t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n\n\t\t\t\t_navigator->set_mission_failure_heading_timeout();\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Handle Loiter/Delay Timeout if the waypoint position and yaw setpoint got reached\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tbool time_inside_reached = false;\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n\t\t\ttime_inside_reached = true;\n\t\t}\n\n\t\t// check if course for exit is reached (only applies for fixed-wing flight)\n\t\tbool exit_course_reached = false;\n\n\t\tif (time_inside_reached) {\n\n\t\t\tstruct position_setpoint_s *curr_sp_new = &_navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float dist_current_next = get_distance_to_next_waypoint(curr_sp_new->lat, curr_sp_new->lon, next_sp.lat,\n\t\t\t\t\t\t\tnext_sp.lon);\n\n\t\t\t/* enforce exit course if in FW, the next wp is valid, the vehicle is currently loitering and either having force_heading set,\n\t\t\t   or if loitering to achieve altitdue at a NAV_CMD_WAYPOINT */\n\t\t\tconst bool enforce_exit_course = _navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t\t && next_sp.valid\n\t\t\t\t\t\t\t && curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t\t\t\t\t\t && (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n\n\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint\n\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.2f * curr_sp_new->loiter_radius;\n\n\t\t\tif (enforce_exit_course && exit_course_is_reachable) {\n\n\t\t\t\tfloat vehicle_position_to_next_waypoint_north;\n\t\t\t\tfloat vehicle_position_to_next_waypoint_east;\n\t\t\t\tget_vector_to_next_waypoint(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon, next_sp.lat,\n\t\t\t\t\t\t\t    next_sp.lon, &vehicle_position_to_next_waypoint_north,  &vehicle_position_to_next_waypoint_east);\n\n\t\t\t\t// this vector defines the exit bearing\n\t\t\t\tconst matrix::Vector2f vector_vehicle_position_to_next_waypoint = {vehicle_position_to_next_waypoint_north, vehicle_position_to_next_waypoint_east};\n\n\t\t\t\tconst matrix::Vector2f vehicle_ground_velocity = {_navigator->get_local_position()->vx, _navigator->get_local_position()->vy};\n\n\t\t\t\texit_course_reached = vector_vehicle_position_to_next_waypoint.dot(vehicle_ground_velocity) >\n\t\t\t\t\t\t      vector_vehicle_position_to_next_waypoint.norm() * vehicle_ground_velocity.norm() * kCosineExitCourseThreshold;\n\n\t\t\t} else {\n\t\t\t\texit_course_reached = true;\n\t\t\t}\n\t\t}\n\n\t\t// set exit flight course to next waypoint\n\t\tif (exit_course_reached) {\n\t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float range = get_distance_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t// exit xtrack location\n\t\t\t// reset lat/lon of loiter waypoint so vehicle follows a tangent\n\t\t\tif (_mission_item.loiter_exit_xtrack && next_sp.valid && PX4_ISFINITE(range) &&\n\t\t\t    (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t     _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT)) {\n\n\t\t\t\tfloat bearing = get_bearing_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t\t// calculate (positive) angle between current bearing vector (orbit center to next waypoint) and vector pointing to tangent exit location\n\t\t\t\tconst float ratio = math::min(fabsf(curr_sp.loiter_radius / range), 1.0f);\n\t\t\t\tfloat inner_angle = acosf(ratio);\n\n\t\t\t\t// Compute \"ideal\" tangent origin\n\t\t\t\tif (curr_sp.loiter_direction_counter_clockwise) {\n\t\t\t\t\tbearing += inner_angle;\n\n\t\t\t\t} else {\n\t\t\t\t\tbearing -= inner_angle;\n\t\t\t\t}\n\n\t\t\t\t// set typ to position, will get set to loiter in the fw position controller once close\n\t\t\t\t// and replace current setpoint lat/lon with tangent coordinate\n\t\t\t\tcurr_sp.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\twaypoint_from_heading_and_distance(curr_sp.lat, curr_sp.lon,\n\t\t\t\t\t\t\t\t   bearing, fabsf(curr_sp.loiter_radius),\n\t\t\t\t\t\t\t\t   &curr_sp.lat, &curr_sp.lon);\n\t\t\t}\n\n\t\t\treturn true; // mission item is reached\n\t\t}\n\t}\n\n\treturn false;\n}"
    }
  },
  "21888": {
    "Mission::update_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "e46add159f304d5e9a16d02b6ffdcbf9c078c666",
      "source": "Mission::update_mission()\n{\n\n\tbool failed = !_navigator->get_mission_result()->valid;\n\n\t_dataman_cache.invalidate();\n\t_load_mission_index = -1;\n\n\t/* Reset vehicle_roi\n\t * Missions that do not explicitly configure ROI would not override\n\t * an existing ROI setting from previous missions */\n\t_navigator->reset_vroi();\n\n\tconst mission_s old_mission = _mission;\n\n\tif (_mission_sub.copy(&_mission)) {\n\n\t\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&_mission),\n\t\t\t\tsizeof(mission_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"Can't update mission state in Dataman\");\n\t\t}\n\n\t\t/* determine current index */\n\t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n\t\t\t_current_mission_index = _mission.current_seq;\n\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_mission_index >= (int)_mission.count) {\n\t\t\t\t_current_mission_index = 0;\n\n\t\t\t} else if (_current_mission_index < 0) {\n\t\t\t\t/* if not initialized, set it to 0 */\n\t\t\t\t_current_mission_index = 0;\n\t\t\t}\n\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\tif (old_mission.mission_update_counter != _mission.mission_update_counter) {\n\t\t\tcheck_mission_valid(true);\n\n\t\t\tfailed = !_navigator->get_mission_result()->valid;\n\n\t\t\tif (!failed) {\n\t\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t\t_navigator->get_mission_result()->failure = false;\n\n\t\t\t\t/* reset sequence info as well */\n\t\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n\t\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\n\t\t\t\t/* reset work item if new mission has been accepted */\n\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t_mission_changed = true;\n\t\t\t}\n\n\t\t\t/* check if the mission waypoints changed while the vehicle is in air\n\t\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n\t\t\tif (((_mission.count != old_mission.count) ||\n\t\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n\t\t\t    !_navigator->get_land_detected()->landed) {\n\t\t\t\t_mission_waypoints_changed = true;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tPX4_ERR(\"mission update failed\");\n\t\tfailed = true;\n\t}\n\n\tif (failed) {\n\t\t// only warn if the check failed on merit\n\t\tif ((int)_mission.count > 0) {\n\t\t\tPX4_WARN(\"mission check failed\");\n\t\t}\n\n\t\t// reset the mission\n\t\t_mission.count = 0;\n\t\t_mission.current_seq = 0;\n\t\t_current_mission_index = 0;\n\t}\n\n\t// we start from the first item so can reset the cache\n\tif (_current_mission_index == 0) {\n\t\tresetItemCache();\n\t}\n\n\t// reset as when we update mission we don't want to proceed at previous index\n\t_inactivation_index = -1;\n\n\t// find and store landing start marker (if available)\n\tfind_mission_land_start();\n\n\tset_current_mission_item();\n}"
    }
  },
  "21852": {
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "3cdfbf5da3db60f2f600e9b941108ba2b7524101",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\tuint16_t geofence_update_counter{0};\n\tuint16_t safe_points_update_counter{0};\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\n\t\t\tif (mission.geofence_update_counter != geofence_update_counter) {\n\t\t\t\tgeofence_update_counter = mission.geofence_update_counter;\n\t\t\t\t_geofence.updateFence();\n\t\t\t}\n\n\t\t\tif (mission.safe_points_update_counter != safe_points_update_counter) {\n\t\t\t\tsafe_points_update_counter = mission.safe_points_update_counter;\n\t\t\t\t_rtl.updateSafePoints();\n\t\t\t}\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = curr->current.loiter_minor_radius;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = NAN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_orientation) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_orientation = curr->current.loiter_orientation;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr->current.loiter_pattern > 0) {\n\t\t\t\t\t\t\trep->current.loiter_pattern = curr->current.loiter_pattern;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_FIGUREEIGHT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n#ifdef CONFIG_FIGURE_OF_EIGHT\n\t\t\t\t// Only valid for fixed wing mode\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param2) && fabsf(cmd.param2) > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_minor_radius = fabsf(cmd.param2);\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = 2.5f * rep->current.loiter_minor_radius;\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.loiter_orientation = cmd.param4;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n\t\t\t\t}\n\n#endif // CONFIG_FIGURE_OF_EIGHT\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n\n\t\t\t\tif (_mission.get_land_start_available()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t\tresult = vehicle_command_ack_s::VEHICLE_CMD_RESULT_CANCELLED;\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, result);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\treset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\n\t\t\t// If we are already in mission landing, do not switch.\n\t\t\tif (_navigation_mode == &_mission && _mission.isLanding()) {\n\t\t\t\tnavigation_mode_new = &_mission;\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t}\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t// If we are in VTOL takeoff, do not switch until it is finished.\n\t\t\tif (_navigation_mode == &_vtol_takeoff && !get_mission_result()->finished) {\n\t\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\n\t\t\t} else\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\t\t\t{\n\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\t_geofence.run();\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    }
  },
  "21806": {
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "a6502c9f2bb7daac4420248f671d0f7fed0fabde",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\t// copy mission to clear any update\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\tposition_setpoint.lon = cmd.param6;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\n\t\t\t\tif (_mission.land_start()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\tset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_NORMAL);\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL: {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tconst bool rtl_activated_now = !_rtl_activated;\n\n\t\t\t\tswitch (_rtl.get_rtl_type()) {\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING:\n\t\t\t\tcase RTL::RTL_TYPE_CLOSEST: {\n\t\t\t\t\t\t// If a mission landing is desired we should only execute mission navigation mode if we currently are in fw mode.\n\t\t\t\t\t\t// In multirotor mode no landing pattern is required so we can just navigate to the land point directly and don't need to run mission.\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t_shouldEngageMissionForLanding = _rtl.getRTLDestinationTypeMission()\n\t\t\t\t\t\t\t\t\t\t\t && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (_shouldEngageMissionForLanding && (on_mission_landing() || _rtl.getRTLState() > RTL::RTL_STATE_CLIMB)) {\n\n\t\t\t\t\t\t\t// already in a mission landing, we just need to inform the user and stay in mission\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL to Mission landing, continue landing\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"rtl_land_at_mission_continue_landing\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL to Mission landing, continue landing\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\t\t// the first time we're here start the mission landig\n\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase RTL::RTL_TYPE_MISSION_LANDING_REVERSED:\n\t\t\t\t\tif (_mission.get_land_start_available() && !get_land_detected()->landed) {\n\t\t\t\t\t\t// the mission contains a landing spot\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD);\n\n\t\t\t\t\t\tif (_navigation_mode != &_mission) {\n\t\t\t\t\t\t\tif (_navigation_mode == nullptr) {\n\t\t\t\t\t\t\t\t// switching from an manual mode, go to landing if not already landing\n\t\t\t\t\t\t\t\tif (!on_mission_landing()) {\n\t\t\t\t\t\t\t\t\tstart_mission_landing();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// switching from an auto mode, continue the mission from the closest item\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, continue mission\\t\");\n\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated\"), events::Log::Info,\n\t\t\t\t\t\t\t\t     \"RTL Mission activated, continue mission\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// fly the mission in reverse if switching from a non-manual mode\n\t\t\t\t\t\t_mission.set_execution_mode(mission_result_s::MISSION_EXECUTION_MODE_REVERSE);\n\n\t\t\t\t\t\tif ((_navigation_mode != nullptr && (_navigation_mode != &_rtl || _mission.get_mission_changed())) &&\n\t\t\t\t\t\t    (! _mission.get_mission_finished()) &&\n\t\t\t\t\t\t    (!get_land_detected()->landed)) {\n\t\t\t\t\t\t\t// determine the closest mission item if switching from a non-mission mode, and we are either not already\n\t\t\t\t\t\t\t// mission mode or the mission waypoints changed.\n\t\t\t\t\t\t\t// The seconds condition is required so that when no mission was uploaded and one is available the closest\n\t\t\t\t\t\t\t// mission item is determined and also that if the user changes the active mission index while rtl is active\n\t\t\t\t\t\t\t// always that waypoint is tracked first.\n\t\t\t\t\t\t\tif ((_navigation_mode != &_mission) && (rtl_activated_now || _mission.get_mission_waypoints_changed())) {\n\t\t\t\t\t\t\t\t_mission.set_closest_item_as_current();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly mission in reverse\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_rev\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly mission in reverse\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL Mission activated, fly to home\\t\");\n\t\t\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_mission_activated_home\"), events::Log::Info,\n\t\t\t\t\t\t\t\t\t     \"RTL Mission activated, fly to home\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtl_activated_now) {\n\t\t\t\t\t\tmavlink_log_info(get_mavlink_log_pub(), \"RTL HOME activated\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"navigator_rtl_home_activated\"), events::Log::Info, \"RTL activated\");\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t_rtl_activated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\t_can_loiter_at_sp = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_RTL) {\n\t\t\t_rtl_activated = false;\n\t\t\t_rtl.resetRtlState();\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    }
  },
  "21798": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "7e0f0516a5b53e3a0fb64fcc5ba663b3d28ca6dd",
      "source": "Loiter::on_activation()\n{\n\tif (_navigator->get_reposition_triplet()->current.valid) {\n\t\treposition();\n\n\t} else {\n\t\tset_loiter_position();\n\t}\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Loiter::set_loiter_position": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "7e0f0516a5b53e3a0fb64fcc5ba663b3d28ca6dd",
      "source": "Loiter::set_loiter_position()\n{\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n\t    _navigator->get_land_detected()->landed) {\n\n\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n\t\t// setpoint as invalid and idle (both, just to be sure).\n\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t_loiter_pos_set = false;\n\t\treturn;\n\n\t} else if (_loiter_pos_set) {\n\t\t// Already set, nothing to do.\n\t\treturn;\n\t}\n\n\t_loiter_pos_set = true;\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t} else {\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// convert mission item to current setpoint\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "21904": {
    "FeasibilityChecker::doCommonChecks": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "444e5d2d4abbb0adaabf1ad3cddaa2f9d2f9ee2b",
      "source": "void FeasibilityChecker::doCommonChecks(mission_item_s &mission_item, const int current_index)\n{\n\n\tif (!_distance_between_waypoints_failed) {\n\t\t_distance_between_waypoints_failed = !checkDistancesBetweenWaypoints(mission_item);\n\t}\n\n\tif (!_distance_first_waypoint_failed) {\n\t\t_distance_first_waypoint_failed = !checkHorizontalDistanceToFirstWaypoint(mission_item);\n\t}\n\n\tif (!_below_home_alt_failed) {\n\t\t_below_home_alt_failed = !checkIfBelowHomeAltitude(mission_item, current_index);\n\t}\n\n\tif (!_takeoff_failed) {\n\t\t_takeoff_failed = !checkTakeoff(mission_item);\n\t}\n\n\tif (!_items_fit_to_vehicle_type_failed) {\n\t\t_items_fit_to_vehicle_type_failed = !checkItemsFitToVehicleType(mission_item);\n\t}\n}"
    },
    "FeasibilityChecker::reset": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "444e5d2d4abbb0adaabf1ad3cddaa2f9d2f9ee2b",
      "source": "void FeasibilityChecker::reset()\n{\n\n\t_is_landed = false;\n\t_home_alt_msl = NAN;\n\t_home_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n\t_current_position_lat_lon = matrix::Vector2d((double)NAN, (double)NAN);\n\t_vehicle_type = VehicleType::RotaryWing;\n\n\t_mission_validity_failed = false;\n\t_takeoff_failed = false;\n\t_land_pattern_validity_failed = false;\n\t_distance_first_waypoint_failed = false;\n\t_distance_between_waypoints_failed = false;\n\t_below_home_alt_failed = false;\n\t_fixed_wing_land_approach_failed = false;\n\t_takeoff_land_available_failed = false;\n\n\t_found_item_with_position = false;\n\t_has_vtol_takeoff = false;\n\t_has_takeoff = false;\n\n\t_landing_valid = false;\n\t_do_land_start_index = -1;\n\t_landing_approach_index = -1;\n\t_mission_item_previous = {};\n\n\t_first_waypoint_found = false;\n\n\t_last_lat = (double)NAN;\n\t_last_lon = (double)NAN;\n\t_last_cmd = -1;\n}"
    },
    "FeasibilityChecker::checkIfBelowHomeAltitude": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "444e5d2d4abbb0adaabf1ad3cddaa2f9d2f9ee2b",
      "source": "bool FeasibilityChecker::checkIfBelowHomeAltitude(const mission_item_s &mission_item, const int current_index)\n{\n\t/* calculate the global waypoint altitude */\n\tfloat wp_alt = (mission_item.altitude_is_relative) ? mission_item.altitude + _home_alt_msl : mission_item.altitude;\n\n\tif (PX4_ISFINITE(_home_alt_msl) && _home_alt_msl > wp_alt && MissionBlock::item_contains_position(mission_item)) {\n\n\t\tmavlink_log_critical(_mavlink_log_pub, \"Warning: Waypoint %d below home\\t\", current_index + 1);\n\t\tevents::send<int16_t>(events::ID(\"navigator_mis_wp_below_home\"), {events::Log::Warning, events::LogInternal::Info},\n\t\t\t\t      \"Waypoint {1} below home\", current_index + 1);\n\t}\n\n\treturn true;\n}"
    },
    "MissionBlock::item_contains_position": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "444e5d2d4abbb0adaabf1ad3cddaa2f9d2f9ee2b",
      "source": "&& MissionBlock::item_contains_position(mission_item)) {\n\n\n\n\t\tmavlink_log_critical(_mavlink_log_pub, \"Mission rejected: No home pos, WP %d uses rel alt\\t\", current_index + 1);\n\t\tevents::send<int16_t>(events::ID(\"navigator_mis_no_home_rel_alt\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t      \"Mission rejected: No home position, waypoint {1} uses relative altitude\",\n\t\t\t\t      current_index + 1);\n\t\treturn false;\n\n\t}"
    },
    "FeasibilityChecker::checkDistancesBetweenWaypoints": {
      "file": "src/modules/navigator/MissionFeasibility/FeasibilityChecker.cpp",
      "commit": "444e5d2d4abbb0adaabf1ad3cddaa2f9d2f9ee2b",
      "source": "bool FeasibilityChecker::checkDistancesBetweenWaypoints(const mission_item_s &mission_item)\n{\n\t/* check only items with valid lat/lon */\n\tif (!MissionBlock::item_contains_position(mission_item)) {\n\t\treturn true;\n\t}\n\n\t/* Compare it to last waypoint if already available. */\n\tif (PX4_ISFINITE(_last_lat) && PX4_ISFINITE(_last_lon)) {\n\t\t/* check distance from current position to item */\n\t\tconst float dist_between_waypoints = get_distance_to_next_waypoint(\n\t\t\t\tmission_item.lat, mission_item.lon,\n\t\t\t\t_last_lat, _last_lon);\n\n\n\t\tif (dist_between_waypoints < 0.05f &&\n\t\t    (mission_item.nav_cmd == NAV_CMD_CONDITION_GATE || _last_cmd == NAV_CMD_CONDITION_GATE)) {\n\n\t\t\t/* Waypoints and gate are at the exact same position, which indicates an\n\t\t\t * invalid mission and makes calculating the direction from one waypoint\n\t\t\t * to another impossible. */\n\t\t\tmavlink_log_critical(_mavlink_log_pub,\n\t\t\t\t\t     \"Distance between waypoint and gate too close: %d meters\\t\",\n\t\t\t\t\t     (int)dist_between_waypoints);\n\t\t\tevents::send<float, float>(events::ID(\"navigator_mis_wp_gate_too_close\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t   \"Distance between waypoint and gate too close: {1:.3m} (minimum: {2:.3m})\", dist_between_waypoints, 0.05f);\n\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t_last_lat = mission_item.lat;\n\t_last_lon = mission_item.lon;\n\t_last_cmd = mission_item.nav_cmd;\n\n\t/* We ran through all waypoints and have not found any distances between waypoints that are too far. */\n\treturn true;\n}"
    }
  },
  "22531": {
    "Geofence::_updateFence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "821d48a21e1383f320c20c10ddb6c4cb614da2fc",
      "source": "void Geofence::_updateFence()\n{\n\tmission_fence_point_s mission_fence_point;\n\tbool is_circle_area = false;\n\n\t// iterate over all polygons and store their starting vertices\n\t_num_polygons = 0;\n\tint current_seq = 1;\n\n\twhile (current_seq <= _dataman_cache.size()) {\n\n\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, current_seq,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t       sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"loadWait failed, seq: %i\", current_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mission_fence_point.nav_cmd) {\n\t\tcase NAV_CMD_FENCE_RETURN_POINT:\n\t\t\t// TODO: do we need to store this?\n\t\t\t++current_seq;\n\t\t\tbreak;\n\n\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n\t\t\tis_circle_area = true;\n\n\t\t/* FALLTHROUGH */\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n\t\t\tif (!is_circle_area && mission_fence_point.vertex_count == 0) {\n\t\t\t\t++current_seq; // avoid endless loop\n\t\t\t\tPX4_ERR(\"Polygon with 0 vertices. Skipping\");\n\n\t\t\t} else {\n\t\t\t\tif (_polygons) {\n\t\t\t\t\t// resize: this is somewhat inefficient, but we do not expect there to be many polygons\n\t\t\t\t\tPolygonInfo *new_polygons = new PolygonInfo[_num_polygons + 1];\n\n\t\t\t\t\tif (new_polygons) {\n\t\t\t\t\t\tmemcpy(new_polygons, _polygons, sizeof(PolygonInfo) * _num_polygons);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete[](_polygons);\n\t\t\t\t\t_polygons = new_polygons;\n\n\t\t\t\t} else {\n\t\t\t\t\t_polygons = new PolygonInfo[1];\n\t\t\t\t}\n\n\t\t\t\tif (!_polygons) {\n\t\t\t\t\t_num_polygons = 0;\n\t\t\t\t\tPX4_ERR(\"alloc failed\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPolygonInfo &polygon = _polygons[_num_polygons];\n\t\t\t\tpolygon.dataman_index = current_seq;\n\t\t\t\tpolygon.fence_type = mission_fence_point.nav_cmd;\n\n\t\t\t\tif (is_circle_area) {\n\t\t\t\t\tpolygon.circle_radius = mission_fence_point.circle_radius;\n\t\t\t\t\tcurrent_seq += 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tpolygon.vertex_count = mission_fence_point.vertex_count;\n\t\t\t\t\tcurrent_seq += mission_fence_point.vertex_count;\n\t\t\t\t}\n\n\t\t\t\t// check if requiremetns for Home location are met\n\t\t\t\tconst bool home_check_okay = checkHomeRequirementsForGeofence(polygon);\n\n\t\t\t\t// check if current position is inside the fence and vehicle is armed\n\t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n\n\t\t\t\t//check if current mission point inside the geofence\n\t\t\t\tconst bool current_mission_check_okay = checkMissionRequirementsForGeofence(polygon);\n\n\t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n\t\t\t\tif (home_check_okay && current_position_check_okay  && current_mission_check_okay) {\n\t\t\t\t\t++_num_polygons;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPX4_ERR(\"unhandled Fence command: %i\", (int)mission_fence_point.nav_cmd);\n\t\t\t++current_seq;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "22519": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "a536e3dfe2fba7795f543c2c82e1da10880d904c",
      "source": "MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, position_setpoint_s *sp)\n{\n\t// Don't change the setpoint for non-position items\n\tif (!item_contains_position(item)) {\n\t\treturn false;\n\t}\n\n\tsp->lat = item.lat;\n\tsp->lon = item.lon;\n\tsp->alt = get_absolute_altitude_for_item(item);\n\tsp->yaw = item.yaw;\n\tsp->yaw_valid = PX4_ISFINITE(item.yaw);\n\tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n\t\t\t    _navigator->get_loiter_radius();\n\tsp->loiter_direction_counter_clockwise = item.loiter_radius < 0;\n\n\tif (item.acceptance_radius > 0.001f && PX4_ISFINITE(item.acceptance_radius)) {\n\t\t// if the mission item has a specified acceptance radius, overwrite the default one from parameters\n\t\tsp->acceptance_radius = item.acceptance_radius;\n\n\t} else {\n\t\tsp->acceptance_radius = _navigator->get_default_acceptance_radius();\n\t}\n\n\tsp->cruising_speed = _navigator->get_cruising_speed();\n\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n\n\t// for fixed wing we don't use cruising_throttle directly anymore, instead we command airspeed setpoints via cruising_speed\n\t// we still use cruising throttle here to determine if gliding is enabled\n\tsp->gliding_enabled = (_navigator->get_cruising_throttle() < FLT_EPSILON);\n\n\tswitch (item.nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\n\t\t// if already flying (armed and !landed) treat TAKEOFF like regular POSITION\n\t\tif ((_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED)\n\t\t    && !_navigator->get_land_detected()->landed && !_navigator->get_land_detected()->maybe_landed) {\n\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\t} else {\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\tcase NAV_CMD_VTOL_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TO_ALT:\n\t\tsp->alt = _navigator->get_global_position()->alt;\n\n\t// FALLTHROUGH\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n\n\tsp->valid = true;\n\tsp->timestamp = hrt_absolute_time();\n\n\treturn sp->valid;\n}"
    }
  },
  "22518": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "ebae9ae3d7fc96607affb8a4a522cf7b9ed1e76d",
      "source": "MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, position_setpoint_s *sp)\n{\n\t// Don't change the setpoint for non-position items\n\tif (!item_contains_position(item)) {\n\t\treturn false;\n\t}\n\n\tsp->lat = item.lat;\n\tsp->lon = item.lon;\n\tsp->alt = get_absolute_altitude_for_item(item);\n\tsp->yaw = item.yaw;\n\tsp->yaw_valid = PX4_ISFINITE(item.yaw);\n\tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n\t\t\t    _navigator->get_loiter_radius();\n\tsp->loiter_direction_counter_clockwise = item.loiter_radius < 0;\n\n\tif (item.acceptance_radius > 0.001f && PX4_ISFINITE(item.acceptance_radius)) {\n\t\t// if the mission item has a specified acceptance radius, overwrite the default one from parameters\n\t\tsp->acceptance_radius = item.acceptance_radius;\n\n\t} else {\n\t\tsp->acceptance_radius = _navigator->get_default_acceptance_radius();\n\t}\n\n\tsp->cruising_speed = _navigator->get_cruising_speed();\n\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n\n\t// for fixed wing we don't use cruising_throttle directly anymore, instead we command airspeed setpoints via cruising_speed\n\t// we still use cruising throttle here to determine if gliding is enabled\n\tsp->gliding_enabled = (_navigator->get_cruising_throttle() < FLT_EPSILON);\n\n\tswitch (item.nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\n\t\t// if already flying (armed and !landed) treat TAKEOFF like regular POSITION\n\t\tif ((_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED)\n\t\t    && !_navigator->get_land_detected()->landed && !_navigator->get_land_detected()->maybe_landed) {\n\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\t} else {\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\tcase NAV_CMD_VTOL_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TO_ALT:\n\t\tsp->alt = _navigator->get_global_position()->alt;\n\n\t// FALLTHROUGH\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n\n\tsp->valid = true;\n\tsp->timestamp = hrt_absolute_time();\n\n\treturn sp->valid;\n}"
    }
  },
  "21839": {
    "MissionBase::resetMission": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "void MissionBase::resetMission()\n{\n\t/* we do not need to reset mission if is already.*/\n\tif (_mission.count == 0u && isMissionValid(_mission)) {\n\t\treturn;\n\t}\n\n\t/* Set a new mission*/\n\tmission_s new_mission{_mission};\n\tnew_mission.timestamp = hrt_absolute_time();\n\tnew_mission.current_seq = 0;\n\tnew_mission.land_start_index = -1;\n\tnew_mission.land_index = -1;\n\tnew_mission.count = 0u;\n\tnew_mission.mission_id = 0u;\n\tnew_mission.dataman_id = _mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ? DM_KEY_WAYPOINTS_OFFBOARD_1 :\n\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_0;\n\n\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&new_mission),\n\t\t\tsizeof(mission_s));\n\n\tif (success) {\n\t\t_mission = new_mission;\n\t\t_mission_pub.publish(_mission);\n\n\t} else {\n\t\tPX4_ERR(\"Mission Initialization failed.\");\n\t}\n}"
    },
    "Geofence::loadFromFile": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "Geofence::loadFromFile(const char *filename)\n{\n\tFILE *fp;\n\tchar line[120];\n\tint pointCounter = 0;\n\tbool gotVertical = false;\n\tconst char commentChar = '#';\n\tint ret_val = PX4_ERROR;\n\n\t/* Make sure no data is left in the datamanager */\n\tclearDm();\n\n\t/* open the mixer definition file */\n\tfp = fopen(GEOFENCE_FILENAME, \"r\");\n\n\tif (fp == nullptr) {\n\t\treturn PX4_ERROR;\n\t}\n\n\t/* create geofence points from valid lines and store in DM */\n\tfor (;;) {\n\t\t/* get a line, bail on error/EOF */\n\t\tif (fgets(line, sizeof(line), fp) == nullptr) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Trim leading whitespace */\n\t\tsize_t textStart = 0;\n\n\t\twhile ((textStart < sizeof(line) / sizeof(char)) && isspace(line[textStart])) { textStart++; }\n\n\t\t/* if the line starts with #, skip */\n\t\tif (line[textStart] == commentChar) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if there is only a linefeed, skip it */\n\t\tif (line[0] == '\\n') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (gotVertical) {\n\t\t\t/* Parse the line as a geofence point */\n\t\t\tmission_fence_point_s vertex{};\n\t\t\tvertex.frame = NAV_FRAME_GLOBAL;\n\t\t\tvertex.nav_cmd = NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION;\n\t\t\tvertex.vertex_count = 0; // this will be filled in a second pass\n\t\t\tvertex.alt = 0; // alt is not used\n\n\t\t\t/* if the line starts with DMS, this means that the coordinate is given as degree minute second instead of decimal degrees */\n\t\t\tif (line[textStart] == 'D' && line[textStart + 1] == 'M' && line[textStart + 2] == 'S') {\n\t\t\t\t/* Handle degree minute second format */\n\t\t\t\tdouble lat_d, lat_m, lat_s, lon_d, lon_m, lon_s;\n\n\t\t\t\tif (sscanf(line, \"DMS %lf %lf %lf %lf %lf %lf\", &lat_d, &lat_m, &lat_s, &lon_d, &lon_m, &lon_s) != 6) {\n\t\t\t\t\tPX4_ERR(\"Scanf to parse DMS geofence vertex failed.\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n//\t\t\t\tPX4_INFO(\"Geofence DMS: %.5lf %.5lf %.5lf ; %.5lf %.5lf %.5lf\", lat_d, lat_m, lat_s, lon_d, lon_m, lon_s);\n\n\t\t\t\tvertex.lat = lat_d + lat_m / 60.0 + lat_s / 3600.0;\n\t\t\t\tvertex.lon = lon_d + lon_m / 60.0 + lon_s / 3600.0;\n\n\t\t\t} else {\n\t\t\t\t/* Handle decimal degree format */\n\t\t\t\tif (sscanf(line, \"%lf %lf\", &vertex.lat, &vertex.lon) != 2) {\n\t\t\t\t\tPX4_ERR(\"Scanf to parse geofence vertex failed.\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, pointCounter + 1, reinterpret_cast<uint8_t *>(&vertex),\n\t\t\t\t\tsizeof(vertex));\n\n\t\t\tif (!success) {\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tPX4_INFO(\"Geofence: point: %d, lat %.5lf: lon: %.5lf\", pointCounter, vertex.lat, vertex.lon);\n\n\t\t\tpointCounter++;\n\n\t\t} else {\n\t\t\t/* Parse the line as the vertical limits */\n\t\t\tif (sscanf(line, \"%f %f\", &_altitude_min, &_altitude_max) != 2) {\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tPX4_INFO(\"Geofence: alt min: %.4f, alt_max: %.4f\", (double)_altitude_min, (double)_altitude_max);\n\t\t\tgotVertical = true;\n\t\t}\n\t}\n\n\n\t/* Check if import was successful */\n\tif (gotVertical && pointCounter > 2) {\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Geofence imported\\t\");\n\t\tevents::send(events::ID(\"navigator_geofence_imported\"), events::Log::Info, \"Geofence imported\");\n\t\tret_val = PX4_ERROR;\n\t\tuint32_t crc32{0U};\n\n\t\t/* do a second pass, now that we know the number of vertices */\n\t\tfor (int seq = 1; seq <= pointCounter; ++seq) {\n\t\t\tmission_fence_point_s mission_fence_point;\n\n\t\t\tbool success = _dataman_client.readSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t\t\tsizeof(mission_fence_point_s));\n\n\t\t\tif (success) {\n\t\t\t\tmission_fence_point.vertex_count = pointCounter;\n\t\t\t\tcrc32 = crc32_for_fence_point(mission_fence_point, crc32);\n\t\t\t\t_dataman_client.writeSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t\t  sizeof(mission_fence_point_s));\n\t\t\t}\n\t\t}\n\n\t\tmission_stats_entry_s stats;\n\t\tstats.num_items = pointCounter;\n\t\tstats.opaque_id = crc32;\n\n\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&stats),\n\t\t\t\tsizeof(mission_stats_entry_s));\n\n\t\tif (success) {\n\t\t\tret_val = PX4_OK;\n\t\t}\n\n\t} else {\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence: import error\\t\");\n\t\tevents::send(events::ID(\"navigator_geofence_import_failed\"), events::Log::Error, \"Geofence: import error\");\n\t}\n\n\tupdateFence();\n\nerror:\n\tfclose(fp);\n\treturn ret_val;\n}"
    },
    "Geofence::run": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "void Geofence::run()\n{\n\tbool success;\n\n\tswitch (_dataman_state) {\n\n\tcase DatamanState::UpdateRequestWait:\n\n\t\tif (_initiate_fence_updated) {\n\t\t\t_initiate_fence_updated = false;\n\t\t\t_dataman_state\t= DatamanState::Read;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Read:\n\n\t\t_dataman_state = DatamanState::ReadWait;\n\t\tsuccess = _dataman_client.readAsync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n\t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\t_error_state = DatamanState::Read;\n\t\t\t_dataman_state = DatamanState::Error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::ReadWait:\n\n\t\t_dataman_client.update();\n\n\t\tif (_dataman_client.lastOperationCompleted(success)) {\n\n\t\t\tif (!success) {\n\t\t\t\t_error_state = DatamanState::ReadWait;\n\t\t\t\t_dataman_state = DatamanState::Error;\n\n\t\t\t} else if (_opaque_id != _stats.opaque_id) {\n\n\t\t\t\t_opaque_id = _stats.opaque_id;\n\t\t\t\t_fence_updated = false;\n\n\t\t\t\t_dataman_cache.invalidate();\n\n\t\t\t\tif (_dataman_cache.size() != _stats.num_items) {\n\t\t\t\t\t_dataman_cache.resize(_stats.num_items);\n\t\t\t\t}\n\n\t\t\t\tfor (int index = 1; index <= _dataman_cache.size(); ++index) {\n\t\t\t\t\t_dataman_cache.load(DM_KEY_FENCE_POINTS, index);\n\t\t\t\t}\n\n\t\t\t\t_dataman_state = DatamanState::Load;\n\n\t\t\t} else {\n\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Load:\n\n\t\t_dataman_cache.update();\n\n\t\tif (!_dataman_cache.isLoading()) {\n\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t_updateFence();\n\t\t\t_fence_updated = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Error:\n\t\tPX4_ERR(\"Geofence update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n}"
    },
    "MissionBase::updateMavlinkMission": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "void MissionBase::updateMavlinkMission()\n{\n\tif (_mission_sub.updated()) {\n\t\tmission_s new_mission;\n\t\t_mission_sub.update(&new_mission);\n\n\t\tif (isMissionValid(new_mission)) {\n\t\t\t/* Relevant mission items updated externally*/\n\t\t\tif (checkMissionDataChanged(new_mission)) {\n\t\t\t\tbool mission_items_changed = (new_mission.mission_id != _mission.mission_id);\n\n\t\t\t\tif (new_mission.current_seq < 0) {\n\t\t\t\t\tnew_mission.current_seq = math::max(math::min(_mission.current_seq, static_cast<int32_t>(new_mission.count) - 1),\n\t\t\t\t\t\t\t\t\t    INT32_C(0));\n\t\t\t\t}\n\n\t\t\t\t_mission = new_mission;\n\n\t\t\t\tonMissionUpdate(mission_items_changed);\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "Mission::save_mission_state": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "Mission::save_mission_state()\n{\n\tif (_vehicle_status_sub.get().arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t// Save only while disarmed, as this is a blocking operation\n\t\t_need_mission_save = true;\n\t\treturn;\n\t}\n\n\t_need_mission_save = false;\n\tmission_s mission_state = {};\n\n\t/* read current state */\n\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\tsizeof(mission_s));\n\n\tif (success) {\n\t\t/* data read successfully, check dataman ID and items count */\n\t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count\n\t\t    && mission_state.mission_id == _mission.mission_id) {\n\t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n\t\t\tif (mission_state.current_seq != _mission.current_seq) {\n\t\t\t\tmission_state = _mission;\n\n\t\t\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\t\t\tif (!success) {\n\n\t\t\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* invalid data, this must not happen and indicates error in mission publisher */\n\t\tmission_state = _mission;\n\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Invalid mission state.\\t\");\n\t\t/* EVENT\n\t\t * @description No mission or storage failure\n\t\t */\n\t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Error, \"Invalid mission state\");\n\n\t\t/* write modified state only if changed */\n\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\tif (!success) {\n\n\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t}\n\t}\n}"
    },
    "MissionBase::checkMissionRestart": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "MissionBase::checkMissionRestart()\n{\n\tif (_system_disarmed_while_inactive && _mission_has_been_activated && (_mission.count > 0U)\n\t    && ((_mission.current_seq + 1) == _mission.count)) {\n\t\tsetMissionIndex(0);\n\t\t_inactivation_index = -1; // reset\n\t\t_is_current_planned_mission_item_valid = isMissionValid(_mission);\n\t\tresetMissionJumpCounter();\n\t\t_navigator->reset_cruising_speed();\n\t\t_navigator->reset_vroi();\n\t\tset_mission_result();\n\t}\n}"
    },
    "MissionBase::checkClimbRequired": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "void MissionBase::checkClimbRequired(int32_t mission_item_index)\n{\n\tint32_t next_mission_item_index;\n\tsize_t num_found_items{0U};\n\tgetNextPositionItems(mission_item_index, &next_mission_item_index, num_found_items, 1U);\n\n\tif (num_found_items > 0U) {\n\n\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n\t\tmission_item_s mission;\n\t\t_mission_init_climb_altitude_amsl = NAN; // default to NAN, overwrite below if applicable\n\n\t\tconst bool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index, reinterpret_cast<uint8_t *>(&mission),\n\t\t\t\t     sizeof(mission), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tconst bool is_fw_and_takeoff = mission.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t\t\t       && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t// for FW when on a Takeoff item do not require climb before mission, as we need to keep course to takeoff item straight\n\t\tif (success && !is_fw_and_takeoff) {\n\t\t\tconst float altitude_amsl_next_position_item = MissionBlock::get_absolute_altitude_for_item(mission);\n\t\t\tconst float error_below_setpoint = altitude_amsl_next_position_item -\n\t\t\t\t\t\t\t   _navigator->get_global_position()->alt;\n\n\t\t\tif (error_below_setpoint > _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_mission_init_climb_altitude_amsl = altitude_amsl_next_position_item;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "RTL::updateDatamanCache": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "void RTL::updateDatamanCache()\n{\n\tbool success;\n\n\tswitch (_dataman_state) {\n\n\tcase DatamanState::UpdateRequestWait:\n\n\t\tif (_initiate_safe_points_updated) {\n\t\t\t_initiate_safe_points_updated = false;\n\t\t\t_dataman_state\t= DatamanState::Read;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Read:\n\n\t\t_dataman_state\t= DatamanState::ReadWait;\n\t\tsuccess = _dataman_client_safepoint.readAsync(DM_KEY_SAFE_POINTS, 0, reinterpret_cast<uint8_t *>(&_stats),\n\t\t\t\tsizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\t_error_state = DatamanState::Read;\n\t\t\t_dataman_state = DatamanState::Error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::ReadWait:\n\n\t\t_dataman_client_safepoint.update();\n\n\t\tif (_dataman_client_safepoint.lastOperationCompleted(success)) {\n\n\t\t\tif (!success) {\n\t\t\t\t_error_state = DatamanState::ReadWait;\n\t\t\t\t_dataman_state = DatamanState::Error;\n\n\t\t\t} else if (_opaque_id != _stats.opaque_id) {\n\n\t\t\t\t_opaque_id = _stats.opaque_id;\n\t\t\t\t_safe_points_updated = false;\n\n\t\t\t\t_dataman_cache_safepoint.invalidate();\n\n\t\t\t\tif (_dataman_cache_safepoint.size() != _stats.num_items) {\n\t\t\t\t\t_dataman_cache_safepoint.resize(_stats.num_items);\n\t\t\t\t}\n\n\t\t\t\tfor (int index = 1; index <= _dataman_cache_safepoint.size(); ++index) {\n\t\t\t\t\t_dataman_cache_safepoint.load(DM_KEY_SAFE_POINTS, index);\n\t\t\t\t}\n\n\t\t\t\t_dataman_state = DatamanState::Load;\n\n\t\t\t} else {\n\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Load:\n\n\t\t_dataman_cache_safepoint.update();\n\n\t\tif (!_dataman_cache_safepoint.isLoading()) {\n\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t_safe_points_updated = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Error:\n\t\tPX4_ERR(\"Safe points update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\tif (_mission_id != _mission_sub.get().mission_id) {\n\t\t_mission_id = _mission_sub.get().mission_id;\n\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().dataman_id);\n\t\t_dataman_cache_landItem.invalidate();\n\n\t\tif (_mission_sub.get().land_index > 0) {\n\t\t\t_dataman_cache_landItem.load(dm_item, _mission_sub.get().land_index);\n\t\t}\n\t}\n\n\t_dataman_cache_landItem.update();\n}"
    },
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "void Navigator::run()\n{\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\tuint32_t geofence_id{0};\n\tuint32_t safe_points_id{0};\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\n\t\t\tif (mission.geofence_id != geofence_id) {\n\t\t\t\tgeofence_id = mission.geofence_id;\n\t\t\t\t_geofence.updateFence();\n\t\t\t}\n\n\t\t\tif (mission.safe_points_id != safe_points_id) {\n\t\t\t\tsafe_points_id = mission.safe_points_id;\n\t\t\t\t_rtl.updateSafePoints();\n\t\t\t}\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = curr->current.loiter_minor_radius;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = NAN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_orientation) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_orientation = curr->current.loiter_orientation;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr->current.loiter_pattern > 0) {\n\t\t\t\t\t\t\trep->current.loiter_pattern = curr->current.loiter_pattern;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_FIGUREEIGHT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n#ifdef CONFIG_FIGURE_OF_EIGHT\n\t\t\t\t// Only valid for fixed wing mode\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param2) && fabsf(cmd.param2) > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_minor_radius = fabsf(cmd.param2);\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = 2.5f * rep->current.loiter_minor_radius;\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.loiter_orientation = cmd.param4;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n\t\t\t\t}\n\n#endif // CONFIG_FIGURE_OF_EIGHT\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n\n\t\t\t\tif (_mission.get_land_start_available()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t\tresult = vehicle_command_ack_s::VEHICLE_CMD_RESULT_CANCELLED;\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, result);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\treset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check();\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\n\t\t\t// If we are already in mission landing, do not switch.\n\t\t\tif (_navigation_mode == &_mission && _mission.isLanding()) {\n\t\t\t\tnavigation_mode_new = &_mission;\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t}\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t// If we are in VTOL takeoff, do not switch until it is finished.\n\t\t\tif (_navigation_mode == &_vtol_takeoff && !get_mission_result()->finished) {\n\t\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\n\t\t\t} else\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\t\t\t{\n\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\t_geofence.run();\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    },
    "mission_instance_count": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "548ffbafcd5468b9da5bb144704951126d49c85d",
      "source": "orb_advert_t *get_mavlink_log_pub() { return &_mavlink_log_pub; }\n\n\tint mission_instance_count() const { return _mission_result.mission_id; }"
    }
  },
  "22511": {
    "MissionBlock::is_mission_item_reached_or_completed": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "e35380d6ae8196ce658b5059388593ec0c3b63d2",
      "source": "MissionBlock::is_mission_item_reached_or_completed()\n{\n\tconst hrt_abstime now = hrt_absolute_time();\n\n\t// Handle indefinite waypoints and action commands\n\tswitch (_mission_item.nav_cmd) {\n\n\t// Action Commands that doesn't have timeout completes instantaneously\n\tcase NAV_CMD_DO_SET_ACTUATOR:\n\tcase NAV_CMD_DO_LAND_START:\n\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\tcase NAV_CMD_VIDEO_START_CAPTURE:\n\tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n\tcase NAV_CMD_DO_CONTROL_VIDEO:\n\tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n\tcase NAV_CMD_DO_MOUNT_CONTROL:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n\tcase NAV_CMD_DO_SET_ROI:\n\tcase NAV_CMD_DO_SET_ROI_LOCATION:\n\tcase NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\tcase NAV_CMD_DO_SET_ROI_NONE:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\tcase NAV_CMD_OBLIQUE_SURVEY:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:\n\tcase NAV_CMD_SET_CAMERA_MODE:\n\tcase NAV_CMD_SET_CAMERA_ZOOM:\n\tcase NAV_CMD_SET_CAMERA_FOCUS:\n\tcase NAV_CMD_DO_CHANGE_SPEED:\n\tcase NAV_CMD_DO_SET_HOME:\n\t\treturn true;\n\n\t// Indefinite Waypoints\n\tcase NAV_CMD_LAND: /* fall through */\n\tcase NAV_CMD_VTOL_LAND:\n\t\treturn _navigator->get_land_detected()->landed;\n\n\tcase NAV_CMD_IDLE: /* fall through */\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\treturn false;\n\n\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\n\t\tif (int(_mission_item.params[0]) == 3) {\n\t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\t\t} else if (int(_mission_item.params[0]) == 4) {\n\t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t} else {\n\t\t\t// invalid vtol transition request\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DELAY:\n\t\t// Set reached flags directly such that only the delay time is considered\n\t\t_waypoint_position_reached = true;\n\t\t_waypoint_yaw_reached = true;\n\n\t\t// Set timestamp when entering only (it's reset to 0 for every waypoint)\n\t\tif (_time_wp_reached == 0) {\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DO_WINCH: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) *\n\t\t\t\t\t1E-6f; // TODO: Add proper microseconds_to_seconds function\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_DO_GRIPPER: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) * 1E-6f;\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\t/* do nothing, this is a 3D waypoint */\n\t\tbreak;\n\t}\n\n\t// Update the 'waypoint position reached' status\n\tif (!_navigator->get_land_detected()->landed && !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tconst float mission_item_altitude_amsl = get_absolute_altitude_for_item(_mission_item);\n\n\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n\t\t\t\t_navigator->get_loiter_radius();\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t/* We want to avoid the edge case where the acceptance radius is bigger or equal than\n\t\t\t * the altitude of the takeoff waypoint above home. Otherwise, we do not really follow\n\t\t\t * take-off procedures like leaving the landing gear down. */\n\n\t\t\tfloat takeoff_alt = _mission_item.altitude_is_relative ?\n\t\t\t\t\t    _mission_item.altitude :\n\t\t\t\t\t    (_mission_item.altitude - _navigator->get_home_position()->alt);\n\n\t\t\tfloat altitude_acceptance_radius = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* It should be safe to just use half of the takoeff_alt as an acceptance radius. */\n\t\t\tif (takeoff_alt > 0 && takeoff_alt < altitude_acceptance_radius) {\n\t\t\t\taltitude_acceptance_radius = takeoff_alt / 2.0f;\n\t\t\t}\n\n\t\t\t/* require only altitude for takeoff for multicopter */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t/* fixed-wing takeoff is reached once the vehicle has exceeded the takeoff altitude */\n\t\t\tif (_navigator->get_global_position()->alt > mission_item_altitude_amsl) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n\t\t\t// Accept takeoff waypoint to be reached if the distance in 2D plane is within acceptance radius\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t// For takeoff mission items use the parameter for the takeoff acceptance radius\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t   (_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t    _mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT)) {\n\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius + navigation switch distance. Time inside and turn count is handled elsewhere.\n\t\t\t */\n\n\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter.\n\t\t\t// First check if the altitude setpoint is the mission setpoint (that means that the loiter is not yet reached)\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\tif (fabsf(curr_sp->alt - mission_item_altitude_amsl) >= FLT_EPSILON) {\n\t\t\t\tdist_xy = -1.0f;\n\t\t\t\tdist_z = -1.0f;\n\n\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n\t\t\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t\tcurr_sp->alt = mission_item_altitude_amsl;\n\t\t\t\t\tcurr_sp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t}\n\n\t\t\t} else if (dist >= 0.f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t// loitering, check if new altitude is reached, while still also having check on position\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\t// if the setpoint is valid we are checking if we reached the gate\n\t\t\t// in the case of an invalid setpoint we are defaulting to\n\t\t\t// assuming that we have already reached the gate to not block\n\t\t\t// the further execution of the mission.\n\t\t\tif (curr_sp->valid) {\n\n\t\t\t\t// location of gate (mission item)\n\t\t\t\tMapProjection ref_pos{_mission_item.lat, _mission_item.lon};\n\n\t\t\t\t// current setpoint\n\t\t\t\tmatrix::Vector2f gate_to_curr_sp = ref_pos.project(curr_sp->lat, curr_sp->lon);\n\n\t\t\t\t// system position\n\t\t\t\tmatrix::Vector2f vehicle_pos = ref_pos.project(_navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t       _navigator->get_global_position()->lon);\n\t\t\t\tconst float dot_product = vehicle_pos.dot(gate_to_curr_sp.normalized());\n\n\t\t\t\t// if the dot product (projected vector) is positive, then\n\t\t\t\t// the current position is between the gate position and the\n\t\t\t\t// next waypoint\n\t\t\t\tif (dot_product >= 0) {\n\t\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t\t\t_time_wp_reached = now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfloat acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t// We use the acceptance radius of the mission item if it has been set (not NAN)\n\t\t\t// but only for multicopter.\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t    && PX4_ISFINITE(_mission_item.acceptance_radius) && _mission_item.acceptance_radius > FLT_EPSILON) {\n\t\t\t\tacceptance_radius = _mission_item.acceptance_radius;\n\t\t\t}\n\n\t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n\t\t\tif (_mission_item.vtol_back_transition\n\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tfloat velocity = sqrtf(_navigator->get_local_position()->vx * _navigator->get_local_position()->vx +\n\t\t\t\t\t\t       _navigator->get_local_position()->vy * _navigator->get_local_position()->vy);\n\n\t\t\t\tconst float back_trans_dec = _navigator->get_vtol_back_trans_deceleration();\n\n\t\t\t\tif (back_trans_dec > FLT_EPSILON && velocity > FLT_EPSILON) {\n\t\t\t\t\tacceptance_radius = (velocity / back_trans_dec / 2) * velocity;\n\n\t\t\t\t}\n\n\t\t\t\t// do not care for altitude when approaching the backtransition point. Not accepting the waypoint causes\n\t\t\t\t// the vehicle to perform a sharp turn after passing the land waypoint and this causes worse unexected behavior\n\t\t\t\talt_acc_rad_m = INFINITY;\n\n\t\t\t}\n\n\t\t\tbool passed_curr_wp = false;\n\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tconst float dist_prev_to_curr = get_distance_to_next_waypoint(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.lon);\n\n\t\t\t\tif (dist_prev_to_curr > 1.0e-6f && _navigator->get_position_setpoint_triplet()->previous.valid) {\n\t\t\t\t\t// Fixed-wing guidance interprets this condition as line segment following\n\n\t\t\t\t\t// vector from previous waypoint to current waypoint\n\t\t\t\t\tfloat vector_prev_to_curr_north;\n\t\t\t\t\tfloat vector_prev_to_curr_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, &vector_prev_to_curr_north,\n\t\t\t\t\t\t\t\t\t &vector_prev_to_curr_east);\n\n\t\t\t\t\t// vector from next waypoint to aircraft\n\t\t\t\t\tfloat vector_curr_to_vehicle_north;\n\t\t\t\t\tfloat vector_curr_to_vehicle_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_global_position()->lon, &vector_curr_to_vehicle_north,\n\t\t\t\t\t\t\t\t\t &vector_curr_to_vehicle_east);\n\n\t\t\t\t\t// if dot product of vectors is positive, we are passed the current waypoint (the terminal point on the line segment) and should switch to next mission item\n\t\t\t\t\tpassed_curr_wp = vector_prev_to_curr_north * vector_curr_to_vehicle_north + vector_prev_to_curr_east *\n\t\t\t\t\t\t\t vector_curr_to_vehicle_east > 0.0f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist_xy >= 0.0f && (dist_xy <= acceptance_radius || passed_curr_wp) && dist_z <= alt_acc_rad_m) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\t// consider yaw reached for non-rotary wing vehicles (such as fixed-wing)\n\t\tif (_navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Update the 'waypoint position reached' status (only for rotary wing flight)\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))\n\t\t    && _navigator->get_local_position()->heading_good_for_control) {\n\n\t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()\n\t\t\t    || (_navigator->get_yaw_timeout() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t// Always accept yaw during takeoff\n\t\t\t// TODO: Ideally Navigator would handle a yaw reset and adjust its yaw setpoint, making the\n\t\t\t// following no longer necessary.\n\t\t\t// FlightTaskAuto is currently also ignoring the yaw setpoint during takeoff and thus \"handling\" it.\n\t\t\tif (_mission_item.nav_cmd == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n\t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n\n\t\t\t\t_navigator->set_mission_failure_heading_timeout();\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Handle Loiter/Delay Timeout if the waypoint position and yaw setpoint got reached\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tbool time_inside_reached = false;\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n\t\t\ttime_inside_reached = true;\n\t\t}\n\n\t\t// check if course for exit is reached (only applies for fixed-wing flight)\n\t\tbool exit_course_reached = false;\n\n\t\tif (time_inside_reached) {\n\n\t\t\tstruct position_setpoint_s *curr_sp_new = &_navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float dist_current_next = get_distance_to_next_waypoint(curr_sp_new->lat, curr_sp_new->lon, next_sp.lat,\n\t\t\t\t\t\t\tnext_sp.lon);\n\n\t\t\t/* enforce exit course if in FW, the next wp is valid, the vehicle is currently loitering and either having force_heading set,\n\t\t\t   or if loitering to achieve altitdue at a NAV_CMD_WAYPOINT */\n\t\t\tconst bool enforce_exit_course = _navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t\t && next_sp.valid\n\t\t\t\t\t\t\t && curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t\t\t\t\t\t && (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n\n\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint\n\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.2f * curr_sp_new->loiter_radius;\n\n\t\t\tif (enforce_exit_course && exit_course_is_reachable) {\n\n\t\t\t\tfloat vehicle_position_to_next_waypoint_north;\n\t\t\t\tfloat vehicle_position_to_next_waypoint_east;\n\t\t\t\tget_vector_to_next_waypoint(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon, next_sp.lat,\n\t\t\t\t\t\t\t    next_sp.lon, &vehicle_position_to_next_waypoint_north,  &vehicle_position_to_next_waypoint_east);\n\n\t\t\t\t// this vector defines the exit bearing\n\t\t\t\tconst matrix::Vector2f vector_vehicle_position_to_next_waypoint = {vehicle_position_to_next_waypoint_north, vehicle_position_to_next_waypoint_east};\n\n\t\t\t\tconst matrix::Vector2f vehicle_ground_velocity = {_navigator->get_local_position()->vx, _navigator->get_local_position()->vy};\n\n\t\t\t\texit_course_reached = vector_vehicle_position_to_next_waypoint.dot(vehicle_ground_velocity) >\n\t\t\t\t\t\t      vector_vehicle_position_to_next_waypoint.norm() * vehicle_ground_velocity.norm() * kCosineExitCourseThreshold;\n\n\t\t\t} else {\n\t\t\t\texit_course_reached = true;\n\t\t\t}\n\t\t}\n\n\t\t// set exit flight course to next waypoint\n\t\tif (exit_course_reached) {\n\t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float range = get_distance_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t// exit xtrack location\n\t\t\t// reset lat/lon of loiter waypoint so vehicle follows a tangent\n\t\t\tif (_mission_item.loiter_exit_xtrack && next_sp.valid && PX4_ISFINITE(range) &&\n\t\t\t    (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t     _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT)) {\n\n\t\t\t\tfloat bearing = get_bearing_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t\t// calculate (positive) angle between current bearing vector (orbit center to next waypoint) and vector pointing to tangent exit location\n\t\t\t\tconst float ratio = math::min(fabsf(curr_sp.loiter_radius / range), 1.0f);\n\t\t\t\tfloat inner_angle = acosf(ratio);\n\n\t\t\t\t// Compute \"ideal\" tangent origin\n\t\t\t\tif (curr_sp.loiter_direction_counter_clockwise) {\n\t\t\t\t\tbearing += inner_angle;\n\n\t\t\t\t} else {\n\t\t\t\t\tbearing -= inner_angle;\n\t\t\t\t}\n\n\t\t\t\t// set typ to position, will get set to loiter in the fw position controller once close\n\t\t\t\t// and replace current setpoint lat/lon with tangent coordinate\n\t\t\t\tcurr_sp.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\twaypoint_from_heading_and_distance(curr_sp.lat, curr_sp.lon,\n\t\t\t\t\t\t\t\t   bearing, fabsf(curr_sp.loiter_radius),\n\t\t\t\t\t\t\t\t   &curr_sp.lat, &curr_sp.lon);\n\t\t\t}\n\n\t\t\treturn true; // mission item is reached\n\t\t}\n\t}\n\n\treturn false;\n}"
    }
  },
  "22469": {
    "RTL::readVtolLandApproaches": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "1b87a0fa41fdf6be27cc8e77e8cd3205c7ff5fad",
      "source": "land_approaches_s RTL::readVtolLandApproaches(DestinationPosition rtl_position) const\n{\n\n\t// go through all mission items in the rally point storage. If we find a mission item of type NAV_CMD_RALLY_POINT\n\t// which is within MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES of our current home position then treat ALL following mission items of type NAV_CMD_LOITER_TO_ALT which come\n\t// BEFORE the next mission item of type NAV_CMD_RALLY_POINT as land approaches for the home position\n\tland_approaches_s vtol_land_approaches{};\n\n\tif (!_safe_points_updated) {\n\t\treturn vtol_land_approaches;\n\t}\n\n\tbool foundHomeLandApproaches = false;\n\tuint8_t sector_counter = 0;\n\n\tfor (int current_seq = 1; current_seq <= _stats.num_items; ++current_seq) {\n\t\tmission_item_s mission_item{};\n\n\t\tbool success_mission_item = _dataman_cache_safepoint.loadWait(DM_KEY_SAFE_POINTS, current_seq,\n\t\t\t\t\t    reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t    sizeof(mission_item_s));\n\n\t\tif (!success_mission_item) {\n\t\t\tPX4_ERR(\"dm_read failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mission_item.nav_cmd == NAV_CMD_RALLY_POINT) {\n\n\t\t\tif (foundHomeLandApproaches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst float dist_to_safepoint = get_distance_to_next_waypoint(mission_item.lat, mission_item.lon, rtl_position.lat,\n\t\t\t\t\t\t\trtl_position.lon);\n\n\t\t\tif (dist_to_safepoint < MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n\t\t\t\tfoundHomeLandApproaches = true;\n\t\t\t\tvtol_land_approaches.land_location_lat_lon = matrix::Vector2d(mission_item.lat, mission_item.lon);\n\t\t\t}\n\n\t\t\tsector_counter = 0;\n\t\t}\n\n\t\tif (foundHomeLandApproaches && mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\tvtol_land_approaches.approaches[sector_counter].lat = mission_item.lat;\n\t\t\tvtol_land_approaches.approaches[sector_counter].lon = mission_item.lon;\n\t\t\tvtol_land_approaches.approaches[sector_counter].height_m = MissionBlock::get_absolute_altitude_for_item(mission_item,\n\t\t\t\t\t_home_pos_sub.get().alt);\n\t\t\tvtol_land_approaches.approaches[sector_counter].loiter_radius_m = mission_item.loiter_radius;\n\t\t\tsector_counter++;\n\t\t}\n\t}\n\n\treturn vtol_land_approaches;\n}"
    },
    "RTL::on_activation": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "1b87a0fa41fdf6be27cc8e77e8cd3205c7ff5fad",
      "source": "void RTL::on_activation()\n{\n\tsetRtlTypeAndDestination();\n\n\tswitch (_rtl_type) {\n\tcase RtlType::RTL_DIRECT_MISSION_LAND:\t// Fall through\n\tcase RtlType::RTL_MISSION_FAST: // Fall through\n\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n\t\t_rtl_mission_type_handle->setReturnAltMin(_enforce_rtl_alt);\n\t\t_rtl_mission_type_handle->on_activation();\n\t\tbreak;\n\n\tcase RtlType::RTL_DIRECT:\n\t\t_rtl_direct.setReturnAltMin(_enforce_rtl_alt);\n\t\t_rtl_direct.on_activation();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}"
    },
    "Geofence::_updateFence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "1b87a0fa41fdf6be27cc8e77e8cd3205c7ff5fad",
      "source": "void Geofence::_updateFence()\n{\n\tmission_fence_point_s mission_fence_point;\n\tbool is_circle_area = false;\n\n\t// iterate over all polygons and store their starting vertices\n\t_num_polygons = 0;\n\tint current_seq = 1;\n\n\twhile (current_seq <= _dataman_cache.size()) {\n\n\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, current_seq,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t       sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"loadWait failed, seq: %i\", current_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mission_fence_point.nav_cmd) {\n\t\tcase NAV_CMD_FENCE_RETURN_POINT:\n\t\t\t// TODO: do we need to store this?\n\t\t\t++current_seq;\n\t\t\tbreak;\n\n\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n\t\t\tis_circle_area = true;\n\n\t\t/* FALLTHROUGH */\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n\t\t\tif (!is_circle_area && mission_fence_point.vertex_count == 0) {\n\t\t\t\t++current_seq; // avoid endless loop\n\t\t\t\tPX4_ERR(\"Polygon with 0 vertices. Skipping\");\n\n\t\t\t} else {\n\t\t\t\tif (_polygons) {\n\t\t\t\t\t// resize: this is somewhat inefficient, but we do not expect there to be many polygons\n\t\t\t\t\tPolygonInfo *new_polygons = new PolygonInfo[_num_polygons + 1];\n\n\t\t\t\t\tif (new_polygons) {\n\t\t\t\t\t\tmemcpy(new_polygons, _polygons, sizeof(PolygonInfo) * _num_polygons);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete[](_polygons);\n\t\t\t\t\t_polygons = new_polygons;\n\n\t\t\t\t} else {\n\t\t\t\t\t_polygons = new PolygonInfo[1];\n\t\t\t\t}\n\n\t\t\t\tif (!_polygons) {\n\t\t\t\t\t_num_polygons = 0;\n\t\t\t\t\tPX4_ERR(\"alloc failed\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPolygonInfo &polygon = _polygons[_num_polygons];\n\t\t\t\tpolygon.dataman_index = current_seq;\n\t\t\t\tpolygon.fence_type = mission_fence_point.nav_cmd;\n\n\t\t\t\tif (is_circle_area) {\n\t\t\t\t\tpolygon.circle_radius = mission_fence_point.circle_radius;\n\t\t\t\t\tcurrent_seq += 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tpolygon.vertex_count = mission_fence_point.vertex_count;\n\t\t\t\t\tcurrent_seq += mission_fence_point.vertex_count;\n\t\t\t\t}\n\n\t\t\t\t// check if requiremetns for Home location are met\n\t\t\t\tconst bool home_check_okay = checkHomeRequirementsForGeofence(polygon);\n\n\t\t\t\t// check if current position is inside the fence and vehicle is armed\n\t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n\n\t\t\t\t//check if current mission point inside the geofence\n\t\t\t\tconst bool current_mission_check_okay = checkMissionRequirementsForGeofence(polygon);\n\t\t\t\t\n\t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n\t\t\t\tif (home_check_okay && current_position_check_okay && current_mission_check_okay) {\n\t\t\t\t\t++_num_polygons;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPX4_ERR(\"unhandled Fence command: %i\", (int)mission_fence_point.nav_cmd);\n\t\t\t++current_seq;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "22455": {
    "MissionBlock::is_mission_item_reached_or_completed": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "868b8c5579dad9cca0e9ff6dc222ba5180b82ec2",
      "source": "MissionBlock::is_mission_item_reached_or_completed()\n{\n\tconst hrt_abstime now = hrt_absolute_time();\n\n\t// Handle indefinite waypoints and action commands\n\tswitch (_mission_item.nav_cmd) {\n\n\t// Action Commands that doesn't have timeout completes instantaneously\n\tcase NAV_CMD_DO_SET_ACTUATOR:\n\tcase NAV_CMD_DO_LAND_START:\n\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\tcase NAV_CMD_VIDEO_START_CAPTURE:\n\tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n\tcase NAV_CMD_DO_CONTROL_VIDEO:\n\tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n\tcase NAV_CMD_DO_MOUNT_CONTROL:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n\tcase NAV_CMD_DO_SET_ROI:\n\tcase NAV_CMD_DO_SET_ROI_LOCATION:\n\tcase NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\tcase NAV_CMD_DO_SET_ROI_NONE:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\tcase NAV_CMD_OBLIQUE_SURVEY:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:\n\tcase NAV_CMD_SET_CAMERA_MODE:\n\tcase NAV_CMD_SET_CAMERA_ZOOM:\n\tcase NAV_CMD_SET_CAMERA_FOCUS:\n\tcase NAV_CMD_DO_CHANGE_SPEED:\n\tcase NAV_CMD_DO_SET_HOME:\n\t\treturn true;\n\n\t// Indefinite Waypoints\n\tcase NAV_CMD_LAND: /* fall through */\n\tcase NAV_CMD_VTOL_LAND:\n\t\treturn _navigator->get_land_detected()->landed;\n\n\tcase NAV_CMD_IDLE: /* fall through */\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\treturn false;\n\n\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\n\t\tif (int(_mission_item.params[0]) == 3) {\n\t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\t\t} else if (int(_mission_item.params[0]) == 4) {\n\t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t} else {\n\t\t\t// invalid vtol transition request\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DELAY:\n\t\t// Set reached flags directly such that only the delay time is considered\n\t\t_waypoint_position_reached = true;\n\t\t_waypoint_yaw_reached = true;\n\n\t\t// Set timestamp when entering only (it's reset to 0 for every waypoint)\n\t\tif (_time_wp_reached == 0) {\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DO_WINCH: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) *\n\t\t\t\t\t1E-6f; // TODO: Add proper microseconds_to_seconds function\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_DO_GRIPPER: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) * 1E-6f;\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\t/* do nothing, this is a 3D waypoint */\n\t\tbreak;\n\t}\n\n\t// Update the 'waypoint position reached' status\n\tif (!_navigator->get_land_detected()->landed && !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tconst float mission_item_altitude_amsl = get_absolute_altitude_for_item(_mission_item);\n\n\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n\t\t\t\t_navigator->get_loiter_radius();\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t/* We want to avoid the edge case where the acceptance radius is bigger or equal than\n\t\t\t * the altitude of the takeoff waypoint above home. Otherwise, we do not really follow\n\t\t\t * take-off procedures like leaving the landing gear down. */\n\n\t\t\tfloat takeoff_alt = _mission_item.altitude_is_relative ?\n\t\t\t\t\t    _mission_item.altitude :\n\t\t\t\t\t    (_mission_item.altitude - _navigator->get_home_position()->alt);\n\n\t\t\tfloat altitude_acceptance_radius = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* It should be safe to just use half of the takoeff_alt as an acceptance radius. */\n\t\t\tif (takeoff_alt > 0 && takeoff_alt < altitude_acceptance_radius) {\n\t\t\t\taltitude_acceptance_radius = takeoff_alt / 2.0f;\n\t\t\t}\n\n\t\t\t/* require only altitude for takeoff for multicopter */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t/* fixed-wing takeoff is reached once the vehicle has exceeded the takeoff altitude */\n\t\t\tif (_navigator->get_global_position()->alt > mission_item_altitude_amsl) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n\t\t\t// Accept takeoff waypoint to be reached if the distance in 2D plane is within acceptance radius\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t// For takeoff mission items use the parameter for the takeoff acceptance radius\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t   (_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t    _mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT)) {\n\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius + navigation switch distance. Time inside and turn count is handled elsewhere.\n\t\t\t */\n\n\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter.\n\t\t\t// First check if the altitude setpoint is the mission setpoint (that means that the loiter is not yet reached)\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\tif (fabsf(curr_sp->alt - mission_item_altitude_amsl) >= FLT_EPSILON) {\n\t\t\t\tdist_xy = -1.0f;\n\t\t\t\tdist_z = -1.0f;\n\n\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n\t\t\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t\tcurr_sp->alt = mission_item_altitude_amsl;\n\t\t\t\t\tcurr_sp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t}\n\n\t\t\t} else if (dist >= 0.f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t// loitering, check if new altitude is reached, while still also having check on position\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\t// if the setpoint is valid we are checking if we reached the gate\n\t\t\t// in the case of an invalid setpoint we are defaulting to\n\t\t\t// assuming that we have already reached the gate to not block\n\t\t\t// the further execution of the mission.\n\t\t\tif (curr_sp->valid) {\n\n\t\t\t\t// location of gate (mission item)\n\t\t\t\tMapProjection ref_pos{_mission_item.lat, _mission_item.lon};\n\n\t\t\t\t// current setpoint\n\t\t\t\tmatrix::Vector2f gate_to_curr_sp = ref_pos.project(curr_sp->lat, curr_sp->lon);\n\n\t\t\t\t// system position\n\t\t\t\tmatrix::Vector2f vehicle_pos = ref_pos.project(_navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t       _navigator->get_global_position()->lon);\n\t\t\t\tconst float dot_product = vehicle_pos.dot(gate_to_curr_sp.normalized());\n\n\t\t\t\t// if the dot product (projected vector) is positive, then\n\t\t\t\t// the current position is between the gate position and the\n\t\t\t\t// next waypoint\n\t\t\t\tif (dot_product >= 0) {\n\t\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t\t\t_time_wp_reached = now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfloat acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t// We use the acceptance radius of the mission item if it has been set (not NAN)\n\t\t\t// but only for multicopter.\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t    && PX4_ISFINITE(_mission_item.acceptance_radius) && _mission_item.acceptance_radius > FLT_EPSILON) {\n\t\t\t\tacceptance_radius = _mission_item.acceptance_radius;\n\t\t\t}\n\n\t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n\t\t\tif (_mission_item.vtol_back_transition\n\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tfloat velocity = sqrtf(_navigator->get_local_position()->vx * _navigator->get_local_position()->vx +\n\t\t\t\t\t\t       _navigator->get_local_position()->vy * _navigator->get_local_position()->vy);\n\n\t\t\t\tconst float back_trans_dec = _navigator->get_vtol_back_trans_deceleration();\n\n\t\t\t\tif (back_trans_dec > FLT_EPSILON && velocity > FLT_EPSILON) {\n\t\t\t\t\tacceptance_radius = (velocity / back_trans_dec / 2) * velocity;\n\n\t\t\t\t}\n\n\t\t\t\t// do not care for altitude when approaching the backtransition point. Not accepting the waypoint causes\n\t\t\t\t// the vehicle to perform a sharp turn after passing the land waypoint and this causes worse unexected behavior\n\t\t\t\talt_acc_rad_m = INFINITY;\n\n\t\t\t}\n\n\t\t\tbool passed_curr_wp = false;\n\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tconst float dist_prev_to_curr = get_distance_to_next_waypoint(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.lon);\n\n\t\t\t\tif (dist_prev_to_curr > 1.0e-6f && _navigator->get_position_setpoint_triplet()->previous.valid) {\n\t\t\t\t\t// Fixed-wing guidance interprets this condition as line segment following\n\n\t\t\t\t\t// vector from previous waypoint to current waypoint\n\t\t\t\t\tfloat vector_prev_to_curr_north;\n\t\t\t\t\tfloat vector_prev_to_curr_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, &vector_prev_to_curr_north,\n\t\t\t\t\t\t\t\t\t &vector_prev_to_curr_east);\n\n\t\t\t\t\t// vector from next waypoint to aircraft\n\t\t\t\t\tfloat vector_curr_to_vehicle_north;\n\t\t\t\t\tfloat vector_curr_to_vehicle_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_global_position()->lon, &vector_curr_to_vehicle_north,\n\t\t\t\t\t\t\t\t\t &vector_curr_to_vehicle_east);\n\n\t\t\t\t\t// if dot product of vectors is positive, we are passed the current waypoint (the terminal point on the line segment) and should switch to next mission item\n\t\t\t\t\tpassed_curr_wp = vector_prev_to_curr_north * vector_curr_to_vehicle_north + vector_prev_to_curr_east *\n\t\t\t\t\t\t\t vector_curr_to_vehicle_east > 0.0f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist_xy >= 0.0f && (dist_xy <= acceptance_radius || passed_curr_wp) && dist_z <= alt_acc_rad_m) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\t// consider yaw reached for non-rotary wing vehicles (such as fixed-wing)\n\t\tif (_navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Update the 'waypoint position reached' status (only for rotary wing flight)\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))\n\t\t    && _navigator->get_local_position()->heading_good_for_control) {\n\n\t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()\n\t\t\t    || (_navigator->get_yaw_timeout() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t// Always accept yaw during takeoff\n\t\t\t// TODO: Ideally Navigator would handle a yaw reset and adjust its yaw setpoint, making the\n\t\t\t// following no longer necessary.\n\t\t\t// FlightTaskAuto is currently also ignoring the yaw setpoint during takeoff and thus \"handling\" it.\n\t\t\tif (_mission_item.nav_cmd == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n\t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n\n\t\t\t\t_navigator->set_mission_failure_heading_timeout();\n\t\t\t}\n\t\t\t// If Weathervane is enabled, ignore yaw setpoint\n\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\tif (_navigator->get_weathervane_enabled() && !pos_sp_triplet->current.disable_weather_vane) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Handle Loiter/Delay Timeout if the waypoint position and yaw setpoint got reached\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tbool time_inside_reached = false;\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n\t\t\ttime_inside_reached = true;\n\t\t}\n\n\t\t// check if course for exit is reached (only applies for fixed-wing flight)\n\t\tbool exit_course_reached = false;\n\n\t\tif (time_inside_reached) {\n\n\t\t\tstruct position_setpoint_s *curr_sp_new = &_navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float dist_current_next = get_distance_to_next_waypoint(curr_sp_new->lat, curr_sp_new->lon, next_sp.lat,\n\t\t\t\t\t\t\tnext_sp.lon);\n\n\t\t\t/* enforce exit course if in FW, the next wp is valid, the vehicle is currently loitering and either having force_heading set,\n\t\t\t   or if loitering to achieve altitdue at a NAV_CMD_WAYPOINT */\n\t\t\tconst bool enforce_exit_course = _navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t\t && next_sp.valid\n\t\t\t\t\t\t\t && curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t\t\t\t\t\t && (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n\n\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint\n\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.2f * curr_sp_new->loiter_radius;\n\n\t\t\tif (enforce_exit_course && exit_course_is_reachable) {\n\n\t\t\t\tfloat vehicle_position_to_next_waypoint_north;\n\t\t\t\tfloat vehicle_position_to_next_waypoint_east;\n\t\t\t\tget_vector_to_next_waypoint(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon, next_sp.lat,\n\t\t\t\t\t\t\t    next_sp.lon, &vehicle_position_to_next_waypoint_north,  &vehicle_position_to_next_waypoint_east);\n\n\t\t\t\t// this vector defines the exit bearing\n\t\t\t\tconst matrix::Vector2f vector_vehicle_position_to_next_waypoint = {vehicle_position_to_next_waypoint_north, vehicle_position_to_next_waypoint_east};\n\n\t\t\t\tconst matrix::Vector2f vehicle_ground_velocity = {_navigator->get_local_position()->vx, _navigator->get_local_position()->vy};\n\n\t\t\t\texit_course_reached = vector_vehicle_position_to_next_waypoint.dot(vehicle_ground_velocity) >\n\t\t\t\t\t\t      vector_vehicle_position_to_next_waypoint.norm() * vehicle_ground_velocity.norm() * kCosineExitCourseThreshold;\n\n\t\t\t} else {\n\t\t\t\texit_course_reached = true;\n\t\t\t}\n\t\t}\n\n\t\t// set exit flight course to next waypoint\n\t\tif (exit_course_reached) {\n\t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float range = get_distance_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t// exit xtrack location\n\t\t\t// reset lat/lon of loiter waypoint so vehicle follows a tangent\n\t\t\tif (_mission_item.loiter_exit_xtrack && next_sp.valid && PX4_ISFINITE(range) &&\n\t\t\t    (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t     _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT)) {\n\n\t\t\t\tfloat bearing = get_bearing_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t\t// calculate (positive) angle between current bearing vector (orbit center to next waypoint) and vector pointing to tangent exit location\n\t\t\t\tconst float ratio = math::min(fabsf(curr_sp.loiter_radius / range), 1.0f);\n\t\t\t\tfloat inner_angle = acosf(ratio);\n\n\t\t\t\t// Compute \"ideal\" tangent origin\n\t\t\t\tif (curr_sp.loiter_direction_counter_clockwise) {\n\t\t\t\t\tbearing += inner_angle;\n\n\t\t\t\t} else {\n\t\t\t\t\tbearing -= inner_angle;\n\t\t\t\t}\n\n\t\t\t\t// set typ to position, will get set to loiter in the fw position controller once close\n\t\t\t\t// and replace current setpoint lat/lon with tangent coordinate\n\t\t\t\tcurr_sp.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\twaypoint_from_heading_and_distance(curr_sp.lat, curr_sp.lon,\n\t\t\t\t\t\t\t\t   bearing, fabsf(curr_sp.loiter_radius),\n\t\t\t\t\t\t\t\t   &curr_sp.lat, &curr_sp.lon);\n\t\t\t}\n\n\t\t\treturn true; // mission item is reached\n\t\t}\n\t}\n\n\treturn false;\n}"
    }
  },
  "22458": {
    "MissionBase::on_inactivation": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "2c717d6b9f3205aab476dd44cb88399d7c77f328",
      "source": "MissionBase::on_inactivation()\n{\n\t_navigator->disable_camera_trigger();\n\n\t_navigator->stop_capturing_images();\n\t_navigator->set_gimbal_neutral(); // point forward\n\t_navigator->release_gimbal_control();\n\n\tif (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n\n\t/* reset so MISSION_ITEM_REACHED isn't published */\n\t_navigator->get_mission_result()->seq_reached = -1;\n\n\t_mission_type = MissionType::MISSION_TYPE_NONE;\n\n\t_inactivation_index = _mission.current_seq;\n}"
    },
    "MissionBase::handleLanding": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "2c717d6b9f3205aab476dd44cb88399d7c77f328",
      "source": "void MissionBase::handleLanding(WorkItemType &new_work_item_type, mission_item_s next_mission_items[],\n\t\t\t\tsize_t &num_found_items)\n{\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tbool needs_to_land = !_land_detected_sub.get().landed &&\n\t\t\t     ((_mission_item.nav_cmd == NAV_CMD_VTOL_LAND)\n\t\t\t      || (_mission_item.nav_cmd == NAV_CMD_LAND));\n\n\tbool needs_vtol_landing = _vehicle_status_sub.get().is_vtol &&\n\t\t\t\t  (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) &&\n\t\t\t\t  (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND) &&\n\t\t\t\t  !_land_detected_sub.get().landed;\n\n\t/* move to land wp as fixed wing */\n\tif (needs_vtol_landing) {\n\t\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\n\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tnum_found_items = 1u;\n\t\t\tnext_mission_items[0u] = _mission_item;\n\n\t\t\tfloat altitude = _global_pos_sub.get().alt;\n\n\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t\t_mission_item.vtol_back_transition = true;\n\n\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n\t\t}\n\n\t\t/* transition to MC */\n\t\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\n\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\n\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n\n\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following\n\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n\t\t}\n\n\t} else if (needs_to_land) {\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif ((_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) &&\n\t\t    do_need_move_to_item() &&\n\t\t    (_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT ||\n\t\t     _work_item_type == WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION)) {\n\n\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tnum_found_items = 1u;\n\t\t\tnext_mission_items[0u] = _mission_item;\n\n\t\t\t/*\n\t\t\t\t* Ignoring waypoint altitude:\n\t\t\t\t* Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t\t* the ground. Actual landing will descend anyway until it touches down.\n\t\t\t\t* XXX: We might want to change that at some point if it is clear to the user\n\t\t\t\t* what the altitude means on this waypoint type.\n\t\t\t\t*/\n\t\t\tfloat altitude = _global_pos_sub.get().alt;\n\n\t\t\tif (pos_sp_triplet->current.valid\n\t\t\t    && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\n\t\t\t// have to reset here because these field were used in set_vtol_transition_item\n\t\t\t_mission_item.time_inside = 0.f;\n\t\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t// make previous setpoint invalid, such that there will be no prev-current line following.\n\t\t\t// if the vehicle drifted off the path during back-transition it should just go straight to the landing point\n\t\t\t_navigator->reset_position_setpoint(pos_sp_triplet->previous);\n\n\t\t\t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n\t\t\t_navigator->acquire_gimbal_control();\n\t\t\t_navigator->set_gimbal_neutral();\n\t\t\t_navigator->release_gimbal_control();\n\n\t\t} else {\n\n\t\t\tif (_mission_item.land_precision > 0 && _mission_item.land_precision < 3) {\n\t\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND;\n\n\t\t\t\tstartPrecLand(_mission_item.land_precision);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ignore yaw for landing items */\n\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t* that aligns the vehicle first */\n\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t_mission_item.yaw = NAN;\n\t}\n}"
    },
    "Land::on_activation": {
      "file": "src/modules/navigator/land.cpp",
      "commit": "2c717d6b9f3205aab476dd44cb88399d7c77f328",
      "source": "Land::on_activation()\n{\n\t/* set current mission item to Land */\n\tset_land_item(&_mission_item);\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\treset_mission_item_reached();\n\n\t/* convert mission item to current setpoint */\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tpos_sp_triplet->previous.valid = false;\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "Navigator::disable_camera_trigger": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "2c717d6b9f3205aab476dd44cb88399d7c77f328",
      "source": "void Navigator::disable_camera_trigger()\n{\n\t// Disable camera trigger\n\tvehicle_command_s cmd {};\n\tcmd.command = vehicle_command_s::VEHICLE_CMD_DO_TRIGGER_CONTROL;\n\t// Pause trigger\n\tcmd.param1 = -1.0f;\n\tcmd.param3 = 1.0f;\n\tpublish_vehicle_cmd(&cmd);\n}"
    },
    "RTL::on_activation": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "2c717d6b9f3205aab476dd44cb88399d7c77f328",
      "source": "void RTL::on_activation()\n{\n\tsetRtlTypeAndDestination();\n\n\tswitch (_rtl_type) {\n\tcase RtlType::RTL_DIRECT_MISSION_LAND:\t// Fall through\n\tcase RtlType::RTL_MISSION_FAST: // Fall through\n\tcase RtlType::RTL_MISSION_FAST_REVERSE:\n\t\t_rtl_mission_type_handle->setReturnAltMin(_enforce_rtl_alt);\n\t\t_rtl_mission_type_handle->on_activation();\n\t\tbreak;\n\n\tcase RtlType::RTL_DIRECT:\n\t\t_rtl_direct.setReturnAltMin(_enforce_rtl_alt);\n\t\t_rtl_direct.on_activation();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}"
    }
  },
  "22434": {
    "Mission::save_mission_state": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "96c2b51a9b5c32684699b1a47ae21554bc68c8cf",
      "source": "Mission::save_mission_state()\n{\n\tif (_vehicle_status_sub.get().arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t// Save only while disarmed, as this is a blocking operation\n\t\t_need_mission_save = true;\n\t\treturn;\n\t}\n\n\t_need_mission_save = false;\n\tmission_s mission_state = {};\n\n\t/* read current state */\n\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\tsizeof(mission_s));\n\n\tif (success) {\n\t\t/* data read successfully, check dataman ID and items count */\n\t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count\n\t\t    && mission_state.mission_update_counter == _mission.mission_update_counter) {\n\t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n\t\t\tif (mission_state.current_seq != _mission.current_seq) {\n\t\t\t\tmission_state = _mission;\n\n\t\t\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\t\t\tif (!success) {\n\n\t\t\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* invalid data, this must not happen and indicates error in mission publisher */\n\t\tmission_state = _mission;\n\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Invalid mission state.\\t\");\n\t\t/* EVENT\n\t\t * @description No mission or storage failure\n\t\t */\n\t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Error, \"Invalid mission state\");\n\n\t\t/* write modified state only if changed */\n\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\tif (!success) {\n\n\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t}\n\t}\n}"
    }
  },
  "22413": {
    "MissionBlock::is_mission_item_reached_or_completed": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "4c088bc4a6e986c548b65817681b33844fb4c118",
      "source": "MissionBlock::is_mission_item_reached_or_completed()\n{\n\tconst hrt_abstime now = hrt_absolute_time();\n\n\t// Handle indefinite waypoints and action commands\n\tswitch (_mission_item.nav_cmd) {\n\n\t// Action Commands that doesn't have timeout completes instantaneously\n\tcase NAV_CMD_DO_SET_ACTUATOR:\n\tcase NAV_CMD_DO_LAND_START:\n\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\tcase NAV_CMD_VIDEO_START_CAPTURE:\n\tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n\tcase NAV_CMD_DO_CONTROL_VIDEO:\n\tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n\tcase NAV_CMD_DO_MOUNT_CONTROL:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n\tcase NAV_CMD_DO_SET_ROI:\n\tcase NAV_CMD_DO_SET_ROI_LOCATION:\n\tcase NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\tcase NAV_CMD_DO_SET_ROI_NONE:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\tcase NAV_CMD_OBLIQUE_SURVEY:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:\n\tcase NAV_CMD_SET_CAMERA_MODE:\n\tcase NAV_CMD_SET_CAMERA_ZOOM:\n\tcase NAV_CMD_SET_CAMERA_FOCUS:\n\tcase NAV_CMD_DO_CHANGE_SPEED:\n\tcase NAV_CMD_DO_SET_HOME:\n\t\treturn true;\n\n\t// Indefinite Waypoints\n\tcase NAV_CMD_LAND: /* fall through */\n\tcase NAV_CMD_VTOL_LAND:\n\t\treturn _navigator->get_land_detected()->landed;\n\n\tcase NAV_CMD_IDLE: /* fall through */\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\treturn false;\n\n\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\n\t\tif (int(_mission_item.params[0]) == 3) {\n\t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\t\t} else if (int(_mission_item.params[0]) == 4) {\n\t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t} else {\n\t\t\t// invalid vtol transition request\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DELAY:\n\t\t// Set reached flags directly such that only the delay time is considered\n\t\t_waypoint_position_reached = true;\n\t\t_waypoint_yaw_reached = true;\n\n\t\t// Set timestamp when entering only (it's reset to 0 for every waypoint)\n\t\tif (_time_wp_reached == 0) {\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DO_WINCH: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) *\n\t\t\t\t\t1E-6f; // TODO: Add proper microseconds_to_seconds function\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_DO_GRIPPER: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) * 1E-6f;\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\t/* do nothing, this is a 3D waypoint */\n\t\tbreak;\n\t}\n\n\t// Update the 'waypoint position reached' status\n\tif (!_navigator->get_land_detected()->landed && !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tconst float mission_item_altitude_amsl = get_absolute_altitude_for_item(_mission_item);\n\n\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n\t\t\t\t_navigator->get_loiter_radius();\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t/* We want to avoid the edge case where the acceptance radius is bigger or equal than\n\t\t\t * the altitude of the takeoff waypoint above home. Otherwise, we do not really follow\n\t\t\t * take-off procedures like leaving the landing gear down. */\n\n\t\t\tfloat takeoff_alt = _mission_item.altitude_is_relative ?\n\t\t\t\t\t    _mission_item.altitude :\n\t\t\t\t\t    (_mission_item.altitude - _navigator->get_home_position()->alt);\n\n\t\t\tfloat altitude_acceptance_radius = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* It should be safe to just use half of the takoeff_alt as an acceptance radius. */\n\t\t\tif (takeoff_alt > 0 && takeoff_alt < altitude_acceptance_radius) {\n\t\t\t\taltitude_acceptance_radius = takeoff_alt / 2.0f;\n\t\t\t}\n\n\t\t\t/* require only altitude for takeoff for multicopter */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t/* fixed-wing takeoff is reached once the vehicle has exceeded the takeoff altitude */\n\t\t\tif (_navigator->get_global_position()->alt > mission_item_altitude_amsl) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n\t\t\t// Accept takeoff waypoint to be reached if the distance in 2D plane is within acceptance radius\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t// For takeoff mission items use the parameter for the takeoff acceptance radius\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t   (_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t    _mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT)) {\n\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius + navigation switch distance. Time inside and turn count is handled elsewhere.\n\t\t\t */\n\n\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter.\n\t\t\t// First check if the altitude setpoint is the mission setpoint (that means that the loiter is not yet reached)\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\tif (fabsf(curr_sp->alt - mission_item_altitude_amsl) >= FLT_EPSILON) {\n\t\t\t\tdist_xy = -1.0f;\n\t\t\t\tdist_z = -1.0f;\n\n\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n\t\t\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t\tcurr_sp->alt = mission_item_altitude_amsl;\n\t\t\t\t\tcurr_sp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t}\n\n\t\t\t} else if (dist >= 0.f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t// loitering, check if new altitude is reached, while still also having check on position\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\t// if the setpoint is valid we are checking if we reached the gate\n\t\t\t// in the case of an invalid setpoint we are defaulting to\n\t\t\t// assuming that we have already reached the gate to not block\n\t\t\t// the further execution of the mission.\n\t\t\tif (curr_sp->valid) {\n\n\t\t\t\t// location of gate (mission item)\n\t\t\t\tMapProjection ref_pos{_mission_item.lat, _mission_item.lon};\n\n\t\t\t\t// current setpoint\n\t\t\t\tmatrix::Vector2f gate_to_curr_sp = ref_pos.project(curr_sp->lat, curr_sp->lon);\n\n\t\t\t\t// system position\n\t\t\t\tmatrix::Vector2f vehicle_pos = ref_pos.project(_navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t       _navigator->get_global_position()->lon);\n\t\t\t\tconst float dot_product = vehicle_pos.dot(gate_to_curr_sp.normalized());\n\n\t\t\t\t// if the dot product (projected vector) is positive, then\n\t\t\t\t// the current position is between the gate position and the\n\t\t\t\t// next waypoint\n\t\t\t\tif (dot_product >= 0) {\n\t\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t\t\t_time_wp_reached = now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfloat acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t// We use the acceptance radius of the mission item if it has been set (not NAN)\n\t\t\t// but only for multicopter.\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t    && PX4_ISFINITE(_mission_item.acceptance_radius) && _mission_item.acceptance_radius > FLT_EPSILON) {\n\t\t\t\tacceptance_radius = _mission_item.acceptance_radius;\n\t\t\t}\n\n\t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n\t\t\tif (_mission_item.vtol_back_transition\n\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tfloat velocity = sqrtf(_navigator->get_local_position()->vx * _navigator->get_local_position()->vx +\n\t\t\t\t\t\t       _navigator->get_local_position()->vy * _navigator->get_local_position()->vy);\n\n\t\t\t\tconst float back_trans_dec = _navigator->get_vtol_back_trans_deceleration();\n\n\t\t\t\tif (back_trans_dec > FLT_EPSILON && velocity > FLT_EPSILON) {\n\t\t\t\t\tacceptance_radius = (velocity / back_trans_dec / 2) * velocity;\n\n\t\t\t\t}\n\n\t\t\t\t// do not care for altitude when approaching the backtransition point. Not accepting the waypoint causes\n\t\t\t\t// the vehicle to perform a sharp turn after passing the land waypoint and this causes worse unexected behavior\n\t\t\t\talt_acc_rad_m = INFINITY;\n\n\t\t\t}\n\n\t\t\tbool passed_curr_wp = false;\n\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tconst float dist_prev_to_curr = get_distance_to_next_waypoint(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.lon);\n\n\t\t\t\tif (dist_prev_to_curr > 1.0e-6f && _navigator->get_position_setpoint_triplet()->previous.valid) {\n\t\t\t\t\t// Fixed-wing guidance interprets this condition as line segment following\n\n\t\t\t\t\t// vector from previous waypoint to current waypoint\n\t\t\t\t\tfloat vector_prev_to_curr_north;\n\t\t\t\t\tfloat vector_prev_to_curr_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, &vector_prev_to_curr_north,\n\t\t\t\t\t\t\t\t\t &vector_prev_to_curr_east);\n\n\t\t\t\t\t// vector from next waypoint to aircraft\n\t\t\t\t\tfloat vector_curr_to_vehicle_north;\n\t\t\t\t\tfloat vector_curr_to_vehicle_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_global_position()->lon, &vector_curr_to_vehicle_north,\n\t\t\t\t\t\t\t\t\t &vector_curr_to_vehicle_east);\n\n\t\t\t\t\t// if dot product of vectors is positive, we are passed the current waypoint (the terminal point on the line segment) and should switch to next mission item\n\t\t\t\t\tpassed_curr_wp = vector_prev_to_curr_north * vector_curr_to_vehicle_north + vector_prev_to_curr_east *\n\t\t\t\t\t\t\t vector_curr_to_vehicle_east > 0.0f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist_xy >= 0.0f && (dist_xy <= acceptance_radius || passed_curr_wp) && dist_z <= alt_acc_rad_m) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\t// consider yaw reached for non-rotary wing vehicles (such as fixed-wing)\n\t\tif (_navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Update the 'waypoint position reached' status (only for rotary wing flight)\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t    && PX4_ISFINITE(_navigator->get_yaw_acceptance(_mission_item.yaw))\n\t\t    && _navigator->get_local_position()->heading_good_for_control) {\n\n\t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()\n\t\t\t    || (_navigator->get_yaw_timeout() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t// Always accept yaw during takeoff\n\t\t\t// TODO: Ideally Navigator would handle a yaw reset and adjust its yaw setpoint, making the\n\t\t\t// following no longer necessary.\n\t\t\t// FlightTaskAuto is currently also ignoring the yaw setpoint during takeoff and thus \"handling\" it.\n\t\t\tif (_mission_item.nav_cmd == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n\t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n\n\t\t\t\t_navigator->set_mission_failure_heading_timeout();\n\t\t\t}\n\n\t\t\t// If Weathervane is enabled, ignore yaw setpoint\n\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\tif ((_navigator->get_weathervane_enabled() == true) && (pos_sp_triplet->current.disable_weather_vane == false)) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Handle Loiter/Delay Timeout if the waypoint position and yaw setpoint got reached\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tbool time_inside_reached = false;\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n\t\t\ttime_inside_reached = true;\n\t\t}\n\n\t\t// check if course for exit is reached (only applies for fixed-wing flight)\n\t\tbool exit_course_reached = false;\n\n\t\tif (time_inside_reached) {\n\n\t\t\tstruct position_setpoint_s *curr_sp_new = &_navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float dist_current_next = get_distance_to_next_waypoint(curr_sp_new->lat, curr_sp_new->lon, next_sp.lat,\n\t\t\t\t\t\t\tnext_sp.lon);\n\n\t\t\t/* enforce exit course if in FW, the next wp is valid, the vehicle is currently loitering and either having force_heading set,\n\t\t\t   or if loitering to achieve altitdue at a NAV_CMD_WAYPOINT */\n\t\t\tconst bool enforce_exit_course = _navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t\t && next_sp.valid\n\t\t\t\t\t\t\t && curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t\t\t\t\t\t && (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n\n\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint\n\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.2f * curr_sp_new->loiter_radius;\n\n\t\t\tif (enforce_exit_course && exit_course_is_reachable) {\n\n\t\t\t\tfloat vehicle_position_to_next_waypoint_north;\n\t\t\t\tfloat vehicle_position_to_next_waypoint_east;\n\t\t\t\tget_vector_to_next_waypoint(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon, next_sp.lat,\n\t\t\t\t\t\t\t    next_sp.lon, &vehicle_position_to_next_waypoint_north,  &vehicle_position_to_next_waypoint_east);\n\n\t\t\t\t// this vector defines the exit bearing\n\t\t\t\tconst matrix::Vector2f vector_vehicle_position_to_next_waypoint = {vehicle_position_to_next_waypoint_north, vehicle_position_to_next_waypoint_east};\n\n\t\t\t\tconst matrix::Vector2f vehicle_ground_velocity = {_navigator->get_local_position()->vx, _navigator->get_local_position()->vy};\n\n\t\t\t\texit_course_reached = vector_vehicle_position_to_next_waypoint.dot(vehicle_ground_velocity) >\n\t\t\t\t\t\t      vector_vehicle_position_to_next_waypoint.norm() * vehicle_ground_velocity.norm() * kCosineExitCourseThreshold;\n\n\t\t\t} else {\n\t\t\t\texit_course_reached = true;\n\t\t\t}\n\t\t}\n\n\t\t// set exit flight course to next waypoint\n\t\tif (exit_course_reached) {\n\t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float range = get_distance_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t// exit xtrack location\n\t\t\t// reset lat/lon of loiter waypoint so vehicle follows a tangent\n\t\t\tif (_mission_item.loiter_exit_xtrack && next_sp.valid && PX4_ISFINITE(range) &&\n\t\t\t    (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t     _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT)) {\n\n\t\t\t\tfloat bearing = get_bearing_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t\t// calculate (positive) angle between current bearing vector (orbit center to next waypoint) and vector pointing to tangent exit location\n\t\t\t\tconst float ratio = math::min(fabsf(curr_sp.loiter_radius / range), 1.0f);\n\t\t\t\tfloat inner_angle = acosf(ratio);\n\n\t\t\t\t// Compute \"ideal\" tangent origin\n\t\t\t\tif (curr_sp.loiter_direction_counter_clockwise) {\n\t\t\t\t\tbearing += inner_angle;\n\n\t\t\t\t} else {\n\t\t\t\t\tbearing -= inner_angle;\n\t\t\t\t}\n\n\t\t\t\t// set typ to position, will get set to loiter in the fw position controller once close\n\t\t\t\t// and replace current setpoint lat/lon with tangent coordinate\n\t\t\t\tcurr_sp.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\twaypoint_from_heading_and_distance(curr_sp.lat, curr_sp.lon,\n\t\t\t\t\t\t\t\t   bearing, fabsf(curr_sp.loiter_radius),\n\t\t\t\t\t\t\t\t   &curr_sp.lat, &curr_sp.lon);\n\t\t\t}\n\n\t\t\treturn true; // mission item is reached\n\t\t}\n\t}\n\n\treturn false;\n}"
    }
  },
  "21594": {
    "Mission::find_mission_land_start": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::find_mission_land_start()\n{\n\t/* return true if a MAV_CMD_DO_LAND_START, NAV_CMD_VTOL_LAND or NAV_CMD_LAND is found and internally save the index\n\t *  return false if not found\n\t */\n\n\tconst dm_item_t dm_current = (dm_item_t)_mission.dataman_id;\n\tstruct mission_item_s missionitem = {};\n\tstruct mission_item_s missionitem_prev = {}; //to store mission item before currently checked on, needed to get pos of wp before NAV_CMD_DO_LAND_START\n\n\t_land_start_available = false;\n\n\tbool found_land_start_marker = false;\n\n\tfor (size_t i = 1; i < _mission.count; i++) {\n\t\tmissionitem_prev = missionitem; // store the last mission item before reading a new one\n\n\t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&missionitem),\n\t\t\t\t\t\t\tsizeof(mission_item_s), 500_ms);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tPX4_ERR(\"dataman read failure\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (missionitem.nav_cmd == NAV_CMD_DO_LAND_START) {\n\t\t\tfound_land_start_marker = true;\n\t\t}\n\n\t\tif (found_land_start_marker && !_land_start_available && item_contains_position(missionitem)) {\n\t\t\t// use the position of any waypoint after the land start marker which specifies a position.\n\t\t\t_landing_start_lat = missionitem.lat;\n\t\t\t_landing_start_lon = missionitem.lon;\n\t\t\t_landing_start_alt = missionitem.altitude_is_relative ?\tmissionitem.altitude +\n\t\t\t\t\t     _navigator->get_home_position()->alt : missionitem.altitude;\n\t\t\t_landing_loiter_radius = (PX4_ISFINITE(missionitem.loiter_radius)\n\t\t\t\t\t\t  && fabsf(missionitem.loiter_radius) > FLT_EPSILON) ? fabsf(missionitem.loiter_radius) :\n\t\t\t\t\t\t _navigator->get_loiter_radius();\n\t\t\t_land_start_available = true;\n\t\t\t_land_start_index = i; // set it to the first item containing a position after the land start marker was found\n\t\t}\n\n\t\tif (((missionitem.nav_cmd == NAV_CMD_VTOL_LAND) && _navigator->get_vstatus()->is_vtol) ||\n\t\t    (missionitem.nav_cmd == NAV_CMD_LAND)) {\n\n\t\t\t_landing_lat = missionitem.lat;\n\t\t\t_landing_lon = missionitem.lon;\n\t\t\t_landing_alt = missionitem.altitude_is_relative ?\tmissionitem.altitude + _navigator->get_home_position()->alt :\n\t\t\t\t       missionitem.altitude;\n\n\t\t\t// don't have a valid land start yet, use the landing item itself then\n\t\t\tif (!_land_start_available) {\n\t\t\t\t_land_start_index = i;\n\t\t\t\t_landing_start_lat = _landing_lat;\n\t\t\t\t_landing_start_lon = _landing_lon;\n\t\t\t\t_landing_start_alt = _landing_alt;\n\t\t\t\t_land_start_available = true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn _land_start_available;\n}"
    },
    "Mission::index_closest_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::index_closest_mission_item()\n{\n\tint32_t min_dist_index(0);\n\tfloat min_dist(FLT_MAX), dist_xy(FLT_MAX), dist_z(FLT_MAX);\n\n\tdm_item_t dm_current = (dm_item_t)(_mission.dataman_id);\n\n\tfor (size_t i = 0; i < _mission.count; i++) {\n\t\tstruct mission_item_s missionitem = {};\n\n\t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&missionitem),\n\t\t\t\t\t\t\tsizeof(mission_item_s), 500_ms);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tPX4_ERR(\"dataman read failure\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (item_contains_position(missionitem)) {\n\t\t\t// do not consider land waypoints for a fw\n\t\t\tif (!((missionitem.nav_cmd == NAV_CMD_LAND) &&\n\t\t\t      (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) &&\n\t\t\t      (!_navigator->get_vstatus()->is_vtol))) {\n\t\t\t\tfloat dist = get_distance_to_point_global_wgs84(missionitem.lat, missionitem.lon,\n\t\t\t\t\t\tget_absolute_altitude_for_item(missionitem),\n\t\t\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t\tmin_dist_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// for mission reverse also consider the home position\n\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\tfloat dist = get_distance_to_point_global_wgs84(\n\t\t\t\t     _navigator->get_home_position()->lat,\n\t\t\t\t     _navigator->get_home_position()->lon,\n\t\t\t\t     _navigator->get_home_position()->alt,\n\t\t\t\t     _navigator->get_global_position()->lat,\n\t\t\t\t     _navigator->get_global_position()->lon,\n\t\t\t\t     _navigator->get_global_position()->alt,\n\t\t\t\t     &dist_xy, &dist_z);\n\n\t\tif (dist < min_dist) {\n\t\t\tmin_dist = dist;\n\t\t\tmin_dist_index = -1;\n\t\t}\n\t}\n\n\treturn min_dist_index;\n}"
    },
    "Mission::publish_navigator_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "void Mission::publish_navigator_mission_item()\n{\n\tnavigator_mission_item_s navigator_mission_item{};\n\n\tnavigator_mission_item.instance_count = _navigator->mission_instance_count();\n\tnavigator_mission_item.sequence_current = _current_mission_index;\n\tnavigator_mission_item.nav_cmd = _mission_item.nav_cmd;\n\tnavigator_mission_item.latitude = _mission_item.lat;\n\tnavigator_mission_item.longitude = _mission_item.lon;\n\tnavigator_mission_item.altitude = _mission_item.altitude;\n\n\tnavigator_mission_item.time_inside = get_time_inside(_mission_item);\n\tnavigator_mission_item.acceptance_radius = _mission_item.acceptance_radius;\n\tnavigator_mission_item.loiter_radius = _mission_item.loiter_radius;\n\tnavigator_mission_item.yaw = _mission_item.yaw;\n\n\tnavigator_mission_item.frame = _mission_item.frame;\n\tnavigator_mission_item.frame = _mission_item.origin;\n\n\tnavigator_mission_item.loiter_exit_xtrack = _mission_item.loiter_exit_xtrack;\n\tnavigator_mission_item.force_heading = _mission_item.force_heading;\n\tnavigator_mission_item.altitude_is_relative = _mission_item.altitude_is_relative;\n\tnavigator_mission_item.autocontinue = _mission_item.autocontinue;\n\tnavigator_mission_item.vtol_back_transition = _mission_item.vtol_back_transition;\n\n\tnavigator_mission_item.timestamp = hrt_absolute_time();\n\n\t_navigator_mission_item_pub.publish(navigator_mission_item);\n}"
    },
    "Mission::advance_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::advance_mission()\n{\n\t/* do not advance mission item if we're processing sub mission work items */\n\tif (_work_item_type != WORK_ITEM_TYPE_DEFAULT) {\n\t\treturn;\n\t}\n\n\tswitch (_mission_type) {\n\tcase MISSION_TYPE_MISSION:\n\t\tswitch (_mission_execution_mode) {\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_NORMAL:\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_FAST_FORWARD: {\n\t\t\t\t_current_mission_index++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase mission_result_s::MISSION_EXECUTION_MODE_REVERSE: {\n\t\t\t\t// find next position item in reverse order\n\t\t\t\tdm_item_t dm_current = (dm_item_t)(_mission.dataman_id);\n\n\t\t\t\tfor (int32_t i = _current_mission_index - 1; i >= 0; i--) {\n\t\t\t\t\tstruct mission_item_s missionitem = {};\n\n\t\t\t\t\tbool success = _dataman_cache.loadWait(dm_current, i, reinterpret_cast<uint8_t *>(&missionitem),\n\t\t\t\t\t\t\t\t\t       sizeof(mission_item_s), 100_ms);\n\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\t\t\t\tPX4_ERR(\"dataman read failure\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item_contains_position(missionitem)) {\n\t\t\t\t\t\t_current_mission_index = i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// finished flying back the mission\n\t\t\t\t_current_mission_index = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t_current_mission_index++;\n\t\t}\n\n\t\tbreak;\n\n\tcase MISSION_TYPE_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n}"
    },
    "Geofence::loadFromFile": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Geofence::loadFromFile(const char *filename)\n{\n\tFILE *fp;\n\tchar line[120];\n\tint pointCounter = 0;\n\tbool gotVertical = false;\n\tconst char commentChar = '#';\n\tint ret_val = PX4_ERROR;\n\n\t/* Make sure no data is left in the datamanager */\n\tclearDm();\n\n\t/* open the mixer definition file */\n\tfp = fopen(GEOFENCE_FILENAME, \"r\");\n\n\tif (fp == nullptr) {\n\t\treturn PX4_ERROR;\n\t}\n\n\t/* create geofence points from valid lines and store in DM */\n\tfor (;;) {\n\t\t/* get a line, bail on error/EOF */\n\t\tif (fgets(line, sizeof(line), fp) == nullptr) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Trim leading whitespace */\n\t\tsize_t textStart = 0;\n\n\t\twhile ((textStart < sizeof(line) / sizeof(char)) && isspace(line[textStart])) { textStart++; }\n\n\t\t/* if the line starts with #, skip */\n\t\tif (line[textStart] == commentChar) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if there is only a linefeed, skip it */\n\t\tif (line[0] == '\\n') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (gotVertical) {\n\t\t\t/* Parse the line as a geofence point */\n\t\t\tmission_fence_point_s vertex{};\n\t\t\tvertex.frame = NAV_FRAME_GLOBAL;\n\t\t\tvertex.nav_cmd = NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION;\n\t\t\tvertex.vertex_count = 0; // this will be filled in a second pass\n\t\t\tvertex.alt = 0; // alt is not used\n\n\t\t\t/* if the line starts with DMS, this means that the coordinate is given as degree minute second instead of decimal degrees */\n\t\t\tif (line[textStart] == 'D' && line[textStart + 1] == 'M' && line[textStart + 2] == 'S') {\n\t\t\t\t/* Handle degree minute second format */\n\t\t\t\tdouble lat_d, lat_m, lat_s, lon_d, lon_m, lon_s;\n\n\t\t\t\tif (sscanf(line, \"DMS %lf %lf %lf %lf %lf %lf\", &lat_d, &lat_m, &lat_s, &lon_d, &lon_m, &lon_s) != 6) {\n\t\t\t\t\tPX4_ERR(\"Scanf to parse DMS geofence vertex failed.\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n//\t\t\t\tPX4_INFO(\"Geofence DMS: %.5lf %.5lf %.5lf ; %.5lf %.5lf %.5lf\", lat_d, lat_m, lat_s, lon_d, lon_m, lon_s);\n\n\t\t\t\tvertex.lat = lat_d + lat_m / 60.0 + lat_s / 3600.0;\n\t\t\t\tvertex.lon = lon_d + lon_m / 60.0 + lon_s / 3600.0;\n\n\t\t\t} else {\n\t\t\t\t/* Handle decimal degree format */\n\t\t\t\tif (sscanf(line, \"%lf %lf\", &vertex.lat, &vertex.lon) != 2) {\n\t\t\t\t\tPX4_ERR(\"Scanf to parse geofence vertex failed.\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, pointCounter + 1, reinterpret_cast<uint8_t *>(&vertex),\n\t\t\t\t\tsizeof(vertex));\n\n\t\t\tif (!success) {\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tPX4_INFO(\"Geofence: point: %d, lat %.5lf: lon: %.5lf\", pointCounter, vertex.lat, vertex.lon);\n\n\t\t\tpointCounter++;\n\n\t\t} else {\n\t\t\t/* Parse the line as the vertical limits */\n\t\t\tif (sscanf(line, \"%f %f\", &_altitude_min, &_altitude_max) != 2) {\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tPX4_INFO(\"Geofence: alt min: %.4f, alt_max: %.4f\", (double)_altitude_min, (double)_altitude_max);\n\t\t\tgotVertical = true;\n\t\t}\n\t}\n\n\n\t/* Check if import was successful */\n\tif (gotVertical && pointCounter > 2) {\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Geofence imported\\t\");\n\t\tevents::send(events::ID(\"navigator_geofence_imported\"), events::Log::Info, \"Geofence imported\");\n\t\tret_val = PX4_ERROR;\n\n\t\t/* do a second pass, now that we know the number of vertices */\n\t\tfor (int seq = 1; seq <= pointCounter; ++seq) {\n\t\t\tmission_fence_point_s mission_fence_point;\n\n\t\t\tbool success = _dataman_client.readSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t\t\tsizeof(mission_fence_point_s));\n\n\t\t\tif (success) {\n\t\t\t\tmission_fence_point.vertex_count = pointCounter;\n\t\t\t\t_dataman_client.writeSync(DM_KEY_FENCE_POINTS, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t\t  sizeof(mission_fence_point_s));\n\t\t\t}\n\t\t}\n\n\t\tmission_stats_entry_s stats;\n\t\tstats.num_items = pointCounter;\n\t\tstats.update_counter = _update_counter + 1;\n\n\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS, 0, reinterpret_cast<uint8_t *>(&stats),\n\t\t\t\tsizeof(mission_stats_entry_s));\n\n\t\tif (success) {\n\t\t\tret_val = PX4_OK;\n\t\t}\n\n\t} else {\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence: import error\\t\");\n\t\tevents::send(events::ID(\"navigator_geofence_import_failed\"), events::Log::Error, \"Geofence: import error\");\n\t}\n\n\tupdateFence();\n\nerror:\n\tfclose(fp);\n\treturn ret_val;\n}"
    },
    "updateFence": {
      "file": "src/modules/navigator/geofence.h",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "*/\n\tvoid updateFence();\n\n\t/**\n\t * Return whether the system obeys the geofence.\n\t *\n\t * @return true: system is obeying fence, false: system is violating fence\n\t */\n\tbool check(const vehicle_global_position_s &global_position, const sensor_gps_s &gps_position);\n\n\t/**\n\t * Return whether a mission item obeys the geofence.\n\t *\n\t * @return true: system is obeying fence, false: system is violating fence\n\t */\n\tbool check(const struct mission_item_s &mission_item);\n\n\t/**\n\t * Check if a point passes the Geofence test.\n\t * In addition to checkPolygons(), this takes all additional parameters into account.\n\t *\n\t * @return false for a geofence violation\n\t */\n\tbool checkAll(double lat, double lon, float altitude);\n\n\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n\n\tbool isBelowMaxAltitude(float altitude);\n\n\tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n\n\tint clearDm();\n\n\tbool valid();\n\n\t/**\n\t * Load a single inclusion polygon, replacing any already existing polygons.\n\t * The file has one of the following formats:\n\t * - Decimal Degrees:\n\t * 0 900\n\t * 47.475273548913222 8.52672100067138672\n\t * 47.4608261578541359 8.53414535522460938\n\t * 47.4613484218861217 8.56444358825683594\n\t * 47.4830758091035534 8.53470325469970703\n\t *\n\t * - Degree-Minute-Second:\n\t * 0 900\n\t * DMS -26 -34 -10.4304 151 50 14.5428\n\t * DMS -26 -34 -11.8416 151 50 21.8580\n\t * DMS -26 -34 -36.5628 151 50 28.1112\n\t * DMS -26 -34 -37.1640 151 50 24.1620\n\t *\n\t * Where the first line is min, max altitude in meters AMSL.\n\t */\n\tint loadFromFile(const char *filename);\n\n\tbool isEmpty() { return (!_fence_updated || (_num_polygons == 0)); }"
    },
    "Mission::update_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::update_mission()\n{\n\n\tbool failed = true;\n\n\t_dataman_cache.invalidate();\n\t_load_mission_index = -1;\n\n\t/* Reset vehicle_roi\n\t * Missions that do not explicitly configure ROI would not override\n\t * an existing ROI setting from previous missions */\n\t_navigator->reset_vroi();\n\n\tconst mission_s old_mission = _mission;\n\n\tif (_mission_sub.copy(&_mission)) {\n\n\t\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&_mission),\n\t\t\t\tsizeof(mission_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"Can't update mission state in Dataman\");\n\t\t}\n\n\t\t/* determine current index */\n\t\tif (_mission.current_seq >= 0 && _mission.current_seq < (int)_mission.count) {\n\t\t\t_current_mission_index = _mission.current_seq;\n\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_mission_index >= (int)_mission.count) {\n\t\t\t\t_current_mission_index = 0;\n\n\t\t\t} else if (_current_mission_index < 0) {\n\t\t\t\t/* if not initialized, set it to 0 */\n\t\t\t\t_current_mission_index = 0;\n\t\t\t}\n\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\tif (old_mission.mission_update_counter != _mission.mission_update_counter) {\n\t\t\tcheck_mission_valid(true);\n\n\t\t\tfailed = !_navigator->get_mission_result()->valid;\n\n\t\t\tif (!failed) {\n\t\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t\t_navigator->get_mission_result()->failure = false;\n\n\t\t\t\t/* reset sequence info as well */\n\t\t\t\t_navigator->get_mission_result()->seq_reached = -1;\n\t\t\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\n\t\t\t\t/* reset work item if new mission has been accepted */\n\t\t\t\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t_mission_changed = true;\n\t\t\t}\n\n\t\t\t/* check if the mission waypoints changed while the vehicle is in air\n\t\t\t * TODO add a flag to mission_s which actually tracks if the position of the waypoint changed */\n\t\t\tif (((_mission.count != old_mission.count) ||\n\t\t\t     (_mission.dataman_id != old_mission.dataman_id)) &&\n\t\t\t    !_navigator->get_land_detected()->landed) {\n\t\t\t\t_mission_waypoints_changed = true;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tPX4_ERR(\"mission update failed\");\n\t}\n\n\tif (failed) {\n\t\t// only warn if the check failed on merit\n\t\tif ((int)_mission.count > 0) {\n\t\t\tPX4_WARN(\"mission check failed\");\n\t\t}\n\n\t\t// reset the mission\n\t\t_mission.count = 0;\n\t\t_mission.current_seq = 0;\n\t\t_current_mission_index = 0;\n\t}\n\n\t// we start from the first item so can reset the cache\n\tif (_current_mission_index == 0) {\n\t\tresetItemCache();\n\t}\n\n\t// reset as when we update mission we don't want to proceed at previous index\n\t_inactivation_index = -1;\n\n\t// find and store landing start marker (if available)\n\tfind_mission_land_start();\n\n\tset_current_mission_item();\n}"
    },
    "Mission::save_mission_state": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::save_mission_state()\n{\n\tif (_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t// Save only while disarmed, as this is a blocking operation\n\t\t_need_mission_save = true;\n\t\treturn;\n\t}\n\n\t_need_mission_save = false;\n\tmission_s mission_state = {};\n\n\t/* read current state */\n\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\tsizeof(mission_s));\n\n\tif (success) {\n\t\t/* data read successfully, check dataman ID and items count */\n\t\tif (mission_state.dataman_id == _mission.dataman_id && mission_state.count == _mission.count) {\n\t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n\t\t\tif (mission_state.current_seq != _current_mission_index) {\n\t\t\t\tmission_state.current_seq = _current_mission_index;\n\t\t\t\tmission_state.timestamp = hrt_absolute_time();\n\n\t\t\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\t\t\tif (!success) {\n\n\t\t\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* invalid data, this must not happen and indicates error in mission publisher */\n\t\tmission_state.timestamp = hrt_absolute_time();\n\t\tmission_state.dataman_id = _mission.dataman_id;\n\t\tmission_state.count = _mission.count;\n\t\tmission_state.current_seq = _current_mission_index;\n\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Invalid mission state.\\t\");\n\t\t/* EVENT\n\t\t * @description No mission or storage failure\n\t\t */\n\t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Error, \"Invalid mission state\");\n\n\t\t/* write modified state only if changed */\n\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\tif (!success) {\n\n\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t}\n\t}\n}"
    },
    "Mission::check_mission_valid": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::check_mission_valid(bool force)\n{\n\tif ((!_home_inited && _navigator->home_global_position_valid()) || force) {\n\n\t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator, _dataman_client);\n\n\t\t_navigator->get_mission_result()->valid =\n\t\t\t_missionFeasibilityChecker.checkMissionFeasible(_mission);\n\n\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\t\t_home_inited = _navigator->home_global_position_valid();\n\n\t\t// find and store landing start marker (if available)\n\t\tfind_mission_land_start();\n\t}\n}"
    },
    "Geofence::Geofence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Geofence::Geofence(Navigator *navigator) :\n\tModuleParams(navigator),\n\t_navigator(navigator),\n\t_sub_airdata(ORB_ID(vehicle_air_data))\n{\n\tif (_navigator != nullptr) {\n\t\tupdateFence();\n\t}\n}"
    },
    "index_closest_mission_item": {
      "file": "src/modules/navigator/mission.h",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "*/\n\tint32_t index_closest_mission_item();\n\n\tbool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;\n\n\tvoid publish_navigator_mission_item();\n\n\n\t/**\n\t* @brief Get the index associated with the last item that contains a position\n\t* @param mission The mission to search\n\t* @param start_index The index to start searching from\n\t* @param prev_pos_index The index of the previous position item containing a position\n\t* @return true if a previous position item was found\n\t*/\n\tbool getPreviousPositionItemIndex(const mission_s &mission, int start_index, unsigned &prev_pos_index) const;\n\n\t/**\n\t * @brief Get the next item after start_index that contains a position\n\t *\n\t * @param mission The mission to search\n\t * @param start_index The index to start searching from\n\t * @param mission_item The mission item to populate\n\t * @return true if successful\n\t */\n\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item);\n\n\t/**\n\t * @brief Cache the mission items containing gimbal, camera mode and trigger commands\n\t *\n\t * @param mission_item The mission item to cache if applicable\n\t */\n\tvoid cacheItem(const mission_item_s &mission_item);\n\n\t/**\n\t * @brief Update the cached items up to the given index\n\t *\n\t * @param end_index The index to update up to\n\t */\n\tvoid updateCachedItemsUpToIndex(int end_index);\n\n\t/**\n\t * @brief Replay the cached gimbal and camera mode items\n\t */\n\tvoid replayCachedGimbalCameraItems();\n\n\t/**\n\t * @brief Replay the cached trigger items\n\t *\n\t */\n\tvoid replayCachedTriggerItems();\n\n\t/**\n\t * @brief Reset the item cache\n\t */\n\tvoid resetItemCache();\n\n\t/**\n\t * @brief Check if there are cached gimbal or camera mode items to be replayed\n\t *\n\t * @return true if there are cached items\n\t */\n\tbool haveCachedGimbalOrCameraItems();\n\n\t/**\n\t * @brief Check if the camera was triggering\n\t *\n\t * @return true if there was a camera trigger command in the cached items that didn't disable triggering\n\t */\n\tbool cameraWasTriggering();\n\n\tDEFINE_PARAMETERS(\n\t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n\t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n\t)\n\n\tuORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item}"
    },
    "Geofence::isBelowMaxAltitude": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Geofence::isBelowMaxAltitude(float altitude)\n{\n\tbool inside_fence = true;\n\n\tif (isHomeRequired() && _navigator->home_alt_valid()) {\n\n\t\tconst float max_vertical_distance = _param_gf_max_ver_dist.get();\n\t\tconst float home_alt = _navigator->get_home_position()->alt;\n\n\t\tfloat dist_z = altitude - home_alt;\n\n\t\tif (max_vertical_distance > FLT_EPSILON && (dist_z > max_vertical_distance)) {\n\t\t\tif (hrt_elapsed_time(&_last_vertical_range_warning) > GEOFENCE_RANGE_WARNING_LIMIT) {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Maximum altitude above home reached (%.5f)\\t\",\n\t\t\t\t\t\t     (double)max_vertical_distance);\n\t\t\t\tevents::send<float>(events::ID(\"navigator_geofence_max_alt_from_home\"), {events::Log::Critical, events::LogInternal::Warning},\n\t\t\t\t\t\t    \"Geofence: maximum altitude above home reached ({1:.0m_v})\",\n\t\t\t\t\t\t    max_vertical_distance);\n\t\t\t\t_last_vertical_range_warning = hrt_absolute_time();\n\t\t\t}\n\n\t\t\tinside_fence = false;\n\t\t}\n\t}\n\n\treturn inside_fence;\n}"
    },
    "Geofence::insideCircle": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon, float altitude)\n{\n\n\tmission_fence_point_s circle_point{};\n\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index,\n\t\t\t\t\t       reinterpret_cast<uint8_t *>(&circle_point), sizeof(mission_fence_point_s));\n\n\tif (!success) {\n\t\tPX4_ERR(\"dm_read failed\");\n\t\treturn false;\n\t}\n\n\tif (circle_point.frame != NAV_FRAME_GLOBAL && circle_point.frame != NAV_FRAME_GLOBAL_INT\n\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n\t\t// TODO: handle different frames\n\t\tPX4_ERR(\"Frame type %i not supported\", (int)circle_point.frame);\n\t\treturn false;\n\t}\n\n\tif (!_projection_reference.isInitialized()) {\n\t\t_projection_reference.initReference(lat, lon);\n\t}\n\n\tfloat x1, y1, x2, y2;\n\t_projection_reference.project(lat, lon, x1, y1);\n\t_projection_reference.project(circle_point.lat, circle_point.lon, x2, y2);\n\tfloat dx = x1 - x2, dy = y1 - y2;\n\treturn dx * dx + dy * dy < circle_point.circle_radius * circle_point.circle_radius;\n}"
    },
    "Copyright": {
      "file": "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp",
      "commit": "99824c445c00580b60995fc4c8ecfc848c1bd0d5",
      "source": "/****************************************************************************\n *\n *   Copyright (c) 2021 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n/**\n * @file dataman_mocks.h\n * Provides a minimal dataman implementation to compile against for testing\n *\n * @author Roman Bapst\n * @author Julian Kent\n */\n#pragma once\n\n#include <dataman/dataman.h>\nextern \"C\" {\n\t__EXPORT ssize_t\n\tdm_read(\n\t\tdm_item_t item,\t\t\t/* The item type to retrieve */\n\t\tunsigned index,\t\t\t/* The index of the item */\n\t\tvoid *buffer,\t\t\t/* Pointer to caller data buffer */\n\t\tsize_t buflen\t\t\t/* Length in bytes of data to retrieve */\n\t) {return 0;};\n\n\t/** write to the data manager store */\n\t__EXPORT ssize_t\n\tdm_write(\n\t\tdm_item_t  item,\t\t/* The item type to store */\n\t\tunsigned index,\t\t\t/* The index of the item */\n\t\tconst void *buffer,\t\t/* Pointer to caller data buffer */\n\t\tsize_t buflen\t\t\t/* Length in bytes of data to retrieve */\n\t) {return 0;};\n\n\t/**\n\t * Lock all items of a type. Can be used for atomic updates of multiple items (single items are always updated\n\t * atomically).\n\t * Note that this lock is independent from dm_read & dm_write calls.\n\t * @return 0 on success and lock taken, -1 on error (lock not taken, errno set)\n\t */\n\t__EXPORT int\n\tdm_lock(\n\t\tdm_item_t item\t\t\t/* The item type to lock */\n\t) {return 0;};\n\n\t/**\n\t * Try to lock all items of a type (@see sem_trywait()).\n\t * @return 0 if lock is taken, -1 otherwise (on error or if already locked. errno is set accordingly)\n\t */\n\t__EXPORT int\n\tdm_trylock(\n\t\tdm_item_t item\t\t\t/* The item type to lock */\n\t) {return 0;};\n\n\t/** Unlock all items of a type */\n\t__EXPORT void\n\tdm_unlock(\n\t\tdm_item_t item\t\t\t/* The item type to unlock */\n\t) {};\n\n\t/** Erase all items of this type */\n\t__EXPORT int\n\tdm_clear(\n\t\tdm_item_t item\t\t\t/* The item type to clear */\n\t) {return 0;};\n}"
    },
    "Mission::need_to_reset_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::need_to_reset_mission()\n{\n\t// reset mission when disarmed, mission was actually started and we reached the last mission item\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED && _need_mission_reset\n\t    && (_current_mission_index == _mission.count - 1)) {\n\t\t_need_mission_reset = false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
    },
    "Geofence::updateFence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "void Geofence::updateFence()\n{\n\t_initiate_fence_updated = true;\n}"
    },
    "type": {
      "file": "src/modules/navigator/GeofenceBreachAvoidance/dataman_mocks.hpp",
      "commit": "99824c445c00580b60995fc4c8ecfc848c1bd0d5",
      "source": "/**\n\t * Try to lock all items of a type (@see sem_trywait()).\n\t * @return 0 if lock is taken, -1 otherwise (on error or if already locked. errno is set accordingly)\n\t */\n\t__EXPORT int\n\tdm_trylock(\n\t\tdm_item_t item\t\t\t/* The item type to lock */\n\t) {return 0;}"
    },
    "_missionFeasibilityChecker": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "if ((!_home_inited && _navigator->home_global_position_valid()) || force) {\n\n\t\tMissionFeasibilityChecker _missionFeasibilityChecker(_navigator, _dataman_client);\n\n\t\t_navigator->get_mission_result()->valid =\n\t\t\t_missionFeasibilityChecker.checkMissionFeasible(_mission);\n\n\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\t\t_home_inited = _navigator->home_global_position_valid();\n\n\t\t// find and store landing start marker (if available)\n\t\tfind_mission_land_start();\n\t}\n}\n\nvoid\nMission::reset_mission(struct mission_s &mission)\n{\n\tif (_dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission), sizeof(mission_s))) {\n\t\tif (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) {\n\t\t\t/* set current item to 0 */\n\t\t\tmission.current_seq = 0;\n\n\t\t\t/* reset jump counters */\n\t\t\tif (mission.count > 0) {\n\t\t\t\tconst dm_item_t dataman_id = (dm_item_t)mission.dataman_id;\n\n\t\t\t\tfor (unsigned index = 0; index < mission.count; index++) {\n\t\t\t\t\tstruct mission_item_s item;\n\t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t\t\t\tbool success = _dataman_client.readSync(dataman_id, index, reinterpret_cast<uint8_t *>(&item), sizeof(mission_item_s),\n\t\t\t\t\t\t\t\t\t\t500_ms);\n\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\t\t\t\titem.do_jump_current_count = 0;\n\n\t\t\t\t\t\tsuccess = _dataman_client.writeSync(dataman_id, index, reinterpret_cast<uint8_t *>(&item), len);\n\n\t\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Could not read mission.\\t\");\n\t\t\tevents::send(events::ID(\"mission_cannot_read_mission\"), events::Log::Error, \"Could not read mission\");\n\n\t\t\t/* initialize mission state in dataman */\n\t\t\tmission.timestamp = hrt_absolute_time();\n\t\t\tmission.dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n\t\t\tmission.count = 0;\n\t\t\tmission.current_seq = 0;\n\t\t}\n\n\t\t_dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission), sizeof(mission_s));\n\t}\n}"
    },
    "getNextPositionMissionItem": {
      "file": "src/modules/navigator/mission.h",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "*/\n\tbool getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item);\n\n\t/**\n\t * @brief Cache the mission items containing gimbal, camera mode and trigger commands\n\t *\n\t * @param mission_item The mission item to cache if applicable\n\t */\n\tvoid cacheItem(const mission_item_s &mission_item);\n\n\t/**\n\t * @brief Update the cached items up to the given index\n\t *\n\t * @param end_index The index to update up to\n\t */\n\tvoid updateCachedItemsUpToIndex(int end_index);\n\n\t/**\n\t * @brief Replay the cached gimbal and camera mode items\n\t */\n\tvoid replayCachedGimbalCameraItems();\n\n\t/**\n\t * @brief Replay the cached trigger items\n\t *\n\t */\n\tvoid replayCachedTriggerItems();\n\n\t/**\n\t * @brief Reset the item cache\n\t */\n\tvoid resetItemCache();\n\n\t/**\n\t * @brief Check if there are cached gimbal or camera mode items to be replayed\n\t *\n\t * @return true if there are cached items\n\t */\n\tbool haveCachedGimbalOrCameraItems();\n\n\t/**\n\t * @brief Check if the camera was triggering\n\t *\n\t * @return true if there was a camera trigger command in the cached items that didn't disable triggering\n\t */\n\tbool cameraWasTriggering();\n\n\tDEFINE_PARAMETERS(\n\t\t(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,\n\t\t(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl\n\t)\n\n\tuORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item}"
    },
    "Mission::cameraWasTriggering": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Mission::cameraWasTriggering()\n{\n\treturn (_last_camera_trigger_item.nav_cmd == NAV_CMD_DO_TRIGGER_CONTROL\n\t\t&& (int)(_last_camera_trigger_item.params[0] + 0.5f) == 1) ||\n\t       (_last_camera_trigger_item.nav_cmd == NAV_CMD_IMAGE_START_CAPTURE) ||\n\t       (_last_camera_trigger_item.nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST\n\t\t&& _last_camera_trigger_item.params[0] > FLT_EPSILON);\n}"
    },
    "Mission::on_inactive": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::on_inactive()\n{\n\t/* Without home a mission can't be valid yet anyway, let's wait. */\n\tif (!_navigator->home_global_position_valid()) {\n\t\treturn;\n\t}\n\n\tif (_need_mission_save && _navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\tsave_mission_state();\n\t}\n\n\tif (_inited) {\n\t\tif (_mission_sub.updated()) {\n\t\t\tupdate_mission();\n\n\t\t\tif (_mission_type == MISSION_TYPE_NONE && _mission.count > 0) {\n\t\t\t\t_mission_type = MISSION_TYPE_MISSION;\n\t\t\t}\n\t\t}\n\n\t\t/* reset the current mission if needed */\n\t\tif (need_to_reset_mission()) {\n\t\t\treset_mission(_mission);\n\t\t\t_navigator->reset_cruising_speed();\n\t\t\t_current_mission_index = 0;\n\t\t\t_navigator->reset_vroi();\n\t\t\tset_current_mission_item();\n\t\t}\n\n\t} else {\n\n\t\t/* load missions from storage */\n\t\tmission_s mission_state = {};\n\n\t\t/* read current state */\n\t\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t\tsizeof(mission_s));\n\n\t\tif (success) {\n\t\t\t_mission.dataman_id = mission_state.dataman_id;\n\t\t\t_mission.count = mission_state.count;\n\t\t\t_current_mission_index = mission_state.current_seq;\n\n\t\t\t// find and store landing start marker (if available)\n\t\t\tfind_mission_land_start();\n\t\t}\n\n\t\t/* On init let's check the mission, maybe there is already one available. */\n\t\tcheck_mission_valid(false);\n\n\t\t_inited = true;\n\t}\n\n\t/* require takeoff after non-loiter or landing */\n\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n\t\t_need_takeoff = true;\n\t}\n\n\t/* reset so current mission item gets restarted if mission was paused */\n\t_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* reset so MISSION_ITEM_REACHED isn't published */\n\t_navigator->get_mission_result()->seq_reached = -1;\n}"
    },
    "Mission::Mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::Mission(Navigator *navigator) :\n\tMissionBlock(navigator),\n\tModuleParams(navigator)\n{\n\tmission_init();\n}"
    },
    "Geofence::insidePolygon": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon, float altitude)\n{\n\t/**\n\t * Adaptation of algorithm originally presented as\n\t * PNPOLY - Point Inclusion in Polygon Test\n\t * W. Randolph Franklin (WRF)\n\t * Only supports non-complex polygons (not self intersecting)\n\t */\n\n\tmission_fence_point_s temp_vertex_i{};\n\tmission_fence_point_s temp_vertex_j{};\n\tbool c = false;\n\n\tfor (unsigned i = 0, j = polygon.vertex_count - 1; i < polygon.vertex_count; j = i++) {\n\n\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index + i,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&temp_vertex_i), sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsuccess = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, polygon.dataman_index + j,\n\t\t\t\t\t\t  reinterpret_cast<uint8_t *>(&temp_vertex_j), sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (temp_vertex_i.frame != NAV_FRAME_GLOBAL && temp_vertex_i.frame != NAV_FRAME_GLOBAL_INT\n\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n\t\t\t// TODO: handle different frames\n\t\t\tPX4_ERR(\"Frame type %i not supported\", (int)temp_vertex_i.frame);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (((double)temp_vertex_i.lon >= lon) != ((double)temp_vertex_j.lon >= lon) &&\n\t\t    (lat <= (double)(temp_vertex_j.lat - temp_vertex_i.lat) * (lon - (double)temp_vertex_i.lon) /\n\t\t     (double)(temp_vertex_j.lon - temp_vertex_i.lon) + (double)temp_vertex_i.lat)) {\n\t\t\tc = !c;\n\t\t}\n\t}\n\n\treturn c;\n}"
    },
    "Geofence::isInsidePolygonOrCircle": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Geofence::isInsidePolygonOrCircle(double lat, double lon, float altitude)\n{\n\tif (isEmpty()) {\n\t\t/* Empty fence -> accept all points */\n\t\treturn true;\n\t}\n\n\t/* Vertical check */\n\tif (_altitude_max > _altitude_min) { // only enable vertical check if configured properly\n\t\tif (altitude > _altitude_max || altitude < _altitude_min) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Horizontal check: iterate all polygons & circles */\n\tbool outside_exclusion = true;\n\tbool inside_inclusion = false;\n\tbool had_inclusion_areas = false;\n\n\tfor (int polygon_index = 0; polygon_index < _num_polygons; ++polygon_index) {\n\t\tif (_polygons[polygon_index].fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n\t\t\tbool inside = insideCircle(_polygons[polygon_index], lat, lon, altitude);\n\n\t\t\tif (inside) {\n\t\t\t\tinside_inclusion = true;\n\t\t\t}\n\n\t\t\thad_inclusion_areas = true;\n\n\t\t} else if (_polygons[polygon_index].fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n\t\t\tbool inside = insideCircle(_polygons[polygon_index], lat, lon, altitude);\n\n\t\t\tif (inside) {\n\t\t\t\toutside_exclusion = false;\n\t\t\t}\n\n\t\t} else { // it's a polygon\n\t\t\tbool inside = insidePolygon(_polygons[polygon_index], lat, lon, altitude);\n\n\t\t\tif (_polygons[polygon_index].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n\t\t\t\tif (inside) {\n\t\t\t\t\tinside_inclusion = true;\n\t\t\t\t}\n\n\t\t\t\thad_inclusion_areas = true;\n\n\t\t\t} else { // exclusion\n\t\t\t\tif (inside) {\n\t\t\t\t\toutside_exclusion = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (!had_inclusion_areas || inside_inclusion) && outside_exclusion;\n}"
    },
    "Mission::getPreviousPositionItemIndex": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Mission::getPreviousPositionItemIndex(const mission_s &mission, int inactivation_index,\n\t\tunsigned &prev_pos_index) const\n{\n\n\tfor (int index = inactivation_index; index >= 0; index--) {\n\t\tmission_item_s mission_item;\n\t\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n\t\tbool success = _dataman_client.readSync(dm_current, index, reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t\t\tsizeof(mission_item), 500_ms);\n\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (MissionBlock::item_contains_position(mission_item)) {\n\t\t\tprev_pos_index = index;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
    },
    "Mission::read_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::read_mission_item(int offset, struct mission_item_s *mission_item)\n{\n\t/* select mission */\n\tconst int current_index = _current_mission_index;\n\tint index_to_read = current_index + offset;\n\n\tint *mission_index_ptr = (offset == 0) ? (int *) &_current_mission_index : &index_to_read;\n\tconst dm_item_t dataman_id = (dm_item_t)_mission.dataman_id;\n\n\t/* do not work on empty missions */\n\tif (_mission.count == 0) {\n\t\treturn false;\n\t}\n\n\t/* Repeat this several times in case there are several DO JUMPS that we need to follow along, however, after\n\t * 10 iterations we have to assume that the DO JUMPS are probably cycling and give up. */\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (*mission_index_ptr < 0 || *mission_index_ptr >= (int)_mission.count) {\n\t\t\t/* mission item index out of bounds - if they are equal, we just reached the end */\n\t\t\tif ((*mission_index_ptr != (int)_mission.count) && (*mission_index_ptr != -1)) {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(),\n\t\t\t\t\t\t     \"Mission item index out of bound, index: %d, max: %\" PRIu16 \".\\t\",\n\t\t\t\t\t\t     *mission_index_ptr, _mission.count);\n\t\t\t\tevents::send<uint16_t, uint16_t>(events::ID(\"mission_index_out_of_bound\"), events::Log::Error,\n\t\t\t\t\t\t\t\t \"Mission item index out of bound, index: {1}, max: {2}\", *mission_index_ptr, _mission.count);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/* read mission item to temp storage first to not overwrite current mission item if data damaged */\n\t\tstruct mission_item_s mission_item_tmp;\n\n\t\t/* read mission item from datamanager */\n\t\tbool success = _dataman_cache.loadWait(dataman_id, *mission_index_ptr, reinterpret_cast<uint8_t *>(&mission_item_tmp),\n\t\t\t\t\t\t       sizeof(mission_item_s), 500_ms);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Waypoint could not be read.\\t\");\n\t\t\tevents::send<uint16_t>(events::ID(\"mission_failed_to_read_wp\"), events::Log::Error,\n\t\t\t\t\t       \"Waypoint {1} could not be read from storage\", *mission_index_ptr);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* check for DO_JUMP item, and whether it hasn't not already been repeated enough times */\n\t\tif (mission_item_tmp.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\tconst bool execute_jumps = _mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_NORMAL;\n\n\t\t\t/* do DO_JUMP as many times as requested if not in reverse mode */\n\t\t\tif ((mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) && execute_jumps) {\n\n\t\t\t\t/* only raise the repeat count if this is for the current mission item\n\t\t\t\t * but not for the read ahead mission item */\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n\n\t\t\t\t\t/* save repeat count */\n\t\t\t\t\tsuccess = _dataman_client.writeSync(dataman_id, *mission_index_ptr, reinterpret_cast<uint8_t *>(&mission_item_tmp),\n\t\t\t\t\t\t\t\t\t    sizeof(struct mission_item_s));\n\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the dataman */\n\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"DO JUMP waypoint could not be written.\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"mission_failed_to_write_do_jump\"), events::Log::Error,\n\t\t\t\t\t\t\t     \"DO JUMP waypoint could not be written\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treport_do_jump_mission_changed(*mission_index_ptr, mission_item_tmp.do_jump_repeat_count);\n\t\t\t\t}\n\n\t\t\t\t/* set new mission item index and repeat\n\t\t\t\t * we don't have to validate here, if it's invalid, we should realize this later .*/\n\t\t\t\t*mission_index_ptr = mission_item_tmp.do_jump_mission_index;\n\n\t\t\t} else {\n\t\t\t\tif (offset == 0 && execute_jumps) {\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"DO JUMP repetitions completed.\\t\");\n\t\t\t\t\tevents::send(events::ID(\"mission_do_jump_rep_completed\"), events::Log::Info,\n\t\t\t\t\t\t     \"DO JUMP repetitions completed\");\n\t\t\t\t}\n\n\t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */\n\t\t\t\tif (_mission_execution_mode == mission_result_s::MISSION_EXECUTION_MODE_REVERSE) {\n\t\t\t\t\t(*mission_index_ptr)--;\n\n\t\t\t\t} else {\n\t\t\t\t\t(*mission_index_ptr)++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* if it's not a DO_JUMP, then we were successful */\n\t\t\tmemcpy(mission_item, &mission_item_tmp, sizeof(struct mission_item_s));\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* we have given up, we don't want to cycle forever */\n\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"DO JUMP is cycling, giving up.\\t\");\n\tevents::send(events::ID(\"mission_do_jump_cycle\"), events::Log::Error, \"DO JUMP is cycling, giving up\");\n\treturn false;\n}"
    },
    "MissionBlock::item_contains_position": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "if (MissionBlock::item_contains_position(mission_item)) {\n\t\t\tprev_pos_index = index;\n\t\t\treturn true;\n\t\t}"
    },
    "isEmpty": {
      "file": "src/modules/navigator/geofence.h",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "int loadFromFile(const char *filename);\n\n\tbool isEmpty() { return (!_fence_updated || (_num_polygons == 0)); }"
    },
    "Mission::getNextPositionMissionItem": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "bool Mission::getNextPositionMissionItem(const mission_s &mission, int start_index, mission_item_s &mission_item)\n{\n\tconst dm_item_t dm_current = (dm_item_t)mission.dataman_id;\n\n\twhile (start_index < mission.count) {\n\t\t// start_index is expected to be after _current_mission_index, and the item should therefore be cached\n\t\tbool success = _dataman_cache.loadWait(dm_current, start_index, reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t\t       sizeof(mission_item), 500_ms);\n\n\t\tif (success && MissionBlock::item_contains_position(mission_item)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tstart_index++;\n\t}\n\n\treturn false;\n}"
    },
    "Mission::reset_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "Mission::reset_mission(struct mission_s &mission)\n{\n\tif (_dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission), sizeof(mission_s))) {\n\t\tif (mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 || mission.dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) {\n\t\t\t/* set current item to 0 */\n\t\t\tmission.current_seq = 0;\n\n\t\t\t/* reset jump counters */\n\t\t\tif (mission.count > 0) {\n\t\t\t\tconst dm_item_t dataman_id = (dm_item_t)mission.dataman_id;\n\n\t\t\t\tfor (unsigned index = 0; index < mission.count; index++) {\n\t\t\t\t\tstruct mission_item_s item;\n\t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t\t\t\tbool success = _dataman_client.readSync(dataman_id, index, reinterpret_cast<uint8_t *>(&item), sizeof(mission_item_s),\n\t\t\t\t\t\t\t\t\t\t500_ms);\n\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\t\t\t\titem.do_jump_current_count = 0;\n\n\t\t\t\t\t\tsuccess = _dataman_client.writeSync(dataman_id, index, reinterpret_cast<uint8_t *>(&item), len);\n\n\t\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Could not read mission.\\t\");\n\t\t\tevents::send(events::ID(\"mission_cannot_read_mission\"), events::Log::Error, \"Could not read mission\");\n\n\t\t\t/* initialize mission state in dataman */\n\t\t\tmission.timestamp = hrt_absolute_time();\n\t\t\tmission.dataman_id = DM_KEY_WAYPOINTS_OFFBOARD_0;\n\t\t\tmission.count = 0;\n\t\t\tmission.current_seq = 0;\n\t\t}\n\n\t\t_dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission), sizeof(mission_s));\n\t}\n}"
    },
    "Geofence::_updateFence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "b5a528b5d1f562fe871140508fb176970d4bf64d",
      "source": "void Geofence::_updateFence()\n{\n\tmission_fence_point_s mission_fence_point;\n\tbool is_circle_area = false;\n\n\t// iterate over all polygons and store their starting vertices\n\t_num_polygons = 0;\n\tint current_seq = 1;\n\n\twhile (current_seq <= _dataman_cache.size()) {\n\n\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, current_seq,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t       sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"loadWait failed, seq: %i\", current_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mission_fence_point.nav_cmd) {\n\t\tcase NAV_CMD_FENCE_RETURN_POINT:\n\t\t\t// TODO: do we need to store this?\n\t\t\t++current_seq;\n\t\t\tbreak;\n\n\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n\t\t\tis_circle_area = true;\n\n\t\t/* FALLTHROUGH */\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n\t\t\tif (!is_circle_area && mission_fence_point.vertex_count == 0) {\n\t\t\t\t++current_seq; // avoid endless loop\n\t\t\t\tPX4_ERR(\"Polygon with 0 vertices. Skipping\");\n\n\t\t\t} else {\n\t\t\t\tif (_polygons) {\n\t\t\t\t\t// resize: this is somewhat inefficient, but we do not expect there to be many polygons\n\t\t\t\t\tPolygonInfo *new_polygons = new PolygonInfo[_num_polygons + 1];\n\n\t\t\t\t\tif (new_polygons) {\n\t\t\t\t\t\tmemcpy(new_polygons, _polygons, sizeof(PolygonInfo) * _num_polygons);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete[](_polygons);\n\t\t\t\t\t_polygons = new_polygons;\n\n\t\t\t\t} else {\n\t\t\t\t\t_polygons = new PolygonInfo[1];\n\t\t\t\t}\n\n\t\t\t\tif (!_polygons) {\n\t\t\t\t\t_num_polygons = 0;\n\t\t\t\t\tPX4_ERR(\"alloc failed\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPolygonInfo &polygon = _polygons[_num_polygons];\n\t\t\t\tpolygon.dataman_index = current_seq;\n\t\t\t\tpolygon.fence_type = mission_fence_point.nav_cmd;\n\n\t\t\t\tif (is_circle_area) {\n\t\t\t\t\tpolygon.circle_radius = mission_fence_point.circle_radius;\n\t\t\t\t\tcurrent_seq += 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tpolygon.vertex_count = mission_fence_point.vertex_count;\n\t\t\t\t\tcurrent_seq += mission_fence_point.vertex_count;\n\t\t\t\t}\n\n\t\t\t\t++_num_polygons;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPX4_ERR(\"unhandled Fence command: %i\", (int)mission_fence_point.nav_cmd);\n\t\t\t++current_seq;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "22346": {
    "MissionBase::checkMissionRestart": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "038500167ac1c1ce17ab9d9b98b1243d9d0f97d9",
      "source": "MissionBase::checkMissionRestart()\n{\n\tif (_system_disarmed_while_inactive && _mission_has_been_activated && (_mission.count > 0U)\n\t    && ((_mission.current_seq + 1) == _mission.count)) {\n\t\tsetMissionIndex(0);\n\t\t_inactivation_index = -1; // reset\n\t\t_is_current_planned_mission_item_valid = isMissionValid(_mission);\n\t\tresetMissionJumpCounter();\n\t\t_navigator->reset_cruising_speed();\n\t\t_navigator->reset_vroi();\n\t\tset_mission_result();\n\t}\n}"
    },
    "missionFeasibilityChecker": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "038500167ac1c1ce17ab9d9b98b1243d9d0f97d9",
      "source": "if (_navigator->get_mission_result()->mission_update_counter != _mission.mission_update_counter) {\n\t\tMissionFeasibilityChecker missionFeasibilityChecker(_navigator, _dataman_client);\n\n\t\tbool is_mission_valid =\n\t\t\tmissionFeasibilityChecker.checkMissionFeasible(_mission);\n\n\t\t_navigator->get_mission_result()->valid = is_mission_valid;\n\t\t_navigator->get_mission_result()->mission_update_counter = _mission.mission_update_counter;\n\t\t_navigator->get_mission_result()->seq_total = _mission.count;\n\t\t_navigator->get_mission_result()->seq_reached = -1;\n\t\t_navigator->get_mission_result()->failure = false;\n\t\tset_mission_result();\n\t}\n}\n\nvoid\nMissionBase::heading_sp_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet =\n\t\t_navigator->get_position_setpoint_triplet();\n\n\t// Only update if current triplet is valid\n\tif (pos_sp_triplet->current.valid) {\n\n\t\tdouble point_from_latlon[2] = { _global_pos_sub.get().lat,\n\t\t\t\t\t\t_global_pos_sub.get().lon\n\t\t\t\t\t      };\n\t\tdouble point_to_latlon[2] = { _global_pos_sub.get().lat,\n\t\t\t\t\t      _global_pos_sub.get().lon\n\t\t\t\t\t    };\n\t\tfloat yaw_offset = 0.0f;\n\n\t\t// Depending on ROI-mode, update heading\n\t\tswitch (_navigator->get_vroi().mode) {\n\t\tcase vehicle_roi_s::ROI_LOCATION: {\n\t\t\t\t// ROI is a fixed location. Vehicle needs to point towards that location\n\t\t\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n\t\t\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n\t\t\t\t// No yaw offset required\n\t\t\t\tyaw_offset = 0.0f;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_roi_s::ROI_WPNEXT: {\n\t\t\t\t// ROI is current waypoint. Vehcile needs to point towards current waypoint\n\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n\t\t\t\t// Add the gimbal's yaw offset\n\t\t\t\tyaw_offset = _navigator->get_vroi().yaw_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_roi_s::ROI_NONE:\n\t\tcase vehicle_roi_s::ROI_WPINDEX:\n\t\tcase vehicle_roi_s::ROI_TARGET:\n\t\tcase vehicle_roi_s::ROI_ENUM_END:\n\t\tdefault: {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Get desired heading and update it.\n\t\t// However, only update if distance to desired heading is\n\t\t// larger than acceptance radius to prevent excessive yawing\n\t\tfloat d_current = get_distance_to_next_waypoint(point_from_latlon[0],\n\t\t\t\t  point_from_latlon[1], point_to_latlon[0], point_to_latlon[1]);\n\n\t\tif (d_current > _navigator->get_acceptance_radius()) {\n\t\t\tfloat yaw = matrix::wrap_pi(\n\t\t\t\t\t    get_bearing_to_next_waypoint(point_from_latlon[0],\n\t\t\t\t\t\t\t    point_from_latlon[1], point_to_latlon[0],\n\t\t\t\t\t\t\t    point_to_latlon[1]) + yaw_offset);\n\n\t\t\t_mission_item.yaw = yaw;\n\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\t\t\tpos_sp_triplet->current.yaw_valid = true;\n\n\t\t} else {\n\t\t\tif (!pos_sp_triplet->current.yaw_valid) {\n\t\t\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\t\t\t\tpos_sp_triplet->current.yaw_valid = true;\n\t\t\t}\n\t\t}\n\n\t\t// we set yaw directly so we can run this in parallel to the FOH update\n\t\tpublish_navigator_mission_item();\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n}"
    },
    "MissionBase::onMissionUpdate": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "038500167ac1c1ce17ab9d9b98b1243d9d0f97d9",
      "source": "void MissionBase::onMissionUpdate(bool has_mission_items_changed)\n{\n\t_is_current_planned_mission_item_valid = _mission.count > 0;\n\n\tif (has_mission_items_changed) {\n\t\t_dataman_cache.invalidate();\n\t\t_load_mission_index = -1;\n\n\t\tcheck_mission_valid();\n\n\t\t// only warn if the check failed on merit\n\t\tif ((!_navigator->get_mission_result()->valid) && _mission.count > 0U) {\n\t\t\tPX4_WARN(\"mission check failed\");\n\t\t}\n\t}\n\n\tif (isActive()) {\n\t\t_mission_has_been_activated = true;\n\t\t_navigator->reset_triplets();\n\t\tupdate_mission();\n\t\tset_mission_items();\n\n\t} else {\n\t\tif (has_mission_items_changed) {\n\t\t\t_mission_has_been_activated = false;\n\t\t}\n\t}\n\n\t// reset as when we update mission we don't want to proceed at previous index\n\t_inactivation_index = -1;\n}"
    },
    "mission_instance_count": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "038500167ac1c1ce17ab9d9b98b1243d9d0f97d9",
      "source": "orb_advert_t *get_mavlink_log_pub() { return &_mavlink_log_pub; }\n\n\tint mission_instance_count() const { return _mission_result.mission_update_counter; }"
    }
  },
  "22532": {
    "Navigator::reset_position_setpoint": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void Navigator::reset_position_setpoint(position_setpoint_s &sp)\n{\n\tsp = position_setpoint_s{};\n\tsp.timestamp = hrt_absolute_time();\n\tsp.lat = static_cast<double>(NAN);\n\tsp.lon = static_cast<double>(NAN);\n\tsp.loiter_radius = get_loiter_radius();\n\tsp.acceptance_radius = get_default_acceptance_radius();\n\tsp.cruising_speed = get_cruising_speed();\n\tsp.cruising_throttle = get_cruising_throttle();\n\tsp.valid = false;\n\tsp.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\tsp.loiter_direction_counter_clockwise = false;\n}"
    },
    "MissionBlock::setLoiterItemFromCurrentPosition": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::setLoiterItemFromCurrentPosition(struct mission_item_s *item)\n{\n\tsetLoiterItemCommonFields(item);\n\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\n\t// check if minimum loiter altitude is specified, and enforce it if so\n\tfloat loiter_altitude_amsl = _navigator->get_global_position()->alt;\n\n\tif (_navigator->get_loiter_min_alt() > FLT_EPSILON) {\n\t\tloiter_altitude_amsl = math::max(loiter_altitude_amsl,\n\t\t\t\t\t\t _navigator->get_home_position()->alt + _navigator->get_loiter_min_alt());\n\t}\n\n\titem->altitude = loiter_altitude_amsl;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->yaw = NAN;\n}"
    },
    "MissionBlock::set_takeoff_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::set_takeoff_item(struct mission_item_s *item, float abs_altitude)\n{\n\titem->nav_cmd = NAV_CMD_TAKEOFF;\n\n\t/* use current position */\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\titem->yaw = NAN;\n\n\titem->altitude = abs_altitude;\n\titem->altitude_is_relative = false;\n\n\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->autocontinue = false;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    },
    "Navigator::geofence_allows_position": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "bool Navigator::geofence_allows_position(const vehicle_global_position_s &pos)\n{\n\tif ((_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_WARN)) {\n\n\t\tif (PX4_ISFINITE(pos.lat) && PX4_ISFINITE(pos.lon) && PX4_ISFINITE(pos.alt)) {\n\t\t\treturn _geofence.checkPointAgainstAllGeofences(pos.lat, pos.lon, pos.alt);\n\t\t}\n\t}\n\n\treturn true;\n}"
    },
    "MissionBlock::set_land_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::set_land_item(struct mission_item_s *item)\n{\n\t/* VTOL transition to RW before landing */\n\tif (_navigator->force_vtol()) {\n\n\t\tvehicle_command_s vcmd = {};\n\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\tvcmd.param2 = 0.0f;\n\t\t_navigator->publish_vehicle_cmd(&vcmd);\n\t}\n\n\t/* set the land item */\n\titem->nav_cmd = NAV_CMD_LAND;\n\n\t// set land item to current position\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\titem->yaw = NAN;\n\n\titem->altitude = 0;\n\titem->altitude_is_relative = false;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->autocontinue = true;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    },
    "MissionBlock::setLoiterItemFromCurrentPositionSetpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::setLoiterItemFromCurrentPositionSetpoint(struct mission_item_s *item)\n{\n\tsetLoiterItemCommonFields(item);\n\n\tconst position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\titem->lat = pos_sp_triplet->current.lat;\n\titem->lon = pos_sp_triplet->current.lon;\n\titem->altitude = pos_sp_triplet->current.alt;\n\titem->loiter_radius = pos_sp_triplet->current.loiter_direction_counter_clockwise ?\n\t\t\t      -pos_sp_triplet->current.loiter_radius : pos_sp_triplet->current.loiter_radius;\n\titem->yaw = pos_sp_triplet->current.yaw;\n}"
    },
    "Takeoff::set_takeoff_position": {
      "file": "src/modules/navigator/takeoff.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "Takeoff::set_takeoff_position()\n{\n\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n\n\tfloat takeoff_altitude_amsl = 0.f;\n\n\tif (rep->current.valid && PX4_ISFINITE(rep->current.alt)) {\n\t\ttakeoff_altitude_amsl = rep->current.alt;\n\n\t} else {\n\t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt + _navigator->get_param_mis_takeoff_alt();\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t \"Using default takeoff altitude: %.1f m\\t\", (double)_navigator->get_param_mis_takeoff_alt());\n\n\t\tevents::send<float>(events::ID(\"navigator_takeoff_default_alt\"), {events::Log::Info, events::LogInternal::Info},\n\t\t\t\t    \"Using default takeoff altitude: {1:.2m}\",\n\t\t\t\t    _navigator->get_param_mis_takeoff_alt());\n\t}\n\n\tif (takeoff_altitude_amsl < _navigator->get_global_position()->alt) {\n\t\t// If the suggestion is lower than our current alt, let's not go down.\n\t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt;\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Already higher than takeoff altitude\\t\");\n\t\tevents::send(events::ID(\"navigator_takeoff_already_higher\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t     \"Already higher than takeoff altitude (not descending)\");\n\t}\n\n\t// set current mission item to takeoff\n\tset_takeoff_item(&_mission_item, takeoff_altitude_amsl);\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\treset_mission_item_reached();\n\n\t// convert mission item to current setpoint\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\tpos_sp_triplet->previous.valid = false;\n\tpos_sp_triplet->next.valid = false;\n\n\tif (rep->current.valid) {\n\n\t\t// Go on and check which changes had been requested\n\t\tif (PX4_ISFINITE(rep->current.yaw)) {\n\t\t\tpos_sp_triplet->current.yaw = rep->current.yaw;\n\t\t}\n\n\t\t// Set the current latitude and longitude even if they are NAN\n\t\t// NANs are handled in FlightTaskAuto.cpp\n\t\tpos_sp_triplet->current.lat = rep->current.lat;\n\t\tpos_sp_triplet->current.lon = rep->current.lon;\n\n\t\t// mark this as done\n\t\tmemset(rep, 0, sizeof(*rep));\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Mission::handleTakeoff": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void Mission::handleTakeoff(WorkItemType &new_work_item_type, mission_item_s next_mission_items[],\n\t\t\t    size_t &num_found_items)\n{\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* do climb before going to setpoint if needed and not already executing climb */\n\t/* in fixed-wing this whole block will be ignored and a takeoff item is always propagated */\n\tif (PX4_ISFINITE(_mission_init_climb_altitude_amsl) &&\n\t    _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_CLIMB;\n\n\t\t/* use current mission item as next position item */\n\t\tnum_found_items = 1u;\n\t\tnext_mission_items[0u] = _mission_item;\n\t\tnext_mission_items[0u].nav_cmd = NAV_CMD_WAYPOINT;\n\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Climb to %.1f meters above home\\t\",\n\t\t\t\t (double)(_mission_init_climb_altitude_amsl - _navigator->get_home_position()->alt));\n\t\tevents::send<float>(events::ID(\"mission_climb_before_start\"), events::Log::Info,\n\t\t\t\t    \"Climb to {1:.1m_v} above home\", _mission_init_climb_altitude_amsl - _navigator->get_home_position()->alt);\n\n\t\tif (_land_detected_sub.get().landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\n\t\t} else {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\t\t}\n\n\t\t_mission_item.lat = _global_pos_sub.get().lat;\n\t\t_mission_item.lon = _global_pos_sub.get().lon;\n\t\t_mission_item.yaw = NAN; // FlightTaskAuto handles yaw directly\n\t\t_mission_item.altitude = _mission_init_climb_altitude_amsl;\n\t\t_mission_item.altitude_is_relative = false;\n\t\t_mission_item.autocontinue = true;\n\t\t_mission_item.time_inside = 0.0f;\n\n\t\t_mission_init_climb_altitude_amsl = NAN;\n\n\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t   && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT\n\t\t   && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t/* if there is no need to do a takeoff but we have a takeoff item, treat is as waypoint */\n\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t_mission_item.yaw = NAN;\n\n\t} else if (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t   && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\t// if the vehicle is already in fixed wing mode then the current mission item\n\t\t// will be accepted immediately and the work items will be skipped\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_CLIMB;\n\n\n\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t_mission_item.yaw = NAN;\n\t}\n\n\t/* if we just did a normal takeoff navigate to the actual waypoint now */\n\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF &&\n\t    _work_item_type == WorkItemType::WORK_ITEM_TYPE_CLIMB) {\n\n\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t_mission_item.yaw = NAN;\n\t}\n\n\t/* if we just did a VTOL takeoff, prepare transition */\n\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t    _work_item_type == WorkItemType::WORK_ITEM_TYPE_CLIMB &&\n\t    _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t    !_land_detected_sub.get().landed) {\n\n\t\t/* set yaw setpoint to heading of VTOL_TAKEOFF wp against current position */\n\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t\t    _global_pos_sub.get().lat, _global_pos_sub.get().lon,\n\t\t\t\t\t    _mission_item.lat, _mission_item.lon);\n\n\t\t_mission_item.force_heading = true;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING;\n\n\t\t/* set position setpoint to current while aligning */\n\t\t_mission_item.lat = _global_pos_sub.get().lat;\n\t\t_mission_item.lon = _global_pos_sub.get().lon;\n\t}\n\n\t/* heading is aligned now, prepare transition */\n\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF &&\n\t    _work_item_type == WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING &&\n\t    _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t    !_land_detected_sub.get().landed) {\n\n\t\t/* check if the vtol_takeoff waypoint is on top of us */\n\t\tif (do_need_move_to_takeoff()) {\n\t\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\t\t}\n\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = NAN;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t}\n\n\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t    && _work_item_type == WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF) {\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t_mission_item.autocontinue = true;\n\t\t_mission_item.time_inside = 0.0f;\n\t}\n}"
    },
    "MissionBlock::is_mission_item_reached_or_completed": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::is_mission_item_reached_or_completed()\n{\n\tconst hrt_abstime now = hrt_absolute_time();\n\n\t// Handle indefinite waypoints and action commands\n\tswitch (_mission_item.nav_cmd) {\n\n\t// Action Commands that doesn't have timeout completes instantaneously\n\tcase NAV_CMD_DO_SET_ACTUATOR:\n\tcase NAV_CMD_DO_LAND_START:\n\tcase NAV_CMD_DO_TRIGGER_CONTROL:\n\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\tcase NAV_CMD_IMAGE_START_CAPTURE:\n\tcase NAV_CMD_IMAGE_STOP_CAPTURE:\n\tcase NAV_CMD_VIDEO_START_CAPTURE:\n\tcase NAV_CMD_VIDEO_STOP_CAPTURE:\n\tcase NAV_CMD_DO_CONTROL_VIDEO:\n\tcase NAV_CMD_DO_MOUNT_CONFIGURE:\n\tcase NAV_CMD_DO_MOUNT_CONTROL:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:\n\tcase NAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:\n\tcase NAV_CMD_DO_SET_ROI:\n\tcase NAV_CMD_DO_SET_ROI_LOCATION:\n\tcase NAV_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\tcase NAV_CMD_DO_SET_ROI_NONE:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\tcase NAV_CMD_OBLIQUE_SURVEY:\n\tcase NAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:\n\tcase NAV_CMD_SET_CAMERA_MODE:\n\tcase NAV_CMD_SET_CAMERA_ZOOM:\n\tcase NAV_CMD_SET_CAMERA_FOCUS:\n\tcase NAV_CMD_DO_CHANGE_SPEED:\n\tcase NAV_CMD_DO_SET_HOME:\n\t\treturn true;\n\n\t// Indefinite Waypoints\n\tcase NAV_CMD_LAND: /* fall through */\n\tcase NAV_CMD_VTOL_LAND:\n\t\treturn _navigator->get_land_detected()->landed;\n\n\tcase NAV_CMD_IDLE: /* fall through */\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\treturn false;\n\n\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\n\t\tif (int(_mission_item.params[0]) == 3) {\n\t\t\t// transition to RW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\t\t} else if (int(_mission_item.params[0]) == 4) {\n\t\t\t// transition to FW requested, only accept waypoint if vehicle state has changed accordingly\n\t\t\treturn _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t} else {\n\t\t\t// invalid vtol transition request\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DELAY:\n\t\t// Set reached flags directly such that only the delay time is considered\n\t\t_waypoint_position_reached = true;\n\t\t_waypoint_yaw_reached = true;\n\n\t\t// Set timestamp when entering only (it's reset to 0 for every waypoint)\n\t\tif (_time_wp_reached == 0) {\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_DO_WINCH: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) *\n\t\t\t\t\t1E-6f; // TODO: Add proper microseconds_to_seconds function\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Winch Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tcase NAV_CMD_DO_GRIPPER: {\n\t\t\tconst float payload_deploy_elasped_time_s = (now - _payload_deployed_time) * 1E-6f;\n\n\t\t\tif (_payload_deploy_ack_successful) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Ack received! Resuming mission\");\n\t\t\t\treturn true;\n\n\t\t\t} else if (payload_deploy_elasped_time_s > _payload_deploy_timeout_s) {\n\t\t\t\tPX4_DEBUG(\"Gripper Deploy Timed out, resuming mission!\");\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// We are still waiting for the acknowledgement / execution of deploy\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\t/* do nothing, this is a 3D waypoint */\n\t\tbreak;\n\t}\n\n\t// Update the 'waypoint position reached' status\n\tif (!_navigator->get_land_detected()->landed && !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tconst float mission_item_altitude_amsl = get_absolute_altitude_for_item(_mission_item);\n\n\t\t// consider mission_item.loiter_radius invalid if NAN or 0, use default value in this case.\n\t\tconst float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n\t\t\t\t_navigator->get_loiter_radius();\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t/* We want to avoid the edge case where the acceptance radius is bigger or equal than\n\t\t\t * the altitude of the takeoff waypoint above home. Otherwise, we do not really follow\n\t\t\t * take-off procedures like leaving the landing gear down. */\n\n\t\t\tfloat takeoff_alt = _mission_item.altitude_is_relative ?\n\t\t\t\t\t    _mission_item.altitude :\n\t\t\t\t\t    (_mission_item.altitude - _navigator->get_home_position()->alt);\n\n\t\t\tfloat altitude_acceptance_radius = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* It should be safe to just use half of the takoeff_alt as an acceptance radius. */\n\t\t\tif (takeoff_alt > 0 && takeoff_alt < altitude_acceptance_radius) {\n\t\t\t\taltitude_acceptance_radius = takeoff_alt / 2.0f;\n\t\t\t}\n\n\t\t\t/* require only altitude for takeoff for multicopter */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t/* fixed-wing takeoff is reached once the vehicle has exceeded the takeoff altitude */\n\t\t\tif (_navigator->get_global_position()->alt > mission_item_altitude_amsl) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t   && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROVER) {\n\t\t\t// Accept takeoff waypoint to be reached if the distance in 2D plane is within acceptance radius\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t// For takeoff mission items use the parameter for the takeoff acceptance radius\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t   (_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t    _mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT)) {\n\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius + navigation switch distance. Time inside and turn count is handled elsewhere.\n\t\t\t */\n\n\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\t// NAV_CMD_LOITER_TO_ALT only uses mission item altitude once it's in the loiter.\n\t\t\t// First check if the altitude setpoint is the mission setpoint (that means that the loiter is not yet reached)\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\tif (fabsf(curr_sp->alt - mission_item_altitude_amsl) >= FLT_EPSILON) {\n\t\t\t\tdist_xy = -1.0f;\n\t\t\t\tdist_z = -1.0f;\n\n\t\t\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, curr_sp->alt,\n\t\t\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\t// check if within loiter radius around wp, if yes then set altitude sp to mission item\n\t\t\t\tif (dist >= 0.0f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t    && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t\tcurr_sp->alt = mission_item_altitude_amsl;\n\t\t\t\t\tcurr_sp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\t\t}\n\n\t\t\t} else if (dist >= 0.f && dist_xy <= (_navigator->get_acceptance_radius() + mission_item_loiter_radius_abs)\n\t\t\t\t   && dist_z <= _navigator->get_altitude_acceptance_radius()) {\n\t\t\t\t// loitering, check if new altitude is reached, while still also having check on position\n\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_CONDITION_GATE) {\n\n\t\t\tstruct position_setpoint_s *curr_sp = &_navigator->get_position_setpoint_triplet()->current;\n\n\t\t\t// if the setpoint is valid we are checking if we reached the gate\n\t\t\t// in the case of an invalid setpoint we are defaulting to\n\t\t\t// assuming that we have already reached the gate to not block\n\t\t\t// the further execution of the mission.\n\t\t\tif (curr_sp->valid) {\n\n\t\t\t\t// location of gate (mission item)\n\t\t\t\tMapProjection ref_pos{_mission_item.lat, _mission_item.lon};\n\n\t\t\t\t// current setpoint\n\t\t\t\tmatrix::Vector2f gate_to_curr_sp = ref_pos.project(curr_sp->lat, curr_sp->lon);\n\n\t\t\t\t// system position\n\t\t\t\tmatrix::Vector2f vehicle_pos = ref_pos.project(_navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t       _navigator->get_global_position()->lon);\n\t\t\t\tconst float dot_product = vehicle_pos.dot(gate_to_curr_sp.normalized());\n\n\t\t\t\t// if the dot product (projected vector) is positive, then\n\t\t\t\t// the current position is between the gate position and the\n\t\t\t\t// next waypoint\n\t\t\t\tif (dot_product >= 0) {\n\t\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t\t\t_time_wp_reached = now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfloat acceptance_radius = _navigator->get_acceptance_radius();\n\n\t\t\t// We use the acceptance radius of the mission item if it has been set (not NAN)\n\t\t\t// but only for multicopter.\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t    && PX4_ISFINITE(_mission_item.acceptance_radius) && _mission_item.acceptance_radius > FLT_EPSILON) {\n\t\t\t\tacceptance_radius = _mission_item.acceptance_radius;\n\t\t\t}\n\n\t\t\tfloat alt_acc_rad_m = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* for vtol back transition calculate acceptance radius based on time and ground speed */\n\t\t\tif (_mission_item.vtol_back_transition\n\t\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tfloat velocity = sqrtf(_navigator->get_local_position()->vx * _navigator->get_local_position()->vx +\n\t\t\t\t\t\t       _navigator->get_local_position()->vy * _navigator->get_local_position()->vy);\n\n\t\t\t\tconst float back_trans_dec = _navigator->get_vtol_back_trans_deceleration();\n\n\t\t\t\tif (back_trans_dec > FLT_EPSILON && velocity > FLT_EPSILON) {\n\t\t\t\t\tacceptance_radius = (velocity / back_trans_dec / 2) * velocity;\n\n\t\t\t\t}\n\n\t\t\t\t// do not care for altitude when approaching the backtransition point. Not accepting the waypoint causes\n\t\t\t\t// the vehicle to perform a sharp turn after passing the land waypoint and this causes worse unexected behavior\n\t\t\t\talt_acc_rad_m = INFINITY;\n\n\t\t\t}\n\n\t\t\tbool passed_curr_wp = false;\n\n\t\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\tconst float dist_prev_to_curr = get_distance_to_next_waypoint(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t_navigator->get_position_setpoint_triplet()->current.lon);\n\n\t\t\t\tif (dist_prev_to_curr > 1.0e-6f && _navigator->get_position_setpoint_triplet()->previous.valid) {\n\t\t\t\t\t// Fixed-wing guidance interprets this condition as line segment following\n\n\t\t\t\t\t// vector from previous waypoint to current waypoint\n\t\t\t\t\tfloat vector_prev_to_curr_north;\n\t\t\t\t\tfloat vector_prev_to_curr_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->previous.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->previous.lon, _navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, &vector_prev_to_curr_north,\n\t\t\t\t\t\t\t\t\t &vector_prev_to_curr_east);\n\n\t\t\t\t\t// vector from next waypoint to aircraft\n\t\t\t\t\tfloat vector_curr_to_vehicle_north;\n\t\t\t\t\tfloat vector_curr_to_vehicle_east;\n\t\t\t\t\tget_vector_to_next_waypoint_fast(_navigator->get_position_setpoint_triplet()->current.lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_position_setpoint_triplet()->current.lon, _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t\t\t _navigator->get_global_position()->lon, &vector_curr_to_vehicle_north,\n\t\t\t\t\t\t\t\t\t &vector_curr_to_vehicle_east);\n\n\t\t\t\t\t// if dot product of vectors is positive, we are passed the current waypoint (the terminal point on the line segment) and should switch to next mission item\n\t\t\t\t\tpassed_curr_wp = vector_prev_to_curr_north * vector_curr_to_vehicle_north + vector_prev_to_curr_east *\n\t\t\t\t\t\t\t vector_curr_to_vehicle_east > 0.0f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist_xy >= 0.0f && (dist_xy <= acceptance_radius || passed_curr_wp) && dist_z <= alt_acc_rad_m) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\n\t\t// consider yaw reached for non-rotary wing vehicles (such as fixed-wing)\n\t\tif (_navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Update the 'waypoint position reached' status (only for rotary wing flight)\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t    && _navigator->get_yaw_to_be_accepted(_mission_item.yaw)\n\t\t    && _navigator->get_local_position()->heading_good_for_control) {\n\n\t\t\tconst float yaw_err = wrap_pi(_mission_item.yaw - _navigator->get_local_position()->heading);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < _navigator->get_yaw_threshold()\n\t\t\t    || (_navigator->get_yaw_timeout() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t    (_navigator->get_yaw_timeout() >= FLT_EPSILON) &&\n\t\t\t    (now - _time_wp_reached >= (hrt_abstime)_navigator->get_yaw_timeout() * 1e6f)) {\n\n\t\t\t\t_navigator->set_mission_failure_heading_timeout();\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t// Handle Loiter/Delay Timeout if the waypoint position and yaw setpoint got reached\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tbool time_inside_reached = false;\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif ((get_time_inside(_mission_item) < FLT_EPSILON) ||\n\t\t    (now - _time_wp_reached >= (hrt_abstime)(get_time_inside(_mission_item) * 1e6f))) {\n\t\t\ttime_inside_reached = true;\n\t\t}\n\n\t\t// check if course for exit is reached (only applies for fixed-wing flight)\n\t\tbool exit_course_reached = false;\n\n\t\tif (time_inside_reached) {\n\n\t\t\tstruct position_setpoint_s *curr_sp_new = &_navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float dist_current_next = get_distance_to_next_waypoint(curr_sp_new->lat, curr_sp_new->lon, next_sp.lat,\n\t\t\t\t\t\t\tnext_sp.lon);\n\n\t\t\t/* enforce exit course if in FW, the next wp is valid, the vehicle is currently loitering and either having force_heading set,\n\t\t\t   or if loitering to achieve altitdue at a NAV_CMD_WAYPOINT */\n\t\t\tconst bool enforce_exit_course = _navigator->get_vstatus()->vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t\t && next_sp.valid\n\t\t\t\t\t\t\t && curr_sp_new->type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t\t\t\t\t\t && (_mission_item.force_heading || _mission_item.nav_cmd == NAV_CMD_WAYPOINT);\n\n\t\t\t// can only enforce exit course if next waypoint is not within loiter radius of current waypoint\n\t\t\tconst bool exit_course_is_reachable = dist_current_next > 1.2f * curr_sp_new->loiter_radius;\n\n\t\t\tif (enforce_exit_course && exit_course_is_reachable) {\n\n\t\t\t\tfloat vehicle_position_to_next_waypoint_north;\n\t\t\t\tfloat vehicle_position_to_next_waypoint_east;\n\t\t\t\tget_vector_to_next_waypoint(_navigator->get_global_position()->lat, _navigator->get_global_position()->lon, next_sp.lat,\n\t\t\t\t\t\t\t    next_sp.lon, &vehicle_position_to_next_waypoint_north,  &vehicle_position_to_next_waypoint_east);\n\n\t\t\t\t// this vector defines the exit bearing\n\t\t\t\tconst matrix::Vector2f vector_vehicle_position_to_next_waypoint = {vehicle_position_to_next_waypoint_north, vehicle_position_to_next_waypoint_east};\n\n\t\t\t\tconst matrix::Vector2f vehicle_ground_velocity = {_navigator->get_local_position()->vx, _navigator->get_local_position()->vy};\n\n\t\t\t\texit_course_reached = vector_vehicle_position_to_next_waypoint.dot(vehicle_ground_velocity) >\n\t\t\t\t\t\t      vector_vehicle_position_to_next_waypoint.norm() * vehicle_ground_velocity.norm() * kCosineExitCourseThreshold;\n\n\t\t\t} else {\n\t\t\t\texit_course_reached = true;\n\t\t\t}\n\t\t}\n\n\t\t// set exit flight course to next waypoint\n\t\tif (exit_course_reached) {\n\t\t\tposition_setpoint_s &curr_sp = _navigator->get_position_setpoint_triplet()->current;\n\t\t\tconst position_setpoint_s &next_sp = _navigator->get_position_setpoint_triplet()->next;\n\n\t\t\tconst float range = get_distance_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t// exit xtrack location\n\t\t\t// reset lat/lon of loiter waypoint so vehicle follows a tangent\n\t\t\tif (_mission_item.loiter_exit_xtrack && next_sp.valid && PX4_ISFINITE(range) &&\n\t\t\t    (_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t     _mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT)) {\n\n\t\t\t\tfloat bearing = get_bearing_to_next_waypoint(curr_sp.lat, curr_sp.lon, next_sp.lat, next_sp.lon);\n\n\t\t\t\t// calculate (positive) angle between current bearing vector (orbit center to next waypoint) and vector pointing to tangent exit location\n\t\t\t\tconst float ratio = math::min(fabsf(curr_sp.loiter_radius / range), 1.0f);\n\t\t\t\tfloat inner_angle = acosf(ratio);\n\n\t\t\t\t// Compute \"ideal\" tangent origin\n\t\t\t\tif (curr_sp.loiter_direction_counter_clockwise) {\n\t\t\t\t\tbearing += inner_angle;\n\n\t\t\t\t} else {\n\t\t\t\t\tbearing -= inner_angle;\n\t\t\t\t}\n\n\t\t\t\t// set typ to position, will get set to loiter in the fw position controller once close\n\t\t\t\t// and replace current setpoint lat/lon with tangent coordinate\n\t\t\t\tcurr_sp.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t\t\twaypoint_from_heading_and_distance(curr_sp.lat, curr_sp.lon,\n\t\t\t\t\t\t\t\t   bearing, fabsf(curr_sp.loiter_radius),\n\t\t\t\t\t\t\t\t   &curr_sp.lat, &curr_sp.lon);\n\t\t\t}\n\n\t\t\treturn true; // mission item is reached\n\t\t}\n\t}\n\n\treturn false;\n}"
    },
    "MissionBlock::set_vtol_transition_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::set_vtol_transition_item(struct mission_item_s *item, const uint8_t new_mode)\n{\n\titem->nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n\titem->params[0] = (float) new_mode;\n\titem->params[1] = 0.0f; // not immediate transition\n\titem->autocontinue = true;\n}"
    },
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBlock::mission_item_to_position_setpoint(const mission_item_s &item, position_setpoint_s *sp)\n{\n\t// Don't change the setpoint for non-position items\n\tif (!item_contains_position(item)) {\n\t\treturn false;\n\t}\n\n\tsp->lat = item.lat;\n\tsp->lon = item.lon;\n\tsp->alt = get_absolute_altitude_for_item(item);\n\tsp->yaw = item.yaw;\n\tsp->loiter_radius = (fabsf(item.loiter_radius) > NAV_EPSILON_POSITION) ? fabsf(item.loiter_radius) :\n\t\t\t    _navigator->get_loiter_radius();\n\tsp->loiter_direction_counter_clockwise = item.loiter_radius < 0;\n\n\tif (item.acceptance_radius > 0.001f && PX4_ISFINITE(item.acceptance_radius)) {\n\t\t// if the mission item has a specified acceptance radius, overwrite the default one from parameters\n\t\tsp->acceptance_radius = item.acceptance_radius;\n\n\t} else {\n\t\tsp->acceptance_radius = _navigator->get_default_acceptance_radius();\n\t}\n\n\tsp->cruising_speed = _navigator->get_cruising_speed();\n\tsp->cruising_throttle = _navigator->get_cruising_throttle();\n\n\t// for fixed wing we don't use cruising_throttle directly anymore, instead we command airspeed setpoints via cruising_speed\n\t// we still use cruising throttle here to determine if gliding is enabled\n\tsp->gliding_enabled = (_navigator->get_cruising_throttle() < FLT_EPSILON);\n\n\tswitch (item.nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\n\t\t// if already flying (armed and !landed) treat TAKEOFF like regular POSITION\n\t\tif ((_navigator->get_vstatus()->arming_state == vehicle_status_s::ARMING_STATE_ARMED)\n\t\t    && !_navigator->get_land_detected()->landed && !_navigator->get_land_detected()->maybe_landed) {\n\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\t} else {\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\n\t\t\t// Don't set a yaw setpoint for takeoff, as Navigator doesn't handle the yaw reset.\n\t\t\t// The yaw setpoint generation is handled by FlightTaskAuto.\n\t\t\tsp->yaw = NAN;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\tcase NAV_CMD_VTOL_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TO_ALT:\n\t\tsp->alt = _navigator->get_global_position()->alt;\n\n\t// FALLTHROUGH\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n\n\tsp->valid = true;\n\tsp->timestamp = hrt_absolute_time();\n\n\treturn sp->valid;\n}"
    },
    "MissionBase::heading_sp_update": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "MissionBase::heading_sp_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet =\n\t\t_navigator->get_position_setpoint_triplet();\n\n\t// Only update if current triplet is valid\n\tif (pos_sp_triplet->current.valid) {\n\n\t\tdouble point_from_latlon[2] = { _global_pos_sub.get().lat,\n\t\t\t\t\t\t_global_pos_sub.get().lon\n\t\t\t\t\t      };\n\t\tdouble point_to_latlon[2] = { _global_pos_sub.get().lat,\n\t\t\t\t\t      _global_pos_sub.get().lon\n\t\t\t\t\t    };\n\t\tfloat yaw_offset = 0.0f;\n\n\t\t// Depending on ROI-mode, update heading\n\t\tswitch (_navigator->get_vroi().mode) {\n\t\tcase vehicle_roi_s::ROI_LOCATION: {\n\t\t\t\t// ROI is a fixed location. Vehicle needs to point towards that location\n\t\t\t\tpoint_to_latlon[0] = _navigator->get_vroi().lat;\n\t\t\t\tpoint_to_latlon[1] = _navigator->get_vroi().lon;\n\t\t\t\t// No yaw offset required\n\t\t\t\tyaw_offset = 0.0f;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_roi_s::ROI_WPNEXT: {\n\t\t\t\t// ROI is current waypoint. Vehcile needs to point towards current waypoint\n\t\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n\t\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n\t\t\t\t// Add the gimbal's yaw offset\n\t\t\t\tyaw_offset = _navigator->get_vroi().yaw_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vehicle_roi_s::ROI_NONE:\n\t\tcase vehicle_roi_s::ROI_WPINDEX:\n\t\tcase vehicle_roi_s::ROI_TARGET:\n\t\tcase vehicle_roi_s::ROI_ENUM_END:\n\t\tdefault: {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Get desired heading and update it.\n\t\t// However, only update if distance to desired heading is\n\t\t// larger than acceptance radius to prevent excessive yawing\n\t\tfloat d_current = get_distance_to_next_waypoint(point_from_latlon[0],\n\t\t\t\t  point_from_latlon[1], point_to_latlon[0], point_to_latlon[1]);\n\n\t\tif (d_current > _navigator->get_acceptance_radius()) {\n\t\t\tfloat yaw = matrix::wrap_pi(\n\t\t\t\t\t    get_bearing_to_next_waypoint(point_from_latlon[0],\n\t\t\t\t\t\t\t    point_from_latlon[1], point_to_latlon[0],\n\t\t\t\t\t\t\t    point_to_latlon[1]) + yaw_offset);\n\n\t\t\t_mission_item.yaw = yaw;\n\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\n\t\t} else {\n\t\t\tif (!PX4_ISFINITE(pos_sp_triplet->current.yaw)) {\n\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\t\t\t}\n\t\t}\n\n\t\t// we set yaw directly so we can run this in parallel to the FOH update\n\t\tpublish_navigator_mission_item();\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n}"
    },
    "PX4_ISFINITE": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "const float mission_item_loiter_radius_abs = (PX4_ISFINITE(_mission_item.loiter_radius)\n\t\t\t\t&& fabsf(_mission_item.loiter_radius) > FLT_EPSILON) ? fabsf(_mission_item.loiter_radius) :\n\t\t\t\t_navigator->get_loiter_radius();\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, mission_item_altitude_amsl,\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\t_navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\n\t\t\t/* We want to avoid the edge case where the acceptance radius is bigger or equal than\n\t\t\t * the altitude of the takeoff waypoint above home. Otherwise, we do not really follow\n\t\t\t * take-off procedures like leaving the landing gear down. */\n\n\t\t\tfloat takeoff_alt = _mission_item.altitude_is_relative ?\n\t\t\t\t\t    _mission_item.altitude :\n\t\t\t\t\t    (_mission_item.altitude - _navigator->get_home_position()->alt);\n\n\t\t\tfloat altitude_acceptance_radius = _navigator->get_altitude_acceptance_radius();\n\n\t\t\t/* It should be safe to just use half of the takoeff_alt as an acceptance radius. */\n\t\t\tif (takeoff_alt > 0 && takeoff_alt < altitude_acceptance_radius) {\n\t\t\t\taltitude_acceptance_radius = takeoff_alt / 2.0f;\n\t\t\t}\n\n\t\t\t/* require only altitude for takeoff for multicopter */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t    mission_item_altitude_amsl - altitude_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\n\t\t}"
    },
    "Navigator::get_acceptance_radius": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "float Navigator::get_acceptance_radius()\n{\n\tfloat acceptance_radius = get_default_acceptance_radius(); // the value specified in the parameter NAV_ACC_RAD\n\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n\n\t// for fixed-wing and rover, return the max of NAV_ACC_RAD and the controller acceptance radius (e.g. navigation switch distance)\n\tif (_vstatus.vehicle_type != vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t    && PX4_ISFINITE(pos_ctrl_status.acceptance_radius) && pos_ctrl_status.timestamp != 0) {\n\n\t\tacceptance_radius = math::max(acceptance_radius, pos_ctrl_status.acceptance_radius);\n\t}\n\n\treturn acceptance_radius;\n}"
    },
    "calculate_breaking_stop": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void set_gimbal_neutral();\n\n\tvoid calculate_breaking_stop(double &lat, double &lon);\n\n\tvoid stop_capturing_images();\n\tvoid disable_camera_trigger();\n\n\tvoid mode_completed(uint8_t nav_state, uint8_t result = mode_completed_s::RESULT_SUCCESS);\n\nprivate:\n\n\tint _local_pos_sub{-1}"
    },
    "Navigator::geofence_breach_check": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void Navigator::geofence_breach_check()\n{\n\t// reset the _time_loitering_after_gf_breach time if no longer in LOITER (and 100ms after it was triggered)\n\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER\n\t    && hrt_elapsed_time(&_time_loitering_after_gf_breach) > 100_ms) {\n\t\t_time_loitering_after_gf_breach = 0;\n\t}\n\n\tif ((_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t    (hrt_elapsed_time(&_last_geofence_check) > GEOFENCE_CHECK_INTERVAL_US)) {\n\n\t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n\n\t\tgeofence_violation_type_u gf_violation_type{};\n\t\tfloat test_point_bearing;\n\t\tfloat test_point_distance;\n\t\tfloat vertical_test_point_distance;\n\n\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\ttest_point_bearing = atan2f(_local_pos.vy, _local_pos.vx);\n\t\t\tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n\t\t\t_gf_breach_avoidance.setHorizontalVelocity(velocity_hor_abs);\n\t\t\t_gf_breach_avoidance.setClimbRate(-_local_pos.vz);\n\t\t\ttest_point_distance = _gf_breach_avoidance.computeBrakingDistanceMultirotor();\n\t\t\tvertical_test_point_distance = _gf_breach_avoidance.computeVerticalBrakingDistanceMultirotor();\n\n\t\t} else {\n\t\t\ttest_point_distance = 2.0f * get_loiter_radius();\n\t\t\tvertical_test_point_distance = 5.0f;\n\n\t\t\tif (hrt_absolute_time() - pos_ctrl_status.timestamp < 100000 && PX4_ISFINITE(pos_ctrl_status.nav_bearing)) {\n\t\t\t\ttest_point_bearing = pos_ctrl_status.nav_bearing;\n\n\t\t\t} else {\n\t\t\t\ttest_point_bearing = atan2f(_local_pos.vy, _local_pos.vx);\n\t\t\t}\n\t\t}\n\n\t\tdouble current_latitude = _global_pos.lat;\n\t\tdouble current_longitude = _global_pos.lon;\n\t\tfloat current_altitude = _global_pos.alt;\n\t\tbool position_valid = _global_pos.timestamp > 0;\n\n\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\tcurrent_latitude = _gps_pos.latitude_deg;\n\t\t\tcurrent_longitude = _gps_pos.longitude_deg;\n\t\t\tcurrent_altitude = _gps_pos.altitude_msl_m;\n\t\t\tposition_valid = _global_pos.timestamp > 0;\n\t\t}\n\n\t\tif (!position_valid) {\n\t\t\t// we don't have a valid position yet, so we can't check for geofence violations\n\t\t\treturn;\n\t\t}\n\n\t\t_gf_breach_avoidance.setHorizontalTestPointDistance(test_point_distance);\n\t\t_gf_breach_avoidance.setVerticalTestPointDistance(vertical_test_point_distance);\n\t\t_gf_breach_avoidance.setTestPointBearing(test_point_bearing);\n\t\t_gf_breach_avoidance.setCurrentPosition(current_latitude, current_longitude, current_altitude);\n\t\t_gf_breach_avoidance.setMaxHorDistHome(_geofence.getMaxHorDistanceHome());\n\n\t\tif (home_global_position_valid()) {\n\t\t\t_gf_breach_avoidance.setHomePosition(_home_pos.lat, _home_pos.lon, _home_pos.alt);\n\t\t}\n\n\t\tdouble test_point_latitude = current_latitude;\n\t\tdouble test_point_longitude = current_longitude;\n\t\tfloat test_point_altitude = current_altitude;\n\n\t\tif (_geofence.getPredict()) {\n\t\t\tmatrix::Vector2<double>fence_violation_test_point = _gf_breach_avoidance.getFenceViolationTestPoint();\n\t\t\ttest_point_latitude = fence_violation_test_point(0);\n\t\t\ttest_point_longitude = fence_violation_test_point(1);\n\t\t\ttest_point_altitude = current_altitude + vertical_test_point_distance;\n\t\t}\n\n\t\tif (_time_loitering_after_gf_breach > 0) {\n\t\t\t// if we are in the loitering state after breaching a GF, only allow new ones to be set, but not unset\n\t\t\t_geofence_result.geofence_max_dist_triggered |= !_geofence.isCloserThanMaxDistToHome(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\t\t\t_geofence_result.geofence_max_alt_triggered |= !_geofence.isBelowMaxAltitude(test_point_altitude);\n\t\t\t_geofence_result.geofence_custom_fence_triggered |= !_geofence.isInsidePolygonOrCircle(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\n\t\t} else {\n\t\t\t_geofence_result.geofence_max_dist_triggered = !_geofence.isCloserThanMaxDistToHome(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\t\t\t_geofence_result.geofence_max_alt_triggered = !_geofence.isBelowMaxAltitude(test_point_altitude);\n\t\t\t_geofence_result.geofence_custom_fence_triggered = !_geofence.isInsidePolygonOrCircle(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\t\t}\n\n\t\t_last_geofence_check = hrt_absolute_time();\n\n\t\t_geofence_result.timestamp = hrt_absolute_time();\n\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\n\t\tif (_geofence_result.geofence_max_dist_triggered || _geofence_result.geofence_max_alt_triggered ||\n\t\t    _geofence_result.geofence_custom_fence_triggered) {\n\n\t\t\t/* Issue a warning about the geofence violation once and only if we are armed */\n\t\t\tif (!_geofence_reposition_sent && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED\n\t\t\t    && _geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n\n\t\t\t\t// we have predicted a geofence violation and if the action is to loiter then\n\t\t\t\t// demand a reposition to a location which is inside the geofence\n\n\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\n\t\t\t\tmatrix::Vector2<double> loiter_center_lat_lon;\n\n\t\t\t\tfloat loiter_altitude_amsl = current_altitude;\n\t\t\t\tdouble loiter_latitude = current_latitude;\n\t\t\t\tdouble loiter_longitude = current_longitude;\n\n\t\t\t\tif (_geofence.getPredict()) {\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t\t\t\t// the computation of the braking distance does not match the actual braking distance. Until we have a better model\n\t\t\t\t\t\t// we set the loiter point to the current position, that will make sure that the vehicle will loiter inside the fence\n\t\t\t\t\t\tloiter_center_lat_lon =  _gf_breach_avoidance.generateLoiterPointForMultirotor(gf_violation_type,\n\t\t\t\t\t\t\t\t\t &_geofence);\n\t\t\t\t\t\tloiter_latitude = loiter_center_lat_lon(0);\n\t\t\t\t\t\tloiter_longitude = loiter_center_lat_lon(1);\n\n\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForMulticopter(gf_violation_type);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tloiter_center_lat_lon = _gf_breach_avoidance.generateLoiterPointForFixedWing(gf_violation_type, &_geofence);\n\t\t\t\t\t\tloiter_latitude = loiter_center_lat_lon(0);\n\t\t\t\t\t\tloiter_longitude = loiter_center_lat_lon(1);\n\n\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForFixedWing(gf_violation_type);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\t\t\t\trep->current.yaw = NAN;\n\t\t\t\trep->current.lat = loiter_latitude;\n\t\t\t\trep->current.lon = loiter_longitude;\n\t\t\t\trep->current.alt = loiter_altitude_amsl;\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t_geofence_reposition_sent = true;\n\t\t\t\t_time_loitering_after_gf_breach = hrt_absolute_time();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_geofence_reposition_sent = false;\n\t\t}\n\n\t\t_geofence_result_pub.publish(_geofence_result);\n\t}\n}"
    },
    "Mission::handleVtolTransition": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void Mission::handleVtolTransition(WorkItemType &new_work_item_type, mission_item_s next_mission_items[],\n\t\t\t\t   size_t &num_found_items)\n{\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* turn towards next waypoint before MC to FW transition */\n\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t    && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT\n\t    && new_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT\n\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t    && !_land_detected_sub.get().landed\n\t    && (num_found_items > 0u)) {\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING;\n\n\t\tset_align_mission_item(&_mission_item, &next_mission_items[0u]);\n\n\t\t/* set position setpoint to target during the transition */\n\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->current);\n\t}\n\n\t/* yaw is aligned now */\n\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING &&\n\t    new_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n\n\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t}\n}"
    },
    "VtolTakeoff::set_takeoff_position": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "VtolTakeoff::set_takeoff_position()\n{\n\t// set current mission item to takeoff\n\tset_takeoff_item(&_mission_item, _transition_alt_amsl);\n\n\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t_mission_item.lon = _navigator->get_global_position()->lon;\n\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\n\t// convert mission item to current setpoint\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\tpos_sp_triplet->previous.valid = false;\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Navigator::calculate_breaking_stop": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void Navigator::calculate_breaking_stop(double &lat, double &lon)\n{\n\t// For multirotors we need to account for the braking distance, otherwise the vehicle will overshoot and go back\n\tconst float course_over_ground = atan2f(_local_pos.vy, _local_pos.vx);\n\n\t// predict braking distance\n\n\tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n\n\tconst float multirotor_braking_distance = math::trajectory::computeBrakingDistanceFromVelocity(velocity_hor_abs,\n\t\t\t_param_mpc_jerk_auto, _param_mpc_acc_hor, 0.6f * _param_mpc_jerk_auto);\n\n\twaypoint_from_heading_and_distance(get_global_position()->lat, get_global_position()->lon, course_over_ground,\n\t\t\t\t\t   multirotor_braking_distance, &lat, &lon);\n}"
    },
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "void Navigator::run()\n{\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\tuint32_t geofence_id{0};\n\tuint32_t safe_points_id{0};\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\n\t\t\tif (mission.geofence_id != geofence_id) {\n\t\t\t\tgeofence_id = mission.geofence_id;\n\t\t\t\t_geofence.updateFence();\n\t\t\t}\n\n\t\t\tif (mission.safe_points_id != safe_points_id) {\n\t\t\t\tsafe_points_id = mission.safe_points_id;\n\t\t\t\t_rtl.updateSafePoints();\n\t\t\t}\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = curr->current.loiter_minor_radius;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = NAN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_orientation) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_orientation = curr->current.loiter_orientation;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr->current.loiter_pattern > 0) {\n\t\t\t\t\t\t\trep->current.loiter_pattern = curr->current.loiter_pattern;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_FIGUREEIGHT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n#ifdef CONFIG_FIGURE_OF_EIGHT\n\t\t\t\t// Only valid for fixed wing mode\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param2) && fabsf(cmd.param2) > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_minor_radius = fabsf(cmd.param2);\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = 2.5f * rep->current.loiter_minor_radius;\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.loiter_orientation = cmd.param4;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n\t\t\t\t}\n\n#endif // CONFIG_FIGURE_OF_EIGHT\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\t// Don't set a yaw setpoint for takeoff, as Navigator doesn't handle the yaw reset.\n\t\t\t\t// The yaw setpoint generation is handled by FlightTaskAuto.\n\t\t\t\trep->current.yaw = NAN;\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n\n\t\t\t\tif (_mission.get_land_start_available()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t\tresult = vehicle_command_ack_s::VEHICLE_CMD_RESULT_CANCELLED;\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, result);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\treset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check();\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\n\t\t\t// If we are already in mission landing, do not switch.\n\t\t\tif (_navigation_mode == &_mission && _mission.isLanding()) {\n\t\t\t\tnavigation_mode_new = &_mission;\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t}\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t// If we are in VTOL takeoff, do not switch until it is finished.\n\t\t\tif (_navigation_mode == &_vtol_takeoff && !get_mission_result()->finished) {\n\t\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\n\t\t\t} else\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\t\t\t{\n\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\t_geofence.run();\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    },
    "VtolTakeoff::on_active": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "VtolTakeoff::on_active()\n{\n\tif (is_mission_item_reached_or_completed()) {\n\t\treset_mission_item_reached();\n\n\t\tswitch\t(_takeoff_state) {\n\t\tcase vtol_takeoff_state::TAKEOFF_HOVER: {\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat,\n\t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n\t\t\t\t_mission_item.force_heading = true;\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::ALIGN_HEADING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::ALIGN_HEADING: {\n\n\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t_mission_item.lat = _loiter_location(0);\n\t\t\t\t_mission_item.lon = _loiter_location(1);\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\tissue_command(_mission_item);\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::TRANSITION;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::TRANSITION: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t\t} else {\n\t\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t\t}\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n\t\t\t\t// however it will just continue loitering as there is no next mission item\n\t\t\t\t_mission_item.time_inside = 1.f;\n\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n\t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.lat = _loiter_location(0);\n\t\t\t\tpos_sp_triplet->current.lon = _loiter_location(1);\n\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n\n\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\treset_mission_item_reached();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::CLIMB;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::CLIMB: {\n\n\t\t\t\t// reset any potentially valid reposition triplet which was not handled\n\t\t\t\t// we do this to avoid random loiter locations after switching to loiter mode after this\n\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n\n\t\t\t\t// the VTOL takeoff is done\n\t\t\t\t_navigator->get_mission_result()->finished = true;\n\t\t\t\t_navigator->set_mission_result_updated();\n\t\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "MissionBase::position_setpoint_equal": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "81e2662fea71d1f95f113de51c8f381472310a05",
      "source": "bool MissionBase::position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const\n{\n\treturn ((p1->valid == p2->valid) &&\n\t\t(p1->type == p2->type) &&\n\t\t(fabsf(p1->vx - p2->vx) < FLT_EPSILON) &&\n\t\t(fabsf(p1->vy - p2->vy) < FLT_EPSILON) &&\n\t\t(fabsf(p1->vz - p2->vz) < FLT_EPSILON) &&\n\t\t(fabs(p1->lat - p2->lat) < DBL_EPSILON) &&\n\t\t(fabs(p1->lon - p2->lon) < DBL_EPSILON) &&\n\t\t(fabsf(p1->alt - p2->alt) < FLT_EPSILON) &&\n\t\t((fabsf(p1->yaw - p2->yaw) < FLT_EPSILON) || (!PX4_ISFINITE(p1->yaw) && !PX4_ISFINITE(p2->yaw))) &&\n\t\t(fabsf(p1->loiter_radius - p2->loiter_radius) < FLT_EPSILON) &&\n\t\t(p1->loiter_direction_counter_clockwise == p2->loiter_direction_counter_clockwise) &&\n\t\t(fabsf(p1->acceptance_radius - p2->acceptance_radius) < FLT_EPSILON) &&\n\t\t(fabsf(p1->cruising_speed - p2->cruising_speed) < FLT_EPSILON) &&\n\t\t((fabsf(p1->cruising_throttle - p2->cruising_throttle) < FLT_EPSILON) || (!PX4_ISFINITE(p1->cruising_throttle)\n\t\t\t\t&& !PX4_ISFINITE(p2->cruising_throttle))));\n\n}"
    }
  },
  "22341": {
    "RTL::findRtlDestination": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "19b681ca1fc9b59790f0f877663e2bd11a914ba5",
      "source": "void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosition &rtl_position, float &rtl_alt)\n{\n\t// set destination to home per default, then check if other valid landing spot is closer\n\trtl_position.alt = _home_pos_sub.get().alt;\n\trtl_position.lat = _home_pos_sub.get().lat;\n\trtl_position.lon = _home_pos_sub.get().lon;\n\trtl_position.yaw = _home_pos_sub.get().yaw;\n\tdestination_type = DestinationType::DESTINATION_TYPE_HOME;\n\n\tconst bool vtol_in_rw_mode = _vehicle_status_sub.get().is_vtol\n\t\t\t\t     && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING);\n\n\t// get distance to home position\n\tfloat home_dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, rtl_position.lat, rtl_position.lon)};\n\tfloat min_dist;\n\n\tif (((_param_rtl_type.get() == 1) && !vtol_in_rw_mode) || ((_param_rtl_approach_force.get() == 1)\n\t\t\t&& !hasVtolLandApproach(rtl_position))) {\n\t\t// Set minimum distance to maximum value when RTL_TYPE is set to 1 and we are not in RW mode or we forces approach landing and it is not defined for home.\n\t\tmin_dist = FLT_MAX;\n\n\t} else {\n\t\tmin_dist = home_dist;\n\t}\n\n\t// consider the mission landing if available and allowed\n\tif (((_param_rtl_type.get() == 1) || (_param_rtl_type.get() == 3) || (fabsf(FLT_MAX - min_dist) < FLT_EPSILON))\n\t    && hasMissionLandStart()) {\n\t\tmission_item_s land_mission_item;\n\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().dataman_id);\n\t\tbool success = _dataman_cache_landItem.loadWait(dm_item, _mission_sub.get().land_index,\n\t\t\t\treinterpret_cast<uint8_t *>(&land_mission_item), sizeof(mission_item_s), 500_ms);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission land item could not be read.\\t\");\n\t\t\tevents::send(events::ID(\"rtl_failed_to_read_land_item\"), events::Log::Error,\n\t\t\t\t     \"Mission land item could not be read\");\n\t\t}\n\n\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_mission_item.lat, land_mission_item.lon)};\n\n\t\tif ((dist + MIN_DIST_THRESHOLD) < min_dist) {\n\t\t\tif (_param_rtl_type.get() != 0) {\n\t\t\t\tmin_dist = dist;\n\n\t\t\t} else {\n\t\t\t\t// Mission landing is not allowed, but home has no approaches. Still use mission landing.\n\t\t\t\tmin_dist = FLT_MAX;\n\t\t\t}\n\n\t\t\tsetLandPosAsDestination(rtl_position, land_mission_item);\n\t\t\tdestination_type = DestinationType::DESTINATION_TYPE_MISSION_LAND;\n\t\t}\n\t}\n\n\tif (_safe_points_updated) {\n\n\t\tfor (int current_seq = 1; current_seq <= _dataman_cache_safepoint.size(); ++current_seq) {\n\t\t\tmission_item_s mission_safe_point;\n\n\t\t\tbool success = _dataman_cache_safepoint.loadWait(DM_KEY_SAFE_POINTS, current_seq,\n\t\t\t\t\treinterpret_cast<uint8_t *>(&mission_safe_point),\n\t\t\t\t\tsizeof(mission_item_s), 500_ms);\n\n\t\t\tif (!success) {\n\t\t\t\tPX4_ERR(\"dm_read failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Ignore safepoints which are too close to the homepoint\n\t\t\tconst float dist_to_home = get_distance_to_next_waypoint(_home_pos_sub.get().lat, _home_pos_sub.get().lon,\n\t\t\t\t\t\t   mission_safe_point.lat, mission_safe_point.lon);\n\n\t\t\tif (mission_safe_point.nav_cmd == NAV_CMD_RALLY_POINT && dist_to_home > MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n\t\t\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, mission_safe_point.lat, mission_safe_point.lon)};\n\n\t\t\t\tDestinationPosition safepoint_position;\n\t\t\t\tsetSafepointAsDestination(safepoint_position, mission_safe_point);\n\n\t\t\t\tif (((dist + MIN_DIST_THRESHOLD) < min_dist) && ((_param_rtl_approach_force.get() == 0)\n\t\t\t\t\t\t|| hasVtolLandApproach(safepoint_position))) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t\trtl_position = safepoint_position;\n\t\t\t\t\tdestination_type = DestinationType::DESTINATION_TYPE_SAFE_POINT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_param_rtl_cone_half_angle_deg.get() > 0\n\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\trtl_alt = calculate_return_alt_from_cone_half_angle(rtl_position, (float)_param_rtl_cone_half_angle_deg.get());\n\n\t} else {\n\t\trtl_alt = max(_global_pos_sub.get().alt, rtl_position.alt + _param_rtl_return_alt.get());\n\t}\n}"
    },
    "RTL::setRtlTypeAndDestination": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "19b681ca1fc9b59790f0f877663e2bd11a914ba5",
      "source": "void RTL::setRtlTypeAndDestination()\n{\n\n\tinit_rtl_mission_type();\n\n\tif (_param_rtl_type.get() != 2) {\n\t\t// check the closest allowed destination.\n\t\tDestinationType destination_type{DestinationType::DESTINATION_TYPE_HOME};\n\t\tDestinationPosition rtl_position;\n\t\tfloat rtl_alt;\n\t\tfindRtlDestination(destination_type, rtl_position, rtl_alt);\n\n\t\tswitch (destination_type) {\n\t\tcase DestinationType::DESTINATION_TYPE_MISSION_LAND:\n\t\t\t_rtl_type = RtlType::RTL_DIRECT_MISSION_LAND;\n\t\t\t_rtl_mission_type_handle->setRtlAlt(rtl_alt);\n\t\t\tbreak;\n\n\t\tcase DestinationType::DESTINATION_TYPE_SAFE_POINT: // Fallthrough\n\t\tcase DestinationType::DESTINATION_TYPE_HOME: // Fallthrough\n\t\tdefault:\n\n\t\t\tloiter_point_s landing_loiter;\n\t\t\tlanding_loiter.lat = rtl_position.lat;\n\t\t\tlanding_loiter.lon = rtl_position.lon;\n\t\t\tlanding_loiter.height_m = NAN;\n\n\t\t\tland_approaches_s rtl_land_approaches{readVtolLandApproaches(rtl_position)};\n\n\t\t\tif (rtl_land_approaches.isAnyApproachValid()) {\n\t\t\t\tlanding_loiter = chooseBestLandingApproach(rtl_land_approaches);\n\t\t\t}\n\n\t\t\t_rtl_type = RtlType::RTL_DIRECT;\n\t\t\t_rtl_direct.setRtlAlt(rtl_alt);\n\t\t\t_rtl_direct.setRtlPosition(rtl_position, landing_loiter);\n\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "4081": {
    "MissionBlock::set_follow_target_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "072645b483f1ce083375ec1165f0352aedd2043e",
      "source": "MissionBlock::set_follow_target_item(struct mission_item_s *item, float min_clearance, follow_target_s & target, float yaw)\n{\n\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t/* landed, don't takeoff, but switch to IDLE mode */\n\t\titem->nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\n\t\titem->nav_cmd = NAV_CMD_FOLLOW_TARGET;\n\n\t\t/* use current target position */\n\n\t\titem->lat = target.lat;\n\t\titem->lon = target.lon;\n\t\titem->altitude = target.alt + _navigator->get_home_position()->alt;\n\n\t\tif (((min_clearance > 0.0f) && (item->altitude < _navigator->get_home_position()->alt + min_clearance)) || PX4_ISFINITE(target.alt)) {\n\t\t\titem->altitude = _navigator->get_home_position()->alt + min_clearance;\n\t\t}\n\t}\n\n\titem->altitude_is_relative = false;\n\titem->yaw = yaw;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->loiter_direction = 1;\n\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->pitch_min = 0.0f;\n\titem->autocontinue = false;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    }
  },
  "22305": {
    "MissionBlock::setLoiterItemFromCurrentPositionSetpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "a989e5338ce3902dd63e5da41d99931d8185fdf8",
      "source": "MissionBlock::setLoiterItemFromCurrentPositionSetpoint(struct mission_item_s *item)\n{\n\tsetLoiterItemCommonFields(item);\n\n\tconst position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\titem->lat = pos_sp_triplet->current.lat;\n\titem->lon = pos_sp_triplet->current.lon;\n\titem->altitude = pos_sp_triplet->current.alt;\n\titem->loiter_radius = pos_sp_triplet->current.loiter_radius;\n}"
    },
    "Loiter::set_loiter_position": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "a989e5338ce3902dd63e5da41d99931d8185fdf8",
      "source": "Loiter::set_loiter_position()\n{\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n\t    _navigator->get_land_detected()->landed) {\n\n\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n\t\t// setpoint as invalid and idle (both, just to be sure).\n\n\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\n\t}\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n\n\t\t} else {\n\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t}\n\n\t}\n\n\t// convert mission item to current setpoint\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "4068": {
    "Navigator::task_main": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "1f47aa11802271d0b7904b38e59f078b99df2600",
      "source": "Navigator::task_main()\n{\n\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t_geofence.setMavlinkFd(_mavlink_fd);\n\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file\n\t * else clear geofence data in datamanager */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\twarnx(\"Try to load geofence.txt\");\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\n\t} else {\n\t\tif (_geofence.clearDm() != OK) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"failed clearing geofence\");\n\t\t}\n\t}\n\n\t/* do subscriptions */\n\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n\t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n\t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n\t_onboard_mission_sub = orb_subscribe(ORB_ID(onboard_mission));\n\t_offboard_mission_sub = orb_subscribe(ORB_ID(offboard_mission));\n\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n\n\t/* copy all topics first time */\n\tvehicle_status_update();\n\tvehicle_control_mode_update();\n\tglobal_position_update();\n\tgps_position_update();\n\tsensor_combined_update();\n\thome_position_update(true);\n\tnavigation_capabilities_update();\n\tparams_update();\n\n\thrt_abstime mavlink_open_time = 0;\n\tconst hrt_abstime mavlink_open_interval = 500000;\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[1] = {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _global_pos_sub;\n\tfds[0].events = POLLIN;\n\n\tbool global_pos_available_once = false;\n\n\twhile (!_task_should_exit) {\n\n\t\t/* wait for up to 200ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n\t\t\tif (global_pos_available_once) {\n\t\t\t\tPX4_WARN(\"navigator timed out\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal_pos_available_once = true;\n\n\t\tperf_begin(_loop_perf);\n\n\t\tif (_mavlink_fd < 0 && hrt_absolute_time() > mavlink_open_time) {\n\t\t\t/* try to reopen the mavlink log device with specified interval */\n\t\t\tmavlink_open_time = hrt_abstime() + mavlink_open_interval;\n\t\t\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t\t}\n\n\t\tbool updated;\n\n\t\t/* gps updated */\n\t\torb_check(_gps_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\tgps_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* sensors combined updated */\n\t\torb_check(_sensor_combined_sub, &updated);\n\t\tif (updated) {\n\t\t\tsensor_combined_update();\n\t\t}\n\n\t\t/* parameters updated */\n\t\torb_check(_param_update_sub, &updated);\n\t\tif (updated) {\n\t\t\tparams_update();\n\t\t\tupdateParams();\n\t\t}\n\n\t\t/* vehicle control mode updated */\n\t\torb_check(_control_mode_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_control_mode_update();\n\t\t}\n\n\t\t/* vehicle status updated */\n\t\torb_check(_vstatus_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_status_update();\n\t\t}\n\n\t\t/* navigation capabilities updated */\n\t\torb_check(_capabilities_sub, &updated);\n\t\tif (updated) {\n\t\t\tnavigation_capabilities_update();\n\t\t}\n\n\t\t/* home position updated */\n\t\torb_check(_home_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\thome_position_update();\n\t\t}\n\n\t\torb_check(_vehicle_command_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_command_s cmd;\n\t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n\t\t\t\twarnx(\"navigator: got reposition command\");\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n\t\t\t\twarnx(\"navigator: got pause/continue command\");\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (fds[0].revents & POLLIN) {\n\t\t\tglobal_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Check geofence violation */\n\t\tstatic hrt_abstime last_geofence_check = 0;\n\t\tif (have_geofence_position_data &&\n\t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n\t\t\tlast_geofence_check = hrt_absolute_time();\n\t\t\thave_geofence_position_data = false;\n\n\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\t\t\tif (!inside) {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = true;\n\t\t\t\tpublish_geofence_result();\n\n\t\t\t\t/* Issue a warning about the geofence violation once */\n\t\t\t\tif (!_geofence_violation_warning_sent) {\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation\");\n\t\t\t\t\t_geofence_violation_warning_sent = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = false;\n\t\t\t\tpublish_geofence_result();\n\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n\t\t\t\t_geofence_violation_warning_sent = false;\n\t\t\t}\n\t\t}\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tswitch (_vstatus.nav_state) {\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t\tif (_nav_caps.abort_landing) {\n\t\t\t\t\t// pos controller aborted landing, requests loiter\n\t\t\t\t\t// above landing waypoint\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t} else {\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t\t_navigation_mode = &_mission;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_rcloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_rcLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_takeoff;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n\t\t\t\t/* Use complex data link loss mode only when enabled via param\n\t\t\t\t* otherwise use rtl */\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_datalinkloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_engineFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_gpsFailure;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\t_pos_sp_triplet.previous.valid = false;\n\t\t\t_pos_sp_triplet.current.valid = false;\n\t\t\t_pos_sp_triplet.next.valid = false;\n\t\t\t_pos_sp_triplet_updated = true;\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t\t_pos_sp_triplet_updated = false;\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t\t_mission_result_updated = false;\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n\twarnx(\"exiting.\");\n\n\t_navigator_task = -1;\n\treturn;\n}"
    }
  },
  "22533": {
    "MissionBase::getNonJumpItem": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "int MissionBase::getNonJumpItem(int32_t &mission_index, mission_item_s &mission, bool execute_jump,\n\t\t\t\tbool write_jumps, bool mission_direction_backward)\n{\n\tif (mission_index >= _mission.count || mission_index < 0) {\n\t\treturn PX4_ERROR;\n\t}\n\n\tconst dm_item_t mission_dataman_id = (dm_item_t)_mission.mission_dataman_id;\n\tint32_t new_mission_index{mission_index};\n\tmission_item_s new_mission;\n\n\tfor (uint16_t jump_count = 0u; jump_count < MAX_JUMP_ITERATION; jump_count++) {\n\t\t/* read mission item from datamanager */\n\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, new_mission_index, reinterpret_cast<uint8_t *>(&new_mission),\n\t\t\t\t\t\t       sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Waypoint could not be read.\\t\");\n\t\t\tevents::send<uint16_t>(events::ID(\"mission_failed_to_read_wp\"), events::Log::Error,\n\t\t\t\t\t       \"Waypoint {1} could not be read from storage\", new_mission_index);\n\t\t\treturn PX4_ERROR;\n\t\t}\n\n\t\tif (new_mission.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\tif (new_mission.do_jump_mission_index >= _mission.count || new_mission.do_jump_mission_index < 0) {\n\t\t\t\tPX4_ERR(\"Do Jump mission index is out of bounds.\");\n\t\t\t\treturn PX4_ERROR;\n\t\t\t}\n\n\t\t\tif ((new_mission.do_jump_current_count < new_mission.do_jump_repeat_count) && execute_jump) {\n\t\t\t\tif (write_jumps) {\n\t\t\t\t\tnew_mission.do_jump_current_count++;\n\t\t\t\t\tsuccess = _dataman_cache.writeWait(mission_dataman_id, new_mission_index, reinterpret_cast<uint8_t *>(&new_mission),\n\t\t\t\t\t\t\t\t\t   sizeof(struct mission_item_s));\n\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the dataman */\n\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"DO JUMP waypoint could not be written.\\t\");\n\t\t\t\t\t\tevents::send(events::ID(\"mission_failed_to_write_do_jump\"), events::Log::Error,\n\t\t\t\t\t\t\t     \"DO JUMP waypoint could not be written\");\n\t\t\t\t\t\t// Still continue searching for next non jump item.\n\t\t\t\t\t}\n\n\t\t\t\t\treport_do_jump_mission_changed(new_mission_index, new_mission.do_jump_repeat_count - new_mission.do_jump_current_count);\n\t\t\t\t}\n\n\t\t\t\tnew_mission_index = new_mission.do_jump_mission_index;\n\n\t\t\t} else {\n\t\t\t\tif (mission_direction_backward) {\n\t\t\t\t\tnew_mission_index--;\n\n\t\t\t\t} else {\n\t\t\t\t\tnew_mission_index++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmission_index = new_mission_index;\n\tmission = new_mission;\n\n\treturn PX4_OK;\n}"
    },
    "Geofence::loadFromFile": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "Geofence::loadFromFile(const char *filename)\n{\n\tFILE *fp;\n\tchar line[120];\n\tint pointCounter = 0;\n\tbool gotVertical = false;\n\tconst char commentChar = '#';\n\tint ret_val = PX4_ERROR;\n\n\tmission_stats_entry_s stat;\n\t{\n\t\tconst bool success = _dataman_client.readAsync(DM_KEY_FENCE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&stat),\n\t\t\t\t     sizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"Could not read fence dataman state\");\n\t\t\treturn PX4_ERROR;\n\t\t}\n\t}\n\n\tdm_item_t write_fence_dataman_id{static_cast<dm_item_t>(stat.dataman_id) == DM_KEY_FENCE_POINTS_0 ? DM_KEY_FENCE_POINTS_1 : DM_KEY_FENCE_POINTS_0};\n\n\t/* open the mixer definition file */\n\tfp = fopen(GEOFENCE_FILENAME, \"r\");\n\n\tif (fp == nullptr) {\n\t\treturn PX4_ERROR;\n\t}\n\n\t/* create geofence points from valid lines and store in DM */\n\tfor (;;) {\n\t\t/* get a line, bail on error/EOF */\n\t\tif (fgets(line, sizeof(line), fp) == nullptr) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Trim leading whitespace */\n\t\tsize_t textStart = 0;\n\n\t\twhile ((textStart < sizeof(line) / sizeof(char)) && isspace(line[textStart])) { textStart++; }\n\n\t\t/* if the line starts with #, skip */\n\t\tif (line[textStart] == commentChar) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if there is only a linefeed, skip it */\n\t\tif (line[0] == '\\n') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (gotVertical) {\n\t\t\t/* Parse the line as a geofence point */\n\t\t\tmission_fence_point_s vertex{};\n\t\t\tvertex.frame = NAV_FRAME_GLOBAL;\n\t\t\tvertex.nav_cmd = NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION;\n\t\t\tvertex.vertex_count = 0; // this will be filled in a second pass\n\t\t\tvertex.alt = 0; // alt is not used\n\n\t\t\t/* if the line starts with DMS, this means that the coordinate is given as degree minute second instead of decimal degrees */\n\t\t\tif (line[textStart] == 'D' && line[textStart + 1] == 'M' && line[textStart + 2] == 'S') {\n\t\t\t\t/* Handle degree minute second format */\n\t\t\t\tdouble lat_d, lat_m, lat_s, lon_d, lon_m, lon_s;\n\n\t\t\t\tif (sscanf(line, \"DMS %lf %lf %lf %lf %lf %lf\", &lat_d, &lat_m, &lat_s, &lon_d, &lon_m, &lon_s) != 6) {\n\t\t\t\t\tPX4_ERR(\"Scanf to parse DMS geofence vertex failed.\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n//\t\t\t\tPX4_INFO(\"Geofence DMS: %.5lf %.5lf %.5lf ; %.5lf %.5lf %.5lf\", lat_d, lat_m, lat_s, lon_d, lon_m, lon_s);\n\n\t\t\t\tvertex.lat = lat_d + lat_m / 60.0 + lat_s / 3600.0;\n\t\t\t\tvertex.lon = lon_d + lon_m / 60.0 + lon_s / 3600.0;\n\n\t\t\t} else {\n\t\t\t\t/* Handle decimal degree format */\n\t\t\t\tif (sscanf(line, \"%lf %lf\", &vertex.lat, &vertex.lon) != 2) {\n\t\t\t\t\tPX4_ERR(\"Scanf to parse geofence vertex failed.\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool success = _dataman_client.writeSync(write_fence_dataman_id, pointCounter, reinterpret_cast<uint8_t *>(&vertex),\n\t\t\t\t\tsizeof(vertex));\n\n\t\t\tif (!success) {\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tPX4_INFO(\"Geofence: point: %d, lat %.5lf: lon: %.5lf\", pointCounter, vertex.lat, vertex.lon);\n\n\t\t\tpointCounter++;\n\n\t\t} else {\n\t\t\t/* Parse the line as the vertical limits */\n\t\t\tif (sscanf(line, \"%f %f\", &_altitude_min, &_altitude_max) != 2) {\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tPX4_INFO(\"Geofence: alt min: %.4f, alt_max: %.4f\", (double)_altitude_min, (double)_altitude_max);\n\t\t\tgotVertical = true;\n\t\t}\n\t}\n\n\n\t/* Check if import was successful */\n\tif (gotVertical && pointCounter > 2) {\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Geofence imported\\t\");\n\t\tevents::send(events::ID(\"navigator_geofence_imported\"), events::Log::Info, \"Geofence imported\");\n\t\tret_val = PX4_ERROR;\n\t\tuint32_t crc32{0U};\n\n\t\t/* do a second pass, now that we know the number of vertices */\n\t\tfor (int seq = 0; seq < pointCounter; ++seq) {\n\t\t\tmission_fence_point_s mission_fence_point;\n\n\t\t\tbool success = _dataman_client.readSync(write_fence_dataman_id, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t\t\tsizeof(mission_fence_point_s));\n\n\t\t\tif (success) {\n\t\t\t\tmission_fence_point.vertex_count = pointCounter;\n\t\t\t\tcrc32 = crc32_for_fence_point(mission_fence_point, crc32);\n\t\t\t\t_dataman_client.writeSync(write_fence_dataman_id, seq, reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t\t  sizeof(mission_fence_point_s));\n\t\t\t}\n\t\t}\n\n\t\tmission_stats_entry_s stats;\n\t\tstats.num_items = pointCounter;\n\t\tstats.opaque_id = crc32;\n\n\t\tbool success = _dataman_client.writeSync(DM_KEY_FENCE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&stats),\n\t\t\t\tsizeof(mission_stats_entry_s));\n\n\t\tif (success) {\n\t\t\tret_val = PX4_OK;\n\t\t}\n\n\t} else {\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence: import error\\t\");\n\t\tevents::send(events::ID(\"navigator_geofence_import_failed\"), events::Log::Error, \"Geofence: import error\");\n\t}\n\n\tupdateFence();\n\nerror:\n\tfclose(fp);\n\treturn ret_val;\n}"
    },
    "math::max": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "end_index = math::max(math::min(end_index, static_cast<int32_t>(_mission.count)), INT32_C(0));\n\n\t\tfor (int32_t index = start_index; index != end_index; index += math::signNoZero(_dataman_cache_size_signed)) {\n\n\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.mission_dataman_id), index);\n\t\t}"
    },
    "MissionBase::updateMavlinkMission": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void MissionBase::updateMavlinkMission()\n{\n\tif (_mission_sub.updated()) {\n\t\tmission_s new_mission;\n\t\t_mission_sub.update(&new_mission);\n\n\t\tconst bool mission_items_changed = (new_mission.mission_id != _mission.mission_id);\n\t\tconst bool mission_data_changed = checkMissionDataChanged(new_mission);\n\n\t\tif (new_mission.current_seq < 0) {\n\t\t\tnew_mission.current_seq = math::max(math::min(_mission.current_seq, static_cast<int32_t>(new_mission.count) - 1),\n\t\t\t\t\t\t\t    INT32_C(0));\n\t\t}\n\n\t\t_mission = new_mission;\n\n\t\t_is_current_planned_mission_item_valid = isMissionValid(_mission);\n\n\t\t/* Relevant mission items updated externally*/\n\t\tif (mission_data_changed) {\n\n\t\t\tonMissionUpdate(mission_items_changed);\n\t\t}\n\t}\n}"
    },
    "Mission::save_mission_state": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "Mission::save_mission_state()\n{\n\tif (_vehicle_status_sub.get().arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t// Save only while disarmed, as this is a blocking operation\n\t\t_need_mission_save = true;\n\t\treturn;\n\t}\n\n\t_need_mission_save = false;\n\tmission_s mission_state = {};\n\n\t/* read current state */\n\tbool success = _dataman_client.readSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\tsizeof(mission_s));\n\n\tif (success) {\n\t\t/* data read successfully, check dataman ID and items count */\n\t\tif (mission_state.mission_dataman_id == _mission.mission_dataman_id && mission_state.count == _mission.count\n\t\t    && mission_state.mission_id == _mission.mission_id) {\n\t\t\t/* navigator may modify only sequence, write modified state only if it changed */\n\t\t\tif (mission_state.current_seq != _mission.current_seq) {\n\t\t\t\tmission_state = _mission;\n\n\t\t\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\t\t\tif (!success) {\n\n\t\t\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* invalid data, this must not happen and indicates error in mission publisher */\n\t\tmission_state = _mission;\n\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Invalid mission state.\\t\");\n\t\t/* EVENT\n\t\t * @description No mission or storage failure\n\t\t */\n\t\tevents::send(events::ID(\"mission_invalid_mission_state\"), events::Log::Error, \"Invalid mission state\");\n\n\t\t/* write modified state only if changed */\n\t\tsuccess = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&mission_state),\n\t\t\t\t\t\t    sizeof(mission_s));\n\n\t\tif (!success) {\n\n\t\t\tPX4_ERR(\"Can't save mission state\");\n\t\t}\n\t}\n}"
    },
    "MissionBase::do_abort_landing": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "MissionBase::do_abort_landing()\n{\n\t// Abort FW landing, loiter above landing site in at least MIS_LND_ABRT_ALT\n\tif (_mission_type == MissionType::MISSION_TYPE_NONE) {\n\t\treturn;\n\t}\n\n\tif (_mission_item.nav_cmd != NAV_CMD_LAND) {\n\t\treturn;\n\t}\n\n\tconst float alt_landing = get_absolute_altitude_for_item(_mission_item);\n\tconst float alt_sp = math::max(alt_landing + _navigator->get_landing_abort_min_alt(),\n\t\t\t\t       _global_pos_sub.get().alt);\n\n\t// turn current landing waypoint into an indefinite loiter\n\t_mission_item.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n\t_mission_item.altitude_is_relative = false;\n\t_mission_item.altitude = alt_sp;\n\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t_mission_item.autocontinue = false;\n\t_mission_item.origin = ORIGIN_ONBOARD;\n\n\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n\n\t// XXX: this is a hack to invalidate the \"next\" position setpoint for the fixed-wing position controller during\n\t// the landing abort hold. otherwise, the \"next\" setpoint would still register as a \"LAND\" point, and trigger\n\t// the early landing configuration (flaps and landing airspeed) during the hold.\n\t_navigator->get_position_setpoint_triplet()->next.lat = (double)NAN;\n\t_navigator->get_position_setpoint_triplet()->next.lon = (double)NAN;\n\t_navigator->get_position_setpoint_triplet()->next.alt = NAN;\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Holding at %d m above landing waypoint.\\t\",\n\t\t\t (int)(alt_sp - alt_landing));\n\tevents::send<float>(events::ID(\"mission_holding_above_landing\"), events::Log::Info,\n\t\t\t    \"Holding at {1:.0m_v} above landing waypoint\", alt_sp - alt_landing);\n\n\t// reset mission index to start of landing\n\tif (hasMissionLandStart()) {\n\t\t_is_current_planned_mission_item_valid = true;\n\t\tsetMissionIndex(_mission.land_start_index);\n\n\t} else {\n\t\t// move mission index back (landing approach point)\n\t\t_is_current_planned_mission_item_valid = goToPreviousItem(false);\n\t}\n\n\t// send reposition cmd to get out of mission\n\tvehicle_command_s vcmd = {};\n\n\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n\tvcmd.param1 = -1;\n\tvcmd.param2 = 1;\n\tvcmd.param5 = _mission_item.lat;\n\tvcmd.param6 = _mission_item.lon;\n\tvcmd.param7 = alt_sp;\n\n\t_navigator->publish_vehicle_cmd(&vcmd);\n}"
    },
    "MissionBase::set_mission_items": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "MissionBase::set_mission_items()\n{\n\tif (_is_current_planned_mission_item_valid) {\n\t\t/* By default set the mission item to the current planned mission item. Depending on request, it can be altered. */\n\t\tloadCurrentMissionItem();\n\n\t\t/* force vtol land */\n\t\tif (_navigator->force_vtol() && _mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n\t\t}\n\n\t\tsetActiveMissionItems();\n\n\t} else {\n\t\tsetEndOfMissionItems();\n\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION);\n\t}\n}"
    },
    "MissionFeasibilityChecker::checkMissionFeasible": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission)\n{\n\t// Reset warning flag\n\t_navigator->get_mission_result()->warning = false;\n\n\t// first check if we have a valid position\n\tconst bool home_valid = _navigator->home_global_position_valid();\n\tconst bool home_alt_valid = _navigator->home_alt_valid();\n\n\t// trivial case: A mission with length zero cannot be valid\n\tif ((int)mission.count <= 0) {\n\t\treturn false;\n\t}\n\n\tif (!home_alt_valid) {\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Not yet ready for mission, no position lock.\\t\");\n\t\tevents::send(events::ID(\"navigator_mis_no_pos_lock\"), events::Log::Info, \"Not yet ready for mission, no position lock\");\n\t\treturn false;\n\t}\n\n\tbool failed = false;\n\n\tfor (size_t i = 0; i < mission.count; i++) {\n\t\tstruct mission_item_s missionitem = {};\n\n\t\tbool success = _dataman_client.readSync((dm_item_t)mission.mission_dataman_id, i,\n\t\t\t\t\t\t\treinterpret_cast<uint8_t *>(&missionitem),\n\t\t\t\t\t\t\tsizeof(mission_item_s));\n\n\t\tif (!success) {\n\t\t\t_navigator->get_mission_result()->warning = true;\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!_feasibility_checker.processNextItem(missionitem, i, mission.count)) {\n\t\t\tfailed = true;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tfailed |= _feasibility_checker.someCheckFailed();\n\n\tfailed |= !checkMissionAgainstGeofence(mission, _navigator->get_home_position()->alt, home_valid);\n\n\t_navigator->get_mission_result()->warning = failed;\n\n\treturn !failed;\n}"
    },
    "Mission::setActiveMissionItems": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void Mission::setActiveMissionItems()\n{\n\t/* Get mission item that comes after current if available */\n\tstatic constexpr size_t max_num_next_items{2u};\n\tint32_t next_mission_items_index[max_num_next_items];\n\tsize_t num_found_items;\n\n\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n\n\tmission_item_s next_mission_items[max_num_next_items];\n\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\n\tfor (size_t i = 0U; i < num_found_items; i++) {\n\t\tmission_item_s next_mission_item;\n\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_items_index[i],\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tif (success) {\n\t\t\tnext_mission_items[i] = next_mission_item;\n\n\t\t} else {\n\t\t\tnum_found_items = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\tWorkItemType new_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tconst position_setpoint_s current_setpoint_copy = pos_sp_triplet->current;\n\n\tif (item_contains_position(_mission_item)) {\n\n\t\thandleTakeoff(new_work_item_type, next_mission_items, num_found_items);\n\n\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (new_work_item_type != WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// Allow a rotary wing vehicle to decelerate before reaching a wp with a hold time or a timeout\n\t\t// This is done by setting the position triplet's next position's valid flag to false,\n\t\t// which makes the FlightTask disregard the next position\n\t\t// TODO: Setting the next waypoint's validity flag to handle braking / correct waypoint behavior\n\t\t// seems hacky, handle this more properly.\n\t\tconst bool brake_for_hold = _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_time_inside(_mission_item) > FLT_EPSILON || item_has_timeout(_mission_item));\n\n\t\tif (_mission_item.autocontinue && !brake_for_hold) {\n\t\t\t/* try to process next mission item */\n\t\t\tif (num_found_items >= 1u) {\n\t\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n\n\t\t\t} else {\n\t\t\t\t/* next mission item is not available */\n\t\t\t\tpos_sp_triplet->next.valid = false;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else if (item_contains_gate(_mission_item)) {\n\t\t// The mission item is a gate, let's check if the next item in the list provides\n\t\t// a position to go towards.\n\n\t\tif (num_found_items > 0u) {\n\t\t\t// We have a position, convert it to the setpoint and update setpoint triplet\n\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->current);\n\t\t}\n\n\t\tif (num_found_items >= 2u) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(next_mission_items[1u], &pos_sp_triplet->next);\n\n\t\t} else {\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\thandleVtolTransition(new_work_item_type, next_mission_items, num_found_items);\n\t}\n\n\t// Only set the previous position item if the current one really changed\n\tif ((_work_item_type != WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND) &&\n\t    !position_setpoint_equal(&pos_sp_triplet->current, &current_setpoint_copy)) {\n\t\tpos_sp_triplet->previous = current_setpoint_copy;\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Geofence::insideCircle": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "bool Geofence::insideCircle(const PolygonInfo &polygon, double lat, double lon, float altitude)\n{\n\n\tmission_fence_point_s circle_point{};\n\tbool success = _dataman_cache.loadWait(static_cast<dm_item_t>(_stats.dataman_id), polygon.dataman_index,\n\t\t\t\t\t       reinterpret_cast<uint8_t *>(&circle_point), sizeof(mission_fence_point_s));\n\n\tif (!success) {\n\t\tPX4_ERR(\"dm_read failed\");\n\t\treturn false;\n\t}\n\n\tif (circle_point.frame != NAV_FRAME_GLOBAL && circle_point.frame != NAV_FRAME_GLOBAL_INT\n\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n\t    && circle_point.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n\t\t// TODO: handle different frames\n\t\tPX4_ERR(\"Frame type %i not supported\", (int)circle_point.frame);\n\t\treturn false;\n\t}\n\n\tif (!_projection_reference.isInitialized()) {\n\t\t_projection_reference.initReference(lat, lon);\n\t}\n\n\tfloat x1, y1, x2, y2;\n\t_projection_reference.project(lat, lon, x1, y1);\n\t_projection_reference.project(circle_point.lat, circle_point.lon, x2, y2);\n\tfloat dx = x1 - x2, dy = y1 - y2;\n\treturn dx * dx + dy * dy < circle_point.circle_radius * circle_point.circle_radius;\n}"
    },
    "MissionFeasibilityChecker::checkMissionAgainstGeofence": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "MissionFeasibilityChecker::checkMissionAgainstGeofence(const mission_s &mission, float home_alt, bool home_valid)\n{\n\tif (_navigator->get_geofence().isHomeRequired() && !home_valid) {\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\\t\");\n\t\tevents::send(events::ID(\"navigator_mis_geofence_no_home\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t     \"Geofence requires a valid home position\");\n\t\treturn false;\n\t}\n\n\t/* Check if all mission items are inside the geofence (if we have a valid geofence) */\n\tif (_navigator->get_geofence().valid()) {\n\t\tfor (size_t i = 0; i < mission.count; i++) {\n\t\t\tstruct mission_item_s missionitem = {};\n\n\t\t\tbool success = _dataman_client.readSync((dm_item_t)mission.mission_dataman_id, i,\n\t\t\t\t\t\t\t\treinterpret_cast<uint8_t *>(&missionitem),\n\t\t\t\t\t\t\t\tsizeof(mission_item_s));\n\n\t\t\tif (!success) {\n\t\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (missionitem.altitude_is_relative && !home_valid) {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence requires valid home position\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_mis_geofence_no_home2\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t     \"Geofence requires a valid home position\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Geofence function checks against home altitude amsl\n\t\t\tmissionitem.altitude = missionitem.altitude_is_relative ? missionitem.altitude + home_alt : missionitem.altitude;\n\n\t\t\tif (MissionBlock::item_contains_position(missionitem) && !_navigator->get_geofence().checkPointAgainstAllGeofences(\n\t\t\t\t    missionitem.lat, missionitem.lon, missionitem.altitude)) {\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Geofence violation for waypoint %zu\\t\", i + 1);\n\t\t\t\tevents::send<int16_t>(events::ID(\"navigator_mis_geofence_violation\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t      \"Geofence violation for waypoint {1}\",\n\t\t\t\t\t\t      i + 1);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}"
    },
    "MissionBase::checkClimbRequired": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void MissionBase::checkClimbRequired(int32_t mission_item_index)\n{\n\tint32_t next_mission_item_index;\n\tsize_t num_found_items{0U};\n\tgetNextPositionItems(mission_item_index, &next_mission_item_index, num_found_items, 1U);\n\n\tif (num_found_items > 0U) {\n\n\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\t\tmission_item_s mission;\n\t\t_mission_init_climb_altitude_amsl = NAN; // default to NAN, overwrite below if applicable\n\n\t\tconst bool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_item_index,\n\t\t\t\t     reinterpret_cast<uint8_t *>(&mission),\n\t\t\t\t     sizeof(mission), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tconst bool is_fw_and_takeoff = mission.nav_cmd == NAV_CMD_TAKEOFF\n\t\t\t\t\t       && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING;\n\n\t\t// for FW when on a Takeoff item do not require climb before mission, as we need to keep course to takeoff item straight\n\t\tif (success && !is_fw_and_takeoff) {\n\t\t\tconst float altitude_amsl_next_position_item = MissionBlock::get_absolute_altitude_for_item(mission);\n\t\t\tconst float error_below_setpoint = altitude_amsl_next_position_item -\n\t\t\t\t\t\t\t   _navigator->get_global_position()->alt;\n\n\t\t\tif (error_below_setpoint > _navigator->get_altitude_acceptance_radius()) {\n\n\t\t\t\t_mission_init_climb_altitude_amsl = altitude_amsl_next_position_item;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "RtlMissionFast::setActiveMissionItems": {
      "file": "src/modules/navigator/rtl_mission_fast.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void RtlMissionFast::setActiveMissionItems()\n{\n\tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Transition to fixed wing if necessary.\n\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t    _vehicle_status_sub.get().is_vtol &&\n\t    !_land_detected_sub.get().landed && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\n\t} else if (item_contains_position(_mission_item)) {\n\n\t\tstatic constexpr size_t max_num_next_items{1u};\n\t\tint32_t next_mission_items_index[max_num_next_items];\n\t\tsize_t num_found_items = 0;\n\t\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n\n\t\tmission_item_s next_mission_items[max_num_next_items];\n\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\n\t\tfor (size_t i = 0U; i < num_found_items; i++) {\n\t\t\tmission_item_s next_mission_item;\n\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_items_index[i],\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\tnext_mission_items[i] = next_mission_item;\n\n\t\t\t} else {\n\t\t\t\tnum_found_items = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND ||\n\t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n\n\t\t} else {\n\t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n\t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t}\n\n\n\n\t\tif (num_found_items > 0) {\n\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n\t\t}\n\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "RTL::findRtlDestination": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void RTL::findRtlDestination(DestinationType &destination_type, DestinationPosition &rtl_position, float &rtl_alt)\n{\n\t// set destination to home per default, then check if other valid landing spot is closer\n\trtl_position.alt = _home_pos_sub.get().alt;\n\trtl_position.lat = _home_pos_sub.get().lat;\n\trtl_position.lon = _home_pos_sub.get().lon;\n\trtl_position.yaw = _home_pos_sub.get().yaw;\n\tdestination_type = DestinationType::DESTINATION_TYPE_HOME;\n\n\tconst bool vtol_in_rw_mode = _vehicle_status_sub.get().is_vtol\n\t\t\t\t     && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING);\n\n\tconst bool vtol_in_fw_mode = _vehicle_status_sub.get().is_vtol\n\t\t\t\t     && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING);\n\n\t// get distance to home position\n\tfloat home_dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, rtl_position.lat, rtl_position.lon)};\n\tfloat min_dist;\n\n\tif (((_param_rtl_type.get() == 1) && !vtol_in_rw_mode) || (vtol_in_fw_mode && (_param_rtl_approach_force.get() == 1)\n\t\t\t&& !hasVtolLandApproach(rtl_position))) {\n\t\t// Set minimum distance to maximum value when RTL_TYPE is set to 1 and we are not in RW mode or we forces approach landing for vtol in fw and it is not defined for home.\n\t\tmin_dist = FLT_MAX;\n\n\t} else {\n\t\tmin_dist = home_dist;\n\t}\n\n\t// consider the mission landing if available and allowed\n\tif (((_param_rtl_type.get() == 1) || (_param_rtl_type.get() == 3) || (fabsf(FLT_MAX - min_dist) < FLT_EPSILON))\n\t    && hasMissionLandStart()) {\n\t\tmission_item_s land_mission_item;\n\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().mission_dataman_id);\n\t\tbool success = _dataman_cache_landItem.loadWait(dm_item, _mission_sub.get().land_index,\n\t\t\t\treinterpret_cast<uint8_t *>(&land_mission_item), sizeof(mission_item_s), 500_ms);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission land item could not be read.\\t\");\n\t\t\tevents::send(events::ID(\"rtl_failed_to_read_land_item\"), events::Log::Error,\n\t\t\t\t     \"Mission land item could not be read\");\n\t\t}\n\n\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, land_mission_item.lat, land_mission_item.lon)};\n\n\t\tif ((dist + MIN_DIST_THRESHOLD) < min_dist) {\n\t\t\tif (_param_rtl_type.get() != 0) {\n\t\t\t\tmin_dist = dist;\n\n\t\t\t} else {\n\t\t\t\t// Mission landing is not allowed, but home has no approaches. Still use mission landing.\n\t\t\t\tmin_dist = FLT_MAX;\n\t\t\t}\n\n\t\t\tsetLandPosAsDestination(rtl_position, land_mission_item);\n\t\t\tdestination_type = DestinationType::DESTINATION_TYPE_MISSION_LAND;\n\t\t}\n\t}\n\n\tif (_safe_points_updated) {\n\n\t\tfor (int current_seq = 0; current_seq < _dataman_cache_safepoint.size(); ++current_seq) {\n\t\t\tmission_item_s mission_safe_point;\n\n\t\t\tbool success = _dataman_cache_safepoint.loadWait(static_cast<dm_item_t>(_stats.dataman_id), current_seq,\n\t\t\t\t\treinterpret_cast<uint8_t *>(&mission_safe_point),\n\t\t\t\t\tsizeof(mission_item_s), 500_ms);\n\n\t\t\tif (!success) {\n\t\t\t\tPX4_ERR(\"dm_read failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Ignore safepoints which are too close to the homepoint\n\t\t\tconst float dist_to_home = get_distance_to_next_waypoint(_home_pos_sub.get().lat, _home_pos_sub.get().lon,\n\t\t\t\t\t\t   mission_safe_point.lat, mission_safe_point.lon);\n\n\t\t\tif (mission_safe_point.nav_cmd == NAV_CMD_RALLY_POINT && dist_to_home > MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n\t\t\t\tfloat dist{get_distance_to_next_waypoint(_global_pos_sub.get().lat, _global_pos_sub.get().lon, mission_safe_point.lat, mission_safe_point.lon)};\n\n\t\t\t\tDestinationPosition safepoint_position;\n\t\t\t\tsetSafepointAsDestination(safepoint_position, mission_safe_point);\n\n\t\t\t\tif (((dist + MIN_DIST_THRESHOLD) < min_dist) && (!vtol_in_fw_mode || (_param_rtl_approach_force.get() == 0)\n\t\t\t\t\t\t|| hasVtolLandApproach(safepoint_position))) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t\trtl_position = safepoint_position;\n\t\t\t\t\tdestination_type = DestinationType::DESTINATION_TYPE_SAFE_POINT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_param_rtl_cone_half_angle_deg.get() > 0\n\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\trtl_alt = calculate_return_alt_from_cone_half_angle(rtl_position, (float)_param_rtl_cone_half_angle_deg.get());\n\n\t} else {\n\t\trtl_alt = max(_global_pos_sub.get().alt, rtl_position.alt + _param_rtl_return_alt.get());\n\t}\n}"
    },
    "MissionBase::resetMission": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void MissionBase::resetMission()\n{\n\t/* we do not need to reset mission if is already.*/\n\tif (_mission.count == 0u && isMissionValid(_mission)) {\n\t\treturn;\n\t}\n\n\t/* Set a new mission*/\n\tmission_s new_mission{_mission};\n\tnew_mission.timestamp = hrt_absolute_time();\n\tnew_mission.current_seq = 0;\n\tnew_mission.land_start_index = -1;\n\tnew_mission.land_index = -1;\n\tnew_mission.count = 0u;\n\tnew_mission.mission_id = 0u;\n\tnew_mission.mission_dataman_id = _mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0 ?\n\t\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_1 :\n\t\t\t\t\t DM_KEY_WAYPOINTS_OFFBOARD_0;\n\n\tbool success = _dataman_client.writeSync(DM_KEY_MISSION_STATE, 0, reinterpret_cast<uint8_t *>(&new_mission),\n\t\t\tsizeof(mission_s));\n\n\tif (success) {\n\t\t_mission = new_mission;\n\t\t_mission_pub.publish(_mission);\n\n\t} else {\n\t\tPX4_ERR(\"Mission Initialization failed.\");\n\t}\n}"
    },
    "MissionBase::updateDatamanCache": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "MissionBase::updateDatamanCache()\n{\n\tif ((_mission.count > 0) && (_mission.current_seq != _load_mission_index)) {\n\n\t\tint32_t start_index = _mission.current_seq;\n\t\tint32_t end_index = start_index + _dataman_cache_size_signed;\n\n\t\tend_index = math::max(math::min(end_index, static_cast<int32_t>(_mission.count)), INT32_C(0));\n\n\t\tfor (int32_t index = start_index; index != end_index; index += math::signNoZero(_dataman_cache_size_signed)) {\n\n\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_mission.mission_dataman_id), index);\n\t\t}\n\n\t\t_load_mission_index = _mission.current_seq;\n\t}\n\n\t_dataman_cache.update();\n}"
    },
    "MissionBase::isMissionValid": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "bool MissionBase::isMissionValid(mission_s &mission) const\n{\n\tbool ret_val{false};\n\n\tif (((mission.current_seq < mission.count) || (mission.count == 0U && mission.current_seq <= 0)) &&\n\t    (mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_0\n\t     || mission.mission_dataman_id == DM_KEY_WAYPOINTS_OFFBOARD_1) &&\n\t    (mission.timestamp != 0u)) {\n\t\tret_val = true;\n\n\t}\n\n\treturn ret_val;\n}"
    },
    "MissionBase::on_active": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "MissionBase::on_active()\n{\n\t_land_detected_sub.update();\n\t_vehicle_status_sub.update();\n\t_global_pos_sub.update();\n\n\tparameters_update();\n\n\tupdateMavlinkMission();\n\tupdateDatamanCache();\n\n\t// check if heading alignment is necessary, and add it to the current mission item if necessary\n\tif (_align_heading_necessary && is_mission_item_reached_or_completed()) {\n\n\t\t// add yaw alignment requirement on the current mission item\n\t\tint32_t next_mission_item_index;\n\t\tsize_t num_found_items{0U};\n\t\tgetNextPositionItems(_mission.current_seq + 1, &next_mission_item_index, num_found_items, 1U);\n\n\t\tif (num_found_items == 1U && !PX4_ISFINITE(_mission_item.yaw)) {\n\t\t\tmission_item_s next_position_mission_item;\n\t\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_item_index,\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_position_mission_item), sizeof(next_position_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon));\n\t\t\t\t_mission_item.force_heading = true; // note: doesn't have effect in fixed-wing mode\n\t\t\t}\n\t\t}\n\n\t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n\n\t\treset_mission_item_reached();\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t_align_heading_necessary = false;\n\t}\n\n\t// replay gimbal and camera commands immediately after resuming mission\n\tif (haveCachedGimbalOrCameraItems()) {\n\t\treplayCachedGimbalCameraItems();\n\t}\n\n\t// replay trigger commands upon raching the resume waypoint if the trigger relay flag is set\n\tif (cameraWasTriggering() && is_mission_item_reached_or_completed()) {\n\t\treplayCachedTriggerItems();\n\t}\n\n\treplayCachedSpeedChangeItems();\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MissionType::MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n\t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n\t\t   there is no need to report that we reached it because we didn't. */\n\t\tif (_work_item_type != WorkItemType::WORK_ITEM_TYPE_CLIMB) {\n\t\t\tset_mission_item_reached();\n\t\t}\n\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif (!_param_mis_mnt_yaw_ctl.get()\n\t    && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING)\n\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t || _work_item_type == WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING)) {\n\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n\t\t// needs to rotate such that ROI is in the field of view.\n\t\t// ROI only makes sense for multicopters.\n\t\theading_sp_update();\n\t}\n\n\t// TODO: Add vtol heading update method if required.\n\t// Question: Why does vtol ever have to update heading?\n\n\t/* check if landing needs to be aborted */\n\tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n\t    && (_navigator->abort_landing())) {\n\n\t\tdo_abort_landing();\n\t}\n\n\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t_navigator->get_precland()->on_active();\n\n\t} else if (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n}"
    },
    "MissionBase::resetMissionJumpCounter": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void MissionBase::resetMissionJumpCounter()\n{\n\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\n\tfor (size_t mission_index = 0u; mission_index < _mission.count; mission_index++) {\n\t\tmission_item_s mission_item;\n\n\t\tbool success = _dataman_client.readSync(mission_dataman_id, mission_index, reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t\t\tsizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Mission could not reset jump count.\\t\");\n\t\t\tevents::send(events::ID(\"mission_failed_set_jump_count\"), events::Log::Error,\n\t\t\t\t     \"Mission could not reset jump count\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mission_item.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\tmission_item.do_jump_current_count = 0u;\n\n\t\t\tbool write_success = _dataman_cache.writeWait(mission_dataman_id, mission_index,\n\t\t\t\t\t     reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t     sizeof(struct mission_item_s));\n\n\t\t\tif (!write_success) {\n\t\t\t\tPX4_ERR(\"Could not write mission item for jump count reset.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "Geofence::run": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void Geofence::run()\n{\n\tbool success;\n\n\tswitch (_dataman_state) {\n\n\tcase DatamanState::UpdateRequestWait:\n\n\t\tif (_initiate_fence_updated) {\n\t\t\t_initiate_fence_updated = false;\n\t\t\t_dataman_state\t= DatamanState::Read;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Read:\n\n\t\t_dataman_state = DatamanState::ReadWait;\n\t\tsuccess = _dataman_client.readAsync(DM_KEY_FENCE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&_stats),\n\t\t\t\t\t\t    sizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\t_error_state = DatamanState::Read;\n\t\t\t_dataman_state = DatamanState::Error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::ReadWait:\n\n\t\t_dataman_client.update();\n\n\t\tif (_dataman_client.lastOperationCompleted(success)) {\n\n\t\t\tif (!success) {\n\t\t\t\t_error_state = DatamanState::ReadWait;\n\t\t\t\t_dataman_state = DatamanState::Error;\n\n\t\t\t} else if (_opaque_id != _stats.opaque_id) {\n\n\t\t\t\t_opaque_id = _stats.opaque_id;\n\t\t\t\t_fence_updated = false;\n\n\t\t\t\t_dataman_cache.invalidate();\n\n\t\t\t\tif (_dataman_cache.size() != _stats.num_items) {\n\t\t\t\t\t_dataman_cache.resize(_stats.num_items);\n\t\t\t\t}\n\n\t\t\t\tfor (int index = 0; index < _dataman_cache.size(); ++index) {\n\t\t\t\t\t_dataman_cache.load(static_cast<dm_item_t>(_stats.dataman_id), index);\n\t\t\t\t}\n\n\t\t\t\t_dataman_state = DatamanState::Load;\n\n\t\t\t} else {\n\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Load:\n\n\t\t_dataman_cache.update();\n\n\t\tif (!_dataman_cache.isLoading()) {\n\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t_updateFence();\n\t\t\t_fence_updated = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Error:\n\t\tPX4_ERR(\"Geofence update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n}"
    },
    "RtlDirectMissionLand::setActiveMissionItems": {
      "file": "src/modules/navigator/rtl_direct_mission_land.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void RtlDirectMissionLand::setActiveMissionItems()\n{\n\tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Climb to altitude\n\tif (_needs_climbing && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\t// do not use LOITER_TO_ALT for rotary wing mode as it would then always climb to at least MIS_LTRMIN_ALT,\n\t\t// even if current climb altitude is below (e.g. RTL immediately after take off)\n\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\n\t\t} else {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\t\t}\n\n\t\t_mission_item.lat = _global_pos_sub.get().lat;\n\t\t_mission_item.lon = _global_pos_sub.get().lon;\n\t\t_mission_item.altitude = _rtl_alt;\n\t\t_mission_item.altitude_is_relative = false;\n\n\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t_mission_item.time_inside = 0.0f;\n\t\t_mission_item.autocontinue = true;\n\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL Mission land: climb to %d m\\t\",\n\t\t\t\t (int)ceilf(_rtl_alt));\n\t\tevents::send<int32_t>(events::ID(\"rtl_mission_land_climb\"), events::Log::Info,\n\t\t\t\t      \"RTL Mission Land: climb to {1m_v}\",\n\t\t\t\t      (int32_t)ceilf(_rtl_alt));\n\n\t\t_needs_climbing = false;\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_CLIMB;\n\n\t} else if (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t   _vehicle_status_sub.get().is_vtol &&\n\t\t   !_land_detected_sub.get().landed && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\t// Transition to fixed wing if necessary.\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\n\t} else if (item_contains_position(_mission_item)) {\n\n\t\tstatic constexpr size_t max_num_next_items{1u};\n\t\tint32_t next_mission_items_index[max_num_next_items];\n\t\tsize_t num_found_items = 0;\n\t\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n\n\t\tmission_item_s next_mission_items[max_num_next_items];\n\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\n\t\tfor (size_t i = 0U; i < num_found_items; i++) {\n\t\t\tmission_item_s next_mission_item;\n\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_items_index[i],\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\tnext_mission_items[i] = next_mission_item;\n\n\t\t\t} else {\n\t\t\t\tnum_found_items = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND ||\n\t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n\n\t\t} else {\n\t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n\t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t}\n\n\t\tif (num_found_items > 0) {\n\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n\t\t}\n\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBase::setMissionToClosestItem": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "int MissionBase::setMissionToClosestItem(double lat, double lon, float alt, float home_alt,\n\t\tconst vehicle_status_s &vehicle_status)\n{\n\tint32_t min_dist_index(-1);\n\tfloat min_dist(FLT_MAX), dist_xy(FLT_MAX), dist_z(FLT_MAX);\n\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\n\tfor (int32_t mission_item_index = 0; mission_item_index < _mission.count; mission_item_index++) {\n\t\tmission_item_s mission;\n\n\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, mission_item_index, reinterpret_cast<uint8_t *>(&mission),\n\t\t\t\t\t\t       sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tif (!success) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Could not set mission closest to position.\\t\");\n\t\t\tevents::send(events::ID(\"mission_failed_set_closest\"), events::Log::Error,\n\t\t\t\t     \"Could not set mission closest to position\");\n\t\t\treturn PX4_ERROR;\n\t\t}\n\n\t\tif (MissionBlock::item_contains_position(mission)) {\n\t\t\t// do not consider land waypoints for a fw\n\t\t\tif (!((mission.nav_cmd == NAV_CMD_LAND) &&\n\t\t\t      (vehicle_status.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) &&\n\t\t\t      (!vehicle_status.is_vtol))) {\n\t\t\t\tfloat dist = get_distance_to_point_global_wgs84(mission.lat, mission.lon,\n\t\t\t\t\t\tMissionBlock::get_absolute_altitude_for_item(mission, home_alt),\n\t\t\t\t\t\tlat,\n\t\t\t\t\t\tlon,\n\t\t\t\t\t\talt,\n\t\t\t\t\t\t&dist_xy, &dist_z);\n\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t\tmin_dist_index = mission_item_index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsetMissionIndex(min_dist_index);\n\n\treturn PX4_OK;\n}"
    },
    "RTL::readVtolLandApproaches": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "land_approaches_s RTL::readVtolLandApproaches(DestinationPosition rtl_position) const\n{\n\n\t// go through all mission items in the rally point storage. If we find a mission item of type NAV_CMD_RALLY_POINT\n\t// which is within MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES of our current home position then treat ALL following mission items of type NAV_CMD_LOITER_TO_ALT which come\n\t// BEFORE the next mission item of type NAV_CMD_RALLY_POINT as land approaches for the home position\n\tland_approaches_s vtol_land_approaches{};\n\n\tif (!_safe_points_updated) {\n\t\treturn vtol_land_approaches;\n\t}\n\n\tbool foundHomeLandApproaches = false;\n\tuint8_t sector_counter = 0;\n\n\tfor (int current_seq = 0; current_seq < _stats.num_items; ++current_seq) {\n\t\tmission_item_s mission_item{};\n\n\t\tbool success_mission_item = _dataman_cache_safepoint.loadWait(static_cast<dm_item_t>(_stats.dataman_id), current_seq,\n\t\t\t\t\t    reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t    sizeof(mission_item_s));\n\n\t\tif (!success_mission_item) {\n\t\t\tPX4_ERR(\"dm_read failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mission_item.nav_cmd == NAV_CMD_RALLY_POINT) {\n\n\t\t\tif (foundHomeLandApproaches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst float dist_to_safepoint = get_distance_to_next_waypoint(mission_item.lat, mission_item.lon, rtl_position.lat,\n\t\t\t\t\t\t\trtl_position.lon);\n\n\t\t\tif (dist_to_safepoint < MAX_DIST_FROM_HOME_FOR_LAND_APPROACHES) {\n\t\t\t\tfoundHomeLandApproaches = true;\n\t\t\t\tvtol_land_approaches.land_location_lat_lon = matrix::Vector2d(mission_item.lat, mission_item.lon);\n\t\t\t}\n\n\t\t\tsector_counter = 0;\n\t\t}\n\n\t\tif (foundHomeLandApproaches && mission_item.nav_cmd == NAV_CMD_LOITER_TO_ALT) {\n\t\t\tvtol_land_approaches.approaches[sector_counter].lat = mission_item.lat;\n\t\t\tvtol_land_approaches.approaches[sector_counter].lon = mission_item.lon;\n\t\t\tvtol_land_approaches.approaches[sector_counter].height_m = MissionBlock::get_absolute_altitude_for_item(mission_item,\n\t\t\t\t\t_home_pos_sub.get().alt);\n\t\t\tvtol_land_approaches.approaches[sector_counter].loiter_radius_m = mission_item.loiter_radius;\n\t\t\tsector_counter++;\n\t\t}\n\t}\n\n\treturn vtol_land_approaches;\n}"
    },
    "Geofence::insidePolygon": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "bool Geofence::insidePolygon(const PolygonInfo &polygon, double lat, double lon, float altitude)\n{\n\t/**\n\t * Adaptation of algorithm originally presented as\n\t * PNPOLY - Point Inclusion in Polygon Test\n\t * W. Randolph Franklin (WRF)\n\t * Only supports non-complex polygons (not self intersecting)\n\t */\n\n\tmission_fence_point_s temp_vertex_i{};\n\tmission_fence_point_s temp_vertex_j{};\n\tbool c = false;\n\n\tfor (unsigned i = 0, j = polygon.vertex_count - 1; i < polygon.vertex_count; j = i++) {\n\n\t\tdm_item_t fence_dataman_id{static_cast<dm_item_t>(_stats.dataman_id)};\n\t\tbool success = _dataman_cache.loadWait(fence_dataman_id, polygon.dataman_index + i,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&temp_vertex_i), sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsuccess = _dataman_cache.loadWait(fence_dataman_id, polygon.dataman_index + j,\n\t\t\t\t\t\t  reinterpret_cast<uint8_t *>(&temp_vertex_j), sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (temp_vertex_i.frame != NAV_FRAME_GLOBAL && temp_vertex_i.frame != NAV_FRAME_GLOBAL_INT\n\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT\n\t\t    && temp_vertex_i.frame != NAV_FRAME_GLOBAL_RELATIVE_ALT_INT) {\n\t\t\t// TODO: handle different frames\n\t\t\tPX4_ERR(\"Frame type %i not supported\", (int)temp_vertex_i.frame);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (((double)temp_vertex_i.lon >= lon) != ((double)temp_vertex_j.lon >= lon) &&\n\t\t    (lat <= (double)(temp_vertex_j.lat - temp_vertex_i.lat) * (lon - (double)temp_vertex_i.lon) /\n\t\t     (double)(temp_vertex_j.lon - temp_vertex_i.lon) + (double)temp_vertex_i.lat)) {\n\t\t\tc = !c;\n\t\t}\n\t}\n\n\treturn c;\n}"
    },
    "MissionBase::updateCachedItemsUpToIndex": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void MissionBase::updateCachedItemsUpToIndex(const int end_index)\n{\n\tfor (int i = 0; i <= end_index; i++) {\n\t\tmission_item_s mission_item;\n\t\tconst dm_item_t dm_current = (dm_item_t)_mission.mission_dataman_id;\n\t\tbool success = _dataman_client.readSync(dm_current, i, reinterpret_cast<uint8_t *>(&mission_item),\n\t\t\t\t\t\t\tsizeof(mission_item), 500_ms);\n\n\t\tif (success) {\n\t\t\tcacheItem(mission_item);\n\t\t}\n\t}\n}"
    },
    "RTL::updateDatamanCache": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void RTL::updateDatamanCache()\n{\n\tbool success;\n\n\tswitch (_dataman_state) {\n\n\tcase DatamanState::UpdateRequestWait:\n\n\t\tif (_initiate_safe_points_updated) {\n\t\t\t_initiate_safe_points_updated = false;\n\t\t\t_dataman_state\t= DatamanState::Read;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Read:\n\n\t\t_dataman_state\t= DatamanState::ReadWait;\n\t\tsuccess = _dataman_client_safepoint.readAsync(DM_KEY_SAFE_POINTS_STATE, 0, reinterpret_cast<uint8_t *>(&_stats),\n\t\t\t\tsizeof(mission_stats_entry_s));\n\n\t\tif (!success) {\n\t\t\t_error_state = DatamanState::Read;\n\t\t\t_dataman_state = DatamanState::Error;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::ReadWait:\n\n\t\t_dataman_client_safepoint.update();\n\n\t\tif (_dataman_client_safepoint.lastOperationCompleted(success)) {\n\n\t\t\tif (!success) {\n\t\t\t\t_error_state = DatamanState::ReadWait;\n\t\t\t\t_dataman_state = DatamanState::Error;\n\n\t\t\t} else if (_opaque_id != _stats.opaque_id) {\n\n\t\t\t\t_opaque_id = _stats.opaque_id;\n\t\t\t\t_safe_points_updated = false;\n\n\t\t\t\t_dataman_cache_safepoint.invalidate();\n\n\t\t\t\tif (_dataman_cache_safepoint.size() != _stats.num_items) {\n\t\t\t\t\t_dataman_cache_safepoint.resize(_stats.num_items);\n\t\t\t\t}\n\n\t\t\t\tfor (int index = 0; index < _dataman_cache_safepoint.size(); ++index) {\n\t\t\t\t\t_dataman_cache_safepoint.load(static_cast<dm_item_t>(_stats.dataman_id), index);\n\t\t\t\t}\n\n\t\t\t\t_dataman_state = DatamanState::Load;\n\n\t\t\t} else {\n\t\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Load:\n\n\t\t_dataman_cache_safepoint.update();\n\n\t\tif (!_dataman_cache_safepoint.isLoading()) {\n\t\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\t\t_safe_points_updated = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase DatamanState::Error:\n\t\tPX4_ERR(\"Safe points update failed! state: %\" PRIu8, static_cast<uint8_t>(_error_state));\n\t\t_dataman_state = DatamanState::UpdateRequestWait;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\tif (_mission_id != _mission_sub.get().mission_id) {\n\t\t_mission_id = _mission_sub.get().mission_id;\n\t\tconst dm_item_t dm_item = static_cast<dm_item_t>(_mission_sub.get().mission_dataman_id);\n\t\t_dataman_cache_landItem.invalidate();\n\n\t\tif (_mission_sub.get().land_index > 0) {\n\t\t\t_dataman_cache_landItem.load(dm_item, _mission_sub.get().land_index);\n\t\t}\n\t}\n\n\t_dataman_cache_landItem.update();\n}"
    },
    "RtlMissionFastReverse::setActiveMissionItems": {
      "file": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void RtlMissionFastReverse::setActiveMissionItems()\n{\n\tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Transition to fixed wing if necessary.\n\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t    _vehicle_status_sub.get().is_vtol &&\n\t    !_land_detected_sub.get().landed && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\n\t} else if (item_contains_position(_mission_item)) {\n\t\tint32_t next_mission_item_index;\n\t\tsize_t num_found_items = 0;\n\t\tgetPreviousPositionItems(_mission.current_seq, &next_mission_item_index, num_found_items, 1u);\n\n\t\t// If the current item is a takeoff item or there is no further position item start landing.\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n\t\t    num_found_items == 0) {\n\t\t\thandleLanding(new_work_item_type);\n\n\t\t} else {\n\t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n\t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t}\n\n\t\tif (num_found_items > 0) {\n\n\t\t\tconst dm_item_t mission_dataman_id = static_cast<dm_item_t>(_mission.mission_dataman_id);\n\t\t\tmission_item_s next_mission_item;\n\t\t\tbool success = _dataman_cache.loadWait(mission_dataman_id, next_mission_item_index,\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\tmission_item_to_position_setpoint(next_mission_item, &pos_sp_triplet->next);\n\t\t\t}\n\t\t}\n\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Geofence::_updateFence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "0aa2d1b3be7e5c4f6c843a434d541d493b2ecbf1",
      "source": "void Geofence::_updateFence()\n{\n\tmission_fence_point_s mission_fence_point;\n\tbool is_circle_area = false;\n\n\t// iterate over all polygons and store their starting vertices\n\t_num_polygons = 0;\n\tint current_seq = 0;\n\n\twhile (current_seq < _dataman_cache.size()) {\n\n\t\tbool success = _dataman_cache.loadWait(static_cast<dm_item_t>(_stats.dataman_id), current_seq,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t       sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"loadWait failed, seq: %i\", current_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mission_fence_point.nav_cmd) {\n\t\tcase NAV_CMD_FENCE_RETURN_POINT:\n\t\t\t// TODO: do we need to store this?\n\t\t\t++current_seq;\n\t\t\tbreak;\n\n\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n\t\t\tis_circle_area = true;\n\n\t\t/* FALLTHROUGH */\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n\t\t\tif (!is_circle_area && mission_fence_point.vertex_count == 0) {\n\t\t\t\t++current_seq; // avoid endless loop\n\t\t\t\tPX4_ERR(\"Polygon with 0 vertices. Skipping\");\n\n\t\t\t} else {\n\t\t\t\tif (_polygons) {\n\t\t\t\t\t// resize: this is somewhat inefficient, but we do not expect there to be many polygons\n\t\t\t\t\tPolygonInfo *new_polygons = new PolygonInfo[_num_polygons + 1];\n\n\t\t\t\t\tif (new_polygons) {\n\t\t\t\t\t\tmemcpy(new_polygons, _polygons, sizeof(PolygonInfo) * _num_polygons);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete[](_polygons);\n\t\t\t\t\t_polygons = new_polygons;\n\n\t\t\t\t} else {\n\t\t\t\t\t_polygons = new PolygonInfo[1];\n\t\t\t\t}\n\n\t\t\t\tif (!_polygons) {\n\t\t\t\t\t_num_polygons = 0;\n\t\t\t\t\tPX4_ERR(\"alloc failed\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPolygonInfo &polygon = _polygons[_num_polygons];\n\t\t\t\tpolygon.dataman_index = current_seq;\n\t\t\t\tpolygon.fence_type = mission_fence_point.nav_cmd;\n\n\t\t\t\tif (is_circle_area) {\n\t\t\t\t\tpolygon.circle_radius = mission_fence_point.circle_radius;\n\t\t\t\t\tcurrent_seq += 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tpolygon.vertex_count = mission_fence_point.vertex_count;\n\t\t\t\t\tcurrent_seq += mission_fence_point.vertex_count;\n\t\t\t\t}\n\n\t\t\t\t// check if requiremetns for Home location are met\n\t\t\t\tconst bool home_check_okay = checkHomeRequirementsForGeofence(polygon);\n\n\t\t\t\t// check if current position is inside the fence and vehicle is armed\n\t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n\n\t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n\t\t\t\tif (home_check_okay && current_position_check_okay) {\n\t\t\t\t\t++_num_polygons;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPX4_ERR(\"unhandled Fence command: %i\", (int)mission_fence_point.nav_cmd);\n\t\t\t++current_seq;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "22376": {
    "MissionBlock::set_vtol_transition_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "MissionBlock::set_vtol_transition_item(struct mission_item_s *item, const uint8_t new_mode)\n{\n\titem->nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n\titem->params[0] = (float) new_mode;\n\titem->params[1] = 0.0f;\n\n\t// Keep yaw from previous mission item if valid, as that is containing the transition heading.\n\t// If not valid use current yaw as yaw setpoint\n\tif (!PX4_ISFINITE(item->yaw)) {\n\t\titem->yaw = _navigator->get_local_position()->heading; // ideally that would be course and not heading\n\t}\n\n\titem->autocontinue = true;\n}"
    },
    "RtlDirectMissionLand::setActiveMissionItems": {
      "file": "src/modules/navigator/rtl_direct_mission_land.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void RtlDirectMissionLand::setActiveMissionItems()\n{\n\tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Climb to altitude\n\tif (_needs_climbing && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\t// do not use LOITER_TO_ALT for rotary wing mode as it would then always climb to at least MIS_LTRMIN_ALT,\n\t\t// even if current climb altitude is below (e.g. RTL immediately after take off)\n\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\n\t\t} else {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TO_ALT;\n\t\t}\n\n\t\t_mission_item.lat = _global_pos_sub.get().lat;\n\t\t_mission_item.lon = _global_pos_sub.get().lon;\n\t\t_mission_item.altitude = _rtl_alt;\n\t\t_mission_item.altitude_is_relative = false;\n\n\t\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t\t_mission_item.time_inside = 0.0f;\n\t\t_mission_item.autocontinue = true;\n\t\t_mission_item.origin = ORIGIN_ONBOARD;\n\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL Mission land: climb to %d m\\t\",\n\t\t\t\t (int)ceilf(_rtl_alt));\n\t\tevents::send<int32_t>(events::ID(\"rtl_mission_land_climb\"), events::Log::Info,\n\t\t\t\t      \"RTL Mission Land: climb to {1m_v}\",\n\t\t\t\t      (int32_t)ceilf(_rtl_alt));\n\n\t\t_needs_climbing = false;\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_CLIMB;\n\n\t} else if (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t\t   _vehicle_status_sub.get().is_vtol &&\n\t\t   !_land_detected_sub.get().landed && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\t// Transition to fixed wing if necessary.\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\n\t} else if (item_contains_position(_mission_item)) {\n\n\t\tstatic constexpr size_t max_num_next_items{1u};\n\t\tint32_t next_mission_items_index[max_num_next_items];\n\t\tsize_t num_found_items = 0;\n\t\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n\n\t\tmission_item_s next_mission_items[max_num_next_items];\n\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n\n\t\tfor (size_t i = 0U; i < num_found_items; i++) {\n\t\t\tmission_item_s next_mission_item;\n\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_items_index[i],\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\tnext_mission_items[i] = next_mission_item;\n\n\t\t\t} else {\n\t\t\t\tnum_found_items = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND ||\n\t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n\n\t\t} else {\n\t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n\t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t}\n\n\t\tif (num_found_items > 0) {\n\t\t\tmission_apply_limitation(next_mission_items[0u]);\n\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n\t\t}\n\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBase::on_active": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "MissionBase::on_active()\n{\n\t_land_detected_sub.update();\n\t_vehicle_status_sub.update();\n\t_global_pos_sub.update();\n\n\tparameters_update();\n\n\tupdateMavlinkMission();\n\tupdateDatamanCache();\n\n\t// check if heading alignment is necessary, and add it to the current mission item if necessary\n\tif (_align_heading_necessary && is_mission_item_reached_or_completed()) {\n\n\t\t// add yaw alignment requirement on the current mission item\n\t\tint32_t next_mission_item_index;\n\t\tsize_t num_found_items{0U};\n\t\tgetNextPositionItems(_mission.current_seq + 1, &next_mission_item_index, num_found_items, 1U);\n\n\t\tif (num_found_items == 1U && !PX4_ISFINITE(_mission_item.yaw)) {\n\t\t\tmission_item_s next_position_mission_item;\n\t\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index,\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_position_mission_item), sizeof(next_position_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\t_mission_item.yaw = matrix::wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t\t\t\t\t\t    next_position_mission_item.lat, next_position_mission_item.lon));\n\t\t\t\t_mission_item.force_heading = true; // note: doesn't have effect in fixed-wing mode\n\t\t\t}\n\t\t}\n\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n\n\t\treset_mission_item_reached();\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t_align_heading_necessary = false;\n\t}\n\n\t// replay gimbal and camera commands immediately after resuming mission\n\tif (haveCachedGimbalOrCameraItems()) {\n\t\treplayCachedGimbalCameraItems();\n\t}\n\n\t// replay trigger commands upon raching the resume waypoint if the trigger relay flag is set\n\tif (cameraWasTriggering() && is_mission_item_reached_or_completed()) {\n\t\treplayCachedTriggerItems();\n\t}\n\n\treplayCachedSpeedChangeItems();\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MissionType::MISSION_TYPE_NONE && is_mission_item_reached_or_completed()) {\n\t\t/* If we just completed a takeoff which was inserted before the right waypoint,\n\t\t   there is no need to report that we reached it because we didn't. */\n\t\tif (_work_item_type != WorkItemType::WORK_ITEM_TYPE_CLIMB) {\n\t\t\tset_mission_item_reached();\n\t\t}\n\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif (!_param_mis_mnt_yaw_ctl.get()\n\t    && (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING)\n\t    && (_navigator->get_vroi().mode != vehicle_roi_s::ROI_NONE)\n\t    && !(_mission_item.nav_cmd == NAV_CMD_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t || _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t || _mission_item.nav_cmd == NAV_CMD_LAND\n\t\t || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t || _work_item_type == WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING)) {\n\t\t// Mount control is disabled If the vehicle is in ROI-mode, the vehicle\n\t\t// needs to rotate such that ROI is in the field of view.\n\t\t// ROI only makes sense for multicopters.\n\t\theading_sp_update();\n\t}\n\n\t// TODO: Add vtol heading update method if required.\n\t// Question: Why does vtol ever have to update heading?\n\n\t/* check if landing needs to be aborted */\n\tif ((_mission_item.nav_cmd == NAV_CMD_LAND)\n\t    && (_navigator->abort_landing())) {\n\n\t\tdo_abort_landing();\n\t}\n\n\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t_navigator->get_precland()->on_active();\n\n\t} else if (_navigator->get_precland()->is_activated()) {\n\t\t_navigator->get_precland()->on_inactivation();\n\t}\n}"
    },
    "MissionBase::do_abort_landing": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "MissionBase::do_abort_landing()\n{\n\t// Abort FW landing, loiter above landing site in at least MIS_LND_ABRT_ALT\n\tif (_mission_type == MissionType::MISSION_TYPE_NONE) {\n\t\treturn;\n\t}\n\n\tif (_mission_item.nav_cmd != NAV_CMD_LAND) {\n\t\treturn;\n\t}\n\n\tconst float alt_landing = get_absolute_altitude_for_item(_mission_item);\n\tconst float alt_sp = math::max(alt_landing + _navigator->get_landing_abort_min_alt(),\n\t\t\t\t       _global_pos_sub.get().alt);\n\n\t// turn current landing waypoint into an indefinite loiter\n\t_mission_item.nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n\t_mission_item.altitude_is_relative = false;\n\t_mission_item.altitude = alt_sp;\n\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t_mission_item.acceptance_radius = _navigator->get_acceptance_radius();\n\t_mission_item.autocontinue = false;\n\t_mission_item.origin = ORIGIN_ONBOARD;\n\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &_navigator->get_position_setpoint_triplet()->current);\n\n\t// XXX: this is a hack to invalidate the \"next\" position setpoint for the fixed-wing position controller during\n\t// the landing abort hold. otherwise, the \"next\" setpoint would still register as a \"LAND\" point, and trigger\n\t// the early landing configuration (flaps and landing airspeed) during the hold.\n\t_navigator->get_position_setpoint_triplet()->next.lat = (double)NAN;\n\t_navigator->get_position_setpoint_triplet()->next.lon = (double)NAN;\n\t_navigator->get_position_setpoint_triplet()->next.alt = NAN;\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Holding at %d m above landing waypoint.\\t\",\n\t\t\t (int)(alt_sp - alt_landing));\n\tevents::send<float>(events::ID(\"mission_holding_above_landing\"), events::Log::Info,\n\t\t\t    \"Holding at {1:.0m_v} above landing waypoint\", alt_sp - alt_landing);\n\n\t// reset mission index to start of landing\n\tif (hasMissionLandStart()) {\n\t\t_is_current_planned_mission_item_valid = true;\n\t\tsetMissionIndex(_mission.land_start_index);\n\n\t} else {\n\t\t// move mission index back (landing approach point)\n\t\t_is_current_planned_mission_item_valid = goToPreviousItem(false);\n\t}\n\n\t// send reposition cmd to get out of mission\n\tvehicle_command_s vcmd = {};\n\n\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n\tvcmd.param1 = -1;\n\tvcmd.param2 = 1;\n\tvcmd.param5 = _mission_item.lat;\n\tvcmd.param6 = _mission_item.lon;\n\tvcmd.param7 = alt_sp;\n\n\t_navigator->publish_vehicle_cmd(&vcmd);\n}"
    },
    "Mission::handleVtolTransition": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void Mission::handleVtolTransition(WorkItemType &new_work_item_type, mission_item_s next_mission_items[],\n\t\t\t\t   size_t &num_found_items)\n{\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* turn towards next waypoint before MC to FW transition */\n\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t    && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT\n\t    && new_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT\n\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t    && !_land_detected_sub.get().landed\n\t    && (num_found_items > 0u)) {\n\n\t\t/* disable weathervane before front transition for allowing yaw to align */\n\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING;\n\n\t\tset_align_mission_item(&_mission_item, &next_mission_items[0u]);\n\n\t\t/* set position setpoint to target during the transition */\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->current);\n\t}\n\n\t/* yaw is aligned now */\n\tif (_work_item_type == WorkItemType::WORK_ITEM_TYPE_ALIGN_HEADING &&\n\t    new_work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n\n\t\t/* re-enable weather vane again after alignment */\n\t\tpos_sp_triplet->current.disable_weather_vane = false;\n\n\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t}\n}"
    },
    "Land::on_activation": {
      "file": "src/modules/navigator/land.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "Land::on_activation()\n{\n\t/* set current mission item to Land */\n\tset_land_item(&_mission_item);\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\treset_mission_item_reached();\n\n\t/* convert mission item to current setpoint */\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n}"
    },
    "mission_apply_limitation": {
      "file": "src/modules/navigator/mission_block.h",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "*/\n\tvoid mission_apply_limitation(mission_item_s &item);\n\n\tvoid setLoiterToAltMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_radius,\n\t\t\t\t       HeadingMode heading_mode) const;\n\n\tvoid setLoiterHoldMissionItem(mission_item_s &item, const DestinationPosition &dest, float loiter_time,\n\t\t\t\t      float loiter_radius, HeadingMode heading_mode) const;\n\n\tvoid setMoveToPositionMissionItem(mission_item_s &item, const DestinationPosition &dest,\n\t\t\t\t\t  HeadingMode heading_mode) const;\n\n\tvoid setLandMissionItem(mission_item_s &item, const DestinationPosition &dest, HeadingMode heading_mode) const;\n\n\tfloat setYawFromHeadingMode(const DestinationPosition &dest, HeadingMode heading_mode) const;\n\n\tvoid startPrecLand(uint16_t land_precision);\n\n\t/**\n\t * @brief Issue a command for mission items with a nav_cmd that specifies an action\n\t *\n\t * Execute the specified command inside the mission item. The action depends on the nav_cmd\n\t * value (which correlates to the MAVLink's MAV_CMD enum values) and the params defined in the\n\t * mission item.\n\t *\n\t * This is used for commands like MAV_CMD_DO* in MAVLink, where immediate actions are defined.\n\t * For more information, refer to: https://mavlink.io/en/services/mission.html#mavlink_commands\n\t *\n\t * @param item Mission item to execute\n\t */\n\tvoid issue_command(const mission_item_s &item);\n\n\t/**\n\t * [s] Get the time to stay that's specified in the mission item\n\t */\n\tfloat get_time_inside(const mission_item_s &item) const;\n\n\tfloat get_absolute_altitude_for_item(const mission_item_s &mission_item) const;\n\n\tmission_item_s _mission_item{}"
    },
    "RtlDirect::set_rtl_item": {
      "file": "src/modules/navigator/rtl_direct.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void RtlDirect::set_rtl_item()\n{\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tconst float destination_dist = get_distance_to_next_waypoint(_destination.lat, _destination.lon,\n\t\t\t\t       _global_pos_sub.get().lat, _global_pos_sub.get().lon);\n\tconst float loiter_altitude = math::min(_land_approach.height_m, _rtl_alt);\n\n\tHeadingMode rtl_heading_mode = static_cast<HeadingMode>(_param_rtl_hdg_md.get());\n\n\tif ((rtl_heading_mode == HeadingMode::NAVIGATION_HEADING) && (destination_dist < _param_rtl_min_dist.get())) {\n\t\trtl_heading_mode = HeadingMode::DESTINATION_HEADING;\n\t}\n\n\tswitch (_rtl_state) {\n\tcase RTLState::CLIMBING: {\n\t\t\tDestinationPosition dest {\n\t\t\t\t.lat = _global_pos_sub.get().lat,\n\t\t\t\t.lon = _global_pos_sub.get().lon,\n\t\t\t\t.alt = _rtl_alt,\n\t\t\t};\n\n\t\t\tsetLoiterToAltMissionItem(_mission_item, dest, _navigator->get_loiter_radius(), HeadingMode::CURRENT_HEADING);\n\n\t\t\t_rtl_state = RTLState::MOVE_TO_LOITER;\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::MOVE_TO_LOITER: {\n\t\t\tDestinationPosition dest {\n\t\t\t\t.lat = _land_approach.lat,\n\t\t\t\t.lon = _land_approach.lon,\n\t\t\t\t.alt = _rtl_alt,\n\t\t\t\t.yaw = _destination.yaw,\n\t\t\t};\n\n\t\t\t// For FW flight:set to LOITER_TIME (with 0s loiter time), such that the loiter (orbit) status\n\t\t\t// can be displayed on groundstation and the WP is accepted once within loiter radius\n\t\t\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t\tsetLoiterHoldMissionItem(_mission_item, dest, 0.f, _land_approach.loiter_radius_m, rtl_heading_mode);\n\n\t\t\t} else {\n\t\t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n\t\t\t}\n\n\t\t\t_rtl_state = RTLState::LOITER_DOWN;\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::LOITER_DOWN: {\n\t\t\tDestinationPosition dest{\n\t\t\t\t.lat = _land_approach.lat,\n\t\t\t\t.lon = _land_approach.lon,\n\t\t\t\t.alt = loiter_altitude,\n\t\t\t\t.yaw = _destination.yaw,\n\t\t\t};\n\n\t\t\tsetLoiterToAltMissionItem(_mission_item, dest, _land_approach.loiter_radius_m, rtl_heading_mode);\n\n\t\t\tpos_sp_triplet->next.valid = true;\n\t\t\tpos_sp_triplet->next.lat = _destination.lat;\n\t\t\tpos_sp_triplet->next.lon = _destination.lon;\n\t\t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\n\t\t\tif (_force_heading) {\n\t\t\t\t_mission_item.force_heading = true;\n\t\t\t}\n\n\t\t\t// Disable previous setpoint to prevent drift.\n\t\t\tpos_sp_triplet->previous.valid = false;\n\n\t\t\t_rtl_state = RTLState::LOITER_HOLD;\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::LOITER_HOLD: {\n\t\t\tDestinationPosition dest {\n\t\t\t\t.lat = _land_approach.lat,\n\t\t\t\t.lon = _land_approach.lon,\n\t\t\t\t.alt = loiter_altitude,\n\t\t\t\t.yaw = _destination.yaw,\n\t\t\t};\n\n\t\t\tsetLoiterHoldMissionItem(_mission_item, dest, _param_rtl_land_delay.get(), _land_approach.loiter_radius_m,\n\t\t\t\t\t\t rtl_heading_mode);\n\n\t\t\tif (_param_rtl_land_delay.get() < -FLT_EPSILON) {\n\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: completed, loitering\\t\");\n\t\t\t\tevents::send(events::ID(\"rtl_completed_loiter\"), events::Log::Info, \"RTL: completed, loitering\");\n\t\t\t}\n\n\t\t\tif (_vehicle_status_sub.get().is_vtol\n\t\t\t    && _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\t\t\t\t_rtl_state = RTLState::MOVE_TO_LAND;\n\n\t\t\t} else {\n\t\t\t\t_rtl_state = RTLState::MOVE_TO_LAND_HOVER;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::MOVE_TO_LAND: {\n\n\t\t\tDestinationPosition dest{_destination};\n\t\t\tdest.alt = loiter_altitude;\n\n\t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n\n\t\t\t// Prepare for transition\n\t\t\t_mission_item.vtol_back_transition = true;\n\t\t\t_mission_item.force_heading = false;\n\n\t\t\t// set previous item location to loiter location such that vehicle tracks line between loiter\n\t\t\t// location and land location after exiting the loiter circle\n\t\t\tpos_sp_triplet->previous.lat = _land_approach.lat;\n\t\t\tpos_sp_triplet->previous.lon = _land_approach.lon;\n\t\t\tpos_sp_triplet->previous.alt = _mission_item.altitude;\n\t\t\tpos_sp_triplet->previous.valid = true;\n\n\t\t\t_rtl_state = RTLState::TRANSITION_TO_MC;\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::TRANSITION_TO_MC: {\n\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC);\n\n\t\t\t_rtl_state = RTLState::MOVE_TO_LAND_HOVER;\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::MOVE_TO_LAND_HOVER: {\n\t\t\tDestinationPosition dest{_destination};\n\t\t\tdest.alt = loiter_altitude;\n\n\t\t\tsetMoveToPositionMissionItem(_mission_item, dest, rtl_heading_mode);\n\n\t\t\t_rtl_state = RTLState::LAND;\n\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::LAND: {\n\n\t\t\tsetLandMissionItem(_mission_item, _destination, rtl_heading_mode);\n\n\t\t\t_mission_item.land_precision = _param_rtl_pld_md.get();\n\n\t\t\tstartPrecLand(_mission_item.land_precision);\n\n\t\t\t_rtl_state = RTLState::IDLE;\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"RTL: land at destination\\t\");\n\t\t\tevents::send(events::ID(\"rtl_land_at_destination\"), events::Log::Info, \"RTL: land at destination\");\n\t\t\tbreak;\n\t\t}\n\n\tcase RTLState::IDLE: {\n\t\t\tset_idle_item(&_mission_item);\n\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_RTL);\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treset_mission_item_reached();\n\n\t// Execute command if set. This is required for commands like VTOL transition.\n\tif (!MissionBlock::item_contains_position(_mission_item)) {\n\t\tissue_command(_mission_item);\n\n\t} else {\n\t\t// Convert mission item to current position setpoint and make it valid.\n\t\tmission_apply_limitation(_mission_item);\n\n\t\tif (mission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current)) {\n\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t}\n\t}\n}"
    },
    "VtolTakeoff::set_takeoff_position": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "VtolTakeoff::set_takeoff_position()\n{\n\t// set current mission item to takeoff\n\tset_takeoff_item(&_mission_item, _transition_alt_amsl);\n\n\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t_mission_item.lon = _navigator->get_global_position()->lon;\n\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\n\t// convert mission item to current setpoint\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\tpos_sp_triplet->previous.valid = false;\n\tpos_sp_triplet->current.yaw_valid = true;\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBase::setEndOfMissionItems": {
      "file": "src/modules/navigator/mission_base.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void MissionBase::setEndOfMissionItems()\n{\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_land_detected_sub.get().landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t} else {\n\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t}\n\t}\n\n\t/* update position setpoint triplet  */\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t// set mission finished\n\t_navigator->get_mission_result()->finished = true;\n\t_navigator->set_mission_result_updated();\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\t_mission_type = MissionType::MISSION_TYPE_NONE;\n}"
    },
    "Mission::setActiveMissionItems": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void Mission::setActiveMissionItems()\n{\n\t/* Get mission item that comes after current if available */\n\tstatic constexpr size_t max_num_next_items{2u};\n\tint32_t next_mission_items_index[max_num_next_items];\n\tsize_t num_found_items;\n\n\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n\n\tmission_item_s next_mission_items[max_num_next_items];\n\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n\n\tfor (size_t i = 0U; i < num_found_items; i++) {\n\t\tmission_item_s next_mission_item;\n\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_items_index[i],\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\tif (success) {\n\t\t\tnext_mission_items[i] = next_mission_item;\n\n\t\t} else {\n\t\t\tnum_found_items = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\tWorkItemType new_work_item_type = WorkItemType::WORK_ITEM_TYPE_DEFAULT;\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tconst position_setpoint_s current_setpoint_copy = pos_sp_triplet->current;\n\n\tif (item_contains_position(_mission_item)) {\n\n\t\thandleTakeoff(new_work_item_type, next_mission_items, num_found_items);\n\n\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n\n\t\t// TODO Precision land needs to be refactored: https://github.com/PX4/Firmware/issues/14320\n\t\tif (new_work_item_type != WorkItemType::WORK_ITEM_TYPE_PRECISION_LAND) {\n\t\t\tmission_apply_limitation(_mission_item);\n\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t}\n\n\t\t// Allow a rotary wing vehicle to decelerate before reaching a wp with a hold time or a timeout\n\t\t// This is done by setting the position triplet's next position's valid flag to false,\n\t\t// which makes the FlightTask disregard the next position\n\t\t// TODO: Setting the next waypoint's validity flag to handle braking / correct waypoint behavior\n\t\t// seems hacky, handle this more properly.\n\t\tconst bool brake_for_hold = _vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_time_inside(_mission_item) > FLT_EPSILON || item_has_timeout(_mission_item));\n\n\t\tif (_mission_item.autocontinue && !brake_for_hold) {\n\t\t\t/* try to process next mission item */\n\t\t\tif (num_found_items >= 1u) {\n\t\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n\n\t\t\t} else {\n\t\t\t\t/* next mission item is not available */\n\t\t\t\tpos_sp_triplet->next.valid = false;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else if (item_contains_gate(_mission_item)) {\n\t\t// The mission item is a gate, let's check if the next item in the list provides\n\t\t// a position to go towards.\n\n\t\tif (num_found_items > 0u) {\n\t\t\t// We have a position, convert it to the setpoint and update setpoint triplet\n\t\t\tmission_apply_limitation(next_mission_items[0u]);\n\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->current);\n\t\t}\n\n\t\tif (num_found_items >= 2u) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_apply_limitation(next_mission_items[1u]);\n\t\t\tmission_item_to_position_setpoint(next_mission_items[1u], &pos_sp_triplet->next);\n\n\t\t} else {\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\thandleVtolTransition(new_work_item_type, next_mission_items, num_found_items);\n\t}\n\n\t// Only set the previous position item if the current one really changed\n\tif ((_work_item_type != WorkItemType::WORK_ITEM_TYPE_MOVE_TO_LAND) &&\n\t    !position_setpoint_equal(&pos_sp_triplet->current, &current_setpoint_copy)) {\n\t\tpos_sp_triplet->previous = current_setpoint_copy;\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "get_lndmc_alt_max": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "float get_yaw_threshold() const { return math::radians(_param_mis_yaw_err.get()); }\n\tfloat get_lndmc_alt_max() const { return _param_lndmc_alt_max.get(); }"
    },
    "Takeoff::on_active": {
      "file": "src/modules/navigator/takeoff.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "Takeoff::on_active()\n{\n\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n\n\tif (rep->current.valid) {\n\t\t// reset the position\n\t\tset_takeoff_position();\n\n\t} else if (is_mission_item_reached_or_completed() && !_navigator->get_mission_result()->finished) {\n\t\t_navigator->get_mission_result()->finished = true;\n\t\t_navigator->set_mission_result_updated();\n\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF);\n\n\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t// set loiter item so position controllers stop doing takeoff logic\n\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t\t} else {\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t} else {\n\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t}\n\t\t}\n\n\t\tmission_apply_limitation(_mission_item);\n\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n}"
    },
    "Takeoff::set_takeoff_position": {
      "file": "src/modules/navigator/takeoff.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "Takeoff::set_takeoff_position()\n{\n\tstruct position_setpoint_triplet_s *rep = _navigator->get_takeoff_triplet();\n\n\tfloat takeoff_altitude_amsl = 0.f;\n\n\tif (rep->current.valid && PX4_ISFINITE(rep->current.alt)) {\n\t\ttakeoff_altitude_amsl = rep->current.alt;\n\n\t} else {\n\t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt + _navigator->get_param_mis_takeoff_alt();\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(),\n\t\t\t\t \"Using default takeoff altitude: %.1f m\\t\", (double)_navigator->get_param_mis_takeoff_alt());\n\n\t\tevents::send<float>(events::ID(\"navigator_takeoff_default_alt\"), {events::Log::Info, events::LogInternal::Info},\n\t\t\t\t    \"Using default takeoff altitude: {1:.2m}\",\n\t\t\t\t    _navigator->get_param_mis_takeoff_alt());\n\t}\n\n\tif (takeoff_altitude_amsl < _navigator->get_global_position()->alt) {\n\t\t// If the suggestion is lower than our current alt, let's not go down.\n\t\ttakeoff_altitude_amsl = _navigator->get_global_position()->alt;\n\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"Already higher than takeoff altitude\\t\");\n\t\tevents::send(events::ID(\"navigator_takeoff_already_higher\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t     \"Already higher than takeoff altitude (not descending)\");\n\t}\n\n\t// set current mission item to takeoff\n\tset_takeoff_item(&_mission_item, takeoff_altitude_amsl);\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\treset_mission_item_reached();\n\n\t// convert mission item to current setpoint\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\n\tpos_sp_triplet->previous.valid = false;\n\tpos_sp_triplet->current.yaw_valid = true;\n\tpos_sp_triplet->next.valid = false;\n\n\tif (rep->current.valid) {\n\n\t\t// Go on and check which changes had been requested\n\t\tif (PX4_ISFINITE(rep->current.yaw)) {\n\t\t\tpos_sp_triplet->current.yaw = rep->current.yaw;\n\t\t}\n\n\t\t// Set the current latitude and longitude even if they are NAN\n\t\t// NANs are handled in FlightTaskAuto.cpp\n\t\tpos_sp_triplet->current.lat = rep->current.lat;\n\t\tpos_sp_triplet->current.lon = rep->current.lon;\n\n\t\t// mark this as done\n\t\tmemset(rep, 0, sizeof(*rep));\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "RtlMissionFastReverse::setActiveMissionItems": {
      "file": "src/modules/navigator/rtl_mission_fast_reverse.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void RtlMissionFastReverse::setActiveMissionItems()\n{\n\tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Transition to fixed wing if necessary.\n\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t    _vehicle_status_sub.get().is_vtol &&\n\t    !_land_detected_sub.get().landed && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\n\t} else if (item_contains_position(_mission_item)) {\n\t\tint32_t next_mission_item_index;\n\t\tsize_t num_found_items = 0;\n\t\tgetPreviousPositionItems(_mission.current_seq, &next_mission_item_index, num_found_items, 1u);\n\n\t\t// If the current item is a takeoff item or there is no further position item start landing.\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n\t\t    num_found_items == 0) {\n\t\t\thandleLanding(new_work_item_type);\n\n\t\t} else {\n\t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n\t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t}\n\n\t\tif (num_found_items > 0) {\n\n\t\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n\t\t\tmission_item_s next_mission_item;\n\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_item_index,\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(mission_item_s), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\tmission_apply_limitation(next_mission_item);\n\t\t\t\tmission_item_to_position_setpoint(next_mission_item, &pos_sp_triplet->next);\n\t\t\t}\n\t\t}\n\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Loiter::set_loiter_position": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "Loiter::set_loiter_position()\n{\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n\t    _navigator->get_land_detected()->landed) {\n\n\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n\t\t// setpoint as invalid and idle (both, just to be sure).\n\n\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\n\t}\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\t// Check if we already loiter on a circle and are on the loiter pattern.\n\t\tbool on_loiter{false};\n\n\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t    && pos_sp_triplet->current.loiter_pattern == position_setpoint_s::LOITER_TYPE_ORBIT) {\n\t\t\tconst float d_current = get_distance_to_next_waypoint(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon,\n\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\t\t\ton_loiter = d_current <= (_navigator->get_acceptance_radius() + pos_sp_triplet->current.loiter_radius);\n\n\t\t}\n\n\t\tif (on_loiter) {\n\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n\n\t\t} else {\n\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t}\n\n\t}\n\n\t// convert mission item to current setpoint\n\tpos_sp_triplet->previous.valid = false;\n\tmission_apply_limitation(_mission_item);\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "RtlMissionFast::setActiveMissionItems": {
      "file": "src/modules/navigator/rtl_mission_fast.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "void RtlMissionFast::setActiveMissionItems()\n{\n\tWorkItemType new_work_item_type{WorkItemType::WORK_ITEM_TYPE_DEFAULT};\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t// Transition to fixed wing if necessary.\n\tif (_vehicle_status_sub.get().vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING &&\n\t    _vehicle_status_sub.get().is_vtol &&\n\t    !_land_detected_sub.get().landed && _work_item_type == WorkItemType::WORK_ITEM_TYPE_DEFAULT) {\n\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t_mission_item.yaw = _navigator->get_local_position()->heading;\n\n\t\t// keep current setpoints (FW position controller generates wp to track during transition)\n\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\tnew_work_item_type = WorkItemType::WORK_ITEM_TYPE_TRANSITION_AFTER_TAKEOFF;\n\n\t} else if (item_contains_position(_mission_item)) {\n\n\t\tstatic constexpr size_t max_num_next_items{1u};\n\t\tint32_t next_mission_items_index[max_num_next_items];\n\t\tsize_t num_found_items = 0;\n\t\tgetNextPositionItems(_mission.current_seq + 1, next_mission_items_index, num_found_items, max_num_next_items);\n\n\t\tmission_item_s next_mission_items[max_num_next_items];\n\t\tconst dm_item_t dataman_id = static_cast<dm_item_t>(_mission.dataman_id);\n\n\t\tfor (size_t i = 0U; i < num_found_items; i++) {\n\t\t\tmission_item_s next_mission_item;\n\t\t\tbool success = _dataman_cache.loadWait(dataman_id, next_mission_items_index[i],\n\t\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&next_mission_item), sizeof(next_mission_item), MAX_DATAMAN_LOAD_WAIT);\n\n\t\t\tif (success) {\n\t\t\t\tnext_mission_items[i] = next_mission_item;\n\n\t\t\t} else {\n\t\t\t\tnum_found_items = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND ||\n\t\t    _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\thandleLanding(new_work_item_type, next_mission_items, num_found_items);\n\n\t\t} else {\n\t\t\t// convert mission item to a simple waypoint, keep loiter to alt\n\t\t\tif (_mission_item.nav_cmd != NAV_CMD_LOITER_TO_ALT) {\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t}\n\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\n\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\t\t}\n\n\n\n\t\tif (num_found_items > 0) {\n\t\t\tmission_apply_limitation(next_mission_items[0u]);\n\t\t\tmission_item_to_position_setpoint(next_mission_items[0u], &pos_sp_triplet->next);\n\t\t}\n\n\t\tmission_apply_limitation(_mission_item);\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t}\n\n\tissue_command(_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\treset_mission_item_reached();\n\n\tif (_mission_type == MissionType::MISSION_TYPE_MISSION) {\n\t\tset_mission_result();\n\t}\n\n\tpublish_navigator_mission_item(); // for logging\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "VtolTakeoff::on_active": {
      "file": "src/modules/navigator/vtol_takeoff.cpp",
      "commit": "0d53bd945ec1e90c7b93a24976fe9deb9e88780a",
      "source": "VtolTakeoff::on_active()\n{\n\tif (is_mission_item_reached_or_completed()) {\n\t\treset_mission_item_reached();\n\n\t\tswitch\t(_takeoff_state) {\n\t\tcase vtol_takeoff_state::TAKEOFF_HOVER: {\n\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t_mission_item.yaw = wrap_pi(get_bearing_to_next_waypoint(_mission_item.lat,\n\t\t\t\t\t\t\t    _mission_item.lon, _loiter_location(0), _loiter_location(1)));\n\t\t\t\t_mission_item.force_heading = true;\n\t\t\t\tmission_apply_limitation(_mission_item);\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.disable_weather_vane = true;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::ALIGN_HEADING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::ALIGN_HEADING: {\n\n\t\t\t\tset_vtol_transition_item(&_mission_item, vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW);\n\t\t\t\t_mission_item.lat = _loiter_location(0);\n\t\t\t\t_mission_item.lon = _loiter_location(1);\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\t\t\tpos_sp_triplet->previous = pos_sp_triplet->current;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\tissue_command(_mission_item);\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::TRANSITION;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::TRANSITION: {\n\t\t\t\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER) {\n\t\t\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t\t\t} else {\n\t\t\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t\t\t}\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_LOITER_TIME_LIMIT;\n\n\t\t\t\t// we need the vehicle to loiter indefinitely but also we want this mission item to be reached as soon\n\t\t\t\t// as the loiter is established. therefore, set a small loiter time so that the mission item will be reached quickly,\n\t\t\t\t// however it will just continue loitering as there is no next mission item\n\t\t\t\t_mission_item.time_inside = 1.f;\n\t\t\t\t_mission_item.loiter_radius = _navigator->get_loiter_radius();\n\t\t\t\t_mission_item.acceptance_radius  = _navigator->get_acceptance_radius();\n\t\t\t\t_mission_item.altitude = _navigator->get_home_position()->alt + _param_loiter_alt.get();\n\n\t\t\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t\t\tpos_sp_triplet->current.lat = _loiter_location(0);\n\t\t\t\tpos_sp_triplet->current.lon = _loiter_location(1);\n\t\t\t\tpos_sp_triplet->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\tpos_sp_triplet->current.cruising_speed = -1.f;\n\t\t\t\tpos_sp_triplet->current.cruising_throttle = -1.f;\n\n\t\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\n\t\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\n\t\t\t\treset_mission_item_reached();\n\n\t\t\t\t_takeoff_state = vtol_takeoff_state::CLIMB;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase vtol_takeoff_state::CLIMB: {\n\n\t\t\t\t// reset any potentially valid reposition triplet which was not handled\n\t\t\t\t// we do this to avoid random loiter locations after switching to loiter mode after this\n\t\t\t\tposition_setpoint_triplet_s *reposition_triplet = _navigator->get_reposition_triplet();\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->previous);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->current);\n\t\t\t\t_navigator->reset_position_setpoint(reposition_triplet->next);\n\n\t\t\t\t// the VTOL takeoff is done\n\t\t\t\t_navigator->get_mission_result()->finished = true;\n\t\t\t\t_navigator->set_mission_result_updated();\n\t\t\t\t_navigator->mode_completed(vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
    }
  },
  "4065": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "072645b483f1ce083375ec1165f0352aedd2043e",
      "source": "Loiter::on_activation()\n{\n\t/* set current mission item to loiter */\n\tset_loiter_item(&_mission_item, _param_min_alt.get());\n\n\t/* convert mission item to current setpoint */\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\tpos_sp_triplet->current.velocity_valid = false;\n\tpos_sp_triplet->previous.valid = false;\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Navigator::task_main": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "072645b483f1ce083375ec1165f0352aedd2043e",
      "source": "Navigator::task_main()\n{\n\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t_geofence.setMavlinkFd(_mavlink_fd);\n\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file\n\t * else clear geofence data in datamanager */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\twarnx(\"Try to load geofence.txt\");\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\n\t} else {\n\t\tif (_geofence.clearDm() != OK) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"failed clearing geofence\");\n\t\t}\n\t}\n\n\t/* do subscriptions */\n\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n\t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n\t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n\t_onboard_mission_sub = orb_subscribe(ORB_ID(onboard_mission));\n\t_offboard_mission_sub = orb_subscribe(ORB_ID(offboard_mission));\n\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n\n\t/* copy all topics first time */\n\tvehicle_status_update();\n\tvehicle_control_mode_update();\n\tglobal_position_update();\n\tgps_position_update();\n\tsensor_combined_update();\n\thome_position_update(true);\n\tnavigation_capabilities_update();\n\tparams_update();\n\n\thrt_abstime mavlink_open_time = 0;\n\tconst hrt_abstime mavlink_open_interval = 500000;\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[1] = {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _global_pos_sub;\n\tfds[0].events = POLLIN;\n\n\tbool global_pos_available_once = false;\n\n\twhile (!_task_should_exit) {\n\n\t\t/* wait for up to 200ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n\t\t\tif (global_pos_available_once) {\n\t\t\t\tPX4_WARN(\"navigator timed out\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal_pos_available_once = true;\n\n\t\tperf_begin(_loop_perf);\n\n\t\tif (_mavlink_fd < 0 && hrt_absolute_time() > mavlink_open_time) {\n\t\t\t/* try to reopen the mavlink log device with specified interval */\n\t\t\tmavlink_open_time = hrt_abstime() + mavlink_open_interval;\n\t\t\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t\t}\n\n\t\tbool updated;\n\n\t\t/* gps updated */\n\t\torb_check(_gps_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\tgps_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* sensors combined updated */\n\t\torb_check(_sensor_combined_sub, &updated);\n\t\tif (updated) {\n\t\t\tsensor_combined_update();\n\t\t}\n\n\t\t/* parameters updated */\n\t\torb_check(_param_update_sub, &updated);\n\t\tif (updated) {\n\t\t\tparams_update();\n\t\t\tupdateParams();\n\t\t}\n\n\t\t/* vehicle control mode updated */\n\t\torb_check(_control_mode_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_control_mode_update();\n\t\t}\n\n\t\t/* vehicle status updated */\n\t\torb_check(_vstatus_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_status_update();\n\t\t}\n\n\t\t/* navigation capabilities updated */\n\t\torb_check(_capabilities_sub, &updated);\n\t\tif (updated) {\n\t\t\tnavigation_capabilities_update();\n\t\t}\n\n\t\t/* home position updated */\n\t\torb_check(_home_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\thome_position_update();\n\t\t}\n\n\t\torb_check(_vehicle_command_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_command_s cmd;\n\t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n\t\t\t\twarnx(\"navigator: got reposition command\");\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n\t\t\t\twarnx(\"navigator: got pause/continue command\");\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (fds[0].revents & POLLIN) {\n\t\t\tglobal_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Check geofence violation */\n\t\tstatic hrt_abstime last_geofence_check = 0;\n\t\tif (have_geofence_position_data &&\n\t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n\t\t\tlast_geofence_check = hrt_absolute_time();\n\t\t\thave_geofence_position_data = false;\n\n\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\t\t\tif (!inside) {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = true;\n\t\t\t\tpublish_geofence_result();\n\n\t\t\t\t/* Issue a warning about the geofence violation once */\n\t\t\t\tif (!_geofence_violation_warning_sent) {\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation\");\n\t\t\t\t\t_geofence_violation_warning_sent = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = false;\n\t\t\t\tpublish_geofence_result();\n\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n\t\t\t\t_geofence_violation_warning_sent = false;\n\t\t\t}\n\t\t}\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tswitch (_vstatus.nav_state) {\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t\tif (_nav_caps.abort_landing) {\n\t\t\t\t\t// pos controller aborted landing, requests loiter\n\t\t\t\t\t// above landing waypoint\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t} else {\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t\t_navigation_mode = &_mission;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_rcloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_rcLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_takeoff;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n\t\t\t\t/* Use complex data link loss mode only when enabled via param\n\t\t\t\t* otherwise use rtl */\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_datalinkloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_engineFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_gpsFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_follow_target;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\t_pos_sp_triplet.previous.valid = false;\n\t\t\t_pos_sp_triplet.current.valid = false;\n\t\t\t_pos_sp_triplet.next.valid = false;\n\t\t\t_pos_sp_triplet_updated = true;\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t\t_pos_sp_triplet_updated = false;\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t\t_mission_result_updated = false;\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n\twarnx(\"exiting.\");\n\n\t_navigator_task = -1;\n\treturn;\n}"
    },
    "MissionBlock::set_loiter_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "072645b483f1ce083375ec1165f0352aedd2043e",
      "source": "MissionBlock::set_loiter_item(struct mission_item_s *item, float min_clearance)\n{\n\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t/* landed, don't takeoff, but switch to IDLE mode */\n\t\titem->nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\titem->nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n\n\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\tif (_navigator->get_can_loiter_at_sp() && pos_sp_triplet->current.valid) {\n\t\t\t/* use current position setpoint */\n\t\t\titem->lat = pos_sp_triplet->current.lat;\n\t\t\titem->lon = pos_sp_triplet->current.lon;\n\t\t\titem->altitude = pos_sp_triplet->current.alt;\n\n\t\t} else {\n\t\t\t/* use current position and use return altitude as clearance */\n\t\t\titem->lat = _navigator->get_global_position()->lat;\n\t\t\titem->lon = _navigator->get_global_position()->lon;\n\t\t\titem->altitude = _navigator->get_global_position()->alt;\n\n\t\t\tif (min_clearance > 0.0f && item->altitude < _navigator->get_home_position()->alt + min_clearance) {\n\t\t\t\titem->altitude = _navigator->get_home_position()->alt + min_clearance;\n\t\t\t}\n\t\t}\n\n\t\titem->altitude_is_relative = false;\n\t\titem->yaw = NAN;\n\t\titem->loiter_radius = _navigator->get_loiter_radius();\n\t\titem->loiter_direction = 1;\n\t\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\t\titem->time_inside = 0.0f;\n\t\titem->pitch_min = 0.0f;\n\t\titem->autocontinue = false;\n\t\titem->origin = ORIGIN_ONBOARD;\n\t}\n}"
    },
    "Navigator::Navigator": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "072645b483f1ce083375ec1165f0352aedd2043e",
      "source": "Navigator::Navigator() :\n\tSuperBlock(NULL, \"NAV\"),\n\t_task_should_exit(false),\n\t_navigator_task(-1),\n\t_mavlink_fd(-1),\n\t_global_pos_sub(-1),\n\t_gps_pos_sub(-1),\n\t_home_pos_sub(-1),\n\t_vstatus_sub(-1),\n\t_capabilities_sub(-1),\n\t_control_mode_sub(-1),\n\t_onboard_mission_sub(-1),\n\t_offboard_mission_sub(-1),\n\t_param_update_sub(-1),\n\t_vehicle_command_sub(-1),\n\t_pos_sp_triplet_pub(nullptr),\n\t_mission_result_pub(nullptr),\n\t_geofence_result_pub(nullptr),\n\t_att_sp_pub(nullptr),\n\t_vstatus{}"
    }
  },
  "4046": {
    "MissionBlock::item_contains_position": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "7e0512bab45bcbd789edaf6b3e7275719c625dda",
      "source": "MissionBlock::item_contains_position(const struct mission_item_s *item)\n{\n\t// XXX: maybe extend that check onto item properties\n\tif (item->nav_cmd == NAV_CMD_DO_JUMP ||\n\t\titem->nav_cmd == NAV_CMD_DO_CHANGE_SPEED ||\n\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO ||\n\t\titem->nav_cmd == NAV_CMD_DO_REPEAT_SERVO ||\n\t\titem->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n\t\titem->nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST ||\n\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
    },
    "MissionFeasibilityChecker::checkGeofence": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "7e0512bab45bcbd789edaf6b3e7275719c625dda",
      "source": "bool MissionFeasibilityChecker::checkGeofence(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence)\n{\n\t/* Check if all mission items are inside the geofence (if we have a valid geofence) */\n\tif (geofence.valid()) {\n\t\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\t\tstruct mission_item_s missionitem;\n\t\t\tconst ssize_t len = sizeof(missionitem);\n\n\t\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (MissionBlock::item_contains_position(&missionitem) &&\n\t\t\t\t!geofence.inside_polygon(missionitem.lat, missionitem.lon, missionitem.altitude)) {\n\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation for waypoint %d\", i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}"
    }
  },
  "3998": {
    "Navigator::task_main": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "475bdb72127b251c3469eca5567c37d4a12e4881",
      "source": "Navigator::task_main()\n{\n\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t_geofence.setMavlinkFd(_mavlink_fd);\n\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file\n\t * else clear geofence data in datamanager */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\twarnx(\"Try to load geofence.txt\");\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\n\t} else {\n\t\tif (_geofence.clearDm() != OK) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"failed clearing geofence\");\n\t\t}\n\t}\n\n\t/* do subscriptions */\n\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n\t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n\t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n\t_onboard_mission_sub = orb_subscribe(ORB_ID(onboard_mission));\n\t_offboard_mission_sub = orb_subscribe(ORB_ID(offboard_mission));\n\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n\n\t/* copy all topics first time */\n\tvehicle_status_update();\n\tvehicle_control_mode_update();\n\tglobal_position_update();\n\tgps_position_update();\n\tsensor_combined_update();\n\thome_position_update(true);\n\tnavigation_capabilities_update();\n\tparams_update();\n\n\thrt_abstime mavlink_open_time = 0;\n\tconst hrt_abstime mavlink_open_interval = 500000;\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[1] = {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _global_pos_sub;\n\tfds[0].events = POLLIN;\n\n\tbool global_pos_available_once = false;\n\n\twhile (!_task_should_exit) {\n\n\t\t/* wait for up to 200ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n\t\t\tif (global_pos_available_once) {\n\t\t\t\tPX4_WARN(\"navigator timed out\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal_pos_available_once = true;\n\n\t\tperf_begin(_loop_perf);\n\n\t\tif (_mavlink_fd < 0 && hrt_absolute_time() > mavlink_open_time) {\n\t\t\t/* try to reopen the mavlink log device with specified interval */\n\t\t\tmavlink_open_time = hrt_abstime() + mavlink_open_interval;\n\t\t\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t\t}\n\n\t\tbool updated;\n\n\t\t/* gps updated */\n\t\torb_check(_gps_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\tgps_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* sensors combined updated */\n\t\torb_check(_sensor_combined_sub, &updated);\n\t\tif (updated) {\n\t\t\tsensor_combined_update();\n\t\t}\n\n\t\t/* parameters updated */\n\t\torb_check(_param_update_sub, &updated);\n\t\tif (updated) {\n\t\t\tparams_update();\n\t\t\tupdateParams();\n\t\t}\n\n\t\t/* vehicle control mode updated */\n\t\torb_check(_control_mode_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_control_mode_update();\n\t\t}\n\n\t\t/* vehicle status updated */\n\t\torb_check(_vstatus_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_status_update();\n\t\t}\n\n\t\t/* navigation capabilities updated */\n\t\torb_check(_capabilities_sub, &updated);\n\t\tif (updated) {\n\t\t\tnavigation_capabilities_update();\n\t\t}\n\n\t\t/* home position updated */\n\t\torb_check(_home_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\thome_position_update();\n\t\t}\n\n\t\torb_check(_vehicle_command_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_command_s cmd;\n\t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n\t\t\t\twarnx(\"navigator: got reposition command\");\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n\t\t\t\twarnx(\"navigator: got pause/continue command\");\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (fds[0].revents & POLLIN) {\n\t\t\tglobal_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Check geofence violation */\n\t\tstatic hrt_abstime last_geofence_check = 0;\n\t\tif (have_geofence_position_data &&\n\t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n\t\t\tlast_geofence_check = hrt_absolute_time();\n\t\t\thave_geofence_position_data = false;\n\n\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\t\t\tif (!inside) {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = true;\n\t\t\t\tpublish_geofence_result();\n\n\t\t\t\t/* Issue a warning about the geofence violation once */\n\t\t\t\tif (!_geofence_violation_warning_sent) {\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation\");\n\t\t\t\t\t_geofence_violation_warning_sent = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = false;\n\t\t\t\tpublish_geofence_result();\n\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n\t\t\t\t_geofence_violation_warning_sent = false;\n\t\t\t}\n\t\t}\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tswitch (_vstatus.nav_state) {\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t\tif (_nav_caps.abort_landing) {\n\t\t\t\t\t// pos controller aborted landing, requests loiter\n\t\t\t\t\t// above landing waypoint\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t} else {\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t\t_navigation_mode = &_mission;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_rcloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_rcLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_takeoff;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n\t\t\t\t/* Use complex data link loss mode only when enabled via param\n\t\t\t\t* otherwise use rtl */\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_datalinkloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_engineFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_gpsFailure;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\t_pos_sp_triplet.previous.valid = false;\n\t\t\t_pos_sp_triplet.current.valid = false;\n\t\t\t_pos_sp_triplet.next.valid = false;\n\t\t\t_pos_sp_triplet_updated = true;\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t\t_pos_sp_triplet_updated = false;\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t\t_mission_result_updated = false;\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n\twarnx(\"exiting.\");\n\n\t_navigator_task = -1;\n\treturn;\n}"
    }
  },
  "4012": {
    "MissionBlock::set_land_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "2f4aaa6449d02d8589246bdd153705d4c3babee6",
      "source": "MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_location)\n{\n\n\t/* VTOL transition to RW before landing */\n\tif(_navigator->get_vstatus()->is_vtol && !_navigator->get_vstatus()->is_rotary_wing){\n\t\tstruct vehicle_command_s cmd = {};\n\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\tif (_cmd_pub != nullptr) {\n\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t} else {\n\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t}\n\t}\n\n\t/* set the land item */\n\titem->nav_cmd = NAV_CMD_LAND;\n\n\t/* use current position */\n\tif (at_current_location) {\n\t\titem->lat = _navigator->get_global_position()->lat;\n\t\titem->lon = _navigator->get_global_position()->lon;\n\t\n\t/* use home position */\n\t} else {\n\t\titem->lat = _navigator->get_home_position()->lat;\n\t\titem->lon = _navigator->get_home_position()->lon;\n\t}\n\n\titem->altitude = 0;\n\titem->altitude_is_relative = false;\n\titem->yaw = NAN;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->loiter_direction = 1;\n\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->pitch_min = 0.0f;\n\titem->autocontinue = true;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    },
    "RTL::on_activation": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "2f4aaa6449d02d8589246bdd153705d4c3babee6",
      "source": "RTL::on_activation()\n{\n\t/* decide where to enter the RTL procedure when we switch into it */\n\tif (_rtl_state == RTL_STATE_NONE) {\n\t\t/* for safety reasons don't go into RTL if landed */\n\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t_rtl_state = RTL_STATE_LANDED;\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no RTL when landed\");\n\n\t\t/* if lower than return altitude, climb up first */\n\t\t} else if (_navigator->get_global_position()->alt < _navigator->get_home_position()->alt\n\t\t\t   + _param_return_alt.get()) {\n\t\t\t_rtl_state = RTL_STATE_CLIMB;\n\t\t\t_rtl_start_lock = false;\n\n\t\t/* otherwise go straight to return */\n\t\t} else {\n\t\t\t/* set altitude setpoint to current altitude */\n\t\t\t_rtl_state = RTL_STATE_RETURN;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t_rtl_start_lock = false;\n\t\t}\n\n\t}\n\n\tset_rtl_item();\n}"
    },
    "RTL::on_inactive": {
      "file": "src/modules/navigator/rtl.cpp",
      "commit": "2f4aaa6449d02d8589246bdd153705d4c3babee6",
      "source": "RTL::on_inactive()\n{\n\t/* reset RTL state only if setpoint moved */\n\tif (!_navigator->get_can_loiter_at_sp()) {\n\t\t_rtl_state = RTL_STATE_NONE;\n\t}\n}"
    }
  },
  "4043": {
    "Mission::on_inactive": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "1c891432eb14c2e318587eee5152f7d025a978e0",
      "source": "Mission::on_inactive()\n{\n\tif (_inited) {\n\t\t/* check if missions have changed so that feedback to ground station is given */\n\t\tbool onboard_updated = false;\n\t\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\t\tif (onboard_updated) {\n\t\t\tupdate_onboard_mission();\n\t\t}\n\n\t\tbool offboard_updated = false;\n\t\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\t\tif (offboard_updated) {\n\t\t\tupdate_offboard_mission();\n\t\t}\n\n\t} else {\n\n\t\t/* load missions from storage */\n\t\tmission_s mission_state;\n\n\t\tdm_lock(DM_KEY_MISSION_STATE);\n\n\t\t/* read current state */\n\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n\n\t\tdm_unlock(DM_KEY_MISSION_STATE);\n\n\t\tif (read_res == sizeof(mission_s)) {\n\t\t\t_offboard_mission.dataman_id = mission_state.dataman_id;\n\t\t\t_offboard_mission.count = mission_state.count;\n\t\t\t_current_offboard_mission_index = mission_state.current_seq;\n\t\t}\n\n\t\t_inited = true;\n\t}\n\n\tcheck_mission_valid();\n\n\t/* require takeoff after non-loiter or landing */\n\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_vstatus()->condition_landed) {\n\t\t_need_takeoff = true;\n\t}\n}"
    },
    "Mission::Mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "1c891432eb14c2e318587eee5152f7d025a978e0",
      "source": "Mission::Mission(Navigator *navigator, const char *name) :\n\tMissionBlock(navigator, name),\n\t_param_onboard_enabled(this, \"MIS_ONBOARD_EN\", false),\n\t_param_takeoff_alt(this, \"MIS_TAKEOFF_ALT\", false),\n\t_param_dist_1wp(this, \"MIS_DIST_1WP\", false),\n\t_param_altmode(this, \"MIS_ALTMODE\", false),\n\t_param_yawmode(this, \"MIS_YAWMODE\", false),\n\t_onboard_mission{}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "1c891432eb14c2e318587eee5152f7d025a978e0",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid();\n\n\t/* check if anything has changed */\n\tbool onboard_updated = false;\n\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\tif (onboard_updated) {\n\t\tupdate_onboard_mission();\n\t}\n\n\tbool offboard_updated = false;\n\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\tif (offboard_updated) {\n\t\tupdate_offboard_mission();\n\t}\n\n\t/* reset mission items if needed */\n\tif (onboard_updated || offboard_updated) {\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached()) {\n\t\tset_mission_item_reached();\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\n\t} else if (_mission_type != MISSION_TYPE_NONE && _param_altmode.get() == MISSION_ALTMODE_FOH) {\n\t\taltitude_sp_foh_update();\n\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif ((_param_yawmode.get() != MISSION_YAWMODE_NONE\n\t\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n\t\t\t&& _mission_type != MISSION_TYPE_NONE)\n\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n\t\theading_sp_update();\n\t}\n\n}"
    },
    "Mission::check_mission_valid": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "1c891432eb14c2e318587eee5152f7d025a978e0",
      "source": "Mission::check_mission_valid()\n{\n\t/* check if the home position became valid in the meantime */\n\tif (!_home_inited && _navigator->home_position_valid()) {\n\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\t_navigator->get_mission_result()->valid = _missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_log_pub(), (_navigator->get_vstatus()->is_rotary_wing || _navigator->get_vstatus()->is_vtol),\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t\t_home_inited = true;\n\t}\n\n\treturn _navigator->get_mission_result()->valid;\n}"
    }
  },
  "3922": {
    "Navigator::get_acceptance_radius": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "65696acf6aea33b4aea93fd5ce53746e935ee0d0",
      "source": "Navigator::get_acceptance_radius()\n{\n\treturn get_acceptance_radius(_param_acceptance_radius.get());\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "65696acf6aea33b4aea93fd5ce53746e935ee0d0",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif ((_navigator->get_vstatus()->condition_landed == false)\n\t\t&& !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n\t\t\t\t\t|| (_param_yaw_timeout.get() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t\t\t\t_param_yaw_timeout.get() >= FLT_EPSILON &&\n\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f) {\n\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    }
  },
  "3908": {
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "d0e0c7e2b40dff3879964a5eab4b6e41a819e493",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif ((_navigator->get_vstatus()->condition_landed == false)\n\t\t&& !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n\t\t\t\t\t|| (_param_yaw_timeout.get() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t\t\t\t_param_yaw_timeout.get() >= FLT_EPSILON &&\n\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f) {\n\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    }
  },
  "22394": {
    "Navigator::geofence_allows_position": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "bool Navigator::geofence_allows_position(const vehicle_global_position_s &pos)\n{\n\tif ((_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_WARN)) {\n\n\t\tif (PX4_ISFINITE(pos.lat) && PX4_ISFINITE(pos.lon) && PX4_ISFINITE(pos.alt)) {\n\t\t\treturn _geofence.checkPointAgainstAllGeofences(pos.lat, pos.lon, pos.alt);\n\t\t}\n\t}\n\n\treturn true;\n}"
    },
    "MissionFeasibilityChecker::checkMissionFeasible": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "MissionFeasibilityChecker::checkMissionFeasible(const mission_s &mission)\n{\n\t// Reset warning flag\n\t_navigator->get_mission_result()->warning = false;\n\n\t// first check if we have a valid position\n\tconst bool home_valid = _navigator->home_global_position_valid();\n\tconst bool home_alt_valid = _navigator->home_alt_valid();\n\n\t// trivial case: A mission with length zero cannot be valid\n\tif ((int)mission.count <= 0) {\n\t\treturn false;\n\t}\n\n\tif (!home_alt_valid) {\n\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"Not yet ready for mission, no position lock.\\t\");\n\t\tevents::send(events::ID(\"navigator_mis_no_pos_lock\"), events::Log::Info, \"Not yet ready for mission, no position lock\");\n\t\treturn false;\n\t}\n\n\tbool failed = false;\n\n\tfor (size_t i = 0; i < mission.count; i++) {\n\t\tstruct mission_item_s missionitem = {};\n\n\t\tbool success = _dataman_client.readSync((dm_item_t)mission.dataman_id, i, reinterpret_cast<uint8_t *>(&missionitem),\n\t\t\t\t\t\t\tsizeof(mission_item_s));\n\n\t\tif (!success) {\n\t\t\t_navigator->get_mission_result()->warning = true;\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!_feasibility_checker.processNextItem(missionitem, i, mission.count)) {\n\t\t\tfailed = true;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tfailed |= _feasibility_checker.someCheckFailed();\n\n\tfailed |= !checkMissionAgainstGeofence(mission, _navigator->get_home_position()->alt, home_valid);\n\n\t_navigator->get_mission_result()->warning = failed;\n\n\treturn !failed;\n}"
    },
    "geofence_breach_check": {
      "file": "src/modules/navigator/navigator.h",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "bool abort_landing();\n\n\tvoid geofence_breach_check(bool &have_geofence_position_data);\n\n\t// Param access\n\tint get_loiter_min_alt() const { return _param_min_ltr_alt.get(); }"
    },
    "Geofence::isBelowMaxAltitude": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "bool Geofence::isBelowMaxAltitude(float altitude)\n{\n\tbool inside_fence = true;\n\n\tif (_param_gf_max_ver_dist.get() > FLT_EPSILON && _navigator->home_alt_valid()) {\n\n\t\tconst float dist_z = altitude - _navigator->get_home_position()->alt;\n\t\tinside_fence = dist_z < _param_gf_max_ver_dist.get();\n\t}\n\n\treturn inside_fence;\n}"
    },
    "Copyright": {
      "file": "src/modules/navigator/geofence.h",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "/****************************************************************************\n *\n *   Copyright (c) 2013-2023 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n/**\n * @file geofence.h\n * Provides functions for handling the geofence\n *\n * @author Jean Cyr <jean.m.cyr@gmail.com>\n * @author Thomas Gubler <thomasgubler@gmail.com>\n */\n\n#pragma once\n\n#include <float.h>\n\n#include <dataman_client/DatamanClient.hpp>\n#include <lib/mathlib/mathlib.h>\n#include <px4_platform_common/module_params.h>\n#include <drivers/drv_hrt.h>\n#include <lib/geo/geo.h>\n#include <px4_platform_common/defines.h>\n#include <uORB/Subscription.hpp>\n#include <uORB/topics/home_position.h>\n#include <uORB/topics/vehicle_global_position.h>\n#include <uORB/topics/sensor_gps.h>\n\n#define GEOFENCE_FILENAME PX4_STORAGEDIR\"/etc/geofence.txt\"\n\nclass Navigator;\n\nclass Geofence : public ModuleParams\n{\npublic:\n\tGeofence(Navigator *navigator);\n\tGeofence(const Geofence &) = delete;\n\tGeofence &operator=(const Geofence &) = delete;\n\tvirtual ~Geofence();\n\n\t/* Source, corresponding to the param GF_SOURCE */\n\tenum {\n\t\tGF_SOURCE_GLOBALPOS = 0,\n\t\tGF_SOURCE_GPS = 1\n\t};\n\n\t/**\n\t * @brief function to call regularly to do background work\n\t */\n\tvoid run();\n\n\t/**\n\t * update the geofence from dataman.\n\t */\n\tvoid updateFence();\n\n\n\t/**\n\t * Check if a 3D point passes the Geofence test.\n\t * Checks max distance, max altitude, inside polygon or circle.\n\t * In addition to checkPolygons(), this takes all additional parameters into account.\n\t *\n\t * @return false for a geofence violation\n\t */\n\tbool checkPointAgainstAllGeofences(double lat, double lon, float altitude);\n\n\t/**\n\t * @brief check if the horizontal distance to Home is greater than the maximum allowed distance\n\t *\n\t * @return true if the horizontal distance to Home is smaller than the maximum allowed distance\n\t */\n\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n\n\n\t/**\n\t * @brief check if the altitude above Home is greater than the maximum allowed altitude\n\t *\n\t * @return true if the altitude above Home is smaller than the maximum allowed altitude\n\t */\n\tbool isBelowMaxAltitude(float altitude);\n\n\tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n\n\tint clearDm();\n\n\tbool valid();\n\n\t/**\n\t * Load a single inclusion polygon, replacing any already existing polygons.\n\t * The file has one of the following formats:\n\t * - Decimal Degrees:\n\t * 0 900\n\t * 47.475273548913222 8.52672100067138672\n\t * 47.4608261578541359 8.53414535522460938\n\t * 47.4613484218861217 8.56444358825683594\n\t * 47.4830758091035534 8.53470325469970703\n\t *\n\t * - Degree-Minute-Second:\n\t * 0 900\n\t * DMS -26 -34 -10.4304 151 50 14.5428\n\t * DMS -26 -34 -11.8416 151 50 21.8580\n\t * DMS -26 -34 -36.5628 151 50 28.1112\n\t * DMS -26 -34 -37.1640 151 50 24.1620\n\t *\n\t * Where the first line is min, max altitude in meters AMSL.\n\t */\n\tint loadFromFile(const char *filename);\n\n\tbool isEmpty() { return (!_fence_updated || (_num_polygons == 0)); }\n\n\tint getSource() { return _param_gf_source.get(); }\n\tint getGeofenceAction() { return _param_gf_action.get(); }\n\n\tfloat getMaxHorDistanceHome() { return _param_gf_max_hor_dist.get(); }\n\tbool getPredict() { return _param_gf_predict.get(); }\n\n\tbool isHomeRequired();\n\n\t/**\n\t * print Geofence status to the console\n\t */\n\tvoid printStatus();\n\nprivate:\n\n\tenum class DatamanState {\n\t\tUpdateRequestWait,\n\t\tRead,\n\t\tReadWait,\n\t\tLoad,\n\t\tError\n\t};\n\n\tstruct PolygonInfo {\n\t\tuint16_t fence_type; ///< one of MAV_CMD_NAV_FENCE_* (can also be a circular region)\n\t\tuint16_t dataman_index;\n\t\tunion {\n\t\t\tuint16_t vertex_count;\n\t\t\tfloat circle_radius;\n\t\t};\n\t};\n\n\tNavigator   *_navigator{nullptr};\n\tPolygonInfo *_polygons{nullptr};\n\n\tmission_stats_entry_s _stats;\n\tDatamanState _dataman_state{DatamanState::UpdateRequestWait};\n\tDatamanState _error_state{DatamanState::UpdateRequestWait};\n\tDatamanCache _dataman_cache{\"geofence_dm_cache_miss\", 4};\n\tDatamanClient\t&_dataman_client = _dataman_cache.client();\n\n\tfloat _altitude_min{0.0f};\n\tfloat _altitude_max{0.0f};\n\n\tint _num_polygons{0};\n\n\tMapProjection _projection_reference{}; ///< class to convert (lon, lat) to local [m]\n\n\n\tuint16_t _update_counter{0}; ///< dataman update counter: if it does not match, polygon data was updated\n\tbool _fence_updated{true};  ///< flag indicating if fence are updated to dataman cache\n\tbool _initiate_fence_updated{true}; ///< flag indicating if fence updated is needed\n\n\t/**\n\t * implementation of updateFence()\n\t */\n\tvoid _updateFence();\n\n\n\t/**\n\t * Check if a single point is within a polygon\n\t * @return true if within polygon\n\t */\n\tbool insidePolygon(const PolygonInfo &polygon, double lat, double lon, float altitude);\n\n\t/**\n\t * Check if a single point is within a circle\n\t * @param polygon must be a circle!\n\t * @return true if within polygon the circle\n\t */\n\tbool insideCircle(const PolygonInfo &polygon, double lat, double lon, float altitude);\n\n\t/**\n\t * Check if a single point is within a polygon or circle\n\t * @return true if within polygon or circle\n\t */\n\n\tbool checkPointAgainstPolygonCircle(const PolygonInfo &polygon, double lat, double lon, float altitude);\n\n\t/**\n\t * Check polygon or circle geofence fullfills the requirements relative to Home.\n\t * @return true if checks pass\n\t */\n\tbool checkHomeRequirementsForGeofence(const PolygonInfo &polygon);\n\n\t/**\n\t * Check polygon or circle geofence fullfills the requirements relative to the current vehicle position.\n\t * @return true if checks pass\n\t */\n\tbool checkCurrentPositionRequirementsForGeofence(const PolygonInfo &polygon);\n\n\tDEFINE_PARAMETERS(\n\t\t(ParamInt<px4::params::GF_ACTION>)         _param_gf_action,\n\t\t(ParamInt<px4::params::GF_SOURCE>)         _param_gf_source,\n\t\t(ParamFloat<px4::params::GF_MAX_HOR_DIST>) _param_gf_max_hor_dist,\n\t\t(ParamFloat<px4::params::GF_MAX_VER_DIST>) _param_gf_max_ver_dist,\n\t\t(ParamBool<px4::params::GF_PREDICT>)       _param_gf_predict\n\t)\n}"
    },
    "matrix::Vector2d": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n\n\t\t\t\tif (_mission.get_land_start_available()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t\tresult = vehicle_command_ack_s::VEHICLE_CMD_RESULT_CANCELLED;\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, result);\n\n\t\t\t}"
    },
    "GeofenceBreachAvoidance::setHomePosition": {
      "file": "src/modules/navigator/GeofenceBreachAvoidance/geofence_breach_avoidance.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "void GeofenceBreachAvoidance::setHomePosition(double lat, double lon, float alt)\n{\n\t_home_lat_lon(0) = lat;\n\t_home_lat_lon(1) = lon;\n}"
    },
    "Navigator::geofence_breach_check": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "void Navigator::geofence_breach_check(bool &have_geofence_position_data)\n{\n\t// reset the _time_loitering_after_gf_breach time if no longer in LOITER (and 100ms after it was triggered)\n\tif (_vstatus.nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER\n\t    && hrt_elapsed_time(&_time_loitering_after_gf_breach) > 100_ms) {\n\t\t_time_loitering_after_gf_breach = 0;\n\t}\n\n\tif (have_geofence_position_data &&\n\t    (_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t    (hrt_elapsed_time(&_last_geofence_check) > GEOFENCE_CHECK_INTERVAL_US)) {\n\n\t\tconst position_controller_status_s &pos_ctrl_status = _position_controller_status_sub.get();\n\n\t\tgeofence_violation_type_u gf_violation_type{};\n\t\tfloat test_point_bearing;\n\t\tfloat test_point_distance;\n\t\tfloat vertical_test_point_distance;\n\n\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\ttest_point_bearing = atan2f(_local_pos.vy, _local_pos.vx);\n\t\t\tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n\t\t\t_gf_breach_avoidance.setHorizontalVelocity(velocity_hor_abs);\n\t\t\t_gf_breach_avoidance.setClimbRate(-_local_pos.vz);\n\t\t\ttest_point_distance = _gf_breach_avoidance.computeBrakingDistanceMultirotor();\n\t\t\tvertical_test_point_distance = _gf_breach_avoidance.computeVerticalBrakingDistanceMultirotor();\n\n\t\t} else {\n\t\t\ttest_point_distance = 2.0f * get_loiter_radius();\n\t\t\tvertical_test_point_distance = 5.0f;\n\n\t\t\tif (hrt_absolute_time() - pos_ctrl_status.timestamp < 100000 && PX4_ISFINITE(pos_ctrl_status.nav_bearing)) {\n\t\t\t\ttest_point_bearing = pos_ctrl_status.nav_bearing;\n\n\t\t\t} else {\n\t\t\t\ttest_point_bearing = atan2f(_local_pos.vy, _local_pos.vx);\n\t\t\t}\n\t\t}\n\n\t\tdouble current_latitude = _global_pos.lat;\n\t\tdouble current_longitude = _global_pos.lon;\n\t\tfloat current_altitude = _global_pos.alt;\n\t\tbool position_valid = _global_pos.timestamp > 0;\n\n\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\tcurrent_latitude = _gps_pos.latitude_deg;\n\t\t\tcurrent_longitude = _gps_pos.longitude_deg;\n\t\t\tcurrent_altitude = _gps_pos.altitude_msl_m;\n\t\t\tposition_valid = _global_pos.timestamp > 0;\n\t\t}\n\n\t\t_gf_breach_avoidance.setHorizontalTestPointDistance(test_point_distance);\n\t\t_gf_breach_avoidance.setVerticalTestPointDistance(vertical_test_point_distance);\n\t\t_gf_breach_avoidance.setTestPointBearing(test_point_bearing);\n\t\t_gf_breach_avoidance.setCurrentPosition(current_latitude, current_longitude, current_altitude);\n\t\t_gf_breach_avoidance.setMaxHorDistHome(_geofence.getMaxHorDistanceHome());\n\n\t\tif (home_global_position_valid()) {\n\t\t\t_gf_breach_avoidance.setHomePosition(_home_pos.lat, _home_pos.lon, _home_pos.alt);\n\t\t}\n\n\t\tdouble test_point_latitude = current_latitude;\n\t\tdouble test_point_longitude = current_longitude;\n\t\tfloat test_point_altitude = current_altitude;\n\n\t\tif (_geofence.getPredict()) {\n\t\t\tmatrix::Vector2<double>fence_violation_test_point = _gf_breach_avoidance.getFenceViolationTestPoint();\n\t\t\ttest_point_latitude = fence_violation_test_point(0);\n\t\t\ttest_point_longitude = fence_violation_test_point(1);\n\t\t\ttest_point_altitude = current_altitude + vertical_test_point_distance;\n\t\t}\n\n\t\tif (_time_loitering_after_gf_breach > 0) {\n\t\t\t// if we are in the loitering state after breaching a GF, only allow new ones to be set, but not unset\n\t\t\t_geofence_result.geofence_max_dist_triggered |= !_geofence.isCloserThanMaxDistToHome(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\t\t\t_geofence_result.geofence_max_alt_triggered |= !_geofence.isBelowMaxAltitude(test_point_altitude);\n\t\t\t_geofence_result.geofence_custom_fence_triggered |= !_geofence.isInsidePolygonOrCircle(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\n\t\t} else {\n\t\t\t_geofence_result.geofence_max_dist_triggered = !_geofence.isCloserThanMaxDistToHome(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\t\t\t_geofence_result.geofence_max_alt_triggered = !_geofence.isBelowMaxAltitude(test_point_altitude);\n\t\t\t_geofence_result.geofence_custom_fence_triggered = !_geofence.isInsidePolygonOrCircle(test_point_latitude,\n\t\t\t\t\ttest_point_longitude, test_point_altitude);\n\t\t}\n\n\t\t_last_geofence_check = hrt_absolute_time();\n\t\thave_geofence_position_data = false;\n\n\t\t_geofence_result.timestamp = hrt_absolute_time();\n\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\n\t\tif (_geofence_result.geofence_max_dist_triggered || _geofence_result.geofence_max_alt_triggered ||\n\t\t    _geofence_result.geofence_custom_fence_triggered) {\n\n\t\t\t/* Issue a warning about the geofence violation once and only if we are armed */\n\t\t\tif (!_geofence_reposition_sent && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED\n\t\t\t    && _geofence.getGeofenceAction() == geofence_result_s::GF_ACTION_LOITER) {\n\n\t\t\t\t// we have predicted a geofence violation and if the action is to loiter then\n\t\t\t\t// demand a reposition to a location which is inside the geofence\n\n\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\n\t\t\t\tmatrix::Vector2<double> loiter_center_lat_lon;\n\n\t\t\t\tfloat loiter_altitude_amsl = current_altitude;\n\t\t\t\tdouble loiter_latitude = current_latitude;\n\t\t\t\tdouble loiter_longitude = current_longitude;\n\n\t\t\t\tif (_geofence.getPredict()) {\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\t\t\t\t// the computation of the braking distance does not match the actual braking distance. Until we have a better model\n\t\t\t\t\t\t// we set the loiter point to the current position, that will make sure that the vehicle will loiter inside the fence\n\t\t\t\t\t\tloiter_center_lat_lon =  _gf_breach_avoidance.generateLoiterPointForMultirotor(gf_violation_type,\n\t\t\t\t\t\t\t\t\t &_geofence);\n\t\t\t\t\t\tloiter_latitude = loiter_center_lat_lon(0);\n\t\t\t\t\t\tloiter_longitude = loiter_center_lat_lon(1);\n\n\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForMulticopter(gf_violation_type);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tloiter_center_lat_lon = _gf_breach_avoidance.generateLoiterPointForFixedWing(gf_violation_type, &_geofence);\n\t\t\t\t\t\tloiter_latitude = loiter_center_lat_lon(0);\n\t\t\t\t\t\tloiter_longitude = loiter_center_lat_lon(1);\n\n\t\t\t\t\t\tloiter_altitude_amsl = _gf_breach_avoidance.generateLoiterAltitudeForFixedWing(gf_violation_type);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\trep->current.lat = loiter_latitude;\n\t\t\t\trep->current.lon = loiter_longitude;\n\t\t\t\trep->current.alt = loiter_altitude_amsl;\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t_geofence_reposition_sent = true;\n\t\t\t\t_time_loitering_after_gf_breach = hrt_absolute_time();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_geofence_reposition_sent = false;\n\t\t}\n\n\t\t_geofence_result_pub.publish(_geofence_result);\n\t}\n}"
    },
    "isCloserThanMaxDistToHome": {
      "file": "src/modules/navigator/geofence.h",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "*/\n\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n\n\n\t/**\n\t * @brief check if the altitude above Home is greater than the maximum allowed altitude\n\t *\n\t * @return true if the altitude above Home is smaller than the maximum allowed altitude\n\t */\n\tbool isBelowMaxAltitude(float altitude);\n\n\tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n\n\tint clearDm();\n\n\tbool valid();\n\n\t/**\n\t * Load a single inclusion polygon, replacing any already existing polygons.\n\t * The file has one of the following formats:\n\t * - Decimal Degrees:\n\t * 0 900\n\t * 47.475273548913222 8.52672100067138672\n\t * 47.4608261578541359 8.53414535522460938\n\t * 47.4613484218861217 8.56444358825683594\n\t * 47.4830758091035534 8.53470325469970703\n\t *\n\t * - Degree-Minute-Second:\n\t * 0 900\n\t * DMS -26 -34 -10.4304 151 50 14.5428\n\t * DMS -26 -34 -11.8416 151 50 21.8580\n\t * DMS -26 -34 -36.5628 151 50 28.1112\n\t * DMS -26 -34 -37.1640 151 50 24.1620\n\t *\n\t * Where the first line is min, max altitude in meters AMSL.\n\t */\n\tint loadFromFile(const char *filename);\n\n\tbool isEmpty() { return (!_fence_updated || (_num_polygons == 0)); }"
    },
    "checkPolygons": {
      "file": "src/modules/navigator/geofence.h",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "* Checks max distance, max altitude, inside polygon or circle.\n\t * In addition to checkPolygons(), this takes all additional parameters into account.\n\t *\n\t * @return false for a geofence violation\n\t */\n\tbool checkPointAgainstAllGeofences(double lat, double lon, float altitude);\n\n\t/**\n\t * @brief check if the horizontal distance to Home is greater than the maximum allowed distance\n\t *\n\t * @return true if the horizontal distance to Home is smaller than the maximum allowed distance\n\t */\n\tbool isCloserThanMaxDistToHome(double lat, double lon, float altitude);\n\n\n\t/**\n\t * @brief check if the altitude above Home is greater than the maximum allowed altitude\n\t *\n\t * @return true if the altitude above Home is smaller than the maximum allowed altitude\n\t */\n\tbool isBelowMaxAltitude(float altitude);\n\n\tvirtual bool isInsidePolygonOrCircle(double lat, double lon, float altitude);\n\n\tint clearDm();\n\n\tbool valid();\n\n\t/**\n\t * Load a single inclusion polygon, replacing any already existing polygons.\n\t * The file has one of the following formats:\n\t * - Decimal Degrees:\n\t * 0 900\n\t * 47.475273548913222 8.52672100067138672\n\t * 47.4608261578541359 8.53414535522460938\n\t * 47.4613484218861217 8.56444358825683594\n\t * 47.4830758091035534 8.53470325469970703\n\t *\n\t * - Degree-Minute-Second:\n\t * 0 900\n\t * DMS -26 -34 -10.4304 151 50 14.5428\n\t * DMS -26 -34 -11.8416 151 50 21.8580\n\t * DMS -26 -34 -36.5628 151 50 28.1112\n\t * DMS -26 -34 -37.1640 151 50 24.1620\n\t *\n\t * Where the first line is min, max altitude in meters AMSL.\n\t */\n\tint loadFromFile(const char *filename);\n\n\tbool isEmpty() { return (!_fence_updated || (_num_polygons == 0)); }"
    },
    "Geofence::isInsidePolygonOrCircle": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "bool Geofence::isInsidePolygonOrCircle(double lat, double lon, float altitude)\n{\n\tif (isEmpty()) {\n\t\t/* Empty fence -> accept all points */\n\t\treturn true;\n\t}\n\n\t/* Vertical check */\n\tif (_altitude_max > _altitude_min) { // only enable vertical check if configured properly\n\t\tif (altitude > _altitude_max || altitude < _altitude_min) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Horizontal check: iterate all polygons & circles */\n\tbool checksPass = true;\n\n\tfor (int polygon_index = 0; polygon_index < _num_polygons; ++polygon_index) {\n\t\tchecksPass &= checkPointAgainstPolygonCircle(_polygons[polygon_index], lat, lon, altitude);\n\t}\n\n\treturn checksPass;\n}"
    },
    "Navigator::run": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "void Navigator::run()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\tuint16_t geofence_update_counter{0};\n\tuint16_t safe_points_update_counter{0};\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\n\t\t\tif (mission.geofence_update_counter != geofence_update_counter) {\n\t\t\t\tgeofence_update_counter = mission.geofence_update_counter;\n\t\t\t\t_geofence.updateFence();\n\t\t\t}\n\n\t\t\tif (mission.safe_points_update_counter != safe_points_update_counter) {\n\t\t\t\tsafe_points_update_counter = mission.safe_points_update_counter;\n\t\t\t\t_rtl.updateSafePoints();\n\t\t\t}\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_vehicle_command_sub.updated() && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\tbool reposition_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\treposition_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (reposition_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t\trep->current.yaw_valid = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\t\trep->current.yaw_valid = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = curr->current.loiter_minor_radius;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = NAN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_orientation) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_orientation = curr->current.loiter_orientation;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr->current.loiter_pattern > 0) {\n\t\t\t\t\t\t\trep->current.loiter_pattern = curr->current.loiter_pattern;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tbool change_altitude_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\tchange_altitude_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (change_altitude_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\trep->current.yaw_valid = false;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon, rep->current.yaw);\n\t\t\t\t\t\trep->current.yaw_valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_FIGUREEIGHT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n#ifdef CONFIG_FIGURE_OF_EIGHT\n\t\t\t\t// Only valid for fixed wing mode\n\n\t\t\t\tbool orbit_location_valid = true;\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (have_geofence_position_data) {\n\t\t\t\t\torbit_location_valid = geofence_allows_position(position_setpoint);\n\t\t\t\t}\n\n\t\t\t\tif (orbit_location_valid) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param2) && fabsf(cmd.param2) > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_minor_radius = fabsf(cmd.param2);\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = 2.5f * rep->current.loiter_minor_radius;\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.loiter_orientation = cmd.param4;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n\t\t\t\t}\n\n#endif // CONFIG_FIGURE_OF_EIGHT\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\t\t\t\t\t// Only set yaw if we know the true heading\n\t\t\t\t\t// We assume that the heading is valid when the global position is valid because true heading\n\t\t\t\t\t// is required to fuse NE (e.g.: GNSS) data. // TODO: we should be more explicit here\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n\n\t\t\t\tif (_mission.get_land_start_available()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t\tresult = vehicle_command_ack_s::VEHICLE_CMD_RESULT_CANCELLED;\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, result);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\treset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check(have_geofence_position_data);\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\n\t\t\t// If we are already in mission landing, do not switch.\n\t\t\tif (_navigation_mode == &_mission && _mission.isLanding()) {\n\t\t\t\tnavigation_mode_new = &_mission;\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t}\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t// If we are in VTOL takeoff, do not switch until it is finished.\n\t\t\tif (_navigation_mode == &_vtol_takeoff && !get_mission_result()->finished) {\n\t\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\n\t\t\t} else\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\t\t\t{\n\t\t\t\tnavigation_mode_new = &_rtl;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\n\n\t\t\t// transition to hover in Descend mode\n\t\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t\t    force_vtol()) {\n\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\\t\");\n\t\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t\t}\n\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\t_geofence.run();\n\n\t\tperf_end(_loop_perf);\n\t}\n}"
    },
    "Navigator::params_update": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "void Navigator::params_update()\n{\n\tupdateParams();\n\n\tif (_handle_back_trans_dec_mss != PARAM_INVALID) {\n\t\tparam_get(_handle_back_trans_dec_mss, &_param_back_trans_dec_mss);\n\t}\n\n\tif (_handle_mpc_jerk_auto != PARAM_INVALID) {\n\t\tparam_get(_handle_mpc_jerk_auto, &_param_mpc_jerk_auto);\n\t}\n\n\tif (_handle_mpc_acc_hor != PARAM_INVALID) {\n\t\tparam_get(_handle_mpc_acc_hor, &_param_mpc_acc_hor);\n\t}\n\n\t_mission.set_payload_deployment_timeout(_param_mis_payload_delivery_timeout.get());\n}"
    },
    "Geofence::printStatus": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "void Geofence::printStatus()\n{\n\tint num_inclusion_polygons = 0, num_exclusion_polygons = 0, total_num_vertices = 0;\n\tint num_inclusion_circles = 0, num_exclusion_circles = 0;\n\n\tfor (int i = 0; i < _num_polygons; ++i) {\n\t\ttotal_num_vertices += _polygons[i].vertex_count;\n\n\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION) {\n\t\t\t++num_inclusion_polygons;\n\t\t}\n\n\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION) {\n\t\t\t++num_exclusion_polygons;\n\t\t}\n\n\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_CIRCLE_INCLUSION) {\n\t\t\t++num_inclusion_circles;\n\t\t}\n\n\t\tif (_polygons[i].fence_type == NAV_CMD_FENCE_CIRCLE_EXCLUSION) {\n\t\t\t++num_exclusion_circles;\n\t\t}\n\t}\n\n\tPX4_INFO(\"Geofence: %i inclusion, %i exclusion polygons, %i inclusion circles, %i exclusion circles, %i total vertices\",\n\t\t num_inclusion_polygons, num_exclusion_polygons, num_inclusion_circles, num_exclusion_circles,\n\t\t total_num_vertices);\n}"
    },
    "Geofence::_updateFence": {
      "file": "src/modules/navigator/geofence.cpp",
      "commit": "66ca5c294952689e0775c5136ad0d7f6604a2d17",
      "source": "void Geofence::_updateFence()\n{\n\tmission_fence_point_s mission_fence_point;\n\tbool is_circle_area = false;\n\n\t// iterate over all polygons and store their starting vertices\n\t_num_polygons = 0;\n\tint current_seq = 1;\n\n\twhile (current_seq <= _dataman_cache.size()) {\n\n\t\tbool success = _dataman_cache.loadWait(DM_KEY_FENCE_POINTS, current_seq,\n\t\t\t\t\t\t       reinterpret_cast<uint8_t *>(&mission_fence_point),\n\t\t\t\t\t\t       sizeof(mission_fence_point_s));\n\n\t\tif (!success) {\n\t\t\tPX4_ERR(\"loadWait failed, seq: %i\", current_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mission_fence_point.nav_cmd) {\n\t\tcase NAV_CMD_FENCE_RETURN_POINT:\n\t\t\t// TODO: do we need to store this?\n\t\t\t++current_seq;\n\t\t\tbreak;\n\n\t\tcase NAV_CMD_FENCE_CIRCLE_INCLUSION:\n\t\tcase NAV_CMD_FENCE_CIRCLE_EXCLUSION:\n\t\t\tis_circle_area = true;\n\n\t\t/* FALLTHROUGH */\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_EXCLUSION:\n\t\tcase NAV_CMD_FENCE_POLYGON_VERTEX_INCLUSION:\n\t\t\tif (!is_circle_area && mission_fence_point.vertex_count == 0) {\n\t\t\t\t++current_seq; // avoid endless loop\n\t\t\t\tPX4_ERR(\"Polygon with 0 vertices. Skipping\");\n\n\t\t\t} else {\n\t\t\t\tif (_polygons) {\n\t\t\t\t\t// resize: this is somewhat inefficient, but we do not expect there to be many polygons\n\t\t\t\t\tPolygonInfo *new_polygons = new PolygonInfo[_num_polygons + 1];\n\n\t\t\t\t\tif (new_polygons) {\n\t\t\t\t\t\tmemcpy(new_polygons, _polygons, sizeof(PolygonInfo) * _num_polygons);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete[](_polygons);\n\t\t\t\t\t_polygons = new_polygons;\n\n\t\t\t\t} else {\n\t\t\t\t\t_polygons = new PolygonInfo[1];\n\t\t\t\t}\n\n\t\t\t\tif (!_polygons) {\n\t\t\t\t\t_num_polygons = 0;\n\t\t\t\t\tPX4_ERR(\"alloc failed\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPolygonInfo &polygon = _polygons[_num_polygons];\n\t\t\t\tpolygon.dataman_index = current_seq;\n\t\t\t\tpolygon.fence_type = mission_fence_point.nav_cmd;\n\n\t\t\t\tif (is_circle_area) {\n\t\t\t\t\tpolygon.circle_radius = mission_fence_point.circle_radius;\n\t\t\t\t\tcurrent_seq += 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tpolygon.vertex_count = mission_fence_point.vertex_count;\n\t\t\t\t\tcurrent_seq += mission_fence_point.vertex_count;\n\t\t\t\t}\n\n\t\t\t\t// check if requiremetns for Home location are met\n\t\t\t\tconst bool home_check_okay = checkHomeRequirementsForGeofence(polygon);\n\n\t\t\t\t// check if current position is inside the fence and vehicle is armed\n\t\t\t\tconst bool current_position_check_okay = checkCurrentPositionRequirementsForGeofence(polygon);\n\n\t\t\t\t// discard the polygon if at least one check fails by not incrementing the counter in that case\n\t\t\t\tif (home_check_okay && current_position_check_okay) {\n\t\t\t\t\t++_num_polygons;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPX4_ERR(\"unhandled Fence command: %i\", (int)mission_fence_point.nav_cmd);\n\t\t\t++current_seq;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "3861": {
    "Navigator::task_main": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "1a55feba17030e8b4d08525c17ea596b7d3d37f5",
      "source": "Navigator::task_main()\n{\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file\n\t * else clear geofence data in datamanager */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\twarnx(\"Try to load geofence.txt\");\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\n\t} else {\n\t\tif (_geofence.clearDm() != OK) {\n\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"failed clearing geofence\");\n\t\t}\n\t}\n\n\t/* do subscriptions */\n\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n\t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n\t_fw_pos_ctrl_status_sub = orb_subscribe(ORB_ID(fw_pos_ctrl_status));\n\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n\t_land_detected_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n\t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n\t_onboard_mission_sub = orb_subscribe(ORB_ID(onboard_mission));\n\t_offboard_mission_sub = orb_subscribe(ORB_ID(offboard_mission));\n\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n\n\t/* copy all topics first time */\n\tvehicle_status_update();\n\tvehicle_land_detected_update();\n\tvehicle_control_mode_update();\n\tglobal_position_update();\n\tgps_position_update();\n\tsensor_combined_update();\n\thome_position_update(true);\n\tfw_pos_ctrl_status_update();\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[2] = {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _global_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_command_sub;\n\tfds[1].events = POLLIN;\n\n\tbool global_pos_available_once = false;\n\n\twhile (!_task_should_exit) {\n\n\t\t/* wait for up to 200ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n\t\t\tif (global_pos_available_once) {\n\t\t\t\tPX4_WARN(\"no GPS - navigator timed out\");\n\t\t\t\tglobal_pos_available_once = false;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal_pos_available_once = true;\n\n\t\tperf_begin(_loop_perf);\n\n\t\tbool updated;\n\n\t\t/* gps updated */\n\t\torb_check(_gps_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\tgps_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* sensors combined updated */\n\t\torb_check(_sensor_combined_sub, &updated);\n\t\tif (updated) {\n\t\t\tsensor_combined_update();\n\t\t}\n\n\t\t/* parameters updated */\n\t\torb_check(_param_update_sub, &updated);\n\t\tif (updated) {\n\t\t\tparams_update();\n\t\t\tupdateParams();\n\t\t}\n\n\t\t/* vehicle control mode updated */\n\t\torb_check(_control_mode_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_control_mode_update();\n\t\t}\n\n\t\t/* vehicle status updated */\n\t\torb_check(_vstatus_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_status_update();\n\t\t}\n\n\t\t/* vehicle land detected updated */\n\t\torb_check(_land_detected_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_land_detected_update();\n\t\t}\n\n\t\t/* navigation capabilities updated */\n\t\torb_check(_fw_pos_ctrl_status_sub, &updated);\n\t\tif (updated) {\n\t\t\tfw_pos_ctrl_status_update();\n\t\t}\n\n\t\t/* home position updated */\n\t\torb_check(_home_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\thome_position_update();\n\t\t}\n\n\t\torb_check(_vehicle_command_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_command_s cmd;\n\t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n\n\t\t\t\tstruct position_setpoint_triplet_s *rep = get_reposition_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_global_position()->yaw;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction = 1;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\t} else {\n\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5 / (double)1e7;\n\t\t\t\t\trep->current.lon = cmd.param6 / (double)1e7;\n\t\t\t\t} else {\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t} else {\n\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t}\n\n\t\t\t\trep->previous.valid = true;\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->next.valid = false;\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tstruct position_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_global_position()->yaw;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction = 1;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.yaw = cmd.param4;\n\t\t\t\trep->current.lat = cmd.param5 / (double)1e7;\n\t\t\t\trep->current.lon = cmd.param6 / (double)1e7;\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->previous.valid = true;\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->next.valid = false;\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n\t\t\t\twarnx(\"navigator: got pause/continue command\");\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (fds[0].revents & POLLIN) {\n\t\t\tglobal_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Check geofence violation */\n\t\tstatic hrt_abstime last_geofence_check = 0;\n\t\tif (have_geofence_position_data &&\n\t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n\t\t\tlast_geofence_check = hrt_absolute_time();\n\t\t\thave_geofence_position_data = false;\n\n\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\t\t\tif (!inside) {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = true;\n\t\t\t\tpublish_geofence_result();\n\n\t\t\t\t/* Issue a warning about the geofence violation once */\n\t\t\t\tif (!_geofence_violation_warning_sent) {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Geofence violation\");\n\t\t\t\t\t_geofence_violation_warning_sent = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = false;\n\t\t\t\tpublish_geofence_result();\n\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n\t\t\t\t_geofence_violation_warning_sent = false;\n\t\t\t}\n\t\t}\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tswitch (_vstatus.nav_state) {\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AIRSPD:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t\tif (_fw_pos_ctrl_status.abort_landing) {\n\t\t\t\t\t// pos controller aborted landing, requests loiter\n\t\t\t\t\t// above landing waypoint\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t} else {\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t\t_navigation_mode = &_mission;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_rcloss_act.get() == 1) {\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t} else if (_param_rcloss_act.get() == 3) {\n\t\t\t\t\t_navigation_mode = &_land;\n\t\t\t\t} else if (_param_rcloss_act.get() == 4) {\n\t\t\t\t\t_navigation_mode = &_rcLoss;\n\t\t\t\t} else { /* if == 2 or unknown, RTL */\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_takeoff;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n\t\t\t\t/* Use complex data link loss mode only when enabled via param\n\t\t\t\t* otherwise use rtl */\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_datalinkloss_act.get() == 1) {\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t} else if (_param_datalinkloss_act.get() == 3) {\n\t\t\t\t\t_navigation_mode = &_land;\n\t\t\t\t} else if (_param_datalinkloss_act.get() == 4) {\n\t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n\t\t\t\t} else { /* if == 2 or unknown, RTL */\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_engineFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_gpsFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_follow_target;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\t_pos_sp_triplet.previous.valid = false;\n\t\t\t_pos_sp_triplet.current.valid = false;\n\t\t\t_pos_sp_triplet.next.valid = false;\n\t\t\t_pos_sp_triplet_updated = true;\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t\t_pos_sp_triplet_updated = false;\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t\t_mission_result_updated = false;\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n\twarnx(\"exiting.\");\n\n\t_navigator_task = -1;\n\treturn;\n}"
    }
  },
  "3880": {
    "Loiter::Loiter": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "3af73e4022a3b9c8e3ccf0df0b6be0afc7b52c3e",
      "source": "Loiter::Loiter(Navigator *navigator, const char *name) :\n\tMissionBlock(navigator, name),\n\t_param_min_alt(this, \"MIS_TAKEOFF_ALT\", false)\n{\n\t/* load initial params */\n\tupdateParams();\n}"
    }
  },
  "4055": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\t/* set the correct setpoint for vtol transition */\n\tif(item->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION) {\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t}\n\n\t/* don't change the setpoint for non-position items */\n\tif (!item_contains_position(item)) {\n\t\treturn;\n\t}\n\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\tsp->disable_mc_yaw_control = false;\n\tsp->cruising_speed = _navigator->get_cruising_speed();\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\tcase NAV_CMD_VTOL_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_loiter.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "copy_positon_if_valid": {
      "file": "src/modules/navigator/mission.h",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "*/\n\tvoid copy_positon_if_valid(struct mission_item_s *mission_item, struct position_setpoint_s *setpoint);\n\n\t/**\n\t * Create mission item to align towards next waypoint\n\t */\n\tvoid set_align_mission_item(struct mission_item_s *mission_item, struct mission_item_s *mission_item_next);\n\n\t/**\n\t * Calculate takeoff height for mission item considering ground clearance\n\t */\n\tfloat calculate_takeoff_altitude(struct mission_item_s *mission_item);\n\n\t/**\n\t * Updates the heading of the vehicle. Rotary wings only.\n\t */\n\tvoid heading_sp_update();\n\n\t/**\n\t * Updates the altitude sp to follow a foh\n\t */\n\tvoid altitude_sp_foh_update();\n\n\t/**\n\t * Resets the altitude sp foh logic\n\t */\n\tvoid altitude_sp_foh_reset();\n\n\tfloat get_absolute_altitude_for_item(struct mission_item_s &mission_item);\n\n\t/**\n\t * Read the current and the next mission item. The next mission item read is the\n\t * next mission item that contains a position.\n\t *\n\t * @return true if current mission item available\n\t */\n\tbool prepare_mission_items(bool onboard, struct mission_item_s *mission_item,\n\t\tstruct mission_item_s *next_position_mission_item, bool *has_next_position_item);\n\n\t/**\n\t * Read current (offset == 0) or a specific (offset > 0) mission item\n\t * from the dataman and watch out for DO_JUMPS\n\t *\n\t * @return true if successful\n\t */\n\tbool read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item);\n\n\t/**\n\t * Save current offboard mission state to dataman\n\t */\n\tvoid save_offboard_mission_state();\n\n\t/**\n\t * Inform about a changed mission item after a DO_JUMP\n\t */\n\tvoid report_do_jump_mission_changed(int index, int do_jumps_remaining);\n\n\t/**\n\t * Set a mission item as reached\n\t */\n\tvoid set_mission_item_reached();\n\n\t/**\n\t * Set the current offboard mission item\n\t */\n\tvoid set_current_offboard_mission_item();\n\n\t/**\n\t * Set that the mission is finished if one exists or that none exists\n\t */\n\tvoid set_mission_finished();\n\n\t/**\n\t * Check wether a mission is ready to go\n\t */\n\tbool check_mission_valid();\n\n\t/**\n\t * Reset offboard mission\n\t */\n\tvoid reset_offboard_mission(struct mission_s &mission);\n\n\t/**\n\t * Returns true if we need to reset the mission\n\t */\n\tbool need_to_reset_mission(bool active);\n\n\tcontrol::BlockParamInt _param_onboard_enabled;\n\tcontrol::BlockParamFloat _param_takeoff_alt;\n\tcontrol::BlockParamFloat _param_dist_1wp;\n\tcontrol::BlockParamInt _param_altmode;\n\tcontrol::BlockParamInt _param_yawmode;\n\tcontrol::BlockParamInt _param_force_vtol;\n\n\tstruct mission_s _onboard_mission;\n\tstruct mission_s _offboard_mission;\n\n\tint _current_onboard_mission_index;\n\tint _current_offboard_mission_index;\n\tbool _need_takeoff;\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n\n\tenum {\n\t\tMISSION_TYPE_NONE,\n\t\tMISSION_TYPE_ONBOARD,\n\t\tMISSION_TYPE_OFFBOARD\n\t}"
    },
    "Mission::reset_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::reset_offboard_mission(struct mission_s &mission)\n{\n\tdm_lock(DM_KEY_MISSION_STATE);\n\n\tif (dm_read(DM_KEY_MISSION_STATE, 0, &mission, sizeof(mission_s)) == sizeof(mission_s)) {\n\t\tif (mission.dataman_id >= 0 && mission.dataman_id <= 1) {\n\t\t\t/* set current item to 0 */\n\t\t\tmission.current_seq = 0;\n\n\t\t\t/* reset jump counters */\n\t\t\tif (mission.count > 0) {\n\t\t\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(mission.dataman_id);\n\n\t\t\t\tfor (int index = 0; index < mission.count; index++) {\n\t\t\t\t\tstruct mission_item_s item;\n\t\t\t\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t\t\t\tif (dm_read(dm_current, index, &item, len) != len) {\n\t\t\t\t\t\tPX4_WARN(\"could not read mission item during reset\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.nav_cmd == NAV_CMD_DO_JUMP) {\n\t\t\t\t\t\titem.do_jump_current_count = 0;\n\n\t\t\t\t\t\tif (dm_write(dm_current, index, DM_PERSIST_POWER_ON_RESET,\n\t\t\t\t\t\t\t     &item, len) != len) {\n\t\t\t\t\t\t\tPX4_WARN(\"could not save mission item during reset\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_log_pub(), \"ERROR: could not read mission\");\n\n\t\t\t/* initialize mission state in dataman */\n\t\t\tmission.dataman_id = 0;\n\t\t\tmission.count = 0;\n\t\t\tmission.current_seq = 0;\n\t\t}\n\n\t\tdm_write(DM_KEY_MISSION_STATE, 0, DM_PERSIST_POWER_ON_RESET, &mission, sizeof(mission_s));\n\t}\n\n\tdm_unlock(DM_KEY_MISSION_STATE);\n}"
    },
    "Mission::do_need_takeoff": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::do_need_takeoff()\n{\n\tif (_navigator->get_vstatus()->is_rotary_wing) {\n\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t/* force takeoff if landed (additional protection) */\n\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t_need_takeoff = true;\n\n\t\t/* if in-air and already above takeoff height, don't do takeoff */\n\t\t} else if (_navigator->get_global_position()->alt > takeoff_alt) {\n\t\t\t_need_takeoff = false;\n\t\t}\n\n\t\t/* check if current mission item is one that requires takeoff before */\n\t\tif (_need_takeoff && (\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n\n\t\t\t_need_takeoff = false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tbool has_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* copy information about the previous mission item */\n\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n\t\t/* Copy previous mission item altitude */\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle position mission items */\n\n\n\tif (item_contains_position(&_mission_item)) {\n\n\t\t/* force vtol land */\n\t\tif(_mission_item.nav_cmd == NAV_CMD_LAND && _param_force_vtol.get()\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing){\n\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n\t\t}\n\n\t\t/* we have a new position item so set previous position setpoint to current */\n\t\tset_previous_pos_setpoint();\n\n\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\thas_next_position_item = true;\n\n\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t/* ignore yaw for takeoff items */\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n\n\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t\t&& has_next_position_item) {\n\t\t\t\t/* check if the vtol_takeoff command is on top of us */\n\t\t\t\tif(do_need_move_to_takeoff()){\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF;\n\t\t\t\t} else {\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t}\n\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\t_mission_item.params[0] = vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t} else {\n\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t}\n\n\t\t}\n\n\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t}\n\n\t\t/* move to land wp as fixed wing */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* transition to MC */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t_mission_item.params[0] = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n\t\t}\n\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif (do_need_move_to_land() &&\n\t\t\t\t(_work_item_type == WORK_ITEM_TYPE_DEFAULT ||\n\t\t\t\t _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION)) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\n\t\t\t/*\n\t\t\t * Ignoring waypoint altitude:\n\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t * what the altitude means on this waypoint type.\n\t\t\t */\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* we just moved to the landing waypoint, now descend */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\n\n\t\t/* ignore yaw for landing items */\n\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t * that aligns the vehicle first */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND ) {\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t/* handle non-position mission items such as commands */\n\t} else {\n\n\t\t/* turn towards next waypoint before MC to FW transition */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\t\t\t\t\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& has_next_position_item) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\t\t\t\n\t\t\tset_align_mission_item(&_mission_item, &mission_item_next_position);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\n\t/* set current position setpoint from mission item (is protected agains non-position items) */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(&_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to process next mission item */\n\n\t\tif (has_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(\n\t\t\t\tpos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionFeasibilityChecker::checkMissionItemValidity": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed) {\n\t// do not allow mission if we find unsupported item\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t// not supposed to happen unless the datamanager can't access the SD card, etc.\n\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Rejecting Mission: Cannot access SD card\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we find unsupported items and reject mission if so\n\t\tif (missionitem.nav_cmd != NAV_CMD_IDLE &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_WAYPOINT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n\t\t\t/* not yet supported: missionitem.nav_cmd != NAV_CMD_LOITER_TURN_COUNT && */\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LAND &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_LAND &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_CHANGE_SPEED &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_DIST &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n\n\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Rejecting mission item %i: unsupported cmd: %d\", (int)(i+1), (int)missionitem.nav_cmd);\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the mission starts with a land command while the vehicle is landed\n\t\tif (missionitem.nav_cmd == NAV_CMD_LAND &&\n\t\t\ti == 0 &&\n\t\t\tcondition_landed) {\n\n\t\t\tmavlink_log_critical(_mavlink_log_pub, \"Rejecting mission that starts with LAND command while vehicle is landed.\");\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\treturn true;\n}"
    },
    "Mission::Mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::Mission(Navigator *navigator, const char *name) :\n\tMissionBlock(navigator, name),\n\t_param_onboard_enabled(this, \"MIS_ONBOARD_EN\", false),\n\t_param_takeoff_alt(this, \"MIS_TAKEOFF_ALT\", false),\n\t_param_dist_1wp(this, \"MIS_DIST_1WP\", false),\n\t_param_altmode(this, \"MIS_ALTMODE\", false),\n\t_param_yawmode(this, \"MIS_YAWMODE\", false),\n\t_param_force_vtol(this, \"VT_NAV_FORCE_VT\", false),\n\t_onboard_mission{}"
    },
    "Mission::do_need_move_to_land": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::do_need_move_to_land()\n{\n\tif (_navigator->get_vstatus()->is_rotary_wing && (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND)) {\n\n\t\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\n\t\treturn d_current > _navigator->get_acceptance_radius();\n\t}\n\n\treturn false;\n}"
    },
    "Mission::altitude_sp_foh_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::altitude_sp_foh_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n\t\t\t!PX4_ISFINITE(_mission_item_previous_alt)) {\n\t\treturn;\n\t}\n\n\t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < FLT_EPSILON) {\n\t\treturn;\n\t}\n\n\t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n\t * and the FW controller has a custom landing logic */\n\tif (_mission_item.nav_cmd == NAV_CMD_LAND\n\t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t|| _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\treturn;\n\t}\n\n\t/* Calculate distance to current waypoint */\n\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\n\t/* Save distance to waypoint if it is the smallest ever achieved, however make sure that\n\t * _min_current_sp_distance_xy is never larger than the distance between the current and the previous wp */\n\t_min_current_sp_distance_xy = math::min(math::min(d_current, _min_current_sp_distance_xy),\n\t\t\t_distance_current_previous);\n\n\t/* if the minimal distance is smaller then the acceptance radius, we should be at waypoint alt\n\t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n\tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n\t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n\n\t} else {\n\t\t/* update the altitude sp of the 'current' item in the sp triplet, but do not update the altitude sp\n\t\t* of the mission item as it is used to check if the mission item is reached\n\t\t* The setpoint is set linearly and such that the system reaches the current altitude at the acceptance\n\t\t* radius around the current waypoint\n\t\t**/\n\t\tfloat delta_alt = (get_absolute_altitude_for_item(_mission_item) - _mission_item_previous_alt);\n\t\tfloat grad = -delta_alt/(_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius));\n\t\tfloat a = _mission_item_previous_alt - grad * _distance_current_previous;\n\t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n\t}\n\n\t// we set altitude directly so we can run this in parallel to the heading update\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND: /* fall through */\n\t\tcase NAV_CMD_VTOL_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * Then monitor the transition status for completion.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 &&\n\t\t\t\t\t!_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED:\n\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\tif (_mission_item.params[1] > 0.0f) {\n\t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n\t\t\t} else {\n\t\t\t\t_navigator->set_cruising_speed();\n\t\t\t}\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif ((_navigator->get_vstatus()->condition_landed == false)\n\t\t&& !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif ((_mission_item.nav_cmd == NAV_CMD_TAKEOFF || _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF)\n\t\t\t&& _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n\t\t\t\t\t|| (_param_yaw_timeout.get() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t\t\t\t_param_yaw_timeout.get() >= FLT_EPSILON &&\n\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f) {\n\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_log_pub, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "Mission::read_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item)\n{\n\t/* select onboard/offboard mission */\n\tint *mission_index_ptr;\n\tdm_item_t dm_item;\n\n\tstruct mission_s *mission = (onboard) ? &_onboard_mission : &_offboard_mission;\n\tint current_index = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n\tint index_to_read = current_index + offset;\n\n\t/* do not work on empty missions */\n\tif (mission->count == 0) {\n\t\treturn false;\n\t}\n\n\tif (onboard) {\n\t\t/* onboard mission */\n\t\tmission_index_ptr = (offset == 0) ? &_current_onboard_mission_index : &index_to_read;\n\t\tdm_item = DM_KEY_WAYPOINTS_ONBOARD;\n\n\t} else {\n\t\t/* offboard mission */\n\t\tmission_index_ptr = (offset == 0) ? &_current_offboard_mission_index : &index_to_read;\n\t\tdm_item = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\t}\n\n\t/* Repeat this several times in case there are several DO JUMPS that we need to follow along, however, after\n\t * 10 iterations we have to assume that the DO JUMPS are probably cycling and give up. */\n\tfor (int i = 0; i < 10; i++) {\n\n\t\tif (*mission_index_ptr < 0 || *mission_index_ptr >= (int)mission->count) {\n\t\t\t/* mission item index out of bounds - if they are equal, we just reached the end */\n\t\t\tif (*mission_index_ptr != (int)mission->count) {\n\t\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_log_pub(), \"[wpm] err: index: %d, max: %d\", *mission_index_ptr, (int)mission->count);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t/* read mission item to temp storage first to not overwrite current mission item if data damaged */\n\t\tstruct mission_item_s mission_item_tmp;\n\n\t\t/* read mission item from datamanager */\n\t\tif (dm_read(dm_item, *mission_index_ptr, &mission_item_tmp, len) != len) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_log_pub(), \"ERROR waypoint could not be read\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/* check for DO_JUMP item, and whether it hasn't not already been repeated enough times */\n\t\tif (mission_item_tmp.nav_cmd == NAV_CMD_DO_JUMP) {\n\n\t\t\t/* do DO_JUMP as many times as requested */\n\t\t\tif (mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) {\n\n\t\t\t\t/* only raise the repeat count if this is for the current mission item\n\t\t\t\t* but not for the read ahead mission item */\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n\t\t\t\t\t/* save repeat count */\n\t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, DM_PERSIST_POWER_ON_RESET,\n\t\t\t\t\t\t&mission_item_tmp, len) != len) {\n\t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the\n\t\t\t\t\t\t * dataman */\n\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"ERROR DO JUMP waypoint could not be written\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treport_do_jump_mission_changed(*mission_index_ptr,\n\t\t\t\t\t\t\t\t\t   mission_item_tmp.do_jump_repeat_count);\n\t\t\t\t}\n\t\t\t\t/* set new mission item index and repeat\n\t\t\t\t* we don't have to validate here, if it's invalid, we should realize this later .*/\n\t\t\t\t*mission_index_ptr = mission_item_tmp.do_jump_mission_index;\n\n\t\t\t} else {\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"DO JUMP repetitions completed\");\n\t\t\t\t}\n\t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */\n\t\t\t\t(*mission_index_ptr)++;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* if it's not a DO_JUMP, then we were successful */\n\t\t\tmemcpy(mission_item, &mission_item_tmp, sizeof(struct mission_item_s));\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* we have given up, we don't want to cycle forever */\n\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"ERROR DO JUMP is cycling, giving up\");\n\treturn false;\n}"
    },
    "MissionBlock::item_contains_position": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "MissionBlock::item_contains_position(const struct mission_item_s *item)\n{\n\t// XXX: maybe extend that check onto item properties\n\tif (item->nav_cmd == NAV_CMD_DO_JUMP ||\n\t\titem->nav_cmd == NAV_CMD_DO_CHANGE_SPEED ||\n\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO ||\n\t\titem->nav_cmd == NAV_CMD_DO_REPEAT_SERVO ||\n\t\titem->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n\t\titem->nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST ||\n\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
    },
    "Mission::heading_sp_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "3b632455740bed4d1878dc7fe5afe6e36e3de80e",
      "source": "Mission::heading_sp_update()\n{\n\t/* we don't want to be yawing during takeoff, landing or aligning for a transition */\n\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF\t\t\t\n\t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t|| _mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t|| _mission_item.nav_cmd == NAV_CMD_LAND\n\t\t\t|| _mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t|| _work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\treturn;\n\t}\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid) {\n\t\treturn;\n\t}\n\n\t/* set yaw angle for the waypoint if a loiter time has been specified */\n\tif (_waypoint_position_reached && _mission_item.time_inside > 0.0f) {\n\t\t// XXX: should actually be param4 from mission item\n\t\t// at the moment it will just keep the heading it has\n\t\t//_mission_item.yaw = _on_arrival_yaw;\n\t\t//pos_sp_triplet->current.yaw = _mission_item.yaw;\n\n\t} else {\n\t\t/* Calculate direction the vehicle should point to. */\n\t\tdouble point_from_latlon[2];\n\t\tdouble point_to_latlon[2];\n\n\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n\n\t\t/* target location is home */\n\t\tif ((_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME\n\t\t\t\t|| _param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME)\n\t\t\t\t// need to be rotary wing for this but not in a transition\n\t\t\t\t// in VTOL mode this will prevent updating yaw during FW flight\n\t\t\t\t// (which would result in a wrong yaw setpoint spike during back transition)\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !(_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION || _navigator->get_vstatus()->in_transition_mode)) {\n\t\t\tpoint_to_latlon[0] = _navigator->get_home_position()->lat;\n\t\t\tpoint_to_latlon[1] = _navigator->get_home_position()->lon;\n\n\t\t/* target location is next (current) waypoint */\n\t\t} else {\n\t\t\tpoint_to_latlon[0] = pos_sp_triplet->current.lat;\n\t\t\tpoint_to_latlon[1] = pos_sp_triplet->current.lon;\n\t\t}\n\n\t\tfloat d_current = get_distance_to_next_waypoint(\n\t\t\tpoint_from_latlon[0], point_from_latlon[1],\n\t\t\tpoint_to_latlon[0], point_to_latlon[1]);\n\n\t\t/* stop if positions are close together to prevent excessive yawing */\n\t\tif (d_current > _navigator->get_acceptance_radius()) {\n\t\t\tfloat yaw = get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\tpoint_to_latlon[0],\n\t\t\t\tpoint_to_latlon[1]);\n\n\t\t\t/* always keep the back of the rotary wing pointing towards home */\n\t\t\tif (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n\t\t\t\t_mission_item.yaw = _wrap_pi(yaw + M_PI_F);\n\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\n\t\t\t} else {\n\t\t\t\t_mission_item.yaw = yaw;\n\t\t\t\tpos_sp_triplet->current.yaw = _mission_item.yaw;\n\t\t\t}\n\t\t}\n\t}\n\n\t// we set yaw directly so we can run this in parallel to the FOH update\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "3736": {
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "dc7077b125f3f193a4ce5405ae4c1b2989afddae",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "dc7077b125f3f193a4ce5405ae4c1b2989afddae",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\t/* don't change the setpoint for non-position items */\n\tif (!item_contains_position(item)) {\n\t\treturn;\n\t}\n\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\tsp->disable_mc_yaw_control = false;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_loiter.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "MissionBlock::MissionBlock": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "dc7077b125f3f193a4ce5405ae4c1b2989afddae",
      "source": "MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n\tNavigatorMode(navigator, name),\n\t_mission_item({0}"
    }
  },
  "3730": {
    "MissionBlock::set_land_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "6e8f563d27de0b9c30b81350808f26e51843377c",
      "source": "MissionBlock::set_land_item(struct mission_item_s *item, bool at_current_location)\n{\n\n\t/* VTOL transition to RW before landing */\n\tif(_navigator->get_vstatus()->is_vtol){\n\t\tstruct vehicle_command_s cmd = {};\n\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\tif (_cmd_pub != nullptr) {\n\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t} else {\n\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t}\n\t}\n\n\t/* set the land item */\n\titem->nav_cmd = NAV_CMD_LAND;\n\n\t/* use current position */\n\tif (at_current_location) {\n\t\titem->lat = _navigator->get_global_position()->lat;\n\t\titem->lon = _navigator->get_global_position()->lon;\n\t\n\t/* use home position */\n\t} else {\n\t\titem->lat = _navigator->get_home_position()->lat;\n\t\titem->lon = _navigator->get_home_position()->lon;\n\t}\n\n\titem->altitude = 0;\n\titem->altitude_is_relative = false;\n\titem->yaw = NAN;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->loiter_direction = 1;\n\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->pitch_min = 0.0f;\n\titem->autocontinue = true;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    }
  },
  "3846": {
    "Mission::on_inactive": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "55554f4098ee860c136e2146b0369aadbbc2c6ac",
      "source": "Mission::on_inactive()\n{\n\tif (_inited) {\n\t\t/* check if missions have changed so that feedback to ground station is given */\n\t\tbool onboard_updated = false;\n\t\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\t\tif (onboard_updated) {\n\t\t\tupdate_onboard_mission();\n\t\t}\n\n\t\tbool offboard_updated = false;\n\t\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\t\tif (offboard_updated) {\n\t\t\tupdate_offboard_mission();\n\t\t}\n\n\t\t/* reset the current offboard mission if needed */\n\t\tif (need_to_reset_mission(false)) {\n\t\t\treset_offboard_mission(_offboard_mission);\n\t\t\tupdate_offboard_mission();\n\t\t}\n\n\t} else {\n\n\t\t/* load missions from storage */\n\t\tmission_s mission_state;\n\n\t\tdm_lock(DM_KEY_MISSION_STATE);\n\n\t\t/* read current state */\n\t\tint read_res = dm_read(DM_KEY_MISSION_STATE, 0, &mission_state, sizeof(mission_s));\n\n\t\tdm_unlock(DM_KEY_MISSION_STATE);\n\n\t\tif (read_res == sizeof(mission_s)) {\n\t\t\t_offboard_mission.dataman_id = mission_state.dataman_id;\n\t\t\t_offboard_mission.count = mission_state.count;\n\t\t\t_current_offboard_mission_index = mission_state.current_seq;\n\t\t}\n\n\t\t_inited = true;\n\t}\n\n\tcheck_mission_valid();\n\n\t/* require takeoff after non-loiter or landing */\n\tif (!_navigator->get_can_loiter_at_sp() || _navigator->get_land_detected()->landed) {\n\t\t_need_takeoff = true;\n\t}\n}"
    },
    "Mission::do_need_takeoff": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "55554f4098ee860c136e2146b0369aadbbc2c6ac",
      "source": "Mission::do_need_takeoff()\n{\n\tif (_navigator->get_vstatus()->is_rotary_wing) {\n\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t/* force takeoff if landed (additional protection) */\n\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t_need_takeoff = true;\n\n\t\t/* if in-air and already above takeoff height, don't do takeoff */\n\t\t} else if (_navigator->get_global_position()->alt > takeoff_alt) {\n\t\t\t_need_takeoff = false;\n\t\t}\n\n\t\t/* check if current mission item is one that requires takeoff before */\n\t\tif (_need_takeoff && (\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n\n\t\t\t_need_takeoff = false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "55554f4098ee860c136e2146b0369aadbbc2c6ac",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tbool has_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* copy information about the previous mission item */\n\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n\t\t/* Copy previous mission item altitude */\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_land_detected()->landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle position mission items */\n\n\n\tif (item_contains_position(&_mission_item)) {\n\n\t\t/* force vtol land */\n\t\tif(_mission_item.nav_cmd == NAV_CMD_LAND && _param_force_vtol.get()\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing){\n\t\t\t_mission_item.nav_cmd = NAV_CMD_VTOL_LAND;\n\t\t}\n\n\t\t/* we have a new position item so set previous position setpoint to current */\n\t\tset_previous_pos_setpoint();\n\n\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\thas_next_position_item = true;\n\n\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_log_pub(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t/* ignore yaw for takeoff items */\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n\n\t\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t\t&& !_navigator->get_land_detected()->landed\n\t\t\t\t\t&& has_next_position_item) {\n\t\t\t\t/* check if the vtol_takeoff command is on top of us */\n\t\t\t\tif(do_need_move_to_takeoff()){\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF;\n\t\t\t\t} else {\n\t\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t}\n\n\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t\t_mission_item.params[0] = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n\t\t\t\t_mission_item.yaw = _navigator->get_global_position()->yaw;\n\t\t\t} else {\n\t\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t\t_mission_item.yaw = NAN;\n\t\t\t}\n\n\t\t}\n\n\t\t/* takeoff completed and transitioned, move to takeoff wp as fixed wing */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF\n\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0.0f;\n\t\t}\n\n\t\t/* move to land wp as fixed wing */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_DEFAULT\n\t\t\t\t&& !_navigator->get_land_detected()->landed) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* transition to MC */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_VTOL_LAND\n\t\t\t\t&& _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_land_detected()->landed) {\n\t\t\t_mission_item.nav_cmd = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\t_mission_item.params[0] = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION;\n\t\t}\n\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif (do_need_move_to_land() &&\n\t\t\t\t(_work_item_type == WORK_ITEM_TYPE_DEFAULT ||\n\t\t\t\t _work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION)) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\n\t\t\t/*\n\t\t\t * Ignoring waypoint altitude:\n\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t * what the altitude means on this waypoint type.\n\t\t\t */\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* we just moved to the landing waypoint, now descend */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\n\n\t\t/* ignore yaw for landing items */\n\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t * that aligns the vehicle first */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND ) {\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t/* handle non-position mission items such as commands */\n\t} else {\n\n\t\t/* turn towards next waypoint before MC to FW transition */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_land_detected()->landed\n\t\t\t\t&& has_next_position_item) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\t\t\tset_align_mission_item(&_mission_item, &mission_item_next_position);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\n\t/* set current position setpoint from mission item (is protected agains non-position items) */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(&_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to process next mission item */\n\n\t\tif (has_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(\n\t\t\t\tpos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Mission::check_mission_valid": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "55554f4098ee860c136e2146b0369aadbbc2c6ac",
      "source": "Mission::check_mission_valid()\n{\n\t/* check if the home position became valid in the meantime */\n\tif (!_home_inited && _navigator->home_position_valid()) {\n\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\t_navigator->get_mission_result()->valid = _missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_log_pub(), (_navigator->get_vstatus()->is_rotary_wing || _navigator->get_vstatus()->is_vtol),\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_default_acceptance_radius(),\n\t\t\t\t_navigator->get_land_detected()->landed);\n\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t\t_home_inited = true;\n\t}\n\n\treturn _navigator->get_mission_result()->valid;\n}"
    },
    "Mission::calculate_takeoff_altitude": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "55554f4098ee860c136e2146b0369aadbbc2c6ac",
      "source": "Mission::calculate_takeoff_altitude(struct mission_item_s *mission_item)\n{\n\t/* calculate takeoff altitude */\n\tfloat takeoff_alt = get_absolute_altitude_for_item(*mission_item);\n\n\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n\tif (_navigator->get_land_detected()->landed) {\n\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n\n\t} else {\n\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n\t}\n\n\treturn takeoff_alt;\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "55554f4098ee860c136e2146b0369aadbbc2c6ac",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_log_pub(), (_navigator->get_vstatus()->is_rotary_wing || _navigator->get_vstatus()->is_vtol),\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_default_acceptance_radius(),\n\t\t\t\t_navigator->get_land_detected()->landed);\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\tif (!failed) {\n\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t_navigator->get_mission_result()->mission_failure = false;\n\t\t}\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    }
  },
  "3724": {
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "382c262a82ae6f9bda9ce291c43878058b36b176",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tbool has_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* copy information about the previous mission item */\n\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n\t\t/* Copy previous mission item altitude */\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle position mission items */\n\tif (item_contains_position(&_mission_item)) {\n\n\t\t/* we have a new position item so set previous position setpoint to current */\n\t\tset_previous_pos_setpoint();\n\n\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\thas_next_position_item = true;\n\n\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t/* ignore yaw for takeoff items */\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\n\t\t\t/*\n\t\t\t * Ignoring waypoint altitude:\n\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t * what the altitude means on this waypoint type.\n\t\t\t */\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* we just moved to the landing waypoint, now descend */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* ignore yaw for landing items */\n\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t * that aligns the vehicle first */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t/* handle non-position mission items such as commands */\n\t} else {\n\n\t\t/* turn towards next waypoint before MC to FW transition */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& has_next_position_item) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\tmission_item_next_position.lat,\n\t\t\t\tmission_item_next_position.lon);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* don't advance mission after FW to MC command */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n\t\t}\n\n\t\t/* after FW to MC transition finish moving to the waypoint */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\n\t/* set current position setpoint from mission item (is protected agains non-position items) */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(&_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to process next mission item */\n\n\t\tif (has_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(\n\t\t\t\tpos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "3814": {
    "Loiter::on_activation": {
      "file": "src/modules/navigator/loiter.cpp",
      "commit": "ccc4ec9d24a666dd2b3aa067792d7eb9dca1b2c4",
      "source": "Loiter::on_activation()\n{\n\t/* set current mission item to loiter */\n\tset_loiter_item(&_mission_item, _param_min_alt.get());\n\n\t/* convert mission item to current setpoint */\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n    pos_sp_triplet->current.velocity_valid = false;\n\tpos_sp_triplet->previous.valid = false;\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Navigator::task_main": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "ccc4ec9d24a666dd2b3aa067792d7eb9dca1b2c4",
      "source": "Navigator::task_main()\n{\n\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t_geofence.setMavlinkFd(_mavlink_fd);\n\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file\n\t * else clear geofence data in datamanager */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\twarnx(\"Try to load geofence.txt\");\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\n\t} else {\n\t\tif (_geofence.clearDm() != OK) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"failed clearing geofence\");\n\t\t}\n\t}\n\n\t/* do subscriptions */\n\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n\t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n\t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n\t_onboard_mission_sub = orb_subscribe(ORB_ID(onboard_mission));\n\t_offboard_mission_sub = orb_subscribe(ORB_ID(offboard_mission));\n\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n\n\t/* copy all topics first time */\n\tvehicle_status_update();\n\tvehicle_control_mode_update();\n\tglobal_position_update();\n\tgps_position_update();\n\tsensor_combined_update();\n\thome_position_update(true);\n\tnavigation_capabilities_update();\n\tparams_update();\n\n\thrt_abstime mavlink_open_time = 0;\n\tconst hrt_abstime mavlink_open_interval = 500000;\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[1] = {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _global_pos_sub;\n\tfds[0].events = POLLIN;\n\n\tbool global_pos_available_once = false;\n\n\twhile (!_task_should_exit) {\n\n\t\t/* wait for up to 200ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n\t\t\tif (global_pos_available_once) {\n\t\t\t\tPX4_WARN(\"navigator timed out\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal_pos_available_once = true;\n\n\t\tperf_begin(_loop_perf);\n\n\t\tif (_mavlink_fd < 0 && hrt_absolute_time() > mavlink_open_time) {\n\t\t\t/* try to reopen the mavlink log device with specified interval */\n\t\t\tmavlink_open_time = hrt_abstime() + mavlink_open_interval;\n\t\t\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t\t}\n\n\t\tbool updated;\n\n\t\t/* gps updated */\n\t\torb_check(_gps_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\tgps_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* sensors combined updated */\n\t\torb_check(_sensor_combined_sub, &updated);\n\t\tif (updated) {\n\t\t\tsensor_combined_update();\n\t\t}\n\n\t\t/* parameters updated */\n\t\torb_check(_param_update_sub, &updated);\n\t\tif (updated) {\n\t\t\tparams_update();\n\t\t\tupdateParams();\n\t\t}\n\n\t\t/* vehicle control mode updated */\n\t\torb_check(_control_mode_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_control_mode_update();\n\t\t}\n\n\t\t/* vehicle status updated */\n\t\torb_check(_vstatus_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_status_update();\n\t\t}\n\n\t\t/* navigation capabilities updated */\n\t\torb_check(_capabilities_sub, &updated);\n\t\tif (updated) {\n\t\t\tnavigation_capabilities_update();\n\t\t}\n\n\t\t/* home position updated */\n\t\torb_check(_home_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\thome_position_update();\n\t\t}\n\n\t\torb_check(_vehicle_command_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_command_s cmd;\n\t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION) {\n\t\t\t\twarnx(\"navigator: got reposition command\");\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_PAUSE_CONTINUE) {\n\t\t\t\twarnx(\"navigator: got pause/continue command\");\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (fds[0].revents & POLLIN) {\n\t\t\tglobal_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Check geofence violation */\n\t\tstatic hrt_abstime last_geofence_check = 0;\n\t\tif (have_geofence_position_data &&\n\t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n\t\t\tlast_geofence_check = hrt_absolute_time();\n\t\t\thave_geofence_position_data = false;\n\n\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\t\t\tif (!inside) {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = true;\n\t\t\t\tpublish_geofence_result();\n\n\t\t\t\t/* Issue a warning about the geofence violation once */\n\t\t\t\tif (!_geofence_violation_warning_sent) {\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation\");\n\t\t\t\t\t_geofence_violation_warning_sent = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = false;\n\t\t\t\tpublish_geofence_result();\n\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n\t\t\t\t_geofence_violation_warning_sent = false;\n\t\t\t}\n\t\t}\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tswitch (_vstatus.nav_state) {\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t\tif (_nav_caps.abort_landing) {\n\t\t\t\t\t// pos controller aborted landing, requests loiter\n\t\t\t\t\t// above landing waypoint\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t} else {\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t\t_navigation_mode = &_mission;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_rcloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_rcLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_takeoff;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n\t\t\t\t/* Use complex data link loss mode only when enabled via param\n\t\t\t\t* otherwise use rtl */\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_datalinkloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_engineFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_gpsFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_follow_target;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\t_pos_sp_triplet.previous.valid = false;\n\t\t\t_pos_sp_triplet.current.valid = false;\n\t\t\t_pos_sp_triplet.next.valid = false;\n\t\t\t_pos_sp_triplet_updated = true;\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t\t_pos_sp_triplet_updated = false;\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t\t_mission_result_updated = false;\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n\twarnx(\"exiting.\");\n\n\t_navigator_task = -1;\n\treturn;\n}"
    },
    "MissionBlock::set_loiter_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "ccc4ec9d24a666dd2b3aa067792d7eb9dca1b2c4",
      "source": "MissionBlock::set_loiter_item(struct mission_item_s *item, float min_clearance)\n{\n\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t/* landed, don't takeoff, but switch to IDLE mode */\n\t\titem->nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\titem->nav_cmd = NAV_CMD_LOITER_UNLIMITED;\n\n\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\tif (_navigator->get_can_loiter_at_sp() && pos_sp_triplet->current.valid) {\n\t\t\t/* use current position setpoint */\n\t\t\titem->lat = pos_sp_triplet->current.lat;\n\t\t\titem->lon = pos_sp_triplet->current.lon;\n\t\t\titem->altitude = pos_sp_triplet->current.alt;\n\n\t\t} else {\n\t\t\t/* use current position and use return altitude as clearance */\n\t\t\titem->lat = _navigator->get_global_position()->lat;\n\t\t\titem->lon = _navigator->get_global_position()->lon;\n\t\t\titem->altitude = _navigator->get_global_position()->alt;\n\n\t\t\tif (min_clearance > 0.0f && item->altitude < _navigator->get_home_position()->alt + min_clearance) {\n\t\t\t\titem->altitude = _navigator->get_home_position()->alt + min_clearance;\n\t\t\t}\n\t\t}\n\n\t\titem->altitude_is_relative = false;\n\t\titem->yaw = NAN;\n\t\titem->loiter_radius = _navigator->get_loiter_radius();\n\t\titem->loiter_direction = 1;\n\t\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\t\titem->time_inside = 0.0f;\n\t\titem->pitch_min = 0.0f;\n\t\titem->autocontinue = false;\n\t\titem->origin = ORIGIN_ONBOARD;\n\t}\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "ccc4ec9d24a666dd2b3aa067792d7eb9dca1b2c4",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED:\n\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\tif (_mission_item.params[1] > 0.0f) {\n\t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n\t\t\t} else {\n\t\t\t\t_navigator->set_cruising_speed();\n\t\t\t}\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif ((_navigator->get_vstatus()->condition_landed == false)\n\t\t&& !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n\t\t\t\t\t|| (_param_yaw_timeout.get() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t\t\t\t_param_yaw_timeout.get() >= FLT_EPSILON &&\n\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f) {\n\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "Navigator::Navigator": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "ccc4ec9d24a666dd2b3aa067792d7eb9dca1b2c4",
      "source": "Navigator::Navigator() :\n\tSuperBlock(NULL, \"NAV\"),\n\t_task_should_exit(false),\n\t_navigator_task(-1),\n\t_mavlink_fd(-1),\n\t_global_pos_sub(-1),\n\t_gps_pos_sub(-1),\n\t_home_pos_sub(-1),\n\t_vstatus_sub(-1),\n\t_capabilities_sub(-1),\n\t_control_mode_sub(-1),\n\t_onboard_mission_sub(-1),\n\t_offboard_mission_sub(-1),\n\t_param_update_sub(-1),\n\t_vehicle_command_sub(-1),\n\t_pos_sp_triplet_pub(nullptr),\n\t_mission_result_pub(nullptr),\n\t_geofence_result_pub(nullptr),\n\t_att_sp_pub(nullptr),\n\t_vstatus{}"
    }
  },
  "3740": {
    "Navigator::publish_att_sp": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "Navigator::publish_att_sp()\n{\n\t/* lazily publish the attitude sp only once available */\n\tif (_att_sp_pub != nullptr) {\n\t\t/* publish att sp*/\n\t\torb_publish(ORB_ID(vehicle_attitude_setpoint), _att_sp_pub, &_att_sp);\n\n\t} else {\n\t\t/* advertise and publish */\n\t\t_att_sp_pub = orb_advertise(ORB_ID(vehicle_attitude_setpoint), &_att_sp);\n\t}\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n\t\t\t\t\t/* check if we should accept heading after a timeout, 0 means accept instantly */\n\t\t\t\t\t|| (_param_yaw_timeout.get() >= -FLT_EPSILON &&\n\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f)) {\n\n\t\t\t\t/* if heading needs to be reached but we got here because of the timeout, abort mission */\n\t\t\t\tif (_mission_item.force_heading && !(fabsf(yaw_err) < math::radians(_param_yaw_err.get()))) {\n\t\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n\n\t\t\t\t} else {\n\t\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\tif (!failed) {\n\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t_navigator->get_mission_result()->mission_failure = false;\n\t\t}\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    },
    "Mission::update_onboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "Mission::update_onboard_mission()\n{\n\tif (orb_copy(ORB_ID(onboard_mission), _navigator->get_onboard_mission_sub(), &_onboard_mission) == OK) {\n\t\t/* accept the current index set by the onboard mission if it is within bounds */\n\t\tif (_onboard_mission.current_seq >=0\n\t\t&& _onboard_mission.current_seq < (int)_onboard_mission.count) {\n\t\t\t_current_onboard_mission_index = _onboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less WPs available, reset to first WP */\n\t\t\tif (_current_onboard_mission_index >= (int)_onboard_mission.count) {\n\t\t\t\t_current_onboard_mission_index = 0;\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_onboard_mission_index < 0) {\n\t\t\t\t_current_onboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t// XXX check validity here as well\n\t\t_navigator->get_mission_result()->valid = true;\n\t\t/* reset mission failure if we have an updated valid mission */\n\t\t_navigator->get_mission_result()->mission_failure = false;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\t_onboard_mission.count = 0;\n\t\t_onboard_mission.current_seq = 0;\n\t\t_current_onboard_mission_index = 0;\n\t}\n}"
    },
    "MissionBlock::reset_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "MissionBlock::reset_mission_item_reached()\n{\n\t_waypoint_position_reached = false;\n\t_waypoint_yaw_reached = false;\n\t_time_first_inside_orbit = 0;\n\t_time_wp_reached = 0;\n}"
    },
    "MissionBlock::MissionBlock": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n\tNavigatorMode(navigator, name),\n\t_mission_item({0}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "eb5b8a32ee66aeff5edf78c4374b3837bff354a2",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tbool has_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* copy information about the previous mission item */\n\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n\t\t/* Copy previous mission item altitude */\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle position mission items */\n\tif (item_contains_position(&_mission_item)) {\n\n\t\t/* we have a new position item so set previous position setpoint to current */\n\t\tset_previous_pos_setpoint();\n\n\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\thas_next_position_item = true;\n\n\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t/* ignore yaw for takeoff items */\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t/* ignore yaw here, otherwise it might yaw before heading_sp_update takes over */\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\n\t\t\t/*\n\t\t\t * Ignoring waypoint altitude:\n\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t * what the altitude means on this waypoint type.\n\t\t\t */\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* we just moved to the landing waypoint, now descend */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* ignore yaw for landing items */\n\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t * that aligns the vehicle first */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t/* handle non-position mission items such as commands */\n\t} else {\n\n\t\t/* turn towards next waypoint before MC to FW transition */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& has_next_position_item) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\tmission_item_next_position.lat,\n\t\t\t\tmission_item_next_position.lon);\n\t\t\t_mission_item.force_heading = true;\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* don't advance mission after FW to MC command */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n\t\t}\n\n\t\t/* after FW to MC transition finish moving to the waypoint */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\n\t/* set current position setpoint from mission item (is protected agains non-position items) */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(&_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to process next mission item */\n\n\t\tif (has_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(\n\t\t\t\tpos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "3690": {
    "MissionFeasibilityChecker::checkFixedWingLanding": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "8c56f38ea6a55e270e9e2d39ce310918cb4d4928",
      "source": "bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size_t nMissionItems)\n{\n\t/* Go through all mission items and search for a landing waypoint\n\t * if landing waypoint is found: the previous waypoint is checked to be at a feasible distance and altitude given the landing slope */\n\n\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(missionitem);\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (missionitem.nav_cmd == NAV_CMD_LAND) {\n\t\t\tstruct mission_item_s missionitem_previous;\n\t\t\tif (i != 0) {\n\t\t\t\tif (dm_read(dm_current, i-1, &missionitem_previous, len) != len) {\n\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfloat wp_distance = get_distance_to_next_waypoint(missionitem_previous.lat , missionitem_previous.lon, missionitem.lat, missionitem.lon);\n\t\t\t\tfloat slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude, _nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad);\n\t\t\t\tfloat wp_distance_req = Landingslope::getLandingSlopeWPDistance(missionitem_previous.altitude, missionitem.altitude, _nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad);\n\t\t\t\tfloat delta_altitude = missionitem.altitude - missionitem_previous.altitude;\n//\t\t\t\twarnx(\"wp_distance %.2f, delta_altitude %.2f, missionitem_previous.altitude %.2f, missionitem.altitude %.2f, slope_alt_req %.2f, wp_distance_req %.2f\",\n//\t\t\t\t\t\twp_distance, delta_altitude, missionitem_previous.altitude, missionitem.altitude, slope_alt_req, wp_distance_req);\n//\t\t\t\twarnx(\"_nav_caps.landing_horizontal_slope_displacement %.4f, _nav_caps.landing_slope_angle_rad %.4f, _nav_caps.landing_flare_length %.4f\",\n//\t\t\t\t\t\t_nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad, _nav_caps.landing_flare_length);\n\n\t\t\t\tif (wp_distance > _nav_caps.landing_flare_length) {\n\t\t\t\t\t/* Last wp is before flare region */\n\n\t\t\t\t\tif (delta_altitude < 0) {\n\t\t\t\t\t\tif (missionitem_previous.altitude <= slope_alt_req) {\n\t\t\t\t\t\t\t/* Landing waypoint is at or below altitude of slope at the given waypoint distance: this is ok, aircraft will intersect the slope */\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Landing waypoint is above altitude of slope at the given waypoint distance */\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Landing: last waypoint too high/too close\");\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Move down to %.1fm or move further away by %.1fm\",\n\t\t\t\t\t\t\t\t\t(double)(slope_alt_req),\n\t\t\t\t\t\t\t\t\t(double)(wp_distance_req - wp_distance));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Landing waypoint is above last waypoint */\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Landing waypoint above last nav waypoint\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Last wp is in flare region */\n\t\t\t\t\t//xxx give recommendations\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Landing: last waypoint in flare region\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: starting with land waypoint\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No landing waypoints or no waypoints */\n\treturn true;\n}"
    }
  },
  "3706": {
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "1853df20e8fda0e05a4fd7322f18a27fdc0b0a44",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "1853df20e8fda0e05a4fd7322f18a27fdc0b0a44",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\t/* don't change the setpoint for non-position items */\n\tif (!item_contains_position(item)) {\n\t\treturn;\n\t}\n\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\tsp->disable_mc_yaw_control = false;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "MissionBlock::MissionBlock": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "1853df20e8fda0e05a4fd7322f18a27fdc0b0a44",
      "source": "MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n\tNavigatorMode(navigator, name),\n\t_mission_item({0}"
    }
  },
  "3687": {
    "MissionBlock::set_takeoff_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "27d7fcf3067c74068cffa3b8e57f1c752708af50",
      "source": "MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance, float min_pitch)\n{\n\titem->nav_cmd = NAV_CMD_TAKEOFF;\n\n\t/* use current position and use return altitude as clearance */\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\titem->altitude = _navigator->get_global_position()->alt;\n\n\tif (min_clearance > 0.0f) {\n\t\titem->altitude += min_clearance;\n\t}\n\n\titem->altitude_is_relative = false;\n\titem->yaw = NAN;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->loiter_direction = 1;\n\titem->acceptance_radius = (_navigator->get_acceptance_radius() > min_clearance / 2.0f) ?\n\t\t\t\t\t(min_clearance / 2) : _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->pitch_min = min_pitch;\n\titem->autocontinue = false;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    }
  },
  "3675": {
    "Navigator::task_main": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "39ee36a8ea38805cb01450ff9fe5a6f5d8c5c136",
      "source": "Navigator::task_main()\n{\n\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t_geofence.setMavlinkFd(_mavlink_fd);\n\n\tbool have_geofence_position_data = false;\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file\n\t * else clear geofence data in datamanager */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\twarnx(\"Try to load geofence.txt\");\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\n\t} else {\n\t\tif (_geofence.clearDm() != OK) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"failed clearing geofence\");\n\t\t}\n\t}\n\n\t/* do subscriptions */\n\t_global_pos_sub = orb_subscribe(ORB_ID(vehicle_global_position));\n\t_gps_pos_sub = orb_subscribe(ORB_ID(vehicle_gps_position));\n\t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n\t_capabilities_sub = orb_subscribe(ORB_ID(navigation_capabilities));\n\t_vstatus_sub = orb_subscribe(ORB_ID(vehicle_status));\n\t_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n\t_home_pos_sub = orb_subscribe(ORB_ID(home_position));\n\t_onboard_mission_sub = orb_subscribe(ORB_ID(onboard_mission));\n\t_offboard_mission_sub = orb_subscribe(ORB_ID(offboard_mission));\n\t_param_update_sub = orb_subscribe(ORB_ID(parameter_update));\n\t_vehicle_command_sub = orb_subscribe(ORB_ID(vehicle_command));\n\n\t/* copy all topics first time */\n\tvehicle_status_update();\n\tvehicle_control_mode_update();\n\tglobal_position_update();\n\tgps_position_update();\n\tsensor_combined_update();\n\thome_position_update(true);\n\tnavigation_capabilities_update();\n\tparams_update();\n\n\thrt_abstime mavlink_open_time = 0;\n\tconst hrt_abstime mavlink_open_interval = 500000;\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[1] = {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _global_pos_sub;\n\tfds[0].events = POLLIN;\n\n\tbool global_pos_available_once = false;\n\n\twhile (!_task_should_exit) {\n\n\t\t/* wait for up to 200ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* timed out - periodic check for _task_should_exit, etc. */\n\t\t\tif (global_pos_available_once) {\n\t\t\t\tPX4_WARN(\"navigator timed out\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_WARN(\"nav: poll error %d, %d\", pret, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal_pos_available_once = true;\n\n\t\tperf_begin(_loop_perf);\n\n\t\tif (_mavlink_fd < 0 && hrt_absolute_time() > mavlink_open_time) {\n\t\t\t/* try to reopen the mavlink log device with specified interval */\n\t\t\tmavlink_open_time = hrt_abstime() + mavlink_open_interval;\n\t\t\t_mavlink_fd = px4_open(MAVLINK_LOG_DEVICE, 0);\n\t\t}\n\n\t\tbool updated;\n\n\t\t/* gps updated */\n\t\torb_check(_gps_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\tgps_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GPS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* sensors combined updated */\n\t\torb_check(_sensor_combined_sub, &updated);\n\t\tif (updated) {\n\t\t\tsensor_combined_update();\n\t\t}\n\n\t\t/* parameters updated */\n\t\torb_check(_param_update_sub, &updated);\n\t\tif (updated) {\n\t\t\tparams_update();\n\t\t\tupdateParams();\n\t\t}\n\n\t\t/* vehicle control mode updated */\n\t\torb_check(_control_mode_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_control_mode_update();\n\t\t}\n\n\t\t/* vehicle status updated */\n\t\torb_check(_vstatus_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_status_update();\n\t\t}\n\n\t\t/* navigation capabilities updated */\n\t\torb_check(_capabilities_sub, &updated);\n\t\tif (updated) {\n\t\t\tnavigation_capabilities_update();\n\t\t}\n\n\t\t/* home position updated */\n\t\torb_check(_home_pos_sub, &updated);\n\t\tif (updated) {\n\t\t\thome_position_update();\n\t\t}\n\n\t\torb_check(_vehicle_command_sub, &updated);\n\t\tif (updated) {\n\t\t\tvehicle_command_s cmd;\n\t\t\torb_copy(ORB_ID(vehicle_command), _vehicle_command_sub, &cmd);\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\twarnx(\"navigator: got takeoff coordinates\");\n\t\t\t}\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (fds[0].revents & POLLIN) {\n\t\t\tglobal_position_update();\n\t\t\tif (_geofence.getSource() == Geofence::GF_SOURCE_GLOBALPOS) {\n\t\t\t\thave_geofence_position_data = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Check geofence violation */\n\t\tstatic hrt_abstime last_geofence_check = 0;\n\t\tif (have_geofence_position_data &&\n\t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n\t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n\t\t\tlast_geofence_check = hrt_absolute_time();\n\t\t\thave_geofence_position_data = false;\n\n\t\t\t_geofence_result.geofence_action = _geofence.getGeofenceAction();\n\t\t\tif (!inside) {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = true;\n\t\t\t\tpublish_geofence_result();\n\n\t\t\t\t/* Issue a warning about the geofence violation once */\n\t\t\t\tif (!_geofence_violation_warning_sent) {\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Geofence violation\");\n\t\t\t\t\t_geofence_violation_warning_sent = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* inform other apps via the mission result */\n\t\t\t\t_geofence_result.geofence_violated = false;\n\t\t\t\tpublish_geofence_result();\n\t\t\t\t/* Reset the _geofence_violation_warning_sent field */\n\t\t\t\t_geofence_violation_warning_sent = false;\n\t\t\t}\n\t\t}\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tswitch (_vstatus.nav_state) {\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t\tif (_nav_caps.abort_landing) {\n\t\t\t\t\t// pos controller aborted landing, requests loiter\n\t\t\t\t\t// above landing waypoint\n\t\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t} else {\n\t\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t\t_navigation_mode = &_mission;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_loiter;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_rcloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_rcLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_takeoff;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_LAND:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_land;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTGS:\n\t\t\t\t/* Use complex data link loss mode only when enabled via param\n\t\t\t\t* otherwise use rtl */\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\tif (_param_datalinkloss_obc.get() != 0) {\n\t\t\t\t\t_navigation_mode = &_dataLinkLoss;\n\t\t\t\t} else {\n\t\t\t\t\t_navigation_mode = &_rtl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_engineFailure;\n\t\t\t\tbreak;\n\t\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LANDGPSFAIL:\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t\t_navigation_mode = &_gpsFailure;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_navigation_mode = nullptr;\n\t\t\t\t_can_loiter_at_sp = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\t_pos_sp_triplet.previous.valid = false;\n\t\t\t_pos_sp_triplet.current.valid = false;\n\t\t\t_pos_sp_triplet.next.valid = false;\n\t\t\t_pos_sp_triplet_updated = true;\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t\t_pos_sp_triplet_updated = false;\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t\t_mission_result_updated = false;\n\t\t}\n\n\t\tperf_end(_loop_perf);\n\t}\n\twarnx(\"exiting.\");\n\n\t_navigator_task = -1;\n\treturn;\n}"
    }
  },
  "3686": {
    "MissionBlock::set_takeoff_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "97296a172d05603dd99bcf9e6b263d3797fe1892",
      "source": "MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance, float min_pitch)\n{\n\titem->nav_cmd = NAV_CMD_TAKEOFF;\n\n\t/* use current position and use return altitude as clearance */\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\titem->altitude = _navigator->get_global_position()->alt;\n\n\tif (min_clearance > 0.0f) {\n\t\titem->altitude += min_clearance;\n\t}\n\n\titem->altitude_is_relative = false;\n\titem->yaw = NAN;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->loiter_direction = 1;\n\titem->acceptance_radius = (_navigator->get_acceptance_radius() > min_clearance / 2.0f) ?\n\t\t\t\t\t(min_clearance / 2) : _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->pitch_min = min_pitch;\n\titem->autocontinue = false;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "97296a172d05603dd99bcf9e6b263d3797fe1892",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO: {\n\t\t\tmemset(&actuators, 0, sizeof(actuators));\n\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n\t\t\tactuators.timestamp = hrt_absolute_time();\n\t\t\tif (_actuator_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n\t\t\t} else {\n\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n\t\t\t{\n\t\t\t/* forward the command to other processes */\n\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n\t\t\tstruct vehicle_command_s cmd = {};\n\t\t\tcmd.command = _mission_item.nav_cmd;\n\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n\t\t\tif (_cmd_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t\t} else {\n\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    }
  },
  "3664": {
    "Mission::check_mission_valid": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "dd6549e1a29cd03fd441c21154c3b047f37e9967",
      "source": "Mission::check_mission_valid()\n{\n\t/* check if the home position became valid in the meantime */\n\tif (!_home_inited && _navigator->home_position_valid()) {\n\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\t_navigator->get_mission_result()->valid = _missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t\t_home_inited = true;\n\t}\n\n\treturn _navigator->get_mission_result()->valid;\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "dd6549e1a29cd03fd441c21154c3b047f37e9967",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\tif (!failed) {\n\t\t\t/* reset mission failure if we have an updated valid mission */\n\t\t\t_navigator->get_mission_result()->mission_failure = false;\n\t\t}\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    }
  },
  "3604": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "5ea5ecf32bfd4b19d8babe94d1ecc02369df3e83",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\t/* Set current position for loitering set point*/\n\t\t\tsp->lat = _navigator->get_global_position()->lat;\n\t\t\tsp->lon = _navigator->get_global_position()->lon;\n\t\t\tsp->alt = _navigator->get_global_position()->alt;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\tbreak;\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\n\t\tif (!_waypoint_position_reached) {\n\t\t\t// we first need to move to the landing waypoint\n\t\t\t// use the altitude specified in the mission item\n\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t} else {\n\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "5ea5ecf32bfd4b19d8babe94d1ecc02369df3e83",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid();\n\t/* check if anything has changed */\n\tbool onboard_updated = false;\n\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\tif (onboard_updated) {\n\t\tupdate_onboard_mission();\n\t}\n\n\tbool offboard_updated = false;\n\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\tif (offboard_updated) {\n\t\tupdate_offboard_mission();\n\t}\n\n\t/* reset mission items if needed */\n\tif (onboard_updated || offboard_updated) {\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached()) {\n\t\tset_mission_item_reached();\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\n\t\t}\n\n\t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n\t\taltitude_sp_foh_update();\n\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND && _waypoint_position_reached && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t// the copter has reached the landing spot location\n\t\t// set the same landing item again but this time the vehicle will actually\n\t\t// descend and land\n\t\tset_mission_item_reached();\n\t\tset_mission_items();\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif ((_param_yawmode.get() != MISSION_YAWMODE_NONE\n\t\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n\t\t\t&& _mission_type != MISSION_TYPE_NONE)\n\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n\t\theading_sp_update();\n\t}\n\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "5ea5ecf32bfd4b19d8babe94d1ecc02369df3e83",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO: {\n\t\t\tmemset(&actuators, 0, sizeof(actuators));\n\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n\t\t\tactuators.timestamp = hrt_absolute_time();\n\t\t\tif (_actuator_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n\t\t\t} else {\n\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\t\tcase NAV_CMD_LAND:\n\t\t\tif (!_navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\t\t\t} else {\n\t\t\t\tif (_waypoint_position_reached) {\n\t\t\t\t\t// the copter has reached the position of the landing spot\n\t\t\t\t\t// it can can start to descend\n\t\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n\t\t\t{\n\t\t\t/* forward the command to other processes */\n\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n\t\t\tstruct vehicle_command_s cmd = {};\n\t\t\tcmd.command = _mission_item.nav_cmd;\n\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n\t\t\tif (_cmd_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t\t} else {\n\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter */\n\n\t\t\t/* _mission_item.acceptance_radius is not always set */\n\t\t\tfloat mission_acceptance_radius = _mission_item.acceptance_radius;\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t// check if we have reached our landing spot\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
    }
  },
  "3673": {
    "Mission::Mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0bde2b6fa3d41559e6cce0d2b6efae210cf8c454",
      "source": "Mission::Mission(Navigator *navigator, const char *name) :\n\tMissionBlock(navigator, name),\n\t_param_onboard_enabled(this, \"MIS_ONBOARD_EN\", false),\n\t_param_takeoff_alt(this, \"MIS_TAKEOFF_ALT\", false),\n\t_param_dist_1wp(this, \"MIS_DIST_1WP\", false),\n\t_param_altmode(this, \"MIS_ALTMODE\", false),\n\t_param_yawmode(this, \"MIS_YAWMODE\", false),\n\t_onboard_mission{}"
    },
    "MissionFeasibilityChecker::checkHomePositionAltitude": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "0bde2b6fa3d41559e6cce0d2b6efae210cf8c454",
      "source": "bool MissionFeasibilityChecker::checkHomePositionAltitude(dm_item_t dm_current, size_t nMissionItems,\n\tfloat home_alt, bool home_valid, bool &warning_issued, bool throw_error)\n{\n\t/* Check if all all waypoints are above the home altitude, only return false if bool throw_error = true */\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\twarning_issued = true;\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\treturn false;\n\t\t}\n\n\t\t/* always reject relative alt without home set */\n\t\tif (missionitem.altitude_is_relative && !home_valid) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: No home pos, WP %d uses rel alt\", i);\n\t\t\twarning_issued = true;\n\t\t\treturn false;\n\t\t}\n\n\t\t/* calculate the global waypoint altitude */\n\t\tfloat wp_alt = (missionitem.altitude_is_relative) ? missionitem.altitude + home_alt : missionitem.altitude;\n\n\t\tif (home_alt > wp_alt) {\n\n\t\t\twarning_issued = true;\n\n\t\t\tif (throw_error) {\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Waypoint %d below home\", i);\n\t\t\t\treturn false;\n\t\t\t} else\t{\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Waypoint %d below home\", i);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}"
    },
    "MissionFeasibilityChecker::checkMissionItemValidity": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "0bde2b6fa3d41559e6cce0d2b6efae210cf8c454",
      "source": "bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed) {\n\t// do not allow mission if we find unsupported item\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t// not supposed to happen unless the datamanager can't access the SD card, etc.\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Cannot access SD card\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we find unsupported items and reject mission if so\n\t\tif (missionitem.nav_cmd != NAV_CMD_IDLE &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_WAYPOINT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TURN_COUNT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LAND &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL &&\n\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the mission starts with a land command while the vehicle is landed\n\t\tif (missionitem.nav_cmd == NAV_CMD_LAND &&\n\t\t\ti == 0 &&\n\t\t\tcondition_landed) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission that starts with LAND command while vehicle is landed.\");\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\treturn true;\n}"
    },
    "MissionFeasibilityChecker::check_dist_1wp": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "0bde2b6fa3d41559e6cce0d2b6efae210cf8c454",
      "source": "MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued)\n{\n\tif (_dist_1wp_ok) {\n\t\t/* always return true after at least one successful check */\n\t\treturn true;\n\t}\n\n\t/* check if first waypoint is not too far from home */\n\tif (dist_first_wp > 0.0f) {\n\t\tstruct mission_item_s mission_item;\n\n\t\t/* find first waypoint (with lat/lon) item in datamanager */\n\t\tfor (unsigned i = 0; i < nMissionItems; i++) {\n\t\t\tif (dm_read(dm_current, i,\n\t\t\t\t\t&mission_item, sizeof(mission_item_s)) == sizeof(mission_item_s)) {\n\t\t\t\t/* Check non navigation item */\n\t\t\t\tif (mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO){\n\n\t\t\t\t\t/* check actuator number */\n\t\t\t\t\tif (mission_item.actuator_num < 0 || mission_item.actuator_num > 5) {\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.actuator_num);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t/* check actuator value */\n\t\t\t\t\tif (mission_item.actuator_value < -2000 || mission_item.actuator_value > 2000) {\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.actuator_value);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* check only items with valid lat/lon */\n\t\t\t\telse if ( mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t\t\t\t\tmission_item.nav_cmd == NAV_CMD_PATHPLANNING) {\n\n\t\t\t\t\t/* check distance from current position to item */\n\t\t\t\t\tfloat dist_to_1wp = get_distance_to_next_waypoint(\n\t\t\t\t\t\t\tmission_item.lat, mission_item.lon, curr_lat, curr_lon);\n\n\t\t\t\t\tif (dist_to_1wp < dist_first_wp) {\n\t\t\t\t\t\t_dist_1wp_ok = true;\n\t\t\t\t\t\tif (dist_to_1wp > ((dist_first_wp * 3) / 2)) {\n\t\t\t\t\t\t\t/* allow at 2/3 distance, but warn */\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: First waypoint very far: %d m\", (int)dist_to_1wp);\n\t\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* item is too far from home */\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"First waypoint too far: %d m,refusing mission\", (int)dist_to_1wp, (int)dist_first_wp);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* error reading, mission is invalid */\n\t\t\t\tmavlink_log_info(_mavlink_fd, \"error reading offboard mission\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* no waypoints found in mission, then we will not fly far away */\n\t\t_dist_1wp_ok = true;\n\t\treturn true;\n\n\t} else {\n\t\treturn true;\n\t}\n}"
    },
    "Mission::check_mission_valid": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0bde2b6fa3d41559e6cce0d2b6efae210cf8c454",
      "source": "Mission::check_mission_valid()\n{\n\t/* check if the home position became valid in the meantime */\n\tif (!_home_inited && _navigator->home_position_valid()) {\n\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\t_navigator->get_mission_result()->valid = _missionFeasiblityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t\t_home_inited = true;\n\t}\n\n\treturn _navigator->get_mission_result()->valid;\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "0bde2b6fa3d41559e6cce0d2b6efae210cf8c454",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasiblityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    }
  },
  "3699": {
    "MissionFeasibilityChecker::isPositionCommand": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "MissionFeasibilityChecker::isPositionCommand(unsigned cmd){\n\tif( cmd == NAV_CMD_WAYPOINT ||\n\t\tcmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\tcmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\tcmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\tcmd == NAV_CMD_TAKEOFF ||\n\t\tcmd == NAV_CMD_VTOL_TAKEOFF ||\n\t\tcmd == NAV_CMD_LAND ||\n\t\tcmd == NAV_CMD_VTOL_LAND ||\n\t\tcmd == NAV_CMD_PATHPLANNING) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\n\t}\n}"
    },
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\t/* Set current position for loitering set point*/\n\t\t\tsp->lat = _navigator->get_global_position()->lat;\n\t\t\tsp->lon = _navigator->get_global_position()->lon;\n\t\t\tsp->alt = _navigator->get_global_position()->alt;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\tbreak;\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\tcase NAV_CMD_VTOL_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\tcase NAV_CMD_VTOL_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "Mission::altitude_sp_foh_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "Mission::altitude_sp_foh_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n\t\t\t!PX4_ISFINITE(_mission_item_previous_alt)) {\n\t\treturn;\n\t}\n\n\t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < 0.0f) {\n\t\treturn;\n\t}\n\n\t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n\t * and the FW controller has a custom landing logic */\n\tif (_mission_item.nav_cmd == NAV_CMD_LAND ||\n\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_LAND ||\n\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF) {\n\t\treturn;\n\t}\n\n\n\t/* Calculate distance to current waypoint */\n\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\n\t/* Save distance to waypoint if it is the smallest ever achieved, however make sure that\n\t * _min_current_sp_distance_xy is never larger than the distance between the current and the previous wp */\n\t_min_current_sp_distance_xy = math::min(math::min(d_current, _min_current_sp_distance_xy),\n\t\t\t_distance_current_previous);\n\n\t/* if the minimal distance is smaller then the acceptance radius, we should be at waypoint alt\n\t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n\tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n\t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n\t} else {\n\t\t/* update the altitude sp of the 'current' item in the sp triplet, but do not update the altitude sp\n\t\t* of the mission item as it is used to check if the mission item is reached\n\t\t* The setpoint is set linearly and such that the system reaches the current altitude at the acceptance\n\t\t* radius around the current waypoint\n\t\t**/\n\t\tfloat delta_alt = (get_absolute_altitude_for_item(_mission_item) - _mission_item_previous_alt);\n\t\tfloat grad = -delta_alt/(_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius));\n\t\tfloat a = _mission_item_previous_alt - grad * _distance_current_previous;\n\t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO: {\n\t\t\tmemset(&actuators, 0, sizeof(actuators));\n\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n\t\t\tactuators.timestamp = hrt_absolute_time();\n\t\t\tif (_actuator_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n\t\t\t} else {\n\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n\t\t\t{\n\t\t\t/* forward the command to other processes */\n\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n\t\t\tstruct vehicle_command_s cmd = {};\n\t\t\tcmd.command = _mission_item.nav_cmd;\n\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n\t\t\tif (_cmd_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t\t} else {\n\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* handle VTOL_LAND command */\n\tif(_waypoint_position_reached && _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\tstruct vehicle_command_s cmd = {};\n\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\tif (_cmd_pub != nullptr) {\n\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t} else {\n\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t}\n\t\treturn _navigator->get_vstatus()->condition_landed;\n\t}\n\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* set previous position setpoint to current */\n\tset_previous_pos_setpoint();\n\n\t/* Copy previous mission item altitude (can be extended to a copy of the full mission item if needed) */\n\tif (pos_sp_triplet->previous.valid) {\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && read_mission_item(true, true, &_mission_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (read_mission_item(false, true, &_mission_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\tif (pos_sp_triplet->current.valid) {\n\t\t_on_arrival_yaw = _mission_item.yaw;\n\t}\n\n\t/* do takeoff on first waypoint for rotary wing vehicles */\n\tif (_navigator->get_vstatus()->is_rotary_wing) {\n\t\t/* force takeoff if landed (additional protection) */\n\t\tif (!_takeoff && _navigator->get_vstatus()->condition_landed) {\n\t\t\t_need_takeoff = true;\n\t\t}\n\n\t\t/* new current mission item set, check if we need takeoff */\n\t\tif (_need_takeoff && (\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n\t\t\t_takeoff = true;\n\t\t\t_need_takeoff = false;\n\t\t}\n\t}\n\n\tif (_takeoff) {\n\t\t/* do takeoff before going to setpoint */\n\t\t/* set mission item as next position setpoint */\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n\t\t/* next SP is not takeoff anymore */\n\t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\t/* calculate takeoff altitude */\n\t\tfloat takeoff_alt = get_absolute_altitude_for_item(_mission_item);\n\n\t\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n\n\t\t} else {\n\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n\t\t}\n\n\t\t/* check if we already above takeoff altitude */\n\t\tif (_navigator->get_global_position()->alt < takeoff_alt) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\n\t\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\treturn;\n\n\t\t} else {\n\t\t\t/* skip takeoff */\n\t\t\t_takeoff = false;\n\t\t}\n\t}\n\n\tif (_takeoff_finished) {\n\n\t\t/* handle VTOL TAKEOFF command */\n\t\tif(_mission_item.nav_cmd == NAV_CMD_VTOL_TAKEOFF){\n\t\t\tstruct vehicle_command_s cmd = {};\n\t\t\tcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\tcmd.param1 = vehicle_status_s::VEHICLE_VTOL_STATE_FW;\n\t\t\tif (_cmd_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t\t} else {\n\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t\t}\n\t\t}\n\n\n\t\t/* we just finished takeoff */\n\t\t/* in case we still have to move to the takeoff waypoint we need a waypoint mission item */\n\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t_takeoff_finished = false;\n\t}\n\n\t/* set current position setpoint from mission item */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to read next mission item */\n\t\tstruct mission_item_s mission_item_next;\n\n\t\tif (read_mission_item(_mission_type == MISSION_TYPE_ONBOARD, false, &mission_item_next)) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(pos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionFeasibilityChecker::checkMissionItemValidity": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed) {\n\t// do not allow mission if we find unsupported item\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t// not supposed to happen unless the datamanager can't access the SD card, etc.\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Cannot access SD card\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we find unsupported items and reject mission if so\n\t\tif (missionitem.nav_cmd != NAV_CMD_IDLE &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_WAYPOINT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n\t\t\t/* not yet supported: missionitem.nav_cmd != NAV_CMD_LOITER_TURN_COUNT && */\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LAND &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_VTOL_LAND) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the mission starts with a land command while the vehicle is landed\n\t\tif (missionitem.nav_cmd == NAV_CMD_LAND &&\n\t\t\ti == 0 &&\n\t\t\tcondition_landed) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission that starts with LAND command while vehicle is landed.\");\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\treturn true;\n}"
    },
    "MissionBlock::MissionBlock": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n\tNavigatorMode(navigator, name),\n\t_mission_item({0}"
    },
    "Mission::heading_sp_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "129ba27f7ffcfbcbc274ef1b4d91a56b9a1e8593",
      "source": "Mission::heading_sp_update()\n{\n\tif (_takeoff) {\n\t\t/* we don't want to be yawing during takeoff */\n\t\treturn;\n\t}\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n\t\t\t!PX4_ISFINITE(_on_arrival_yaw)) {\n\t\treturn;\n\t}\n\n\t/* Don't change heading for takeoff waypoints, the ground may be near */\n\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\treturn;\n\t}\n\n\t/* set yaw angle for the waypoint iff a loiter time has been specified */\n\tif (_waypoint_position_reached && _mission_item.time_inside > 0.0f) {\n\t\t_mission_item.yaw = _on_arrival_yaw;\n\t} else {\n\n\t\t/* calculate direction the vehicle should point to:\n\t\t * normal waypoint: current position to {waypoint or home or home + 180deg}\n\t\t * landing waypoint: last waypoint to {waypoint or home or home + 180deg}\n\t\t * For landing the last waypoint (= constant) is used to avoid excessive yawing near the ground\n\t\t */\n\t\tdouble point_from_latlon[2];\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_VTOL_LAND) {\n\t\t\tpoint_from_latlon[0] = pos_sp_triplet->previous.lat;\n\t\t\tpoint_from_latlon[1] = pos_sp_triplet->previous.lon;\n\t\t} else {\n\t\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n\t\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n\t\t}\n\n\t\t/* always keep the front of the rotary wing pointing to the next waypoint */\n\t\tif (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT\n\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\t_mission_item.lat,\n\t\t\t\t_mission_item.lon);\n\t\t/* always keep the back of the rotary wing pointing towards home */\n\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME) {\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\t_navigator->get_home_position()->lat,\n\t\t\t\t_navigator->get_home_position()->lon);\n\t\t/* always keep the back of the rotary wing pointing towards home */\n\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n\t\t\t_mission_item.yaw = _wrap_pi(get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\t_navigator->get_home_position()->lat,\n\t\t\t\t_navigator->get_home_position()->lon) + M_PI_F);\n\t\t}\n\t}\n\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "3579": {
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "06b496e2578957ee73cfe4c013f2fe264d757e58",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO: {\n\t\t\tmemset(&actuators, 0, sizeof(actuators));\n\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n\t\t\tactuators.timestamp = hrt_absolute_time();\n\t\t\tif (_actuator_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n\t\t\t} else {\n\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\t\tcase NAV_CMD_LAND:\n\t\t\tif (!_navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\t\t\t} else {\n\t\t\t\tif (_waypoint_position_reached) {\n\t\t\t\t\t// the copter has reached the position of the landing spot\n\t\t\t\t\t// it can can start to descend\n\t\t\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n\t\t\t{\n\t\t\t/* forward the command to other processes */\n\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n\t\t\tstruct vehicle_command_s cmd = {};\n\t\t\tcmd.command = _mission_item.nav_cmd;\n\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n\t\t\tif (_cmd_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t\t} else {\n\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter */\n\n\t\t\t/* _mission_item.acceptance_radius is not always set */\n\t\t\tfloat mission_acceptance_radius = _mission_item.acceptance_radius;\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t// check if we have reached our landing spot\n\t\t\tif (dist_xy >= 0.0f && dist_xy <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
    },
    "MissionBlock::MissionBlock": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "06b496e2578957ee73cfe4c013f2fe264d757e58",
      "source": "MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n\tNavigatorMode(navigator, name),\n\t_mission_item({0}"
    }
  },
  "3582": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "6eac78d67529e20c3170092fd271c11c57c70f2f",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\t/* Set current position for loitering set point*/\n\t\t\tsp->lat = _navigator->get_global_position()->lat;\n\t\t\tsp->lon = _navigator->get_global_position()->lon;\n\t\t\tsp->alt = _navigator->get_global_position()->alt;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\tbreak;\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\n\t\tif (!_waypoint_position_reached) {\n\t\t\t// we first need to move to the landing waypoint\n\t\t\t// use the altitude specified in the mission item\n\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\t} else {\n\t\t\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\t}\n\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "6eac78d67529e20c3170092fd271c11c57c70f2f",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* set previous position setpoint to current */\n\tset_previous_pos_setpoint();\n\n\t/* Copy previous mission item altitude (can be extended to a copy of the full mission item if needed) */\n\tif (pos_sp_triplet->previous.valid) {\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && read_mission_item(true, true, &_mission_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (read_mission_item(false, true, &_mission_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\tif (pos_sp_triplet->current.valid) {\n\t\t_on_arrival_yaw = _mission_item.yaw;\n\t}\n\n\t/* do takeoff on first waypoint for rotary wing vehicles */\n\tif (_navigator->get_vstatus()->is_rotary_wing) {\n\t\t/* force takeoff if landed (additional protection) */\n\t\tif (!_takeoff && _navigator->get_vstatus()->condition_landed) {\n\t\t\t_need_takeoff = true;\n\t\t}\n\n\t\t/* new current mission item set, check if we need takeoff */\n\t\tif (_need_takeoff && (\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n\t\t\t_takeoff = true;\n\t\t\t_need_takeoff = false;\n\t\t}\n\t}\n\n\tif (_takeoff) {\n\t\t/* do takeoff before going to setpoint */\n\t\t/* set mission item as next position setpoint */\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n\t\t/* next SP is not takeoff anymore */\n\t\tpos_sp_triplet->next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\n\t\t/* calculate takeoff altitude */\n\t\tfloat takeoff_alt = get_absolute_altitude_for_item(_mission_item);\n\n\t\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n\n\t\t} else {\n\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n\t\t}\n\n\t\t/* check if we already above takeoff altitude */\n\t\tif (_navigator->get_global_position()->alt < takeoff_alt) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\n\t\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\treturn;\n\n\t\t} else {\n\t\t\t/* skip takeoff */\n\t\t\t_takeoff = false;\n\t\t}\n\t}\n\n\tif (_takeoff_finished) {\n\t\t/* we just finished takeoff */\n\t\t/* in case we still have to move to the takeoff waypoint we need a waypoint mission item */\n\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t_takeoff_finished = false;\n\t}\n\n\t/* set current position setpoint from mission item */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to read next mission item */\n\t\tstruct mission_item_s mission_item_next;\n\n\t\tif (read_mission_item(_mission_type == MISSION_TYPE_ONBOARD, false, &mission_item_next)) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(pos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBlock::mission_item_to_vehicle_command": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "6eac78d67529e20c3170092fd271c11c57c70f2f",
      "source": "MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd)\n{\n\t// we're expecting a mission command item here so assign the \"raw\" inputs to the command\n\t// (MAV_FRAME_MISSION mission item)\n\tcmd->param1 = item->params[0];\n\tcmd->param2 = item->params[1];\n\tcmd->param3 = item->params[2];\n\tcmd->param4 = item->params[3];\n\tcmd->param5 = item->params[4];\n\tcmd->param6 = item->params[5];\n\tcmd->param7 = item->params[6];\n\n\tcmd->target_system = _navigator->get_vstatus()->system_id;\n\tcmd->target_component = _navigator->get_vstatus()->component_id;\n\tcmd->source_system = _navigator->get_vstatus()->system_id;\n\tcmd->source_component = _navigator->get_vstatus()->component_id;\n\tcmd->confirmation = false;\n}"
    },
    "Mission::heading_sp_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "6eac78d67529e20c3170092fd271c11c57c70f2f",
      "source": "Mission::heading_sp_update()\n{\n\tif (_takeoff) {\n\t\t/* we don't want to be yawing during takeoff */\n\t\treturn;\n\t}\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n\t\t\t!PX4_ISFINITE(_on_arrival_yaw)) {\n\t\treturn;\n\t}\n\n\t/* Don't change heading for takeoff waypoints, the ground may be near */\n\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\treturn;\n\t}\n\n\t/* set yaw angle for the waypoint iff a loiter time has been specified */\n\tif (_waypoint_position_reached && _mission_item.time_inside > 0.0f) {\n\t\t_mission_item.yaw = _on_arrival_yaw;\n\t} else {\n\n\t\t/* calculate direction the vehicle should point to:\n\t\t * normal waypoint: current position to {waypoint or home or home + 180deg}\n\t\t * landing waypoint: last waypoint to {waypoint or home or home + 180deg}\n\t\t * For landing the last waypoint (= constant) is used to avoid excessive yawing near the ground\n\t\t */\n\t\tdouble point_from_latlon[2];\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\tpoint_from_latlon[0] = pos_sp_triplet->previous.lat;\n\t\t\tpoint_from_latlon[1] = pos_sp_triplet->previous.lon;\n\t\t} else {\n\t\t\tpoint_from_latlon[0] = _navigator->get_global_position()->lat;\n\t\t\tpoint_from_latlon[1] = _navigator->get_global_position()->lon;\n\t\t}\n\n\t\t/* always keep the front of the rotary wing pointing to the next waypoint */\n\t\tif (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_WAYPOINT\n\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\t_mission_item.lat,\n\t\t\t\t_mission_item.lon);\n\t\t/* always keep the back of the rotary wing pointing towards home */\n\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_FRONT_TO_HOME) {\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\t_navigator->get_home_position()->lat,\n\t\t\t\t_navigator->get_home_position()->lon);\n\t\t/* always keep the back of the rotary wing pointing towards home */\n\t\t} else if (_param_yawmode.get() == MISSION_YAWMODE_BACK_TO_HOME) {\n\t\t\t_mission_item.yaw = _wrap_pi(get_bearing_to_next_waypoint(\n\t\t\t\tpoint_from_latlon[0],\n\t\t\t\tpoint_from_latlon[1],\n\t\t\t\t_navigator->get_home_position()->lat,\n\t\t\t\t_navigator->get_home_position()->lon) + M_PI_F);\n\t\t}\n\t}\n\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    }
  },
  "3523": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "170f9aec498c776d84db7a739a0602cc4977e3b6",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\t/* Set current position for loitering set point*/\n\t\t\tsp->lat = _navigator->get_global_position()->lat;\n\t\t\tsp->lon = _navigator->get_global_position()->lon;\n\t\t\tsp->alt = _navigator->get_global_position()->alt;\n\t\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\tbreak;\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "170f9aec498c776d84db7a739a0602cc4977e3b6",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid();\n\n\t/* check if anything has changed */\n\tbool onboard_updated = false;\n\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\tif (onboard_updated) {\n\t\tupdate_onboard_mission();\n\t}\n\n\tbool offboard_updated = false;\n\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\tif (offboard_updated) {\n\t\tupdate_offboard_mission();\n\t}\n\n\t/* reset mission items if needed */\n\tif (onboard_updated || offboard_updated) {\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached()) {\n\t\tset_mission_item_reached();\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\n\t\t}\n\n\t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n\t\taltitude_sp_foh_update();\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading for rotary wing types */\n\tif (_navigator->get_vstatus()->is_rotary_wing\n\t\t\t&& _param_yawmode.get() != MISSION_YAWMODE_NONE\n\t\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n\t\t\t&& _mission_type != MISSION_TYPE_NONE) {\n\t\theading_sp_update();\n\t}\n\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "170f9aec498c776d84db7a739a0602cc4977e3b6",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO: {\n\t\t\tmemset(&actuators, 0, sizeof(actuators));\n\t\t\tactuators.control[_mission_item.actuator_num] = 1.0f / 2000 * -_mission_item.actuator_value;\n\t\t\tactuators.timestamp = hrt_absolute_time();\n\t\t\tif (_actuator_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(actuator_controls_2), _actuator_pub, &actuators);\n\t\t\t} else {\n\t\t\t\t_actuator_pub = orb_advertise(ORB_ID(actuator_controls_2), &actuators);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL: /* fallthrough */\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION:\n\t\t\t{\n\t\t\t/* forward the command to other processes */\n\t\t\twarnx(\"got instantaneous command, forwarding.\\n\");\n\t\t\tstruct vehicle_command_s cmd = {};\n\t\t\tcmd.command = _mission_item.nav_cmd;\n\t\t\tmission_item_to_vehicle_command(&_mission_item, &cmd);\n\t\t\tif (_cmd_pub != nullptr) {\n\t\t\t\torb_publish(ORB_ID(vehicle_command), _cmd_pub, &cmd);\n\t\t\t} else {\n\t\t\t\t_cmd_pub = orb_advertise(ORB_ID(vehicle_command), &cmd);\n\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter */\n\n\t\t\t/* _mission_item.acceptance_radius is not always set */\n\t\t\tfloat mission_acceptance_radius = _mission_item.acceptance_radius;\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    }
  },
  "3571": {
    "MissionFeasibilityChecker::MissionFeasibilityChecker": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "MissionFeasibilityChecker::MissionFeasibilityChecker() :\n\t_mavlink_fd(-1),\n\t_capabilities_sub(-1),\n\t_initDone(false),\n\t_dist_1wp_ok(false)\n{\n\t_nav_caps = {0};\n}"
    },
    "checkMissionItemValidity": {
      "file": "src/modules/navigator/mission_feasibility_checker.h",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "bool checkHomePositionAltitude(dm_item_t dm_current, size_t nMissionItems, float home_alt, bool home_valid, bool &warning_issued, bool throw_error = false);\n\tbool checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems);\n\tbool check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued);\n\n\t/* Checks specific to fixedwing airframes */\n\tbool checkMissionFeasibleFixedwing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid);\n\tbool checkFixedWingLanding(dm_item_t dm_current, size_t nMissionItems);\n\tvoid updateNavigationCapabilities();\n\n\t/* Checks specific to rotarywing airframes */\n\tbool checkMissionFeasibleRotarywing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid, float default_acceptance_rad);\npublic:\n\n\tMissionFeasibilityChecker();\n\t~MissionFeasibilityChecker() {}"
    },
    "MissionFeasibilityChecker::checkHomePositionAltitude": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "bool MissionFeasibilityChecker::checkHomePositionAltitude(dm_item_t dm_current, size_t nMissionItems,\n\tfloat home_alt, bool home_valid, bool &warning_issued, bool throw_error)\n{\n\t/* Check if all all waypoints are above the home altitude, only return false if bool throw_error = true */\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\twarning_issued = true;\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\treturn false;\n\t\t}\n\n\t\t/* always reject relative alt without home set */\n\t\tif (missionitem.altitude_is_relative && !home_valid) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: No home pos, WP %d uses rel alt\", i);\n\t\t\twarning_issued = true;\n\t\t\treturn false;\n\t\t}\n\n\t\t/* calculate the global waypoint altitude */\n\t\tfloat wp_alt = (missionitem.altitude_is_relative) ? missionitem.altitude + home_alt : missionitem.altitude;\n\n\t\tif (home_alt > wp_alt) {\n\n\t\t\twarning_issued = true;\n\n\t\t\tif (throw_error) {\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Waypoint %d below home\", i);\n\t\t\t\treturn false;\n\t\t\t} else\t{\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Waypoint %d below home\", i);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}"
    },
    "MissionFeasibilityChecker::checkMissionFeasible": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "bool MissionFeasibilityChecker::checkMissionFeasible(int mavlink_fd, bool isRotarywing,\n\tdm_item_t dm_current, size_t nMissionItems, Geofence &geofence,\n\tfloat home_alt, bool home_valid, double curr_lat, double curr_lon, float max_waypoint_distance, bool &warning_issued,\n\tfloat default_acceptance_rad)\n{\n\tbool failed = false;\n\tbool warned = false;\n\t/* Init if not done yet */\n\tinit();\n\n\t_mavlink_fd = mavlink_fd;\n\n\t// first check if we have a valid position\n\tif (!home_valid /* can later use global / local pos for finer granularity */) {\n\t\tfailed = true;\n\t\twarned = true;\n\t\tmavlink_log_info(_mavlink_fd, \"Not yet ready for mission, no position lock.\");\n\t} else {\n\t\tfailed = failed || !check_dist_1wp(dm_current, nMissionItems, curr_lat, curr_lon, max_waypoint_distance, warning_issued);\n\t}\n\n\t// check if all mission item commands are supported\n\tfailed = failed || !checkMissionItemValidity(dm_current, nMissionItems);\n\tfailed = failed || !checkGeofence(dm_current, nMissionItems, geofence);\n\tfailed = failed || !checkHomePositionAltitude(dm_current, nMissionItems, home_alt, home_valid, warned);\n\n\tif (isRotarywing) {\n\t\tfailed = failed || !checkMissionFeasibleRotarywing(dm_current, nMissionItems, geofence, home_alt, home_valid, default_acceptance_rad);\n\t} else {\n\t\tfailed = failed || !checkMissionFeasibleFixedwing(dm_current, nMissionItems, geofence, home_alt, home_valid);\n\t}\n\n\treturn !failed;\n}"
    },
    "MissionFeasibilityChecker::checkMissionItemValidity": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems) {\n\t// do not allow mission if we find unsupported item\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t// not supposed to happen unless the datamanager can't access the SD card, etc.\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Cannot access SD card\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we find unsupported item and reject mission if so\n\t\tif (missionitem.nav_cmd != NAV_CMD_IDLE &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_WAYPOINT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TURN_COUNT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LAND &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_DIGICAM_CONTROL &&\n\t\t\tmissionitem.nav_cmd != vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported action.\", (int)(i+1));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
    },
    "Mission::check_mission_valid": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "Mission::check_mission_valid()\n{\n\t/* check if the home position became valid in the meantime */\n\tif (!_home_inited && _navigator->home_position_valid()) {\n\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\t_navigator->get_mission_result()->valid = _missionFeasiblityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius());\n\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t\t_home_inited = true;\n\t}\n\n\treturn _navigator->get_mission_result()->valid;\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "c2aaeefa6c42838f1234a4389767a2f17d5be02c",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasiblityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius());\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    }
  },
  "3567": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "2a2dca84bfddef0a5194b85541a6579a8acf2e6d",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\t/* don't change the setpoint for non-position items */\n\tif (!item_contains_position(item)) {\n\t\treturn;\n\t}\n\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\tsp->disable_mc_yaw_control = false;\n\tsp->cruising_speed = _navigator->get_cruising_speed();\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_loiter.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "Navigator::get_acceptance_radius": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "2a2dca84bfddef0a5194b85541a6579a8acf2e6d",
      "source": "Navigator::get_acceptance_radius()\n{\n\treturn get_acceptance_radius(_param_acceptance_radius.get());\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "2a2dca84bfddef0a5194b85541a6579a8acf2e6d",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\tcase NAV_CMD_DO_SET_CAM_TRIGG_DIST:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tcase vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED:\n\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\tif (_mission_item.params[1] > 0.0f) {\n\t\t\t\t_navigator->set_cruising_speed(_mission_item.params[1]);\n\t\t\t} else {\n\t\t\t\t_navigator->set_cruising_speed();\n\t\t\t}\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif ((_navigator->get_vstatus()->condition_landed == false)\n\t\t&& !_waypoint_position_reached) {\n\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\n\t\tif (_waypoint_position_reached) {\n\t\t\t// reached just now\n\t\t\t_time_wp_reached = now;\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\t/* accept yaw if reached or if timeout is set in which case we ignore not forced headings */\n\t\t\tif (fabsf(yaw_err) < math::radians(_param_yaw_err.get())\n\t\t\t\t\t|| (_param_yaw_timeout.get() >= FLT_EPSILON && !_mission_item.force_heading)) {\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t\t/* if heading needs to be reached, the timeout is enabled and we don't make it, abort mission */\n\t\t\tif (!_waypoint_yaw_reached && _mission_item.force_heading &&\n\t\t\t\t\t\t_param_yaw_timeout.get() >= FLT_EPSILON &&\n\t\t\t\t\t\tnow - _time_wp_reached >= (hrt_abstime)_param_yaw_timeout.get() * 1e6f) {\n\t\t\t\t_navigator->set_mission_failure(\"unable to reach heading within timeout\");\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "MissionBlock::item_contains_position": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "2a2dca84bfddef0a5194b85541a6579a8acf2e6d",
      "source": "MissionBlock::item_contains_position(const struct mission_item_s *item)\n{\n\t// XXX: maybe extend that check onto item properties\n\tif (item->nav_cmd == NAV_CMD_DO_DIGICAM_CONTROL ||\n\t\t\titem->nav_cmd == NAV_CMD_DO_SET_CAM_TRIGG_DIST ||\n\t\t\titem->nav_cmd == NAV_CMD_DO_VTOL_TRANSITION ||\n\t\t\titem->nav_cmd == NAV_CMD_DO_SET_SERVO ||\n\t\t\titem->nav_cmd == NAV_CMD_DO_CHANGE_SPEED) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
    },
    "MissionFeasibilityChecker::checkMissionItemValidity": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "2a2dca84bfddef0a5194b85541a6579a8acf2e6d",
      "source": "bool MissionFeasibilityChecker::checkMissionItemValidity(dm_item_t dm_current, size_t nMissionItems, bool condition_landed) {\n\t// do not allow mission if we find unsupported item\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t// not supposed to happen unless the datamanager can't access the SD card, etc.\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting Mission: Cannot access SD card\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we find unsupported items and reject mission if so\n\t\tif (missionitem.nav_cmd != NAV_CMD_IDLE &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_WAYPOINT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_UNLIMITED &&\n\t\t\t/* not yet supported: missionitem.nav_cmd != NAV_CMD_LOITER_TURN_COUNT && */\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LOITER_TIME_LIMIT &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_LAND &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_TAKEOFF &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_PATHPLANNING &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_JUMP &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_SERVO &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_CHANGE_SPEED &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_DIGICAM_CONTROL &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_SET_CAM_TRIGG_DIST &&\n\t\t\tmissionitem.nav_cmd != NAV_CMD_DO_VTOL_TRANSITION) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission item %i: unsupported cmd: %d\", (int)(i+1), (int)missionitem.nav_cmd);\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the mission starts with a land command while the vehicle is landed\n\t\tif (missionitem.nav_cmd == NAV_CMD_LAND &&\n\t\t\ti == 0 &&\n\t\t\tcondition_landed) {\n\n\t\t\tmavlink_log_critical(_mavlink_fd, \"Rejecting mission that starts with LAND command while vehicle is landed.\");\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\treturn true;\n}"
    },
    "Navigator::Navigator": {
      "file": "src/modules/navigator/navigator_main.cpp",
      "commit": "2a2dca84bfddef0a5194b85541a6579a8acf2e6d",
      "source": "Navigator::Navigator() :\n\tSuperBlock(NULL, \"NAV\"),\n\t_task_should_exit(false),\n\t_navigator_task(-1),\n\t_mavlink_fd(-1),\n\t_global_pos_sub(-1),\n\t_gps_pos_sub(-1),\n\t_home_pos_sub(-1),\n\t_vstatus_sub(-1),\n\t_capabilities_sub(-1),\n\t_control_mode_sub(-1),\n\t_onboard_mission_sub(-1),\n\t_offboard_mission_sub(-1),\n\t_param_update_sub(-1),\n\t_vehicle_command_sub(-1),\n\t_pos_sp_triplet_pub(nullptr),\n\t_mission_result_pub(nullptr),\n\t_geofence_result_pub(nullptr),\n\t_att_sp_pub(nullptr),\n\t_vstatus{}"
    }
  },
  "3694": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\t/* don't change the setpoint for non-position items */\n\tif (!item_contains_position(item)) {\n\t\treturn;\n\t}\n\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\tsp->disable_mc_yaw_control = false;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tif(_navigator->get_vstatus()->is_vtol && _param_vtol_wv_land.get()){\n\t\t\tsp->disable_mc_yaw_control = true;\n\t\t}\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "MissionBlock::set_takeoff_item": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "MissionBlock::set_takeoff_item(struct mission_item_s *item, float min_clearance, float min_pitch)\n{\n\titem->nav_cmd = NAV_CMD_TAKEOFF;\n\n\t/* use current position and use return altitude as clearance */\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\titem->altitude = _navigator->get_global_position()->alt;\n\n\tif (min_clearance > 0.0f) {\n\t\titem->altitude += min_clearance;\n\n\t\t/* we must takeoff to a point further above ground than the acceptance radius */\n\t\tif (_navigator->get_acceptance_radius() > min_clearance) {\n\t\t\titem->altitude += _navigator->get_acceptance_radius();\n\t\t}\n\t}\n\n\titem->altitude_is_relative = false;\n\titem->yaw = NAN;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->loiter_direction = 1;\n\titem->time_inside = 0.0f;\n\titem->pitch_min = min_pitch;\n\titem->autocontinue = false;\n\titem->origin = ORIGIN_ONBOARD;\n}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tbool has_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* copy information about the previous mission item */\n\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n\t\t/* Copy previous mission item altitude */\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle position mission items */\n\tif (item_contains_position(&_mission_item)) {\n\n\t\t/* we have a new position item so set previous position setpoint to current */\n\t\tset_previous_pos_setpoint();\n\n\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\thas_next_position_item = true;\n\n\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t/* ignore yaw for takeoff items */\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t}\n\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\n\t\t\t/*\n\t\t\t * Ignoring waypoint altitude:\n\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t * what the altitude means on this waypoint type.\n\t\t\t */\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* we just moved to the landing waypoint, now descend */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* ignore yaw for landing items */\n\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t * that aligns the vehicle first */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t/* handle non-position mission items such as commands */\n\t} else {\n\n\t\t/* turn towards next waypoint before MC to FW transition */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& has_next_position_item) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\tmission_item_next_position.lat,\n\t\t\t\tmission_item_next_position.lon);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* don't advance mission after FW to MC command */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n\t\t}\n\n\t\t/* after FW to MC transition finish moving to the waypoint */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\n\t/* set current position setpoint from mission item (is protected agains non-position items) */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(&_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to process next mission item */\n\n\t\tif (has_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(\n\t\t\t\tpos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid();\n\n\t/* check if anything has changed */\n\tbool onboard_updated = false;\n\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\tif (onboard_updated) {\n\t\tupdate_onboard_mission();\n\t}\n\n\tbool offboard_updated = false;\n\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\tif (offboard_updated) {\n\t\tupdate_offboard_mission();\n\t}\n\n\t/* reset mission items if needed */\n\tif (onboard_updated || offboard_updated) {\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached()) {\n\t\tset_mission_item_reached();\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\n\t} else if (_mission_type != MISSION_TYPE_NONE && _param_altmode.get() == MISSION_ALTMODE_FOH) {\n\t\taltitude_sp_foh_update();\n\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif ((_param_yawmode.get() != MISSION_YAWMODE_NONE\n\t\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n\t\t\t&& _mission_type != MISSION_TYPE_NONE)\n\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n\t\theading_sp_update();\n\t}\n\n}"
    },
    "MissionFeasibilityChecker::check_dist_1wp": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued)\n{\n\n\t/* check if first waypoint is not too far from home */\n\tif (dist_first_wp > 0.0f) {\n\t\tstruct mission_item_s mission_item;\n\n\t\t/* find first waypoint (with lat/lon) item in datamanager */\n\t\tfor (unsigned i = 0; i < nMissionItems; i++) {\n\t\t\tif (dm_read(dm_current, i,\n\t\t\t\t\t&mission_item, sizeof(mission_item_s)) == sizeof(mission_item_s)) {\n\t\t\t\t/* Check non navigation item */\n\t\t\t\tif (mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO){\n\n\t\t\t\t\t/* check actuator number */\n\t\t\t\t\tif (mission_item.params[0] < 0 || mission_item.params[0] > 5) {\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.params[0]);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t/* check actuator value */\n\t\t\t\t\tif (mission_item.params[1] < -2000 || mission_item.params[1] > 2000) {\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.params[1]);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* check only items with valid lat/lon */\n\t\t\t\telse if (isPositionCommand(mission_item.nav_cmd)) {\n\n\t\t\t\t\t/* check distance from current position to item */\n\t\t\t\t\tfloat dist_to_1wp = get_distance_to_next_waypoint(\n\t\t\t\t\t\t\tmission_item.lat, mission_item.lon, curr_lat, curr_lon);\n\n\t\t\t\t\tif (dist_to_1wp < dist_first_wp) {\n\t\t\t\t\t\t_dist_1wp_ok = true;\n\t\t\t\t\t\tif (dist_to_1wp > ((dist_first_wp * 3) / 2)) {\n\t\t\t\t\t\t\t/* allow at 2/3 distance, but warn */\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: First waypoint very far: %d m\", (int)dist_to_1wp);\n\t\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* item is too far from home */\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"First waypoint too far: %d m,refusing mission\", (int)dist_to_1wp, (int)dist_first_wp);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* error reading, mission is invalid */\n\t\t\t\tmavlink_log_info(_mavlink_fd, \"error reading offboard mission\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* no waypoints found in mission, then we will not fly far away */\n\t\t_dist_1wp_ok = true;\n\t\treturn true;\n\n\t} else {\n\t\treturn true;\n\t}\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    },
    "waypoint": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\tmission_item_next_position.lat,\n\t\t\t\tmission_item_next_position.lon);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}"
    },
    "Mission::Mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::Mission(Navigator *navigator, const char *name) :\n\tMissionBlock(navigator, name),\n\t_param_onboard_enabled(this, \"MIS_ONBOARD_EN\", false),\n\t_param_takeoff_alt(this, \"MIS_TAKEOFF_ALT\", false),\n\t_param_dist_1wp(this, \"MIS_DIST_1WP\", false),\n\t_param_altmode(this, \"MIS_ALTMODE\", false),\n\t_param_yawmode(this, \"MIS_YAWMODE\", false),\n\t_onboard_mission{}"
    },
    "read_mission_item": {
      "file": "src/modules/navigator/mission.h",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "*/\n\tbool read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item);\n\n\t/**\n\t * Save current offboard mission state to dataman\n\t */\n\tvoid save_offboard_mission_state();\n\n\t/**\n\t * Inform about a changed mission item after a DO_JUMP\n\t */\n\tvoid report_do_jump_mission_changed(int index, int do_jumps_remaining);\n\n\t/**\n\t * Set a mission item as reached\n\t */\n\tvoid set_mission_item_reached();\n\n\t/**\n\t * Set the current offboard mission item\n\t */\n\tvoid set_current_offboard_mission_item();\n\n\t/**\n\t * Set that the mission is finished if one exists or that none exists\n\t */\n\tvoid set_mission_finished();\n\n\t/**\n\t * Check wether a mission is ready to go\n\t */\n\tbool check_mission_valid();\n\n\tcontrol::BlockParamInt _param_onboard_enabled;\n\tcontrol::BlockParamFloat _param_takeoff_alt;\n\tcontrol::BlockParamFloat _param_dist_1wp;\n\tcontrol::BlockParamInt _param_altmode;\n\tcontrol::BlockParamInt _param_yawmode;\n\n\tstruct mission_s _onboard_mission;\n\tstruct mission_s _offboard_mission;\n\n\tint _current_onboard_mission_index;\n\tint _current_offboard_mission_index;\n\tbool _need_takeoff;\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n\n\tenum {\n\t\tMISSION_TYPE_NONE,\n\t\tMISSION_TYPE_ONBOARD,\n\t\tMISSION_TYPE_OFFBOARD\n\t}"
    },
    "Mission::altitude_sp_foh_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::altitude_sp_foh_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n\t\t\t!PX4_ISFINITE(_mission_item_previous_alt)) {\n\t\treturn;\n\t}\n\n\t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < 0.0f) {\n\t\treturn;\n\t}\n\n\t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n\t * and the FW controller has a custom landing logic */\n\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\treturn;\n\t}\n\n\t/* Calculate distance to current waypoint */\n\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\n\t/* Save distance to waypoint if it is the smallest ever achieved, however make sure that\n\t * _min_current_sp_distance_xy is never larger than the distance between the current and the previous wp */\n\t_min_current_sp_distance_xy = math::min(math::min(d_current, _min_current_sp_distance_xy),\n\t\t\t_distance_current_previous);\n\n\t/* if the minimal distance is smaller then the acceptance radius, we should be at waypoint alt\n\t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n\tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n\t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n\n\t} else {\n\t\t/* update the altitude sp of the 'current' item in the sp triplet, but do not update the altitude sp\n\t\t* of the mission item as it is used to check if the mission item is reached\n\t\t* The setpoint is set linearly and such that the system reaches the current altitude at the acceptance\n\t\t* radius around the current waypoint\n\t\t**/\n\t\tfloat delta_alt = (get_absolute_altitude_for_item(_mission_item) - _mission_item_previous_alt);\n\t\tfloat grad = -delta_alt/(_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius));\n\t\tfloat a = _mission_item_previous_alt - grad * _distance_current_previous;\n\t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n\t}\n\n\t// we set altitude directly so we can run this in parallel to the heading update\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "Mission::read_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item)\n{\n\t/* select onboard/offboard mission */\n\tint *mission_index_ptr;\n\tdm_item_t dm_item;\n\n\tstruct mission_s *mission = (onboard) ? &_onboard_mission : &_offboard_mission;\n\tint current_index = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n\tint index_to_read = current_index + offset;\n\n\t/* do not work on empty missions */\n\tif (mission->count == 0) {\n\t\treturn false;\n\t}\n\n\tif (onboard) {\n\t\t/* onboard mission */\n\t\tmission_index_ptr = (offset == 0) ? &_current_onboard_mission_index : &index_to_read;\n\t\tdm_item = DM_KEY_WAYPOINTS_ONBOARD;\n\n\t} else {\n\t\t/* offboard mission */\n\t\tmission_index_ptr = (offset == 0) ? &_current_offboard_mission_index : &index_to_read;\n\t\tdm_item = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\t}\n\n\t/* Repeat this several times in case there are several DO JUMPS that we need to follow along, however, after\n\t * 10 iterations we have to assume that the DO JUMPS are probably cycling and give up. */\n\tfor (int i = 0; i < 10; i++) {\n\n\t\tif (*mission_index_ptr < 0 || *mission_index_ptr >= (int)mission->count) {\n\t\t\t/* mission item index out of bounds - if they are equal, we just reached the end */\n\t\t\tif (*mission_index_ptr != (int)mission->count) {\n\t\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_fd(), \"[wpm] err: index: %d, max: %d\", *mission_index_ptr, (int)mission->count);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t/* read mission item to temp storage first to not overwrite current mission item if data damaged */\n\t\tstruct mission_item_s mission_item_tmp;\n\n\t\t/* read mission item from datamanager */\n\t\tif (dm_read(dm_item, *mission_index_ptr, &mission_item_tmp, len) != len) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_fd(),\n\t\t\t                     \"ERROR waypoint could not be read\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/* check for DO_JUMP item, and whether it hasn't not already been repeated enough times */\n\t\tif (mission_item_tmp.nav_cmd == NAV_CMD_DO_JUMP) {\n\n\t\t\t/* do DO_JUMP as many times as requested */\n\t\t\tif (mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) {\n\n\t\t\t\t/* only raise the repeat count if this is for the current mission item\n\t\t\t\t* but not for the read ahead mission item */\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n\t\t\t\t\t/* save repeat count */\n\t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, DM_PERSIST_POWER_ON_RESET,\n\t\t\t\t\t    &mission_item_tmp, len) != len) {\n\t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the\n\t\t\t\t\t\t * dataman */\n\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(),\n\t\t\t\t\t\t\t\t     \"ERROR DO JUMP waypoint could not be written\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treport_do_jump_mission_changed(*mission_index_ptr,\n\t\t\t\t\t\t\t\t       mission_item_tmp.do_jump_repeat_count);\n\t\t\t\t}\n\t\t\t\t/* set new mission item index and repeat\n\t\t\t\t* we don't have to validate here, if it's invalid, we should realize this later .*/\n\t\t\t\t*mission_index_ptr = mission_item_tmp.do_jump_mission_index;\n\n\t\t\t} else {\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(),\n\t\t\t\t\t\t\t     \"DO JUMP repetitions completed\");\n\t\t\t\t}\n\t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */\n\t\t\t\t(*mission_index_ptr)++;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* if it's not a DO_JUMP, then we were successful */\n\t\t\tmemcpy(mission_item, &mission_item_tmp, sizeof(struct mission_item_s));\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* we have given up, we don't want to cycle forever */\n\tmavlink_log_critical(_navigator->get_mavlink_fd(),\n\t\t\t     \"ERROR DO JUMP is cycling, giving up\");\n\treturn false;\n}"
    },
    "MissionFeasibilityChecker::checkFixedWingLanding": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "bool MissionFeasibilityChecker::checkFixedWingLanding(dm_item_t dm_current, size_t nMissionItems)\n{\n\t/* Go through all mission items and search for a landing waypoint\n\t * if landing waypoint is found: the previous waypoint is checked to be at a feasible distance and altitude given the landing slope */\n\n\n\tfor (size_t i = 0; i < nMissionItems; i++) {\n\t\tstruct mission_item_s missionitem;\n\t\tconst ssize_t len = sizeof(missionitem);\n\t\tif (dm_read(dm_current, i, &missionitem, len) != len) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (missionitem.nav_cmd == NAV_CMD_LAND) {\n\t\t\tstruct mission_item_s missionitem_previous;\n\t\t\tif (i != 0) {\n\t\t\t\tif (dm_read(dm_current, i-1, &missionitem_previous, len) != len) {\n\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfloat wp_distance = get_distance_to_next_waypoint(missionitem_previous.lat , missionitem_previous.lon, missionitem.lat, missionitem.lon);\n\t\t\t\tfloat slope_alt_req = Landingslope::getLandingSlopeAbsoluteAltitude(wp_distance, missionitem.altitude, _nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad);\n\t\t\t\tfloat wp_distance_req = Landingslope::getLandingSlopeWPDistance(missionitem_previous.altitude, missionitem.altitude, _nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad);\n\t\t\t\tfloat delta_altitude = missionitem.altitude - missionitem_previous.altitude;\n//\t\t\t\twarnx(\"wp_distance %.2f, delta_altitude %.2f, missionitem_previous.altitude %.2f, missionitem.altitude %.2f, slope_alt_req %.2f, wp_distance_req %.2f\",\n//\t\t\t\t\t\twp_distance, delta_altitude, missionitem_previous.altitude, missionitem.altitude, slope_alt_req, wp_distance_req);\n//\t\t\t\twarnx(\"_nav_caps.landing_horizontal_slope_displacement %.4f, _nav_caps.landing_slope_angle_rad %.4f, _nav_caps.landing_flare_length %.4f\",\n//\t\t\t\t\t\t_nav_caps.landing_horizontal_slope_displacement, _nav_caps.landing_slope_angle_rad, _nav_caps.landing_flare_length);\n\n\t\t\t\tif (wp_distance > _nav_caps.landing_flare_length) {\n\t\t\t\t\t/* Last wp is before flare region */\n\n\t\t\t\t\tif (delta_altitude < 0) {\n\t\t\t\t\t\tif (missionitem_previous.altitude <= slope_alt_req) {\n\t\t\t\t\t\t\t/* Landing waypoint is at or below altitude of slope at the given waypoint distance: this is ok, aircraft will intersect the slope */\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Landing waypoint is above altitude of slope at the given waypoint distance */\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Landing: last waypoint too high/too close\");\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Move down to %.1fm or move further away by %.1fm\",\n\t\t\t\t\t\t\t\t\t(double)(slope_alt_req),\n\t\t\t\t\t\t\t\t\t(double)(wp_distance_req - wp_distance));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Landing waypoint is above last waypoint */\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Landing waypoint above last nav waypoint\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Last wp is in flare region */\n\t\t\t\t\t//xxx give recommendations\n\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: Landing: last waypoint in flare region\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: starting with land waypoint\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* No landing waypoints or no waypoints */\n\treturn true;\n}"
    },
    "Mission::altitude_sp_foh_reset": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "Mission::altitude_sp_foh_reset()\n{\n\t_min_current_sp_distance_xy = FLT_MAX;\n}"
    },
    "MissionBlock::mission_item_to_vehicle_command": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "MissionBlock::mission_item_to_vehicle_command(const struct mission_item_s *item, struct vehicle_command_s *cmd)\n{\n\t// we're expecting a mission command item here so assign the \"raw\" inputs to the command\n\t// (MAV_FRAME_MISSION mission item)\n\tcmd->param1 = item->params[0];\n\tcmd->param2 = item->params[1];\n\tcmd->param3 = item->params[2];\n\tcmd->param4 = item->params[3];\n\tcmd->param5 = item->params[4];\n\tcmd->param6 = item->params[5];\n\tcmd->param7 = item->params[6];\n\tcmd->command = item->nav_cmd;\n\n\tcmd->target_system = _navigator->get_vstatus()->system_id;\n\tcmd->target_component = _navigator->get_vstatus()->component_id;\n\tcmd->source_system = _navigator->get_vstatus()->system_id;\n\tcmd->source_component = _navigator->get_vstatus()->component_id;\n\tcmd->confirmation = false;\n}"
    },
    "MissionBlock::MissionBlock": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "b4ed79ad57935fad4f79163968f21c0f212d2796",
      "source": "MissionBlock::MissionBlock(Navigator *navigator, const char *name) :\n\tNavigatorMode(navigator, name),\n\t_mission_item({0}"
    }
  },
  "3459": {
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b2aa25448b3961a653c47013df3133f2918cf188",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* set previous position setpoint to current */\n\tset_previous_pos_setpoint();\n\n\t/* Copy previous mission item altitude (can be extended to a copy of the full mission item if needed) */\n\tif (pos_sp_triplet->previous.valid) {\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && read_mission_item(true, true, &_mission_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (read_mission_item(false, true, &_mission_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\tif (pos_sp_triplet->current.valid) {\n\t\t_on_arrival_yaw = _mission_item.yaw;\n\t}\n\n\t/* do takeoff on first waypoint for rotary wing vehicles */\n\tif (_navigator->get_vstatus()->is_rotary_wing) {\n\t\t/* force takeoff if landed (additional protection) */\n\t\tif (!_takeoff && _navigator->get_vstatus()->condition_landed) {\n\t\t\t_need_takeoff = true;\n\t\t}\n\n\t\t/* new current mission item set, check if we need takeoff */\n\t\tif (_need_takeoff && (\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_TAKEOFF ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_WAYPOINT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t\t_mission_item.nav_cmd == NAV_CMD_RETURN_TO_LAUNCH)) {\n\t\t\t_takeoff = true;\n\t\t\t_need_takeoff = false;\n\t\t}\n\t}\n\n\tif (_takeoff) {\n\t\t/* do takeoff before going to setpoint */\n\t\t/* set mission item as next position setpoint */\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->next);\n\n\t\t/* calculate takeoff altitude */\n\t\tfloat takeoff_alt = get_absolute_altitude_for_item(_mission_item);\n\n\t\t/* takeoff to at least NAV_TAKEOFF_ALT above home/ground, even if first waypoint is lower */\n\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_global_position()->alt + _param_takeoff_alt.get());\n\n\t\t} else {\n\t\t\ttakeoff_alt = fmaxf(takeoff_alt, _navigator->get_home_position()->alt + _param_takeoff_alt.get());\n\t\t}\n\n\t\t/* check if we already above takeoff altitude */\n\t\tif (_navigator->get_global_position()->alt < takeoff_alt) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\n\t\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\t\treturn;\n\n\t\t} else {\n\t\t\t/* skip takeoff */\n\t\t\t_takeoff = false;\n\t\t}\n\t}\n\n\t/* set current position setpoint from mission item */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to read next mission item */\n\t\tstruct mission_item_s mission_item_next;\n\n\t\tif (read_mission_item(_mission_type == MISSION_TYPE_ONBOARD, false, &mission_item_next)) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(pos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Mission::advance_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "b2aa25448b3961a653c47013df3133f2918cf188",
      "source": "Mission::advance_mission()\n{\n\tif (_takeoff) {\n\t\t_takeoff = false;\n\n\t} else {\n\t\tswitch (_mission_type) {\n\t\tcase MISSION_TYPE_ONBOARD:\n\t\t\t_current_onboard_mission_index++;\n\t\t\tbreak;\n\n\t\tcase MISSION_TYPE_OFFBOARD:\n\t\t\t_current_offboard_mission_index++;\n\t\t\tbreak;\n\n\t\tcase MISSION_TYPE_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
    }
  },
  "3598": {
    "MissionBlock::mission_item_to_position_setpoint": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "MissionBlock::mission_item_to_position_setpoint(const struct mission_item_s *item, struct position_setpoint_s *sp)\n{\n\t/* don't change the setpoint for non-position items */\n\tif (!item_contains_position(item)) {\n\t\treturn;\n\t}\n\n\tsp->valid = true;\n\tsp->lat = item->lat;\n\tsp->lon = item->lon;\n\tsp->alt = item->altitude_is_relative ? item->altitude + _navigator->get_home_position()->alt : item->altitude;\n\tsp->yaw = item->yaw;\n\tsp->loiter_radius = (item->loiter_radius > NAV_EPSILON_POSITION) ? item->loiter_radius :\n\t\t\t\t_navigator->get_loiter_radius();\n\tsp->loiter_direction = item->loiter_direction;\n\tsp->pitch_min = item->pitch_min;\n\tsp->acceptance_radius = item->acceptance_radius;\n\n\tswitch (item->nav_cmd) {\n\tcase NAV_CMD_IDLE:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\tbreak;\n\n\tcase NAV_CMD_TAKEOFF:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\tbreak;\n\n\tcase NAV_CMD_LAND:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LAND;\n\t\tbreak;\n\n\tcase NAV_CMD_LOITER_TIME_LIMIT:\n\tcase NAV_CMD_LOITER_TURN_COUNT:\n\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\tbreak;\n\n\tdefault:\n\t\tsp->type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t\tbreak;\n\t}\n}"
    },
    "Mission::set_mission_items": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "Mission::set_mission_items()\n{\n\t/* make sure param is up to date */\n\tupdateParams();\n\n\t/* reset the altitude foh logic, if altitude foh is enabled (param) a new foh element starts now */\n\taltitude_sp_foh_reset();\n\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* the home dist check provides user feedback, so we initialize it to this */\n\tbool user_feedback_done = false;\n\n\t/* mission item that comes after current if available */\n\tstruct mission_item_s mission_item_next_position;\n\tbool has_next_position_item = false;\n\n\twork_item_type new_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t/* copy information about the previous mission item */\n\tif (item_contains_position(&_mission_item) && pos_sp_triplet->current.valid) {\n\t\t/* Copy previous mission item altitude */\n\t\t_mission_item_previous_alt = get_absolute_altitude_for_item(_mission_item);\n\t}\n\n\t/* try setting onboard mission item */\n\tif (_param_onboard_enabled.get() && prepare_mission_items(true, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_ONBOARD) {\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"onboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_ONBOARD;\n\n\t/* try setting offboard mission item */\n\t} else if (prepare_mission_items(false, &_mission_item, &mission_item_next_position, &has_next_position_item)) {\n\t\t/* if mission type changed, notify */\n\t\tif (_mission_type != MISSION_TYPE_OFFBOARD) {\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"offboard mission now running\");\n\t\t\tuser_feedback_done = true;\n\t\t}\n\t\t_mission_type = MISSION_TYPE_OFFBOARD;\n\t} else {\n\t\t/* no mission available or mission finished, switch to loiter */\n\t\tif (_mission_type != MISSION_TYPE_NONE) {\n\t\t\t/* https://en.wikipedia.org/wiki/Loiter_(aeronautics) */\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"mission finished, loitering\");\n\t\t\tuser_feedback_done = true;\n\n\t\t\t/* use last setpoint for loiter */\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\n\t\t}\n\n\t\t_mission_type = MISSION_TYPE_NONE;\n\n\t\t/* set loiter mission item and ensure that there is a minimum clearance from home */\n\t\tset_loiter_item(&_mission_item, _param_takeoff_alt.get());\n\n\t\t/* update position setpoint triplet  */\n\t\tpos_sp_triplet->previous.valid = false;\n\t\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\t\tpos_sp_triplet->next.valid = false;\n\n\t\t/* reuse setpoint for LOITER only if it's not IDLE */\n\t\t_navigator->set_can_loiter_at_sp(pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\tset_mission_finished();\n\n\t\tif (!user_feedback_done) {\n\t\t\t/* only tell users that we got no mission if there has not been any\n\t\t\t * better, more specific feedback yet\n\t\t\t * https://en.wikipedia.org/wiki/Loiter_(aeronautics)\n\t\t\t */\n\n\t\t\tif (_navigator->get_vstatus()->condition_landed) {\n\t\t\t\t/* landed, refusing to take off without a mission */\n\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, refusing takeoff\");\n\t\t\t} else {\n\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(), \"no valid mission available, loitering\");\n\t\t\t}\n\n\t\t\tuser_feedback_done = true;\n\n\t\t}\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\t}\n\n\t/*********************************** handle mission item *********************************************/\n\n\t/* handle position mission items */\n\tif (item_contains_position(&_mission_item)) {\n\n\t\t/* we have a new position item so set previous position setpoint to current */\n\t\tset_previous_pos_setpoint();\n\n\t\t/* do takeoff before going to setpoint if needed and not already in takeoff */\n\t\tif (do_need_takeoff() && _work_item_type != WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_TAKEOFF;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\tmission_item_next_position.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\thas_next_position_item = true;\n\n\t\t\tfloat takeoff_alt = calculate_takeoff_altitude(&_mission_item);\n\n\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(), \"takeoff to %.1f meters above home\", (double)(takeoff_alt - _navigator->get_home_position()->alt));\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_TAKEOFF;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t/* ignore yaw for takeoff items */\n\t\t\t_mission_item.yaw = NAN;\n\t\t\t_mission_item.altitude = takeoff_alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* if we just did a takeoff navigate to the actual waypoint now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_TAKEOFF) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t}\n\n\t\t/* move to landing waypoint before descent if necessary */\n\t\tif (do_need_move_to_land() && _work_item_type != WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_MOVE_TO_LAND;\n\n\t\t\t/* use current mission item as next position item */\n\t\t\tmemcpy(&mission_item_next_position, &_mission_item, sizeof(struct mission_item_s));\n\t\t\thas_next_position_item = true;\n\n\t\t\t/*\n\t\t\t * Ignoring waypoint altitude:\n\t\t\t * Set altitude to the same as we have now to prevent descending too fast into\n\t\t\t * the ground. Actual landing will descend anyway until it touches down.\n\t\t\t * XXX: We might want to change that at some point if it is clear to the user\n\t\t\t * what the altitude means on this waypoint type.\n\t\t\t */\n\t\t\tfloat altitude = _navigator->get_global_position()->alt;\n\t\t\tif (pos_sp_triplet->current.valid) {\n\t\t\t\taltitude = pos_sp_triplet->current.alt;\n\t\t\t}\n\n\t\t\t_mission_item.altitude = altitude;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t\t/* we just moved to the landing waypoint, now descend */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_MOVE_TO_LAND) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* ignore yaw for landing items */\n\t\t/* XXX: if specified heading for landing is desired we could add another step before the descent\n\t\t * that aligns the vehicle first */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_LAND) {\n\t\t\t_mission_item.yaw = NAN;\n\t\t}\n\n\t/* handle non-position mission items such as commands */\n\t} else {\n\n\t\t/* turn towards next waypoint before MC to FW transition */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_ALIGN\n\t\t\t\t&& _navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& has_next_position_item) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_ALIGN;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = _navigator->get_global_position()->lat;\n\t\t\t_mission_item.lon = _navigator->get_global_position()->lon;\n\t\t\t_mission_item.altitude = _navigator->get_global_position()->alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t\t_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\tmission_item_next_position.lat,\n\t\t\t\tmission_item_next_position.lon);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}\n\n\t\t/* don't advance mission after FW to MC command */\n\t\tif (_mission_item.nav_cmd == NAV_CMD_DO_VTOL_TRANSITION\n\t\t\t\t&& _work_item_type != WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& !_navigator->get_vstatus()->is_rotary_wing\n\t\t\t\t&& !_navigator->get_vstatus()->condition_landed\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_CMD_BEFORE_MOVE;\n\t\t}\n\n\t\t/* after FW to MC transition finish moving to the waypoint */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_CMD_BEFORE_MOVE\n\t\t\t\t&& pos_sp_triplet->current.valid) {\n\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\n\t\t\t_mission_item.nav_cmd = NAV_CMD_WAYPOINT;\n\t\t\t_mission_item.lat = pos_sp_triplet->current.lat;\n\t\t\t_mission_item.lon = pos_sp_triplet->current.lon;\n\t\t\t_mission_item.altitude = pos_sp_triplet->current.alt;\n\t\t\t_mission_item.altitude_is_relative = false;\n\t\t\t_mission_item.autocontinue = true;\n\t\t\t_mission_item.time_inside = 0;\n\t\t}\n\n\t}\n\n\t/*********************************** set setpoints and check next *********************************************/\n\n\t/* set current position setpoint from mission item (is protected agains non-position items) */\n\tmission_item_to_position_setpoint(&_mission_item, &pos_sp_triplet->current);\n\n\t/* issue command if ready (will do nothing for position mission items) */\n\tissue_command(&_mission_item);\n\n\t/* set current work item type */\n\t_work_item_type = new_work_item_type;\n\n\t/* require takeoff after landing or idle */\n\tif (pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LAND || pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_IDLE) {\n\t\t_need_takeoff = true;\n\t}\n\n\t_navigator->set_can_loiter_at_sp(false);\n\treset_mission_item_reached();\n\n\tif (_mission_type == MISSION_TYPE_OFFBOARD) {\n\t\tset_current_offboard_mission_item();\n\t}\n\t// TODO: report onboard mission item somehow\n\n\tif (_mission_item.autocontinue && _mission_item.time_inside <= 0.001f) {\n\t\t/* try to process next mission item */\n\n\t\tif (has_next_position_item) {\n\t\t\t/* got next mission item, update setpoint triplet */\n\t\t\tmission_item_to_position_setpoint(&mission_item_next_position, &pos_sp_triplet->next);\n\t\t} else {\n\t\t\t/* next mission item is not available */\n\t\t\tpos_sp_triplet->next.valid = false;\n\t\t}\n\n\t} else {\n\t\t/* vehicle will be paused on current waypoint, don't set next item */\n\t\tpos_sp_triplet->next.valid = false;\n\t}\n\n\t/* Save the distance between the current sp and the previous one */\n\tif (pos_sp_triplet->current.valid && pos_sp_triplet->previous.valid) {\n\t\t_distance_current_previous = get_distance_to_next_waypoint(\n\t\t\t\tpos_sp_triplet->current.lat,\n\t\t\t\tpos_sp_triplet->current.lon,\n\t\t\t\tpos_sp_triplet->previous.lat,\n\t\t\t\tpos_sp_triplet->previous.lon);\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "Mission::on_active": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "Mission::on_active()\n{\n\tcheck_mission_valid();\n\n\t/* check if anything has changed */\n\tbool onboard_updated = false;\n\torb_check(_navigator->get_onboard_mission_sub(), &onboard_updated);\n\tif (onboard_updated) {\n\t\tupdate_onboard_mission();\n\t}\n\n\tbool offboard_updated = false;\n\torb_check(_navigator->get_offboard_mission_sub(), &offboard_updated);\n\tif (offboard_updated) {\n\t\tupdate_offboard_mission();\n\t}\n\n\t/* reset mission items if needed */\n\tif (onboard_updated || offboard_updated) {\n\t\tset_mission_items();\n\t}\n\n\t/* lets check if we reached the current mission item */\n\tif (_mission_type != MISSION_TYPE_NONE && is_mission_item_reached()) {\n\t\tset_mission_item_reached();\n\t\tif (_mission_item.autocontinue) {\n\t\t\t/* switch to next waypoint if 'autocontinue' flag set */\n\t\t\tadvance_mission();\n\t\t\tset_mission_items();\n\t\t}\n\n\t} else if (_mission_type != MISSION_TYPE_NONE &&_param_altmode.get() == MISSION_ALTMODE_FOH) {\n\t\taltitude_sp_foh_update();\n\n\t} else {\n\t\t/* if waypoint position reached allow loiter on the setpoint */\n\t\tif (_waypoint_position_reached && _mission_item.nav_cmd != NAV_CMD_IDLE) {\n\t\t\t_navigator->set_can_loiter_at_sp(true);\n\t\t}\n\t}\n\n\t/* see if we need to update the current yaw heading */\n\tif ((_param_yawmode.get() != MISSION_YAWMODE_NONE\n\t\t\t&& _param_yawmode.get() < MISSION_YAWMODE_MAX\n\t\t\t&& _mission_type != MISSION_TYPE_NONE)\n\t\t\t|| _navigator->get_vstatus()->is_vtol) {\n\t\theading_sp_update();\n\t}\n\n}"
    },
    "MissionFeasibilityChecker::check_dist_1wp": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "MissionFeasibilityChecker::check_dist_1wp(dm_item_t dm_current, size_t nMissionItems, double curr_lat, double curr_lon, float dist_first_wp, bool &warning_issued)\n{\n\n\t/* check if first waypoint is not too far from home */\n\tif (dist_first_wp > 0.0f) {\n\t\tstruct mission_item_s mission_item;\n\n\t\t/* find first waypoint (with lat/lon) item in datamanager */\n\t\tfor (unsigned i = 0; i < nMissionItems; i++) {\n\t\t\tif (dm_read(dm_current, i,\n\t\t\t\t\t&mission_item, sizeof(mission_item_s)) == sizeof(mission_item_s)) {\n\t\t\t\t/* Check non navigation item */\n\t\t\t\tif (mission_item.nav_cmd == NAV_CMD_DO_SET_SERVO){\n\n\t\t\t\t\t/* check actuator number */\n\t\t\t\t\tif (mission_item.params[0] < 0 || mission_item.params[0] > 5) {\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator number %d is out of bounds 0..5\", (int)mission_item.params[0]);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t/* check actuator value */\n\t\t\t\t\tif (mission_item.params[1] < -2000 || mission_item.params[1] > 2000) {\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Actuator value %d is out of bounds -2000..2000\", (int)mission_item.params[1]);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* check only items with valid lat/lon */\n\t\t\t\telse if (isPositionCommand(mission_item.nav_cmd)) {\n\n\t\t\t\t\t/* check distance from current position to item */\n\t\t\t\t\tfloat dist_to_1wp = get_distance_to_next_waypoint(\n\t\t\t\t\t\t\tmission_item.lat, mission_item.lon, curr_lat, curr_lon);\n\n\t\t\t\t\tif (dist_to_1wp < dist_first_wp) {\n\t\t\t\t\t\t_dist_1wp_ok = true;\n\t\t\t\t\t\tif (dist_to_1wp > ((dist_first_wp * 3) / 2)) {\n\t\t\t\t\t\t\t/* allow at 2/3 distance, but warn */\n\t\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"Warning: First waypoint very far: %d m\", (int)dist_to_1wp);\n\t\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* item is too far from home */\n\t\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"First waypoint too far: %d m,refusing mission\", (int)dist_to_1wp, (int)dist_first_wp);\n\t\t\t\t\t\twarning_issued = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* error reading, mission is invalid */\n\t\t\t\tmavlink_log_info(_mavlink_fd, \"error reading offboard mission\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* no waypoints found in mission, then we will not fly far away */\n\t\t_dist_1wp_ok = true;\n\t\treturn true;\n\n\t} else {\n\t\treturn true;\n\t}\n}"
    },
    "Mission::update_offboard_mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "Mission::update_offboard_mission()\n{\n\tbool failed = true;\n\n\tif (orb_copy(ORB_ID(offboard_mission), _navigator->get_offboard_mission_sub(), &_offboard_mission) == OK) {\n\t\twarnx(\"offboard mission updated: dataman_id=%d, count=%d, current_seq=%d\", _offboard_mission.dataman_id, _offboard_mission.count, _offboard_mission.current_seq);\n\t\t/* determine current index */\n\t\tif (_offboard_mission.current_seq >= 0 && _offboard_mission.current_seq < (int)_offboard_mission.count) {\n\t\t\t_current_offboard_mission_index = _offboard_mission.current_seq;\n\t\t} else {\n\t\t\t/* if less items available, reset to first item */\n\t\t\tif (_current_offboard_mission_index >= (int)_offboard_mission.count) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\n\t\t\t/* if not initialized, set it to 0 */\n\t\t\t} else if (_current_offboard_mission_index < 0) {\n\t\t\t\t_current_offboard_mission_index = 0;\n\t\t\t}\n\t\t\t/* otherwise, just leave it */\n\t\t}\n\n\t\t/* Check mission feasibility, for now do not handle the return value,\n\t\t * however warnings are issued to the gcs via mavlink from inside the MissionFeasiblityChecker */\n\t\tdm_item_t dm_current = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\n\t\tfailed = !_missionFeasibilityChecker.checkMissionFeasible(_navigator->get_mavlink_fd(), _navigator->get_vstatus()->is_rotary_wing,\n\t\t\t\tdm_current, (size_t) _offboard_mission.count, _navigator->get_geofence(),\n\t\t\t\t_navigator->get_home_position()->alt, _navigator->home_position_valid(),\n\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon,\n\t\t\t\t_param_dist_1wp.get(), _navigator->get_mission_result()->warning, _navigator->get_acceptance_radius(),\n\t\t\t\t_navigator->get_vstatus()->condition_landed);\n\n\t\t_navigator->get_mission_result()->valid = !failed;\n\t\t_navigator->increment_mission_instance_count();\n\t\t_navigator->set_mission_result_updated();\n\n\t} else {\n\t\tPX4_WARN(\"offboard mission update failed, handle: %d\", _navigator->get_offboard_mission_sub());\n\t}\n\n\tif (failed) {\n\t\t_offboard_mission.count = 0;\n\t\t_offboard_mission.current_seq = 0;\n\t\t_current_offboard_mission_index = 0;\n\n\t\twarnx(\"mission check failed\");\n\t}\n\n\tset_current_offboard_mission_item();\n}"
    },
    "waypoint": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "_mission_item.yaw = get_bearing_to_next_waypoint(\n\t\t\t\t_navigator->get_global_position()->lat,\n\t\t\t\t_navigator->get_global_position()->lon,\n\t\t\t\tmission_item_next_position.lat,\n\t\t\t\tmission_item_next_position.lon);\n\t\t}\n\n\t\t/* yaw is aligned now */\n\t\tif (_work_item_type == WORK_ITEM_TYPE_ALIGN) {\n\t\t\tnew_work_item_type = WORK_ITEM_TYPE_DEFAULT;\n\t\t}"
    },
    "Mission::Mission": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "Mission::Mission(Navigator *navigator, const char *name) :\n\tMissionBlock(navigator, name),\n\t_param_onboard_enabled(this, \"MIS_ONBOARD_EN\", false),\n\t_param_takeoff_alt(this, \"MIS_TAKEOFF_ALT\", false),\n\t_param_dist_1wp(this, \"MIS_DIST_1WP\", false),\n\t_param_altmode(this, \"MIS_ALTMODE\", false),\n\t_param_yawmode(this, \"MIS_YAWMODE\", false),\n\t_onboard_mission{}"
    },
    "read_mission_item": {
      "file": "src/modules/navigator/mission.h",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "*/\n\tbool read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item);\n\n\t/**\n\t * Save current offboard mission state to dataman\n\t */\n\tvoid save_offboard_mission_state();\n\n\t/**\n\t * Inform about a changed mission item after a DO_JUMP\n\t */\n\tvoid report_do_jump_mission_changed(int index, int do_jumps_remaining);\n\n\t/**\n\t * Set a mission item as reached\n\t */\n\tvoid set_mission_item_reached();\n\n\t/**\n\t * Set the current offboard mission item\n\t */\n\tvoid set_current_offboard_mission_item();\n\n\t/**\n\t * Set that the mission is finished if one exists or that none exists\n\t */\n\tvoid set_mission_finished();\n\n\t/**\n\t * Check wether a mission is ready to go\n\t */\n\tbool check_mission_valid();\n\n\tcontrol::BlockParamInt _param_onboard_enabled;\n\tcontrol::BlockParamFloat _param_takeoff_alt;\n\tcontrol::BlockParamFloat _param_dist_1wp;\n\tcontrol::BlockParamInt _param_altmode;\n\tcontrol::BlockParamInt _param_yawmode;\n\n\tstruct mission_s _onboard_mission;\n\tstruct mission_s _offboard_mission;\n\n\tint _current_onboard_mission_index;\n\tint _current_offboard_mission_index;\n\tbool _need_takeoff;\t\t\t\t\t/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */\n\n\tenum {\n\t\tMISSION_TYPE_NONE,\n\t\tMISSION_TYPE_ONBOARD,\n\t\tMISSION_TYPE_OFFBOARD\n\t}"
    },
    "Mission::altitude_sp_foh_update": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "Mission::altitude_sp_foh_update()\n{\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t/* Don't change setpoint if last and current waypoint are not valid */\n\tif (!pos_sp_triplet->previous.valid || !pos_sp_triplet->current.valid ||\n\t\t\t!PX4_ISFINITE(_mission_item_previous_alt)) {\n\t\treturn;\n\t}\n\n\t/* Do not try to find a solution if the last waypoint is inside the acceptance radius of the current one */\n\tif (_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius) < 0.0f) {\n\t\treturn;\n\t}\n\n\t/* Don't do FOH for landing and takeoff waypoints, the ground may be near\n\t * and the FW controller has a custom landing logic */\n\tif (_mission_item.nav_cmd == NAV_CMD_LAND || _mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\treturn;\n\t}\n\n\n\t/* Calculate distance to current waypoint */\n\tfloat d_current = get_distance_to_next_waypoint(_mission_item.lat, _mission_item.lon,\n\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\n\t/* Save distance to waypoint if it is the smallest ever achieved, however make sure that\n\t * _min_current_sp_distance_xy is never larger than the distance between the current and the previous wp */\n\t_min_current_sp_distance_xy = math::min(math::min(d_current, _min_current_sp_distance_xy),\n\t\t\t_distance_current_previous);\n\n\t/* if the minimal distance is smaller then the acceptance radius, we should be at waypoint alt\n\t * navigator will soon switch to the next waypoint item (if there is one) as soon as we reach this altitude */\n\tif (_min_current_sp_distance_xy < _navigator->get_acceptance_radius(_mission_item.acceptance_radius)) {\n\t\tpos_sp_triplet->current.alt = get_absolute_altitude_for_item(_mission_item);\n\t} else {\n\t\t/* update the altitude sp of the 'current' item in the sp triplet, but do not update the altitude sp\n\t\t* of the mission item as it is used to check if the mission item is reached\n\t\t* The setpoint is set linearly and such that the system reaches the current altitude at the acceptance\n\t\t* radius around the current waypoint\n\t\t**/\n\t\tfloat delta_alt = (get_absolute_altitude_for_item(_mission_item) - _mission_item_previous_alt);\n\t\tfloat grad = -delta_alt/(_distance_current_previous - _navigator->get_acceptance_radius(_mission_item.acceptance_radius));\n\t\tfloat a = _mission_item_previous_alt - grad * _distance_current_previous;\n\t\tpos_sp_triplet->current.alt = a + grad * _min_current_sp_distance_xy;\n\n\t}\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}"
    },
    "MissionBlock::is_mission_item_reached": {
      "file": "src/modules/navigator/mission_block.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "MissionBlock::is_mission_item_reached()\n{\n\t/* handle non-navigation or indefinite waypoints */\n\tswitch (_mission_item.nav_cmd) {\n\t\tcase NAV_CMD_DO_SET_SERVO:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_LAND:\n\t\t\treturn _navigator->get_vstatus()->condition_landed;\n\n\t\t/* TODO: count turns */\n\t\t/*_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT ||*/\n\t\tcase NAV_CMD_IDLE: /* fall through */\n\t\tcase NAV_CMD_LOITER_UNLIMITED:\n\t\t\treturn false;\n\n\t\tcase NAV_CMD_DO_DIGICAM_CONTROL:\n\t\t\treturn true;\n\n\t\tcase NAV_CMD_DO_VTOL_TRANSITION:\n\t\t\t/*\n\t\t\t * We wait half a second to give the transition command time to propagate.\n\t\t\t * As soon as the timeout is over or when we're in transition mode let the mission continue.\n\t\t\t */\n\t\t\tif (hrt_absolute_time() - _action_start > 500000 ||\n\t\t\t\t\t_navigator->get_vstatus()->in_transition_mode) {\n\t\t\t\t_action_start = 0;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* do nothing, this is a 3D waypoint */\n\t\t\tbreak;\n\t}\n\n\thrt_abstime now = hrt_absolute_time();\n\n\tif (!_waypoint_position_reached) {\n\t\tfloat dist = -1.0f;\n\t\tfloat dist_xy = -1.0f;\n\t\tfloat dist_z = -1.0f;\n\n\t\tfloat altitude_amsl = _mission_item.altitude_is_relative\n\t\t\t\t      ? _mission_item.altitude + _navigator->get_home_position()->alt\n\t\t\t              : _mission_item.altitude;\n\n\t\tdist = get_distance_to_point_global_wgs84(_mission_item.lat, _mission_item.lon, altitude_amsl,\n\t\t\t\t                          _navigator->get_global_position()->lat,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->lon,\n\t\t\t\t\t\t\t  _navigator->get_global_position()->alt,\n\t\t\t\t&dist_xy, &dist_z);\n\n\t\tif (_mission_item.nav_cmd == NAV_CMD_TAKEOFF && _navigator->get_vstatus()->is_rotary_wing) {\n\t\t\t/* require only altitude for takeoff for multicopter, do not use waypoint acceptance radius */\n\t\t\tif (_navigator->get_global_position()->alt >\n\t\t\t\taltitude_amsl - _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (_mission_item.nav_cmd == NAV_CMD_TAKEOFF) {\n\t\t\t/* for takeoff mission items use the parameter for the takeoff acceptance radius */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius()) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else if (!_navigator->get_vstatus()->is_rotary_wing &&\n\t\t\t(_mission_item.nav_cmd == NAV_CMD_LOITER_UNLIMITED ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TIME_LIMIT ||\n\t\t\t_mission_item.nav_cmd == NAV_CMD_LOITER_TURN_COUNT)) {\n\t\t\t/* Loiter mission item on a non rotary wing: the aircraft is going to circle the\n\t\t\t * coordinates with a radius equal to the loiter_radius field. It is not flying\n\t\t\t * through the waypoint center.\n\t\t\t * Therefore the item is marked as reached once the system reaches the loiter\n\t\t\t * radius (+ some margin). Time inside and turn count is handled elsewhere.\n\t\t\t */\n\t\t\tif (dist >= 0.0f && dist <= _navigator->get_acceptance_radius(_mission_item.loiter_radius * 1.2f)) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* for normal mission items used their acceptance radius */\n\t\t\tfloat mission_acceptance_radius = _navigator->get_acceptance_radius(_mission_item.acceptance_radius);\n\n\t\t\t/* if set to zero use the default instead */\n\t\t\tif (mission_acceptance_radius < NAV_EPSILON_POSITION) {\n\t\t\t\tmission_acceptance_radius = _navigator->get_acceptance_radius();\n\t\t\t}\n\n\t\t\tif (dist >= 0.0f && dist <= mission_acceptance_radius) {\n\t\t\t\t_waypoint_position_reached = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the waypoint and the requested yaw setpoint. */\n\tif (_waypoint_position_reached && !_waypoint_yaw_reached) {\n\n\t\t/* TODO: removed takeoff, why? */\n\t\tif (_navigator->get_vstatus()->is_rotary_wing && PX4_ISFINITE(_mission_item.yaw)) {\n\n\t\t\t/* check yaw if defined only for rotary wing except takeoff */\n\t\t\tfloat yaw_err = _wrap_pi(_mission_item.yaw - _navigator->get_global_position()->yaw);\n\n\t\t\tif (fabsf(yaw_err) < 0.2f) { /* TODO: get rid of magic number */\n\t\t\t\t_waypoint_yaw_reached = true;\n\t\t\t}\n\n\t\t} else {\n\t\t\t_waypoint_yaw_reached = true;\n\t\t}\n\t}\n\n\t/* Once the waypoint and yaw setpoint have been reached we can start the loiter time countdown */\n\tif (_waypoint_position_reached && _waypoint_yaw_reached) {\n\n\t\tif (_time_first_inside_orbit == 0) {\n\t\t\t_time_first_inside_orbit = now;\n\n\t\t\t// if (_mission_item.time_inside > 0.01f) {\n\t\t\t// \tmavlink_log_critical(_mavlink_fd, \"waypoint reached, wait for %.1fs\",\n\t\t\t// \t\t(double)_mission_item.time_inside);\n\t\t\t// }\n\t\t}\n\n\t\t/* check if the MAV was long enough inside the waypoint orbit */\n\t\tif (now - _time_first_inside_orbit >= (hrt_abstime)_mission_item.time_inside * 1e6f) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
    },
    "Mission::read_mission_item": {
      "file": "src/modules/navigator/mission.cpp",
      "commit": "a63197b82b0cc36abed21d269310196a65c757a6",
      "source": "Mission::read_mission_item(bool onboard, int offset, struct mission_item_s *mission_item)\n{\n\t/* select onboard/offboard mission */\n\tint *mission_index_ptr;\n\tdm_item_t dm_item;\n\n\tstruct mission_s *mission = (onboard) ? &_onboard_mission : &_offboard_mission;\n\tint current_index = (onboard) ? _current_onboard_mission_index : _current_offboard_mission_index;\n\tint index_to_read = current_index + offset;\n\n\t/* do not work on empty missions */\n\tif (mission->count == 0) {\n\t\treturn false;\n\t}\n\n\tif (onboard) {\n\t\t/* onboard mission */\n\t\tmission_index_ptr = (offset == 0) ? &_current_onboard_mission_index : &index_to_read;\n\t\tdm_item = DM_KEY_WAYPOINTS_ONBOARD;\n\n\t} else {\n\t\t/* offboard mission */\n\t\tmission_index_ptr = (offset == 0) ? &_current_offboard_mission_index : &index_to_read;\n\t\tdm_item = DM_KEY_WAYPOINTS_OFFBOARD(_offboard_mission.dataman_id);\n\t}\n\n\t/* Repeat this several times in case there are several DO JUMPS that we need to follow along, however, after\n\t * 10 iterations we have to assume that the DO JUMPS are probably cycling and give up. */\n\tfor (int i = 0; i < 10; i++) {\n\n\t\tif (*mission_index_ptr < 0 || *mission_index_ptr >= (int)mission->count) {\n\t\t\t/* mission item index out of bounds - if they are equal, we just reached the end */\n\t\t\tif (*mission_index_ptr != (int)mission->count) {\n\t\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_fd(), \"[wpm] err: index: %d, max: %d\", *mission_index_ptr, (int)mission->count);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tconst ssize_t len = sizeof(struct mission_item_s);\n\n\t\t/* read mission item to temp storage first to not overwrite current mission item if data damaged */\n\t\tstruct mission_item_s mission_item_tmp;\n\n\t\t/* read mission item from datamanager */\n\t\tif (dm_read(dm_item, *mission_index_ptr, &mission_item_tmp, len) != len) {\n\t\t\t/* not supposed to happen unless the datamanager can't access the SD card, etc. */\n\t\t\tmavlink_and_console_log_critical(_navigator->get_mavlink_fd(),\n\t\t\t                     \"ERROR waypoint could not be read\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/* check for DO_JUMP item, and whether it hasn't not already been repeated enough times */\n\t\tif (mission_item_tmp.nav_cmd == NAV_CMD_DO_JUMP) {\n\n\t\t\t/* do DO_JUMP as many times as requested */\n\t\t\tif (mission_item_tmp.do_jump_current_count < mission_item_tmp.do_jump_repeat_count) {\n\n\t\t\t\t/* only raise the repeat count if this is for the current mission item\n\t\t\t\t* but not for the read ahead mission item */\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\t(mission_item_tmp.do_jump_current_count)++;\n\t\t\t\t\t/* save repeat count */\n\t\t\t\t\tif (dm_write(dm_item, *mission_index_ptr, DM_PERSIST_POWER_ON_RESET,\n\t\t\t\t\t    &mission_item_tmp, len) != len) {\n\t\t\t\t\t\t/* not supposed to happen unless the datamanager can't access the\n\t\t\t\t\t\t * dataman */\n\t\t\t\t\t\tmavlink_log_critical(_navigator->get_mavlink_fd(),\n\t\t\t\t\t\t\t\t     \"ERROR DO JUMP waypoint could not be written\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treport_do_jump_mission_changed(*mission_index_ptr,\n\t\t\t\t\t\t\t\t       mission_item_tmp.do_jump_repeat_count);\n\t\t\t\t}\n\t\t\t\t/* set new mission item index and repeat\n\t\t\t\t* we don't have to validate here, if it's invalid, we should realize this later .*/\n\t\t\t\t*mission_index_ptr = mission_item_tmp.do_jump_mission_index;\n\n\t\t\t} else {\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\tmavlink_log_info(_navigator->get_mavlink_fd(),\n\t\t\t\t\t\t\t     \"DO JUMP repetitions completed\");\n\t\t\t\t}\n\t\t\t\t/* no more DO_JUMPS, therefore just try to continue with next mission item */\n\t\t\t\t(*mission_index_ptr)++;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* if it's not a DO_JUMP, then we were successful */\n\t\t\tmemcpy(mission_item, &mission_item_tmp, sizeof(struct mission_item_s));\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* we have given up, we don't want to cycle forever */\n\tmavlink_log_critical(_navigator->get_mavlink_fd(),\n\t\t\t     \"ERROR DO JUMP is cycling, giving up\");\n\treturn false;\n}"
    }
  },
  "3518": {
    "MissionFeasibilityChecker::MissionFeasibilityChecker": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "170f9aec498c776d84db7a739a0602cc4977e3b6",
      "source": "MissionFeasibilityChecker::MissionFeasibilityChecker() :\n\t_mavlink_fd(-1),\n\t_capabilities_sub(-1),\n\t_initDone(false),\n\t_dist_1wp_ok(false)\n{\n\t_nav_caps = {0};\n}"
    },
    "MissionFeasibilityChecker::checkMissionFeasibleRotarywing": {
      "file": "src/modules/navigator/mission_feasibility_checker.cpp",
      "commit": "170f9aec498c776d84db7a739a0602cc4977e3b6",
      "source": "bool MissionFeasibilityChecker::checkMissionFeasibleRotarywing(dm_item_t dm_current, size_t nMissionItems, Geofence &geofence, float home_alt, bool home_valid)\n{\n\t/* no custom rotary wing checks yet */\n\treturn true;\n}"
    }
  }
}