print('''
    "source": "void RTL::find_RTL_destination()\n{\n\t// get home position:\n\thome_position_s &home_landing_position = *_navigator->get_home_position();\n\n\t// get global position\n\tconst vehicle_global_position_s &global_position = *_navigator->get_global_position();\n\n\t// set destination to home per default, then check if other valid landing spot is closer\n\t_destination.set(home_landing_position);\n\n\t// get distance to home position\n\tdouble dlat = home_landing_position.lat - global_position.lat;\n\tdouble dlon = home_landing_position.lon - global_position.lon;\n\n\tdouble lon_scale = cos(radians(global_position.lat));\n\n\tauto coord_dist_sq = [lon_scale](double lat_diff, double lon_diff) -> double {\n\t\tdouble lon_diff_scaled =  lon_scale * matrix::wrap(lon_diff, -180., 180.);\n\t\treturn lat_diff * lat_diff + lon_diff_scaled * lon_diff_scaled;\n\t};\n\n\tdouble min_dist_squared = coord_dist_sq(dlat, dlon);\n\n\t_destination.type = RTL_DESTINATION_HOME;\n\n\tconst bool vtol_in_rw_mode = _navigator->get_vstatus()->is_vtol\n\t\t\t\t     && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING;\n\n\n\t// consider the mission landing if not RTL_TYPE_HOME_OR_RALLY type set\n\tif (_param_rtl_type.get() != RTL_TYPE_HOME_OR_RALLY && _navigator->get_mission_start_land_available()) {\n\t\tdouble mission_landing_lat;\n\t\tdouble mission_landing_lon;\n\t\tfloat mission_landing_alt;\n\n\t\tif (vtol_in_rw_mode) {\n\t\t\tmission_landing_lat = _navigator->get_mission_landing_lat();\n\t\t\tmission_landing_lon = _navigator->get_mission_landing_lon();\n\t\t\tmission_landing_alt = _navigator->get_mission_landing_alt();\n\n\t\t} else {\n\t\t\tmission_landing_lat = _navigator->get_mission_landing_start_lat();\n\t\t\tmission_landing_lon = _navigator->get_mission_landing_start_lon();\n\t\t\tmission_landing_alt = _navigator->get_mission_landing_start_alt();\n\t\t}\n\n\t\tdlat = mission_landing_lat - global_position.lat;\n\t\tdlon = mission_landing_lon - global_position.lon;\n\t\tdouble dist_squared = coord_dist_sq(dlat, dlon);\n\n\t\t// always find closest destination if in hover and VTOL\n\t\tif (_param_rtl_type.get() == RTL_TYPE_CLOSEST || (vtol_in_rw_mode && !_navigator->on_mission_landing())) {\n\n\t\t\t// compare home position to landing position to decide which is closer\n\t\t\tif (dist_squared < min_dist_squared) {\n\t\t\t\t_destination.type = RTL_DESTINATION_MISSION_LANDING;\n\t\t\t\tmin_dist_squared = dist_squared;\n\t\t\t\t_destination.lat = mission_landing_lat;\n\t\t\t\t_destination.lon = mission_landing_lon;\n\t\t\t\t_destination.alt = mission_landing_alt;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// it has to be the mission landing\n\t\t\t_destination.type = RTL_DESTINATION_MISSION_LANDING;\n\t\t\tmin_dist_squared = dist_squared;\n\t\t\t_destination.lat = mission_landing_lat;\n\t\t\t_destination.lon = mission_landing_lon;\n\t\t\t_destination.alt = mission_landing_alt;\n\t\t}\n\t}\n\n\t// do not consider rally point if RTL type is set to RTL_TYPE_MISSION_LANDING_REVERSED, so exit function and use either home or mission landing\n\tif (_param_rtl_type.get() == RTL_TYPE_MISSION_LANDING_REVERSED) {\n                if (_param_rtl_cone_half_angle_deg.get() > 0\n                    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n                        _rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n\n                } else {\n                        _rtl_alt = max(global_position.alt, _destination.alt + _param_rtl_return_alt.get());\n                }\n\t\treturn;\n\t}\n\n\t// compare to safe landing positions\n\tmission_safe_point_s closest_safe_point {};\n\tmission_stats_entry_s stats;\n\tint ret = dm_read(DM_KEY_SAFE_POINTS, 0, &stats, sizeof(mission_stats_entry_s));\n\tint num_safe_points = 0;\n\n\tif (ret == sizeof(mission_stats_entry_s)) {\n\t\tnum_safe_points = stats.num_items;\n\t}\n\n\t// check if a safe point is closer than home or landing\n\tint closest_index = 0;\n\n\tfor (int current_seq = 1; current_seq <= num_safe_points; ++current_seq) {\n\t\tmission_safe_point_s mission_safe_point;\n\n\t\tif (dm_read(DM_KEY_SAFE_POINTS, current_seq, &mission_safe_point, sizeof(mission_safe_point_s)) !=\n\t\t    sizeof(mission_safe_point_s)) {\n\t\t\tPX4_ERR(\"dm_read failed\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// TODO: take altitude into account for distance measurement\n\t\tdlat = mission_safe_point.lat - global_position.lat;\n\t\tdlon = mission_safe_point.lon - global_position.lon;\n\t\tdouble dist_squared = coord_dist_sq(dlat, dlon);\n\n\t\tif (dist_squared < min_dist_squared) {\n\t\t\tclosest_index = current_seq;\n\t\t\tmin_dist_squared = dist_squared;\n\t\t\tclosest_safe_point = mission_safe_point;\n\t\t}\n\t}\n\n\tif (closest_index > 0) {\n\t\t_destination.type = RTL_DESTINATION_SAFE_POINT;\n\n\t\t// There is a safe point closer than home/mission landing\n\t\t// TODO: handle all possible mission_safe_point.frame cases\n\t\tswitch (closest_safe_point.frame) {\n\t\tcase 0: // MAV_FRAME_GLOBAL\n\t\t\t_destination.lat = closest_safe_point.lat;\n\t\t\t_destination.lon = closest_safe_point.lon;\n\t\t\t_destination.alt = closest_safe_point.alt;\n\t\t\t_destination.yaw = home_landing_position.yaw;\n\t\t\tbreak;\n\n\t\tcase 3: // MAV_FRAME_GLOBAL_RELATIVE_ALT\n\t\t\t_destination.lat = closest_safe_point.lat;\n\t\t\t_destination.lon = closest_safe_point.lon;\n\t\t\t_destination.alt = closest_safe_point.alt + home_landing_position.alt; // alt of safe point is rel to home\n\t\t\t_destination.yaw = home_landing_position.yaw;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmavlink_log_critical(_navigator->get_mavlink_log_pub(), \"RTL: unsupported MAV_FRAME\\t\");\n\t\t\tevents::send<uint8_t>(events::ID(\"rtl_unsupported_mav_frame\"), events::Log::Error, \"RTL: unsupported MAV_FRAME ({1})\",\n\t\t\t\t\t      closest_safe_point.frame);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (_param_rtl_cone_half_angle_deg.get() > 0\n\t    && _navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t_rtl_alt = calculate_return_alt_from_cone_half_angle((float)_param_rtl_cone_half_angle_deg.get());\n\n\t} else {\n\t\t_rtl_alt = max(global_position.alt, _destination.alt + _param_rtl_return_alt.get());\n\t}\n}"
   
''')
