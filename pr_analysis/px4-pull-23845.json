{
    "functions": ["Land::on_activation", "Land::on_active", "Loiter::set_loiter_position", 
                  "MissionBlock::setLoiterItemFromCurrentPositionWithBreaking", 
                  "MissionBlock::set_land_item", "Navigator::run"],
    "commit": "808153b049a386e37a814772589f33d2b2a4989c",
    "source":
    {
        "Land::on_active": "void\nLand::on_active()\n{\n\t/* for VTOL update landing location during back transition */\n\tif (_navigator->get_vstatus()->is_vtol &&\n\t    _navigator->get_vstatus()->in_transition_mode) {\n\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\t\t// create a wp in front of the VTOL while in back-transition, based on MPC settings that will apply in MC phase afterwards\n\t\t_navigator->calculate_breaking_stop(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon);\n\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_navigator->get_mission_result()->finished = true;\n\t\t_navigator->set_mission_result_updated();\n\t\t_navigator->mode_completed(getNavigatorStateId());\n\t\tset_idle_item(&_mission_item);\n\n\t\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\t\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t}\n\n\t/* check if landing needs to be aborted */\n\tif (_navigator->abort_landing()) {\n\n\t\t// send reposition cmd to get out of land mode (will loiter at current position and altitude)\n\t\tvehicle_command_s vcmd = {};\n\n\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_DO_REPOSITION;\n\t\tvcmd.param1 = -1;\n\t\tvcmd.param2 = 1;\n\t\tvcmd.param5 = _navigator->get_global_position()->lat;\n\t\tvcmd.param6 = _navigator->get_global_position()->lon;\n\t\t// as we don't know the landing point altitude assume the worst case (abort at 0m above ground),\n\t\t// and thus always climb MIS_LND_ABRT_ALT\n\t\tvcmd.param7 = _navigator->get_global_position()->alt + _navigator->get_landing_abort_min_alt();\n\n\t\t_navigator->publish_vehicle_cmd(&vcmd);\n\t}\n}",
        "Land::on_activation": "void\nLand::on_activation()\n{\n\t/* set current mission item to Land */\n\tset_land_item(&_mission_item);\n\t_navigator->get_mission_result()->finished = false;\n\t_navigator->set_mission_result_updated();\n\treset_mission_item_reached();\n\n\t/* convert mission item to current setpoint */\n\tstruct position_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t_navigator->calculate_breaking_stop(_mission_item.lat, _mission_item.lon);\n\t}\n\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->previous.valid = false;\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n\n\t// reset cruising speed to default\n\t_navigator->reset_cruising_speed();\n\n\t// set gimbal to neutral position (level with horizon) to reduce change of damage on landing\n\t_navigator->acquire_gimbal_control();\n\t_navigator->set_gimbal_neutral();\n\t_navigator->release_gimbal_control();\n\n}",
        "Loiter::set_loiter_position": "void\nLoiter::set_loiter_position()\n{\n\tif (_navigator->get_vstatus()->arming_state != vehicle_status_s::ARMING_STATE_ARMED &&\n\t    _navigator->get_land_detected()->landed) {\n\n\t\t// Not setting loiter position if disarmed and landed, instead mark the current\n\t\t// setpoint as invalid and idle (both, just to be sure).\n\n\t\t_navigator->get_position_setpoint_triplet()->current.type = position_setpoint_s::SETPOINT_TYPE_IDLE;\n\t\t_navigator->set_position_setpoint_triplet_updated();\n\t\treturn;\n\n\t}\n\n\tposition_setpoint_triplet_s *pos_sp_triplet = _navigator->get_position_setpoint_triplet();\n\n\tif (_navigator->get_land_detected()->landed) {\n\t\t_mission_item.nav_cmd = NAV_CMD_IDLE;\n\n\t} else {\n\t\t// Check if we already loiter on a circle and are on the loiter pattern.\n\t\tbool on_loiter{false};\n\n\t\tif (pos_sp_triplet->current.valid && pos_sp_triplet->current.type == position_setpoint_s::SETPOINT_TYPE_LOITER\n\t\t    && pos_sp_triplet->current.loiter_pattern == position_setpoint_s::LOITER_TYPE_ORBIT) {\n\t\t\tconst float d_current = get_distance_to_next_waypoint(pos_sp_triplet->current.lat, pos_sp_triplet->current.lon,\n\t\t\t\t\t\t_navigator->get_global_position()->lat, _navigator->get_global_position()->lon);\n\t\t\ton_loiter = d_current <= (_navigator->get_acceptance_radius() + pos_sp_triplet->current.loiter_radius);\n\n\t\t}\n\n\t\tif (on_loiter) {\n\t\t\tsetLoiterItemFromCurrentPositionSetpoint(&_mission_item);\n\n\t\t} else if (_navigator->get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {\n\t\t\tsetLoiterItemFromCurrentPositionWithBreaking(&_mission_item);\n\n\t\t} else {\n\t\t\tsetLoiterItemFromCurrentPosition(&_mission_item);\n\t\t}\n\n\t}\n\n\t// convert mission item to current setpoint\n\tpos_sp_triplet->previous.valid = false;\n\tmission_item_to_position_setpoint(_mission_item, &pos_sp_triplet->current);\n\tpos_sp_triplet->next.valid = false;\n\n\t_navigator->set_position_setpoint_triplet_updated();\n}",
        "MissionBlock::setLoiterItemFromCurrentPositionWithBreaking": "void\nMissionBlock::setLoiterItemFromCurrentPositionWithBreaking(struct mission_item_s *item)\n{\n\tsetLoiterItemCommonFields(item);\n\n\t_navigator->calculate_breaking_stop(item->lat, item->lon);\n\n\titem->altitude = _navigator->get_global_position()->alt;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->yaw = NAN;\n}",
        "MissionBlock::set_land_item": "void\nMissionBlock::set_land_item(struct mission_item_s *item)\n{\n\t/* VTOL transition to RW before landing */\n\tif (_navigator->force_vtol()) {\n\n\t\tvehicle_command_s vcmd = {};\n\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\tvcmd.param2 = 0.0f;\n\t\t_navigator->publish_vehicle_cmd(&vcmd);\n\t}\n\n\t/* set the land item */\n\titem->nav_cmd = NAV_CMD_LAND;\n\n\t// set land item to current position\n\titem->lat = _navigator->get_global_position()->lat;\n\titem->lon = _navigator->get_global_position()->lon;\n\titem->yaw = NAN;\n\n\titem->altitude = 0;\n\titem->altitude_is_relative = false;\n\titem->loiter_radius = _navigator->get_loiter_radius();\n\titem->acceptance_radius = _navigator->get_acceptance_radius();\n\titem->time_inside = 0.0f;\n\titem->autocontinue = true;\n\titem->origin = ORIGIN_ONBOARD;\n}",
        "Navigator::run": "void Navigator::run()\n{\n\n\t/* Try to load the geofence:\n\t * if /fs/microsd/etc/geofence.txt load from this file */\n\tstruct stat buffer;\n\n\tif (stat(GEOFENCE_FILENAME, &buffer) == 0) {\n\t\tPX4_INFO(\"Loading geofence from %s\", GEOFENCE_FILENAME);\n\t\t_geofence.loadFromFile(GEOFENCE_FILENAME);\n\t}\n\n\tparams_update();\n\n\t/* wakeup source(s) */\n\tpx4_pollfd_struct_t fds[3] {};\n\n\t/* Setup of loop */\n\tfds[0].fd = _local_pos_sub;\n\tfds[0].events = POLLIN;\n\tfds[1].fd = _vehicle_status_sub;\n\tfds[1].events = POLLIN;\n\tfds[2].fd = _mission_sub;\n\tfds[2].events = POLLIN;\n\n\tuint32_t geofence_id{0};\n\tuint32_t safe_points_id{0};\n\n\t/* rate-limit position subscription to 20 Hz / 50 ms */\n\torb_set_interval(_local_pos_sub, 50);\n\n\twhile (!should_exit()) {\n\n\t\t/* wait for up to 1000ms for data */\n\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 1000);\n\n\t\tif (pret == 0) {\n\t\t\t/* Let the loop run anyway, don't do `continue` here. */\n\n\t\t} else if (pret < 0) {\n\t\t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n\t\t\tPX4_ERR(\"poll error %d, %d\", pret, errno);\n\t\t\tpx4_usleep(10000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tperf_begin(_loop_perf);\n\n\t\torb_copy(ORB_ID(vehicle_local_position), _local_pos_sub, &_local_pos);\n\t\torb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vstatus);\n\n\t\tif (fds[2].revents & POLLIN) {\n\t\t\tmission_s mission;\n\t\t\torb_copy(ORB_ID(mission), _mission_sub, &mission);\n\n\t\t\tif (mission.geofence_id != geofence_id) {\n\t\t\t\tgeofence_id = mission.geofence_id;\n\t\t\t\t_geofence.updateFence();\n\t\t\t}\n\n\t\t\tif (mission.safe_points_id != safe_points_id) {\n\t\t\t\tsafe_points_id = mission.safe_points_id;\n\t\t\t\t_rtl.updateSafePoints(safe_points_id);\n\t\t\t}\n\t\t}\n\n\t\t/* gps updated */\n\t\tif (_gps_pos_sub.updated()) {\n\t\t\t_gps_pos_sub.copy(&_gps_pos);\n\t\t}\n\n\t\t/* global position updated */\n\t\tif (_global_pos_sub.updated()) {\n\t\t\t_global_pos_sub.copy(&_global_pos);\n\t\t}\n\n\t\t/* check for parameter updates */\n\t\tif (_parameter_update_sub.updated()) {\n\t\t\t// clear update\n\t\t\tparameter_update_s pupdate;\n\t\t\t_parameter_update_sub.copy(&pupdate);\n\n\t\t\t// update parameters from storage\n\t\t\tparams_update();\n\t\t}\n\n\t\t_land_detected_sub.update(&_land_detected);\n\t\t_position_controller_status_sub.update();\n\t\t_home_pos_sub.update(&_home_pos);\n\n\t\t// Handle Vehicle commands\n\t\tint vehicle_command_updates = 0;\n\n\t\twhile (_wait_for_vehicle_status_timestamp == 0 && _vehicle_command_sub.updated()\n\t\t       && (vehicle_command_updates < vehicle_command_s::ORB_QUEUE_LENGTH)) {\n\t\t\tvehicle_command_updates++;\n\t\t\tconst unsigned last_generation = _vehicle_command_sub.get_last_generation();\n\n\t\t\tvehicle_command_s cmd{};\n\t\t\t_vehicle_command_sub.copy(&cmd);\n\n\t\t\tif (_vehicle_command_sub.get_last_generation() != last_generation + 1) {\n\t\t\t\tPX4_ERR(\"vehicle_command lost, generation %d -> %d\", last_generation, _vehicle_command_sub.get_last_generation());\n\t\t\t}\n\n\t\t\tif (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_GO_AROUND) {\n\n\t\t\t\t// DO_GO_AROUND is currently handled by the position controller (unacknowledged)\n\t\t\t\t// TODO: move DO_GO_AROUND handling to navigator\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_REPOSITION\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the reposition setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\tposition_setpoint.lat = cmd.param5;\n\t\t\t\t\tposition_setpoint.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\t}\n\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\tbool only_alt_change_requested = false;\n\n\t\t\t\t\t// If no argument for ground speed, use default value.\n\t\t\t\t\tif (cmd.param1 <= 0 || !PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = cmd.param1;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\n\t\t\t\t\t// Go on and check which changes had been requested\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.yaw = cmd.param4;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.yaw = NAN;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\t\t// Position change with optional altitude change\n\t\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (PX4_ISFINITE(cmd.param7) || PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t\tif (PX4_ISFINITE(cmd.param7)) {\n\t\t\t\t\t\t\trep->current.alt = cmd.param7;\n\t\t\t\t\t\t\tonly_alt_change_requested = true;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// All three set to NaN - pause vehicle\n\t\t\t\t\t\trep->current.alt = get_global_position()->alt;\n\n\t\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For fixedwings we can use the current vehicle's position to define the loiter point\n\t\t\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (only_alt_change_requested) {\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_minor_radius) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = curr->current.loiter_minor_radius;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_minor_radius = NAN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_orientation) && fabsf(curr->current.loiter_minor_radius) > FLT_EPSILON) {\n\t\t\t\t\t\t\trep->current.loiter_orientation = curr->current.loiter_orientation;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr->current.loiter_pattern > 0) {\n\t\t\t\t\t\t\trep->current.loiter_pattern = curr->current.loiter_pattern;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Reposition is outside geofence\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_reposition_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Reposition is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// CMD_DO_REPOSITION is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_ALTITUDE\n\t\t\t\t   && _vstatus.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\t\t// only update the setpoint if armed, as it otherwise won't get executed until the vehicle switches to loiter,\n\t\t\t\t// which can lead to dangerous and unexpected behaviors (see loiter.cpp, there is an if(armed) in there too)\n\n\t\t\t\t// A VEHICLE_CMD_DO_CHANGE_ALTITUDE has the exact same effect as a VEHICLE_CMD_DO_REPOSITION with only the altitude\n\t\t\t\t// field populated, this logic is copied from above.\n\n\t\t\t\t// only supports MAV_FRAME_GLOBAL and MAV_FRAMEs with absolute altitude amsl\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\tposition_setpoint_triplet_s *curr = get_position_setpoint_triplet();\n\n\t\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\t\t\t\t\trep->current.acceptance_radius = get_acceptance_radius();\n\t\t\t\t\trep->current.yaw = NAN;\n\n\t\t\t\t\t// Position is not changing, thus we keep the setpoint\n\t\t\t\t\trep->current.lat = PX4_ISFINITE(curr->current.lat) ? curr->current.lat : get_global_position()->lat;\n\t\t\t\t\trep->current.lon = PX4_ISFINITE(curr->current.lon) ? curr->current.lon : get_global_position()->lon;\n\n\t\t\t\t\t// set the altitude corresponding to command\n\t\t\t\t\trep->current.alt = PX4_ISFINITE(cmd.param1) ? cmd.param1 : get_global_position()->alt;\n\n\t\t\t\t\tif (_vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING\n\t\t\t\t\t    && (get_position_setpoint_triplet()->current.type != position_setpoint_s::SETPOINT_TYPE_TAKEOFF)) {\n\n\t\t\t\t\t\tcalculate_breaking_stop(rep->current.lat, rep->current.lon);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(curr->current.loiter_radius) && curr->current.loiter_radius > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_radius = curr->current.loiter_radius;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = curr->current.loiter_direction_counter_clockwise;\n\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\trep->next.valid = false;\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Altitude change is outside geofence\t\");\n\t\t\t\t\tevents::send(events::ID(\"navigator_change_altitude_outside_geofence\"), {events::Log::Error, events::LogInternal::Info},\n\t\t\t\t\t\t     \"Altitude change is outside geofence\");\n\t\t\t\t}\n\n\t\t\t\t// DO_CHANGE_ALTITUDE is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_ORBIT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n\n\t\t\t\t// for multicopters the orbit command is directly executed by the orbit flighttask\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_ORBIT;\n\t\t\t\t\trep->current.cruising_throttle = get_cruising_throttle();\n\n\t\t\t\t\t// on entering Loiter mode, reset speed setpoint to default\n\t\t\t\t\tif (_navigation_mode != &_loiter) {\n\t\t\t\t\t\trep->current.cruising_speed = -1.f;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Orbit is outside geofence\");\n\t\t\t\t}\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_FIGUREEIGHT &&\n\t\t\t\t   get_vstatus()->vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING) {\n#ifdef CONFIG_FIGURE_OF_EIGHT\n\t\t\t\t// Only valid for fixed wing mode\n\n\t\t\t\tvehicle_global_position_s position_setpoint{};\n\t\t\t\tposition_setpoint.lat = PX4_ISFINITE(cmd.param5) ? cmd.param5 : get_global_position()->lat;\n\t\t\t\tposition_setpoint.lon = PX4_ISFINITE(cmd.param6) ? cmd.param6 : get_global_position()->lon;\n\t\t\t\tposition_setpoint.alt = PX4_ISFINITE(cmd.param7) ? cmd.param7 : get_global_position()->alt;\n\n\t\t\t\t// Wait for vehicle_status before handling the next command, otherwise the setpoint could be overwritten\n\t\t\t\t_wait_for_vehicle_status_timestamp = hrt_absolute_time();\n\n\t\t\t\tif (geofence_allows_position(position_setpoint)) {\n\t\t\t\t\tposition_setpoint_triplet_s *rep = get_reposition_triplet();\n\t\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_LOITER;\n\t\t\t\t\trep->current.loiter_minor_radius = fabsf(get_loiter_radius());\n\t\t\t\t\trep->current.loiter_direction_counter_clockwise = get_loiter_radius() < 0;\n\t\t\t\t\trep->current.loiter_orientation = 0.0f;\n\t\t\t\t\trep->current.loiter_pattern = position_setpoint_s::LOITER_TYPE_FIGUREEIGHT;\n\t\t\t\t\trep->current.cruising_speed = get_cruising_speed();\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param2) && fabsf(cmd.param2) > FLT_EPSILON) {\n\t\t\t\t\t\trep->current.loiter_minor_radius = fabsf(cmd.param2);\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = 2.5f * rep->current.loiter_minor_radius;\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param1)) {\n\t\t\t\t\t\trep->current.loiter_radius = fabsf(cmd.param1);\n\t\t\t\t\t\trep->current.loiter_direction_counter_clockwise = cmd.param1 < 0;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.loiter_radius = math::max(rep->current.loiter_radius, 2.0f * rep->current.loiter_minor_radius);\n\n\t\t\t\t\tif (PX4_ISFINITE(cmd.param4)) {\n\t\t\t\t\t\trep->current.loiter_orientation = cmd.param4;\n\t\t\t\t\t}\n\n\t\t\t\t\trep->current.lat = position_setpoint.lat;\n\t\t\t\t\trep->current.lon = position_setpoint.lon;\n\t\t\t\t\trep->current.alt = position_setpoint.alt;\n\n\t\t\t\t\trep->current.valid = true;\n\t\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\t\t_time_loitering_after_gf_breach = 0; // have to manually reset this in all LOITER cases\n\n\t\t\t\t} else {\n\t\t\t\t\tmavlink_log_critical(&_mavlink_log_pub, \"Figure 8 is outside geofence\");\n\t\t\t\t}\n\n#endif // CONFIG_FIGURE_OF_EIGHT\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_TAKEOFF) {\n\t\t\t\tposition_setpoint_triplet_s *rep = get_takeoff_triplet();\n\n\t\t\t\t// store current position as previous position and goal as next\n\t\t\t\trep->previous.yaw = get_local_position()->heading;\n\t\t\t\trep->previous.lat = get_global_position()->lat;\n\t\t\t\trep->previous.lon = get_global_position()->lon;\n\t\t\t\trep->previous.alt = get_global_position()->alt;\n\n\t\t\t\trep->current.loiter_radius = get_loiter_radius();\n\t\t\t\trep->current.loiter_direction_counter_clockwise = false;\n\t\t\t\trep->current.type = position_setpoint_s::SETPOINT_TYPE_TAKEOFF;\n\t\t\t\trep->current.cruising_speed = -1.f; // reset to default\n\n\t\t\t\tif (home_global_position_valid()) {\n\n\t\t\t\t\trep->previous.valid = true;\n\t\t\t\t\trep->previous.timestamp = hrt_absolute_time();\n\n\t\t\t\t} else {\n\t\t\t\t\trep->previous.valid = false;\n\t\t\t\t}\n\n\t\t\t\t// Don't set a yaw setpoint for takeoff, as Navigator doesn't handle the yaw reset.\n\t\t\t\t// The yaw setpoint generation is handled by FlightTaskAuto.\n\t\t\t\trep->current.yaw = NAN;\n\n\t\t\t\tif (PX4_ISFINITE(cmd.param5) && PX4_ISFINITE(cmd.param6)) {\n\t\t\t\t\trep->current.lat = cmd.param5;\n\t\t\t\t\trep->current.lon = cmd.param6;\n\n\t\t\t\t} else {\n\t\t\t\t\t// If one of them is non-finite set the current global position as target\n\t\t\t\t\trep->current.lat = get_global_position()->lat;\n\t\t\t\t\trep->current.lon = get_global_position()->lon;\n\n\t\t\t\t}\n\n\t\t\t\trep->current.alt = cmd.param7;\n\n\t\t\t\trep->current.valid = true;\n\t\t\t\trep->current.timestamp = hrt_absolute_time();\n\n\t\t\t\trep->next.valid = false;\n\n\t\t\t\t// CMD_NAV_TAKEOFF is acknowledged by commander\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_VTOL_TAKEOFF) {\n\n\t\t\t\t_vtol_takeoff.setTransitionAltitudeAbsolute(cmd.param7);\n\n\t\t\t\t// after the transition the vehicle will establish on a loiter at this position\n\t\t\t\t_vtol_takeoff.setLoiterLocation(matrix::Vector2d(cmd.param5, cmd.param6));\n\n\t\t\t\t// loiter height is the height above takeoff altitude at which the vehicle will establish on a loiter circle\n\t\t\t\t_vtol_takeoff.setLoiterHeight(cmd.param1);\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_LAND_START) {\n\n\t\t\t\t// find NAV_CMD_DO_LAND_START in the mission and\n\t\t\t\t// use MAV_CMD_MISSION_START to start the mission from the next item containing a position setpoint\n\t\t\t\tuint8_t result{vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED};\n\n\t\t\t\tif (_mission.get_land_start_available()) {\n\t\t\t\t\tvehicle_command_s vcmd = {};\n\t\t\t\t\tvcmd.command = vehicle_command_s::VEHICLE_CMD_MISSION_START;\n\t\t\t\t\tvcmd.param1 = _mission.get_land_start_index();\n\t\t\t\t\tpublish_vehicle_cmd(&vcmd);\n\n\t\t\t\t} else {\n\t\t\t\t\tPX4_WARN(\"planned mission landing not available\");\n\t\t\t\t\tresult = vehicle_command_ack_s::VEHICLE_CMD_RESULT_CANCELLED;\n\t\t\t\t}\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, result);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_MISSION_START) {\n\t\t\t\tif (_mission_result.valid && PX4_ISFINITE(cmd.param1) && (cmd.param1 >= 0)) {\n\t\t\t\t\tif (!_mission.set_current_mission_index(cmd.param1)) {\n\t\t\t\t\t\tPX4_WARN(\"CMD_MISSION_START failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// CMD_MISSION_START is acknowledged by commander\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_CHANGE_SPEED) {\n\t\t\t\tif (cmd.param2 > FLT_EPSILON) {\n\t\t\t\t\t// XXX not differentiating ground and airspeed yet\n\t\t\t\t\tset_cruising_speed(cmd.param2);\n\n\t\t\t\t} else {\n\t\t\t\t\treset_cruising_speed();\n\n\t\t\t\t\t/* if no speed target was given try to set throttle */\n\t\t\t\t\tif (cmd.param3 > FLT_EPSILON) {\n\t\t\t\t\t\tset_cruising_throttle(cmd.param3 / 100);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_cruising_throttle();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// TODO: handle responses for supported DO_CHANGE_SPEED options?\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_NAV_ROI\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET\n\t\t\t\t   || cmd.command == vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE) {\n\t\t\t\t_vroi = {};\n\n\t\t\t\tswitch (cmd.command) {\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI:\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_NAV_ROI:\n\t\t\t\t\t_vroi.mode = cmd.param1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_LOCATION:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_LOCATION;\n\t\t\t\t\t_vroi.lat = cmd.param5;\n\t\t\t\t\t_vroi.lon = cmd.param6;\n\t\t\t\t\t_vroi.alt = cmd.param7;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_WPNEXT_OFFSET:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_WPNEXT;\n\t\t\t\t\t_vroi.pitch_offset = (float)cmd.param5 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.roll_offset = (float)cmd.param6 * M_DEG_TO_RAD_F;\n\t\t\t\t\t_vroi.yaw_offset = (float)cmd.param7 * M_DEG_TO_RAD_F;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vehicle_command_s::VEHICLE_CMD_DO_SET_ROI_NONE:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_vroi.mode = vehicle_command_s::VEHICLE_ROI_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t_vroi.timestamp = hrt_absolute_time();\n\n\t\t\t\t_vehicle_roi_pub.publish(_vroi);\n\n\t\t\t\tpublish_vehicle_command_ack(cmd, vehicle_command_ack_s::VEHICLE_CMD_RESULT_ACCEPTED);\n\n\t\t\t} else if (cmd.command == vehicle_command_s::VEHICLE_CMD_DO_VTOL_TRANSITION\n\t\t\t\t   && get_vstatus()->nav_state != vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF) {\n\t\t\t\t// reset cruise speed and throttle to default when transitioning (VTOL Takeoff handles it separately)\n\t\t\t\treset_cruising_speed();\n\t\t\t\tset_cruising_throttle();\n\t\t\t}\n\t\t}\n\n\t\t/* Check for traffic */\n\t\tcheck_traffic();\n\n\t\t/* Check geofence violation */\n\t\tgeofence_breach_check();\n\n\t\t/* Do stuff according to navigation state set by commander */\n\t\tNavigatorMode *navigation_mode_new{nullptr};\n\n\t\tswitch (_vstatus.nav_state) {\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_MISSION:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\n\t\t\tnavigation_mode_new = &_mission;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_loiter;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_RTL:\n\n\t\t\t// If we are already in mission landing, do not switch.\n\t\t\tif (_navigation_mode == &_mission && _mission.isLanding()) {\n\t\t\t\tnavigation_mode_new = &_mission;\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\t}\n\n\t\t\tnavigation_mode_new = &_rtl;\n\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_takeoff;\n\t\t\tbreak;\n\n#if CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_VTOL_TAKEOFF:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_vtol_takeoff;\n\t\t\tbreak;\n#endif //CONFIG_MODE_NAVIGATOR_VTOL_TAKEOFF\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_LAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_land;\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_AUTO_PRECLAND:\n\t\t\t_pos_sp_triplet_published_invalid_once = false;\n\t\t\tnavigation_mode_new = &_precland;\n\t\t\t_precland.set_mode(PrecLandMode::Required);\n\t\t\tbreak;\n\n\t\tcase vehicle_status_s::NAVIGATION_STATE_MANUAL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ACRO:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_ALTCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_POSCTL:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_DESCEND:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_TERMINATION:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_OFFBOARD:\n\t\tcase vehicle_status_s::NAVIGATION_STATE_STAB:\n\t\tdefault:\n\t\t\tnavigation_mode_new = nullptr;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Do not execute any state machine while we are disarmed\n\t\tif (_vstatus.arming_state != vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tnavigation_mode_new = nullptr;\n\t\t}\n\n\t\t/* we have a new navigation mode: reset triplet */\n\t\tif (_navigation_mode != navigation_mode_new) {\n\t\t\t// We don't reset the triplet in the following two cases:\n\t\t\t// 1)  if we just did an auto-takeoff and are now\n\t\t\t// going to loiter. Otherwise, we lose the takeoff altitude and end up lower\n\t\t\t// than where we wanted to go.\n\t\t\t// 2) We switch to loiter and the current position setpoint already has a valid loiter point.\n\t\t\t// In that case we can assume that the vehicle has already established a loiter and we don't need to set a new\n\t\t\t// loiter position.\n\t\t\t//\n\t\t\t// FIXME: a better solution would be to add reset where they are needed and remove\n\t\t\t//        this general reset here.\n\n\t\t\tconst bool current_mode_is_takeoff = _navigation_mode == &_takeoff;\n\t\t\tconst bool new_mode_is_loiter = navigation_mode_new == &_loiter;\n\t\t\tconst bool valid_loiter_setpoint = (_pos_sp_triplet.current.valid\n\t\t\t\t\t\t\t    && _pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_LOITER);\n\n\t\t\tconst bool did_not_switch_takeoff_to_loiter = !(current_mode_is_takeoff && new_mode_is_loiter);\n\t\t\tconst bool did_not_switch_to_loiter_with_valid_loiter_setpoint = !(new_mode_is_loiter && valid_loiter_setpoint);\n\n\t\t\tif (did_not_switch_takeoff_to_loiter && did_not_switch_to_loiter_with_valid_loiter_setpoint) {\n\t\t\t\treset_triplets();\n\t\t\t}\n\t\t}\n\n\t\t// VTOL: transition to hover in Descend mode if force_vtol() is true\n\t\tif (_vstatus.nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND &&\n\t\t    _vstatus.is_vtol && _vstatus.vehicle_type == vehicle_status_s::VEHICLE_TYPE_FIXED_WING &&\n\t\t    force_vtol()) {\n\t\t\tvehicle_command_s vcmd = {};\n\t\t\tvcmd.command = NAV_CMD_DO_VTOL_TRANSITION;\n\t\t\tvcmd.param1 = vtol_vehicle_status_s::VEHICLE_VTOL_STATE_MC;\n\t\t\tpublish_vehicle_cmd(&vcmd);\n\t\t\tmavlink_log_info(&_mavlink_log_pub, \"Transition to hover mode and descend.\t\");\n\t\t\tevents::send(events::ID(\"navigator_transition_descend\"), events::Log::Critical,\n\t\t\t\t     \"Transition to hover mode and descend\");\n\t\t}\n\n\t\t_navigation_mode = navigation_mode_new;\n\n\t\tif (_wait_for_vehicle_status_timestamp != 0 && _vstatus.timestamp > _wait_for_vehicle_status_timestamp) {\n\t\t\t_wait_for_vehicle_status_timestamp = 0;\n\t\t}\n\n\t\t/* iterate through navigation modes and set active/inactive for each */\n\t\tfor (unsigned int i = 0; i < NAVIGATOR_MODE_ARRAY_SIZE; i++) {\n\t\t\tif (_navigation_mode_array[i]) {\n\t\t\t\t_navigation_mode_array[i]->run(_navigation_mode == _navigation_mode_array[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* if nothing is running, set position setpoint triplet invalid once */\n\t\tif (_navigation_mode == nullptr && !_pos_sp_triplet_published_invalid_once) {\n\t\t\t_pos_sp_triplet_published_invalid_once = true;\n\t\t\treset_triplets();\n\t\t}\n\n\t\tif (_pos_sp_triplet_updated) {\n\t\t\tpublish_position_setpoint_triplet();\n\t\t}\n\n\t\tif (_mission_result_updated) {\n\t\t\tpublish_mission_result();\n\t\t}\n\n\t\tpublish_navigator_status();\n\n\t\tpublish_distance_sensor_mode_request();\n\n\t\t_geofence.run();\n\n\t\tperf_end(_loop_perf);\n\t}\n}",
        "Navigator::calculate_breaking_stop": "void Navigator::calculate_breaking_stop(double &lat, double &lon)\n{\n\t// For multirotors we need to account for the braking distance, otherwise the vehicle will overshoot and go back\n\tconst float course_over_ground = atan2f(_local_pos.vy, _local_pos.vx);\n\n\t// predict braking distance\n\n\tconst float velocity_hor_abs = sqrtf(_local_pos.vx * _local_pos.vx + _local_pos.vy * _local_pos.vy);\n\n\tconst float multirotor_braking_distance = math::trajectory::computeBrakingDistanceFromVelocity(velocity_hor_abs,\n\t\t\t_param_mpc_jerk_auto, _param_mpc_acc_hor, 0.6f * _param_mpc_jerk_auto);\n\n\twaypoint_from_heading_and_distance(get_global_position()->lat, get_global_position()->lon, course_over_ground,\n\t\t\t\t\t   multirotor_braking_distance, &lat, &lon);\n}"
    }
}
